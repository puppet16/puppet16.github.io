<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>Kotlin学习系列二：类与接口初解 · Puppet</title><meta name="description" content="一、前言
二、类与接口

1. 类定义

1. Kotlin中构造方法使用关键字constructor
2.创建构造方法时类内变量分情况判断是否需要初始化值
3. 构造方法分为主构造器与副构造器


2. 类的实例化
3. 接口的定义
4. 接口的实现
5. 抽象类的定义
6. 类的继承
7. 属"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Kotlin学习系列二：类与接口初解</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">二、类与接口</a>
<ul>
<li><a href="#1-%E7%B1%BB%E5%AE%9A%E4%B9%89">1. 类定义</a>
<ul>
<li><a href="#1-kotlin%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97constructor">1. Kotlin中构造方法使用关键字<code>constructor</code></a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%97%B6%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E5%88%86%E6%83%85%E5%86%B5%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC">2.创建构造方法时类内变量分情况判断是否需要初始化值</a></li>
<li><a href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%86%E4%B8%BA%E4%B8%BB%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8E%E5%89%AF%E6%9E%84%E9%80%A0%E5%99%A8">3. 构造方法分为主构造器与副构造器</a></li>
</ul>
</li>
<li><a href="#2-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96">2. 类的实例化</a></li>
<li><a href="#3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89">3. 接口的定义</a></li>
<li><a href="#4-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0">4. 接口的实现</a></li>
<li><a href="#5-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">5. 抽象类的定义</a></li>
<li><a href="#6-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">6. 类的继承</a></li>
<li><a href="#7-%E5%B1%9E%E6%80%A7property">7. 属性<code>Property</code></a>
<ul>
<li><a href="#1-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89">1. 属性定义</a></li>
<li><a href="#2-%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7">2. 实现在接口中定义的属性</a></li>
<li><a href="#3-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BC%95%E7%94%A8">3. 属性的引用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%89%A9%E5%B1%95">三、 扩展</a>
<ul>
<li><a href="#1-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89">1. 扩展方法定义</a></li>
<li><a href="#2-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B">2. 扩展方法的类型</a></li>
<li><a href="#3-%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7">3. 扩展属性</a></li>
<li><a href="#4-%E6%89%A9%E5%B1%95%E7%9A%84%E8%83%BD%E5%8A%9B%E8%BE%B9%E7%95%8C">4. 扩展的能力边界</a>
<ul>
<li><a href="#1-%E6%89%A9%E5%B1%95%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88">1. 扩展可以做什么</a></li>
<li><a href="#2-%E6%89%A9%E5%B1%95%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88">2. 扩展不可以做什么</a></li>
</ul>
</li>
<li><a href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5. 使用场景</a>
<ul>
<li><a href="#1-%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">1. 关注点分离</a></li>
<li><a href="#2-%E6%8F%90%E9%AB%98%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87">2. 提高可读性与开发效率</a></li>
<li><a href="#3-%E6%80%BB%E7%BB%93">3. 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E7%A9%BA%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8">四、空类型安全</a>
<ul>
<li><a href="#1-%E7%A9%BA%E7%B1%BB%E5%9E%8B%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0">1. 空类型异常原因</a></li>
<li><a href="#2-%E5%8F%AF%E7%A9%BA%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8">2. 可空变量属性调用</a>
<ul>
<li><a href="#1-%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6">1. 非空断言运算符<code>!!</code></a></li>
<li><a href="#2-%E5%AE%89%E5%85%A8%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6">2. 安全调用操作符<code>?.</code></a></li>
<li><a href="#3-elvis%E8%BF%90%E7%AE%97%E7%AC%A6">3. <strong><code>elvis</code>运算符<code>?:</code></strong></a></li>
</ul>
</li>
<li><a href="#3-%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">3. 空类型的继承关系</a></li>
<li><a href="#4-%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B">4. 平台类型</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%99%BA%E8%83%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">五、智能类型转换</a>
<ul>
<li><a href="#1-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">1. 强制类型转换</a></li>
<li><a href="#2-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%89%E5%85%A8%E8%BD%AC%E6%8D%A2">2. 类型的安全转换</a></li>
<li><a href="#3-%E6%99%BA%E8%83%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BB%B6%E4%BC%B8%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE">3. 智能类型转换延伸的几点建议</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8retrofit%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82">六、示例–使用Retrofit访问网络请求</a></li>
<li><a href="#%E4%B8%83-%E9%99%84%E5%BD%95">七、附录</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 类型进阶</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://github.com/enbandari">Bennyhuo老师</a>讲解的<code>Kotlin</code>系列视频及朱涛老师讲解的<code>Kotlin</code>编程第一课的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程初解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程进阶</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程应用</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-类与接口" class="header-anchor">#</a><span id="二-类与接口">二、类与接口</span></h1>
<h2><a href="#1-类定义" class="header-anchor">#</a><span id="1-类定义">1. 类定义</span></h2>
<p><strong>Kotlin中类的概念与Java中类的概念一致</strong></p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>Kotlin中不加作用域修饰符时默认<font size="5">public</font></strong></li>
<li><strong>Kotlin中类内无内容时可省略{}</strong></li>
<li><strong>类内的变量必须初始化值，否则会报错<em>Variable must be initialized</em></strong><br>
例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中的类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin中的类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span></span><br></pre></td></tr></table></figure>
<h3><a href="#1-kotlin中构造方法使用关键字constructor" class="header-anchor">#</a><span id="1-kotlin中构造方法使用关键字constructor">1. Kotlin中构造方法使用关键字<code>constructor</code></span></h3>
<p>Java中构造方法名称必须与类名一致，且不添加方法返回值，而Kotlin中没有这种限制</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中构造方法创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleClass</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin中构造方法创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">constructor</span>(x:<span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> simple = SimpleClass(<span class="number">5</span>)</span><br><span class="line">    println(simple.getValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2创建构造方法时类内变量分情况判断是否需要初始化值" class="header-anchor">#</a><span id="2创建构造方法时类内变量分情况判断是否需要初始化值">2.创建构造方法时类内变量分情况判断是否需要初始化值</span></h3>
<p><strong>当类中只有一个带入参的构造方法时，类内声明入参变量时可不初始化值，但是若有无参构造方法则声明变量时一定要初始化值</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin中构造方法创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span> = <span class="number">6</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(x:<span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> simple = SimpleClass(<span class="number">5</span>)</span><br><span class="line">    println(simple.getValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，当类<code>SimpleClass</code>中有两个构造方法，其中一个是无参构造方法，则变量<code>x</code>需要初始化值</p>
<h3><a href="#3-构造方法分为主构造器与副构造器" class="header-anchor">#</a><span id="3-构造方法分为主构造器与副构造器">3. 构造方法分为主构造器与副构造器</span></h3>
<ol>
<li>如<code>java</code>一般，将构造方法定义在类内，则为副构造器<em>secondary constructor</em></li>
<li>将构造方法定义在类的定义上，则为主构造器<em>primary constructor</em></li>
<li>当为主构造器时，可将关键字<code>constructor</code>省略</li>
</ol>
<p>例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//副构造器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(x:<span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主构造器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">constructor</span>(x:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略关键字的主构造器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> (x:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>
<p><strong>主构造器要求类内的其它构造器都要调用它</strong></p>
<p>例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">constructor</span>(x:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span> = x</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">constructor</span>(x:<span class="built_in">Int</span> = <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个主构造器之后又声明了一个无参副构造器，在无参副构造器执行前使用<code>this</code>先执行主构造器，或者在主构造器里为入参赋默认值也可不声明无参副构造器，而调用时不需要传参</p>
</li>
<li>
<p><strong>如果在主构造器内入参前加上<code>var</code>或<code>val</code>则表示声明一个属性，类内不需要再声明该属性</strong></p>
<p>例：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> x:<span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><a href="#2-类的实例化" class="header-anchor">#</a><span id="2-类的实例化">2. 类的实例化</span></h2>
<p><code>Kotlin</code>中的实例化不需要<code>new</code></p>
<p>例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> x:<span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> simple = SimpleClass(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-接口的定义" class="header-anchor">#</a><span id="3-接口的定义">3. 接口的定义</span></h2>
<ul>
<li><code>Kotlin</code>中接口定义使用关键字 <strong><code>interface</code></strong></li>
</ul>
<p>例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SimpleInf</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#4-接口的实现" class="header-anchor">#</a><span id="4-接口的实现">4. 接口的实现</span></h2>
<ul>
<li><code>Java</code>中接口的实现使用关键字<code>implements</code>，而<code>Kotlin</code>中使用英文冒号<code>:</code></li>
<li><code>Java</code>中重写使用注解<code>@Override</code>，而<code>Kotlin</code>中使用关键字<code>override</code>，<code>Java</code>中重写可加可不加注解，<strong>但<code>Kotlin</code>中一定要加<code>override</code>关键字</strong></li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java接口的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">implements</span> <span class="title class_">SimpleInf</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin接口的实现，属性实现方式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>) : SimpleInf &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#5-抽象类的定义" class="header-anchor">#</a><span id="5-抽象类的定义">5. 抽象类的定义</span></h2>
<ul>
<li><code>Kotlin</code>中抽象类定义使用关键字<code>abstract</code></li>
<li><strong><code>Java</code>中类和方法默认可以被覆写，而<code>Kotlin</code>中默认不可覆写，需要添加关键字<code>open</code>来标识可覆写的类和方法</strong></li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java抽象类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">absMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">overridable</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">nonOverridable</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin抽象类的定义及实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsClass</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">absMethod</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">overridable</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nonOverridable</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbsClassImpl</span> : <span class="type">AbsClass</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">absMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">overridable</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.overridable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#6-类的继承" class="header-anchor">#</a><span id="6-类的继承">6. 类的继承</span></h2>
<ul>
<li><code>Java</code>中接口的实现使用关键字<code>extends</code>，而<code>Kotlin</code>中使用英文冒号<code>:</code>，且类需要加一对小括号</li>
<li><code>Kotlin</code>中使用<code>open</code>标识了某方法可覆写，则类的继承不会改变这种特性，除非在该方法再加上关键字<code>final</code></li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">extends</span> <span class="title class_">AbsClass</span> <span class="keyword">implements</span> <span class="title class_">SimpleInf</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span>(<span class="keyword">var</span> x:<span class="built_in">Int</span>) :AbsClass(), SimpleInf &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">absMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">overridable</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.overridable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SimpleClass2</span> : <span class="type">SimpleClass</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">overridable</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.overridable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass3</span> : <span class="type">SimpleClass2</span>() &#123;</span><br><span class="line">    <span class="comment">//不可再覆写overridable方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，<code>SimpleClass2</code>继承了<code>SimpleClass</code>，<code>SimpleClass3</code>继承了<code>SimpleClass2</code>。<br>
因<code>SimpleClass</code>类中<code>overridable()</code>方法未做其它关键字修饰，则<code>SimpleClass2</code>可以覆写<code>overridable()</code>方法。<br>
而<code>SimpleClass2</code>类中<code>overridable()</code>方法被关键字<code>final</code>修饰，表示不可再改变，则<code>SimpleClass3</code>不可以覆写<code>overridable()</code>方法。</p>
<h2><a href="#7-属性property" class="header-anchor">#</a><span id="7-属性property">7. 属性<code>Property</code></span></h2>
<p><code>Java</code>中定义属性称之为<code>field</code>，<code>Kotlin</code>中声明的变量称之为<code>property</code></p>
<h3><a href="#1-属性定义" class="header-anchor">#</a><span id="1-属性定义">1. 属性定义</span></h3>
<p>若使用<code>var</code>在<strong>类中</strong>声明则包含三部分：<strong><code>backing field</code></strong>、<strong><code>get</code>方法</strong>、<strong><code>set</code>方法</strong>；若使用<code>val</code>声明因不可更改特性，则不包含<code>set</code>方法。<br>
例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;<span class="comment">//field</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//field</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(age:<span class="built_in">Int</span>, name:String) &#123;</span><br><span class="line">    <span class="keyword">val</span> age = age<span class="comment">//property</span></span><br><span class="line">    <span class="keyword">var</span> name = name<span class="comment">//property</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述Person类还可写成如下形式，以方便在属性中的get、set方法中做其它操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(age:<span class="built_in">Int</span>, name:String) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">val</span> age = age</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> field</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> field</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        field = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args:<span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> simpleClass = SimpleClass(<span class="number">3</span>)</span><br><span class="line">    println(simpleClass.simpleProperty)</span><br><span class="line">    <span class="keyword">val</span> person : Person = Person(<span class="number">3</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Person:age=<span class="subst">$&#123;person.age&#125;</span>,name=<span class="subst">$&#123;person.name&#125;</span>&quot;</span>)</span><br><span class="line">    person.name = <span class="string">&quot;王五&quot;</span></span><br><span class="line">    <span class="comment">//不能为age赋值，因为age被val声明</span></span><br><span class="line">    person.age = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Java</code>中接口定义属性，则该属性直接是<code>public</code>且<code>final</code>不可修改，而<code>Kotlin</code>在接口中定义属性不可赋值且需要在实现类里实现，因为在接口中没有<code>backing field</code><br>
例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SimpleInf</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> simpleProperty:<span class="built_in">Int</span><span class="comment">//property</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-实现在接口中定义的属性" class="header-anchor">#</a><span id="2-实现在接口中定义的属性">2. 实现在接口中定义的属性</span></h3>
<p>若<code>Kotlin</code>接口中声明了属性，则在实现类中使用必须实现它，例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin接口的实现，属性实现方式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>) : SimpleInf &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> simpleProperty: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性实现方式二，直接写在主构造器中，初始值在类创建时传入</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span>(<span class="keyword">override</span> <span class="keyword">val</span> simpleProperty: <span class="built_in">Int</span>) : SimpleInf &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">absMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#3-属性的引用" class="header-anchor">#</a><span id="3-属性的引用">3. 属性的引用</span></h3>
<p>属性的引用和函数的引用是一样的都是使用双冒号<code>::</code>，例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person : Person = Person(<span class="number">3</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Person:age=<span class="subst">$&#123;person.age&#125;</span>,name=<span class="subst">$&#123;person.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ageRef = Person::age</span><br><span class="line">    <span class="keyword">val</span> nameRef = Person::name</span><br><span class="line">    nameRef.<span class="keyword">set</span>(person, <span class="string">&quot;王五&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ageRef2 = person::age</span><br><span class="line">    <span class="keyword">val</span> nameRef2 = person::name</span><br><span class="line">    nameRef2.<span class="keyword">set</span>(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，变量<code>ageRef</code>和<code>ageRef2</code>类型为<code>KProperty0&lt;Int&gt;</code>，变量<code>ageRef2</code>和<code>nameRef2</code>类型为<code>KMutableProperty0&lt;String&gt;</code></p>
<h1><a href="#三-扩展" class="header-anchor">#</a><span id="三-扩展">三、 扩展</span></h1>
<p><code>Kotlin</code>能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。例如，可以为一个不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为<strong>扩展函数</strong>。此外，也有<strong>扩展属性</strong>， 允许你为一个已经存在的类添加新的属性。</p>
<h2><a href="#1-扩展方法定义" class="header-anchor">#</a><span id="1-扩展方法定义">1. 扩展方法定义</span></h2>
<p>与类外函数定义差不多，只是在函数名前加一个<code>receiver</code>，表示定义的函数是这个<code>receiver</code>类的方法。例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args:<span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    println(list)</span><br><span class="line">    list.swap(<span class="number">0</span>,<span class="number">4</span>)<span class="comment">//交换下标0，4位置的元素</span></span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// “this”对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，为<code>MutableList&lt;Int&gt;</code>类添加了一个扩展方法，该方法名为<code>swap</code>，作用为交换两个位置的元素。<code>this</code>关键字在扩展函数内部对应到<code>receiver</code>对象（传过来的在点符号前的对象）。</p>
<ul>
<li>
<p><strong>扩展不能真正的修改他们所扩展的类</strong><br>
通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。<br>
扩展其实是生成一个静态方法，其参数是它声明时点前的<code>receiver</code>, 如上为<code>MutableList&lt;Int&gt;</code>类添加了一个方法名为<code>swap</code>扩展方法反编译为：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KotlinLabKt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="meta">@NotNull</span> List&lt;Number&gt; $<span class="built_in">this</span>$swap, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter($<span class="built_in">this</span>$swap, <span class="string">&quot;$this$swap&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ((Number)$<span class="built_in">this</span>$swap.get(index1)).intValue();</span><br><span class="line">        $<span class="built_in">this</span>$swap.set(index1, $<span class="built_in">this</span>$swap.get(index2));</span><br><span class="line">        $<span class="built_in">this</span>$swap.set(index2, Integer.valueOf(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>扩展是静态的</strong><br>
扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。<br>
如果类本身和其子类都进行了同一个函数的扩展，这函数是不会有重写关系的，在使用的时候，只会根据需要使用该方法的对象的实际类型来决定是调用了哪个，就是相当于调用静态方法。而不是动态分派。<br>
例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="type">Shape</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shape.<span class="title">getName</span><span class="params">()</span></span> = <span class="string">&quot;Shape&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Rectangle.<span class="title">getName</span><span class="params">()</span></span> = <span class="string">&quot;Rectangle&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printClassName</span><span class="params">(s: <span class="type">Shape</span>)</span></span> &#123;</span><br><span class="line">    println(s.getName())</span><br><span class="line">&#125;    </span><br><span class="line">printClassName(Rectangle())</span><br></pre></td></tr></table></figure>
<p>打印结果是<code>Shape</code>因为<code>s</code>的类型是<code>Shape</code></p>
</li>
<li>
<p><strong>成员函数与扩展函数</strong></p>
<p>如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。但是，<strong>扩展函数可以重载同样名字但不同签名成员函数</strong></p>
</li>
<li>
<p><strong>扩展的<code>receiver</code>可以为空</strong></p>
<p>注意可以为<strong>可空的接收者类型</strong>定义扩展。这样的扩展可以在对象(即<code>Any</code>)变量上调用， 即使其值为<code>null</code>，并且可以在函数体内检测<code>this == null</code>，这能让你在没有检测<code>null</code>的时候调用<code>Kotlin</code>中的<code>toString()</code>。例：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">    <span class="comment">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</span></span><br><span class="line">    <span class="comment">// 解析为 Any 类的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><a href="#2-扩展方法的类型" class="header-anchor">#</a><span id="2-扩展方法的类型">2. 扩展方法的类型</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个String类的扩展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(count:<span class="type">Int</span>)</span></span>:String &#123;</span><br><span class="line">    <span class="keyword">return</span> count.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str1 = (String::times)(<span class="string">&quot;str&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> str2 = (<span class="string">&quot;*&quot;</span>::times)(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>str1</code>使用的是未绑定<code>receiver</code>的函数引用，其类型为<code>(String, Int) -&gt;String</code>，<code>str2</code>使用的是绑定<code>receiver</code>的函数引用，其类型为<code>(Int) -&gt;String</code></p>
<h2><a href="#3-扩展属性" class="header-anchor">#</a><span id="3-扩展属性">3. 扩展属性</span></h2>
<p>与函数类似，Kotlin 支持扩展属性，例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>由于扩展没有实际的将成员插入类中，因此对扩展属性来说<code>backing field</code>(即存储空间)是无效的，不能存值。所以扩展属性不能有初值。他们的行为只能由显式提供的 getters/setters 定义。但是扩展属性可通过<code>this</code>来获取类中的成员变量。例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoorGuy</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pocket: <span class="built_in">Double</span> = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PoorGuy.monkeyLeft : <span class="built_in">Double</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pocket</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        pocket = value</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p><code>backing field</code>无效的还有在接口中定义的属性。<strong>接口中只能定义行为，不能持有状态</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Guy</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> moneyLeft: <span class="built_in">Double</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在接口中的属性可以写get和set方法，是因为接口方法的默认实现</p>
<h2><a href="#4-扩展的能力边界" class="header-anchor">#</a><span id="4-扩展的能力边界">4. 扩展的能力边界</span></h2>
<p>扩展虽然看起来很神奇，但也并不是无所不能的</p>
<h3><a href="#1-扩展可以做什么" class="header-anchor">#</a><span id="1-扩展可以做什么">1. 扩展可以做什么</span></h3>
<p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在<code>Kotlin</code>中几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的<code>java</code>类。唯有匿名内部类，因为他本身不存在名称，我们无法指定<code>receiver</code>，所以不能被扩展。</p>
<p>可以说，<code>Kotlin</code>的扩展应用范围还是非常广的。它最主要的用途，就是 <strong>用来取代<code>Java</code>当中的各种工具类</strong>，比如 <code>StringUtils</code>、<code>DateUtils</code>等等。</p>
<p>所有<code>Java</code>工具类能做的事情，<code>Kotlin</code>扩展函数都可以做，并且可以做得更好。扩展函数优势在于，开发工具可以在编写代码的时候智能提示。</p>
<h3><a href="#2-扩展不可以做什么" class="header-anchor">#</a><span id="2-扩展不可以做什么">2. 扩展不可以做什么</span></h3>
<p><code>Kotlin</code> 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p>
<ol>
<li><code>Kotlin</code> 扩展不是真正的类成员，因此它无法被继承它的子类重写。</li>
<li>扩展属性无法存储状态。扩展属性本身没有状态，也无法存储状态。因为它都是静态方法。</li>
<li>扩展的 <strong>访问</strong> 作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。
<ul>
<li>如果扩展是顶层的扩展，那么扩展的访问域仅限于该 <code>Kotlin</code> 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</li>
<li>如果扩展是被定义在某个类当中的，那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</li>
</ul>
</li>
</ol>
<h2><a href="#5-使用场景" class="header-anchor">#</a><span id="5-使用场景">5. 使用场景</span></h2>
<h3><a href="#1-关注点分离" class="header-anchor">#</a><span id="1-关注点分离">1. 关注点分离</span></h3>
<p><code>Kotlin</code> 标准库当中的 <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt"><code>String.kt</code>源代码</a> 如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> : <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt;, <span class="type">CharSequence</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@kotlin</span>.<span class="keyword">internal</span>.IntrinsicConstEvaluation</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="meta">@kotlin</span>.<span class="keyword">internal</span>.IntrinsicConstEvaluation</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@kotlin</span>.<span class="keyword">internal</span>.IntrinsicConstEvaluation</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subSequence</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span>)</span></span>: CharSequence</span><br><span class="line"></span><br><span class="line">    <span class="meta">@kotlin</span>.<span class="keyword">internal</span>.IntrinsicConstEvaluation</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@kotlin</span>.<span class="keyword">internal</span>.IntrinsicConstEvaluation</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@kotlin</span>.<span class="keyword">internal</span>.IntrinsicConstEvaluation</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Kotlin</code> 里面的 <code>String</code> 类竟然只有这些代码。那么，<code>String</code> 类的那些字符操作的方法到哪里去了？比如，<code>String.substring()</code>、<code>String.toLowerCase()</code> 它们定义在什么地方？实际上，<code>String</code> 相关的操作方法全都放到了<code>Strings.kt</code>当中去了。而这些字符操作方法全部都是以扩展函数的方式定义的，<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt"><code>Strings.kt</code>部分源码</a>如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strings.kt 部分代码</span></span><br><span class="line"><span class="keyword">package</span> kotlin.text</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;Use uppercase() instead.&quot;</span>, ReplaceWith(<span class="string">&quot;uppercase()&quot;</span>))</span></span><br><span class="line"><span class="meta">@DeprecatedSinceKotlin(warningSince = <span class="string">&quot;1.5&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">toUpperCase</span><span class="params">()</span></span>: String</span><br><span class="line"></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">substring</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span> = length)</span></span>: String = subSequence(startIndex, endIndex).toString()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是 <code>Kotlin</code> 扩展的第一个典型使用场景：<strong>关注点分离</strong> 。所谓 <strong>关注点分离</strong> ，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以上面的 <code>String</code> 类为例，<code>String.kt</code>这个类，只关注 <code>String</code> 的核心逻辑；而<code>Strings.kt</code>则只关注 <code>String</code> 的操作符逻辑。</p>
<h3><a href="#2-提高可读性与开发效率" class="header-anchor">#</a><span id="2-提高可读性与开发效率">2. 提高可读性与开发效率</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : ViewGroup.LayoutParams&gt;</span> View.<span class="title">updateLayoutParams</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> params = layoutParams <span class="keyword">as</span> T</span><br><span class="line">    block(params)</span><br><span class="line">    layoutParams = params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">updateMargin</span><span class="params">(left: <span class="type">Int</span>? = <span class="literal">null</span>, top: <span class="type">Int</span>? = <span class="literal">null</span>, right: <span class="type">Int</span>? = <span class="literal">null</span>, bottom: <span class="type">Int</span>? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    (layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123; param -&gt;</span><br><span class="line">        updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; &#123;</span><br><span class="line">            left?.let &#123;</span><br><span class="line">                marginStart = left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            right?.let &#123;</span><br><span class="line">                marginEnd = right</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top?.let &#123;</span><br><span class="line">                topMargin = top</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bottom?.let &#123;</span><br><span class="line">                bottomMargin = bottom</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了两个扩展函数，<code>updateLayoutParams()</code>、<code>updateMargin()</code>，后者的方法体当中用到了前者。通过 <code>updateMargin()</code> 这个扩展函数，可以大大简化 <code>Android</code> 当中的 <code>margin</code> 更新。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.updateMargin(top = <span class="number">100</span>, bottom = <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>而如果不借助扩展函数，我们将不得不写一堆的模板代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> params = view.layoutParams</span><br><span class="line"><span class="keyword">if</span> (params <span class="keyword">is</span> ViewGroup.MarginLayoutParams) &#123;</span><br><span class="line">    params.marginTop = <span class="number">100</span></span><br><span class="line">    params.marginBottom = <span class="number">100</span></span><br><span class="line">    view.layoutParams = params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，借助扩展函数，我们不仅提升了代码的可读性，还提升了编码效率，而这种效率可以说是成倍的提升：借助扩展函数，我们只需要写一行代码，<code>IntelliJ</code> 还会智能提示，帮我们补全代码；不借助扩展函数的话，我们需要写 5 行代码，这样的代码模式不仅枯燥繁琐，<code>IntelliJ</code> 也无法智能提示，也更容易出错。</p>
<h3><a href="#3-总结" class="header-anchor">#</a><span id="3-总结">3. 总结</span></h3>
<p><code>Kotlin</code> 扩展主要有两个核心使用场景：</p>
<ul>
<li>主动使用扩展，通过它来优化软件架构。<br>
对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的<code>String.kt</code>与<code>Strings.kt</code>。</li>
<li>被动使用扩展，提升可读性与开发效率。<br>
当我们无法修改外部的 <code>SDK</code> 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如 <code>view.updateMargin()</code>。</li>
</ul>
<h1><a href="#四-空类型安全" class="header-anchor">#</a><span id="四-空类型安全">四、空类型安全</span></h1>
<h2><a href="#1-空类型异常原因" class="header-anchor">#</a><span id="1-空类型异常原因">1. 空类型异常原因</span></h2>
<p><code>Kotlin</code> 的类型系统旨在消除来自代码空引用的危险的，<code>Kotlin</code> 中唯一可能引起空类型异常原因可能是：</p>
<ol>
<li>显式调用<code>throw NullPointerException()</code></li>
<li>使用了下文描述的 <code>!!</code> 操作符；</li>
<li>有些数据在初始化时不一致，例如当：
<ul>
<li>传递一个在构造函数中出现的未初始化的 <code>this</code> 并用于其他地方（“泄漏 <code>this</code>”）；</li>
<li>超类的构造函数调用一个开放成员，该成员在派生中类的实现使用了未初始化的状态；</li>
</ul>
</li>
<li>Java 互操作：
<ul>
<li>企图访问平台类型的 <code>null</code> 引用的成员；</li>
<li>用于具有错误可空性的 <code>Java</code> 互操作的泛型类型，例如一段 <code>Java</code> 代码可能会向 <code>Kotlin</code> 的 <code>MutableList&lt;String&gt;</code> 中加入 <code>null</code>，这意味着应该使用 <code>MutableList&lt;String?&gt;</code> 来处理它；</li>
</ul>
</li>
<li>由外部 <code>Java</code> 代码引发的其他问题。</li>
</ol>
<p>声明变量时，在不支持空类型的类型后面加一个 <strong><code>?</code></strong>，表示该变量可为空，例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullable: String? = <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>调用可空变量的属性时会报编译错误。</p>
<h2><a href="#2-可空变量属性调用" class="header-anchor">#</a><span id="2-可空变量属性调用">2. 可空变量属性调用</span></h2>
<h3><a href="#1-非空断言运算符" class="header-anchor">#</a><span id="1-非空断言运算符">1. 非空断言运算符<code>!!</code></span></h3>
<p><strong>作用：</strong> 将任何值转换为非空类型，若该值为空则抛出异常。<br>
<strong>注意：</strong> 使用时一定要确定可空变量<strong>一定不为空</strong>。<br>
<strong>使用方法：</strong> 在调用时变量后跟 <strong><code>!!</code></strong> 将变量强转为不可空类型，例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> length = nullable!!.length</span><br></pre></td></tr></table></figure>
<p>若<code>nullable</code>为空，则会报错<code>NullPointerException</code>，否则返回<code>nullable.length</code>的值，变量<code>length</code>不会为空</p>
<h3><a href="#2-安全调用操作符" class="header-anchor">#</a><span id="2-安全调用操作符">2. 安全调用操作符<code>?.</code></span></h3>
<p><strong>作用：</strong> 如果变量非空，就返回调用的变量属性，否则返回<code>null</code><br>
<strong>注意：</strong> 可能返回<code>null</code><br>
<strong>使用方法：</strong> 在调用时变量后跟 <strong><code>？</code></strong> 表示可空变量的属性变量也可能为空。例：<br>
安全调用也可以出现在赋值的左侧。这样，如果调用链中的任何一个接收者为空都会跳过赋值，而右侧的表达式根本不会求值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> length = nullable?.length <span class="comment">//表示length变量也是可空的</span></span><br></pre></td></tr></table></figure>
<p>若<code>nullable</code>为空，则返回<code>null</code>，否则返回<code>nullable.length</code>的值，变量<code>length</code>可能会空</p>
<h3><a href="#3-elvis运算符" class="header-anchor">#</a><span id="3-elvis运算符">3. <strong><code>elvis</code>运算符<code>?:</code></strong></span></h3>
<p><strong>作用：</strong> 若运算符左侧非空，就返回运算符左侧表达式，否则返回运算符右侧非空值<br>
<strong>注意：</strong> 当且仅当左侧为空时，才会对右侧表达式求值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> length nullable?.length ?:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果<code>nullable.length</code>为空，则返回0，所以变量<code>length</code>不会为空。</p>
<h2><a href="#3-空类型的继承关系" class="header-anchor">#</a><span id="3-空类型的继承关系">3. 空类型的继承关系</span></h2>
<p>空类型可接收对应非空类型变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x: String = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> y: String? = <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line">x = y <span class="comment">// Type mismatch</span></span><br><span class="line">y = x <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b: Number = <span class="number">10.1</span></span><br><span class="line"></span><br><span class="line">a = b <span class="comment">// Type mismatch</span></span><br><span class="line">b = a <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2><a href="#4-平台类型" class="header-anchor">#</a><span id="4-平台类型">4. 平台类型</span></h2>
<p>客观存在，不能主观定义，指<code>kotlin</code>外其它语言平台的类型，在<code>kotlin</code>中的表现为其它语言平台类型后面加<code>!</code>，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kotlin</code>中调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br><span class="line"><span class="keyword">val</span> title = person.title</span><br></pre></td></tr></table></figure>
<p>其中变量<code>title</code>就是<code>Java</code>平台中的<code>String</code>类型，该类型表示形式为<code>String!</code>，但不可自定义。<br>
<strong><code>kotlin</code>不能推断出平台类型是否为空</strong>，即调用平台类型的属性时最好使用安全调用操作符<code>?.</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> titleLength = title.length <span class="comment">// 直接报空指针错误</span></span><br><span class="line"><span class="keyword">val</span> titleLength = title?.length <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h1><a href="#五-智能类型转换" class="header-anchor">#</a><span id="五-智能类型转换">五、智能类型转换</span></h1>
<h2><a href="#1-强制类型转换" class="header-anchor">#</a><span id="1-强制类型转换">1. 强制类型转换</span></h2>
<p><code>Kotlin</code>中如果之前已经判断过某变量是某类型，则不需要再强转为该类型，<code>Kotlin</code>可以自动转换为该类型，而可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java 定义一个接口和一个实现该接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Kotliner</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Kotliner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>java</code>的类型转换</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Kotliner</span> <span class="variable">kotliner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span> (kotliner <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    System.out.println(((Person)kotliner).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中已使用操作符<code>instanceof</code>判断变量<code>kotliner</code>为<code>Person</code>类型，但是在调用<code>name</code>属性时仍需要强制转换为<code>Person</code></p>
</li>
<li>
<p><code>kotlin</code>的类型转换</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotliner: Kotiner = Person(<span class="string">&quot;Lee&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> (kotliner <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    println((kotliner <span class="keyword">as</span> Person).name)</span><br><span class="line">    println(kotliner.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>操作符<code>is</code></strong> 类似于<code>Java</code>中的<code>instanceof</code>，用于判断某变量是否属于某个类型<br>
<strong>操作符<code>as</code></strong> 将某变量强制转换为某类型<br>
<code>kotlin</code>智能类型转换自动将变量<code>kotliner</code>转换为了<code>Person</code>类型，所以上述两个输出语句等价<br>
<strong>类型自动转换作用范围：在<code>if</code>语句之内是转换后的类型，在<code>if</code>语句之外还是之前类型</strong></p>
</li>
</ul>
<p><strong>不支持智能转换的情况</strong></p>
<p>定义的顶级<code>property</code>,在多个方法里都可以调用，虽然在某个方法中调用时判断了该变量是某个值，但是其它线程可能对它做修改，所以不支持智能转换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tag : String? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tag != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(tag.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会在<code>tag.length</code>报错<code>Smart cast to 'String' is impossible, because 'tag' is a mutable property that could have been changed by this time</code>，即<em>无法将类型强制转换为“字符串”，因为“tag”是可变属性，而此时可能已更改</em></p>
<h2><a href="#2-类型的安全转换" class="header-anchor">#</a><span id="2-类型的安全转换">2. 类型的安全转换</span></h2>
<p>强制转换时要考虑空情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotliner: Kotiner = Person(<span class="string">&quot;Lee&quot;</span>, <span class="number">20</span>)</span><br><span class="line">println((kotliner <span class="keyword">as</span>? Person)?.name)</span><br></pre></td></tr></table></figure>
<p>上述代码，在将变量<code>kotliner</code>通过操作符<code>as</code>强制转换为<code>Person</code>时添加了操作符<code>?</code>，表示如果强制转换失败的话返回<code>null</code>，又因变量<code>kotliner</code>强转后的结果可能为<code>null</code>，则调用<code>name</code>属性之前也要加操作符<code>?</code>以判断非空时再调用<code>name</code>属性</p>
<h2><a href="#3-智能类型转换延伸的几点建议" class="header-anchor">#</a><span id="3-智能类型转换延伸的几点建议">3. 智能类型转换延伸的几点建议</span></h2>
<ul>
<li>尽可能使用<code>val</code>来声明不可变引用，让程序含义更加清晰确定</li>
<li>尽可能减少函数对外部变量的访问，也为函数式编程提供基础</li>
<li>必要时创建局部变量指向外部变量，避免因它变化引起程序错误</li>
</ul>
<h1><a href="#六-示例使用retrofit访问网络请求" class="header-anchor">#</a><span id="六-示例使用retrofit访问网络请求">六、示例–使用Retrofit访问网络请求</span></h1>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repos/&#123;owner&#125;/&#123;repo&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRespository</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;owner&quot;</span>)</span> owner: <span class="type">String</span>, <span class="meta">@Path(<span class="string">&quot;repo&quot;</span>)</span> repo:<span class="type">String</span>)</span></span>: Call&lt;Respository&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gitHubApi = Retrofit.Builder().baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">            .create(GitHubApi::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> response = gitHubApi.getRespository(<span class="string">&quot;JetBrains&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>).execute()</span><br><span class="line">    <span class="keyword">val</span> repository = response.body()</span><br><span class="line">    <span class="keyword">if</span> (repository == <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error! <span class="subst">$&#123;response.code()&#125;</span> - <span class="subst">$&#123;response.message()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(repository.name)</span><br><span class="line">        println(repository.full_name)</span><br><span class="line">        println(repository.owner.login)</span><br><span class="line">        File(<span class="string">&quot;Kotlin.html&quot;</span>).writeText(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">            &lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;head&gt;</span></span><br><span class="line"><span class="string">                    &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;title&gt;<span class="subst">$&#123;repository.owner.login&#125;</span> - <span class="subst">$&#123;repository.name&#125;</span>&lt;/title&gt;</span></span><br><span class="line"><span class="string">                &lt;/head&gt;</span></span><br><span class="line"><span class="string">                &lt;body&gt;</span></span><br><span class="line"><span class="string">                    &lt;h1&gt;&lt;a href=&#x27;<span class="subst">$&#123;repository.html_url&#125;</span>&#x27;&gt;<span class="subst">$&#123;repository.owner.login&#125;</span> - <span class="subst">$&#123;repository.name&#125;</span>&lt;/a&gt;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                &lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>.trimIndent())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取<code>kotlin</code>项目在<code>GitHub</code>中的一些数据，并将其生成一个网页文件。其中的<code>Respository</code>数据类可使用<code>Android Studio</code>的插件<code>NewDataClassAction</code>生成。</p>
<h1><a href="#七-附录" class="header-anchor">#</a><span id="七-附录">七、附录</span></h1>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/null-safety.html">https://www.kotlincn.net/docs/reference/null-safety.html</a><br>
<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/properties.html">https://www.kotlincn.net/docs/reference/properties.html</a><br>
<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/extensions.html">https://www.kotlincn.net/docs/reference/extensions.html</a></p>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/类型/" title="类型">类型 </a><span class="leancloud_visitors"></span><span>大约6638个字, 22分钟7秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2020/12/15/kotlin学习系列二/,Puppet,Kotlin学习系列二：类与接口初解,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><!-- Mermaid diagrams support--><script src="https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  mermaid.initialize({
    startOnLoad: true,
    securityLevel: 'loose',
    flowchart: { htmlLabels: true, useMaxWidth: true },
    classDiagram: {
      layout: 'elk',
      elk: {
        'elk.spacing.nodeNodeBetweenLayers': 200,
        'elk.spacing.nodeNode': 80
      }
    },
    theme: 'default',
    logLevel: 1
  });
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>