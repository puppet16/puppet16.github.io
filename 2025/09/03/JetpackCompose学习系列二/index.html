<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>JetpackCompose学习系列二： 状态订阅与自动更新 · Puppet</title><meta name="description" content="一、前言
二、自定义 Composable

1. 自定义 Compose 函数建议外层只调用一个 Compose 函数


三、刷新逻辑中的组合
四、MutableState

1. by 与 = 的区别
2. mutableStateOf

1. SnapshotMutableStateImpl"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JetpackCompose学习系列二： 状态订阅与自动更新</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89-composable">二、自定义 Composable</a>
<ul>
<li><a href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89-compose-%E5%87%BD%E6%95%B0%E5%BB%BA%E8%AE%AE%E5%A4%96%E5%B1%82%E5%8F%AA%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA-compose-%E5%87%BD%E6%95%B0">1. 自定义 Compose 函数建议外层只调用一个 Compose 函数</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%88%B7%E6%96%B0%E9%80%BB%E8%BE%91%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88">三、刷新逻辑中的组合</a></li>
<li><a href="#%E5%9B%9B-mutablestate">四、MutableState</a>
<ul>
<li><a href="#1-by-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB">1. by 与 = 的区别</a></li>
<li><a href="#2-mutablestateof">2. <code>mutableStateOf</code></a>
<ul>
<li><a href="#1-snapshotmutablestateimpl">1. SnapshotMutableStateImpl</a></li>
<li><a href="#2-sateobject-%E4%B8%8E-staterecord">2. SateObject 与 StateRecord</a></li>
<li><a href="#3-get-nextreadablethisvalue-%E8%A7%A3%E6%9E%90">3. <code>get() = next.readable(this).value</code> 解析</a></li>
<li><a href="#4-set-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90">4. set() 方法解析</a></li>
<li><a href="#5-%E4%B8%A4%E5%A5%97%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9F">5. 两套订阅系统</a></li>
<li><a href="#6-mutablestateof-%E6%80%BB%E7%BB%93">6. mutableStateOf 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94-remember">五、 remember</a>
<ul>
<li><a href="#1-%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F">1. 重组作用域</a></li>
<li><a href="#2-remember">2. remember</a></li>
<li><a href="#3-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84-remember">3. 带参数的 remember</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E6%97%A0%E7%8A%B6%E6%80%81%E4%B8%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">六、无状态与单向数据流</a>
<ul>
<li><a href="#1-%E6%97%A0%E7%8A%B6%E6%80%81-stateless">1. 无状态 <em><code>Stateless</code></em></a></li>
<li><a href="#2-%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87">2. 状态提升</a></li>
<li><a href="#3-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">3. 单向数据流</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-list-%E8%87%AA%E5%8A%A8%E8%AE%A2%E9%98%85-mutablestatelistof">七、List 自动订阅 – mutableStateListOf</a></li>
<li><a href="#%E5%85%AB-%E9%87%8D%E7%BB%84%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">八、重组的性能优化</a>
<ul>
<li><a href="#1-%E9%87%8D%E7%BB%84%E7%9A%84%E6%80%A7%E8%83%BD%E9%A3%8E%E9%99%A9">1. 重组的性能风险</a></li>
<li><a href="#2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">2. 性能优化</a>
<ul>
<li><a href="#1-stable-%E6%B3%A8%E8%A7%A3">1. @Stable 注解</a></li>
<li><a href="#2-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%AC%E5%BC%80%E5%B1%9E%E6%80%A7%E5%8A%A0%E7%8A%B6%E6%80%81">2. 类型的公开属性加状态</a></li>
<li><a href="#3-%E6%80%BB%E7%BB%93">3. 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%9D-derivedstateof">九、derivedStateOf()</a>
<ul>
<li><a href="#1-derivedstateof-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81">1. derivedStateOf: 将一个或多个状态对象转换为其他状态</a></li>
<li><a href="#2-derivedstateof-%E4%B8%8E-rememberkey-%E5%8C%BA%E5%88%AB">2. derivedStateOf 与 remember(key) 区别</a></li>
<li><a href="#3-dervedstateof-%E4%B8%8E-rememberkey-%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8">3. dervedStateOf 与 remember(key) 综合使用</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81-compositionlocal">十、CompositionLocal</a>
<ul>
<li><a href="#1-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">1. 简单使用</a></li>
<li><a href="#2-%E8%A6%86%E7%9B%96%E4%BD%BF%E7%94%A8">2. 覆盖使用</a></li>
<li><a href="#3-compositionlocalof-%E4%B8%8E-staticcompositionlocalof">3. compositionLocalOf 与 staticCompositionLocalOf</a></li>
<li><a href="#4-%E6%BA%90%E7%A0%81">4. 源码</a></li>
<li><a href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5. 使用场景</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B1%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84-materialtheme">示例1：系统提供的 MaterialTheme</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B2-%E7%BB%84%E5%90%88%E5%BC%8F%E6%97%A5%E5%BF%97%E9%80%9A%E9%81%93">示例2 ：组合式日志通道</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h2><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h2>
<ol>
<li>本文主要讲述<strong>Jetpack Compose 的状态订阅与自动更新</strong></li>
<li><strong>Google 官网：<a target="_blank" rel="noopener" href="https://developer.android.com/develop/ui/compose/documentation?hl=zh-cn">https://developer.android.com/develop/ui/compose/documentation?hl=zh-cn</a></strong></li>
</ol>
<h2><a href="#二-自定义-composable" class="header-anchor">#</a><span id="二-自定义-composable">二、自定义 Composable</span></h2>
<ul>
<li><strong>只有 <code>Composable</code> 函数才可以调用 <code>Composable</code> 函数</strong></li>
<li><strong><code>Composable</code> 函数名采用大驼峰命名法，首字母都大写</strong></li>
</ul>
<p><code>@Composeable</code> 就是相当于标识符，为函数添加注解 <code>@Composeable</code> 即可创建自定义 <code>Compose</code> 组件，这些添加注解的组件函数会在编译阶段被 <code>Compose</code> 的编译器插件进行修改，添加 <code>Composer</code> 类型的参数。实际调用的就是这些被修改后的产物。<br>
这就和协程有些相似，添加了<code>suspend</code> 关键字的方法是协程函数，而在编译阶段编译器会给协程函数添加一个<code>Continuation</code>类型的参数。</p>
<blockquote>
<p>Tips：这就是面向切面编程 <em>(AOP)</em> 的实例， 一般使用注解处理器 <em>（Annotation Processor）</em> 或修改字节码进行实现。而 <code>Compose</code> 使用了第三种方式，使用了编译器插件 <em>(Compiler Plugin)</em>，该方式功能更强大，且便于跨平台。</p>
</blockquote>
<p>界面的入口 <code>ComponentActivity.setContent()</code> 方法，该方法并没有直接调用 <code>Composable</code> 函数，而是对它进行了传递，经过层层传递，最终<code>invokeComposable()</code> 方法直接调用 <code>Composable</code> 函数，该方法里直接将 <code>Composable</code> 函数进行强制类型转换，并进行调用。源码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeComposable</span><span class="params">(composer: <span class="type">Composer</span>, composable: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> realFn = composable <span class="keyword">as</span> Function2&lt;Composer, <span class="built_in">Int</span>, <span class="built_in">Unit</span>&gt;</span><br><span class="line">    realFn(composer, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#1-自定义-compose-函数建议外层只调用一个-compose-函数" class="header-anchor">#</a><span id="1-自定义-compose-函数建议外层只调用一个-compose-函数">1. 自定义 Compose 函数建议外层只调用一个 Compose 函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MultiComposableDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里连续调用多个可组合函数是完全合法的，但是不建议</span></span><br><span class="line">    Text(<span class="string">&quot;标题&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;按钮&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MultiComposableDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(<span class="string">&quot;标题&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;按钮&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MultiComposableDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Row &#123;</span><br><span class="line">        Text(<span class="string">&quot;标题&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;按钮&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Compose</code> 中，<code>@Composable</code> 不&quot;返回 <code>View</code>&quot;，而是 <em>“向父级插槽发射节点”</em>。同一个函数里多次调用可组合函数，会发射多个兄弟节点。<br>
这些兄弟节点如何&quot;测量/摆放&quot;，完全由&quot;外层容器&quot;的布局策略决定 <em>（Row/Column/Box 各不相同）</em>。</p>
<p>如上代码所示，这三个示例都是合法的。但是在示例1中，发射两个兄弟节点，但不声明布局策略。它们将&quot;交给调用处的父容器&quot;去布局：</p>
<ul>
<li>被放进 <code>Column &#123; MultiComposableDemo1() &#125;</code> → 垂直排布</li>
<li>被放进 <code>Row &#123; MultiComposableDemo1() &#125;</code> → 水平排布</li>
<li>被放进 <code>Box &#123; MultiComposableDemo1() &#125;</code> → 默认重叠在一起</li>
</ul>
<p>因此&quot;<strong>合法但不建议</strong>&quot;：组件自身没有确定的布局，表现取决于外部场景，易产生不可预期的重叠/间距问题，也不便封装间距、对齐、可访问性语义等。<br>
当&quot;刻意把布局交给调用方&quot;时 <em>（比如做一个纯内容片段、让它在不同父容器中按父布局策略呈现）</em>。否则，优先在组件内部选定 Row/Column/Box 等，让组件行为可预期。</p>
<h2><a href="#三-刷新逻辑中的组合" class="header-anchor">#</a><span id="三-刷新逻辑中的组合">三、刷新逻辑中的组合</span></h2>
<p>刷新层层递进分三部分：组合 --&gt; 布局 --&gt; 绘制。</p>
<p>后两层与传统 <code>View</code> 体系里的布局、绘制是一样的。</p>
<p>组合是执行这些 <code>@Compose</code> 函数的过程，这个过程就是拼凑实际界面内容的过程。也就是根据各 <code>@Compose</code> 函数组合出一个个的实际对象，这些实际对象参与后续的布局、绘制。实际对象就是 <code>LayoutNode</code> 等。</p>
<h2><a href="#四-mutablestate" class="header-anchor">#</a><span id="四-mutablestate">四、MutableState</span></h2>
<p>在 <code>Compose</code> 里进行界面的刷新，通过 <code>MutableState</code> 状态的订阅来进行更新。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MutableState</span>&lt;<span class="type">T</span>&gt; : <span class="type">State</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> value: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我的理解是 <code>MutableState</code> 是给真实的值套了一层状态的壳子，<code>Compose</code> 通过这层状态的壳子来判断并进行更新，而里面的值才是使用方真正用到的值。</p>
<h3><a href="#1-by-与-的区别" class="header-anchor">#</a><span id="1-by-与-的区别">1. by 与 = 的区别</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MutableStateDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name = mutableStateOf(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name2 <span class="keyword">by</span> mutableStateOf(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    Text(text = <span class="string">&quot;名称1：<span class="subst">$&#123;name.value&#125;</span>, 名称2：<span class="subst">$&#123;name2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 如果年增修改 name2 ，则需要 var 定义</span></span><br><span class="line">    name2 = <span class="string">&quot;C&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示：</p>
<ul>
<li><code>name</code> 的类型为 <code>MutableState</code> 类型，在调用位置需要使用 <code>value</code> 属性获取 <code>String</code> 值，而且因为是 <code>MutableState</code> 类型，只有里面的值需要改变，所以 <code>name</code> 被 <code>val</code> 定义</li>
<li><code>name2</code> 的类型为 <code>String</code> 类型，在调用位置可直接使用该值，它其实通 <code>by</code> 关键字进行委托右边的值进行读写，也就是说可以通过修改右侧的值，来达到修改它的目的，所以也可以被 <code>val</code> 定义。但是如果需要直接修改 <code>name2</code> 来达到修改值的目的，则需要被 <code>var</code> 定义。</li>
</ul>
<p><code>by</code> 委托模式，需要右边的内容实现 <code>getValue()</code> 和 <code>setValue</code> 两个方法，而查看 <code>MutableState</code> 里是没有这个方法，而是通过 <code>MutableState</code> 的扩展函数来进行实现的。源码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.  androidx.compose.runtime.SnapshotState.kt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;NOTHING_TO_INLINE&quot;</span>)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> State<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(thisObj: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = value</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;NOTHING_TO_INLINE&quot;</span>)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableState<span class="type">&lt;T&gt;</span>.<span class="title">setValue</span><span class="params">(thisObj: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在使用 <code>by</code> 关键字时，通知还需要引入两个包 <code>import androidx.compose.runtime.setValue</code> 、<code>import androidx.compose.runtime.getValue</code>，来达到 委托的条件。不需要全引，看使用场景。</p>
<h3><a href="#2-mutablestateof" class="header-anchor">#</a><span id="2-mutablestateof">2. <code>mutableStateOf</code></span></h3>
<h4><a href="#1-snapshotmutablestateimpl" class="header-anchor">#</a><span id="1-snapshotmutablestateimpl">1. SnapshotMutableStateImpl</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.  androidx.compose.runtime.SnapshotState.kt</span></span><br><span class="line"><span class="meta">@StateFactoryMarker</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">mutableStateOf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    value: <span class="type">T</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    policy: <span class="type">SnapshotMutationPolicy</span>&lt;<span class="type">T</span>&gt; = structuralEqualityPolicy()</span></span></span><br><span class="line">): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. androidx.compose.runtime.ActualAndroid.android.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">createSnapshotMutableState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    value: <span class="type">T</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    policy: <span class="type">SnapshotMutationPolicy</span>&lt;<span class="type">T</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. androidx.compose.runtime.ParcelableSnapshotMutableState.android.kt</span></span><br><span class="line"><span class="meta">@SuppressLint(<span class="string">&quot;BanParcelableUsage&quot;</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ParcelableSnapshotMutableState</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    value: T,</span><br><span class="line">    policy: SnapshotMutationPolicy&lt;T&gt;</span><br><span class="line">) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. androidx.compose.runtime.SnapshotState.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SnapshotMutableStateImpl</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    value: T,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> policy: SnapshotMutationPolicy&lt;T&gt;</span><br><span class="line">) : StateObjectImpl(), SnapshotMutableState&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() = next.readable(<span class="keyword">this</span>).value</span><br><span class="line">        <span class="keyword">set</span>(value) = next.withCurrent &#123;</span><br><span class="line">            <span class="keyword">if</span> (!policy.equivalent(it.value, value)) &#123;</span><br><span class="line">                next.overwritable(<span class="keyword">this</span>, it) &#123; <span class="keyword">this</span>.value = value &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> next: StateStateRecord&lt;T&gt; = StateStateRecord(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> firstStateRecord: StateRecord</span><br><span class="line">        <span class="keyword">get</span>() = next</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上源码所示，在经过 4 层查找后，最终，找到了 <code>SnapshotMutableStateImpl</code>，这里实现了 <code>mutableStateOf</code> 里传递的那个 <code>value</code>的 <code>get()</code>和 <code>set</code> 方法。<br>
观察其 <code>set</code> 和 <code>get</code> 方法：</p>
<ul>
<li>调用 <code>get</code> 方法时，不仅仅返回了结果，<strong>还记录了是在哪里调用的 <code>get</code> 方法。</strong></li>
<li>调用 <code>set</code> 方法时，不只是修改 <code>value</code> 的值，<strong>还要查找那些调用 <code>get</code> 方法的位置，然后通知这些位置进行刷新。</strong></li>
</ul>
<h4><a href="#2-sateobject-与-staterecord" class="header-anchor">#</a><span id="2-sateobject-与-staterecord">2. SateObject 与 StateRecord</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. androidx.compose.runtime.SnapshotState.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StateStateRecord</span>&lt;<span class="type">T</span>&gt;(myValue: T) : StateRecord() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">assign</span><span class="params">(value: <span class="type">StateRecord</span>)</span></span> &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">this</span>.value = (value <span class="keyword">as</span> StateStateRecord&lt;T&gt;).value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: StateRecord = StateStateRecord(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> value: T = myValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. androidx.compose.runtime.snapshots.StateRecord</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">StateRecord</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> snapshotId: <span class="built_in">Int</span> = currentSnapshot().id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> next: StateRecord? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">assign</span><span class="params">(value: <span class="type">StateRecord</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: StateRecord</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看 <code>get() = next.readable(this).value</code>，其中的 <code>next</code> 其实是 <code>StateStateRecord</code> 对象，而 <code>StateStateRecord</code> 继续自 <code>StateRecord</code>。</p>
<p>而 <code>SnapshotMutableStateImpl</code> 继承了 <code>StateObjectImpl</code>，而它又实现了 <code>StateObject</code> 接口。<strong>能够被订阅的，实际都是 <code>SateObject</code> 的实现类。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7. androidx.compose.runtime.snapshots.StateRecord</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StateObject</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> firstStateRecord: StateRecord</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">prependStateRecord</span><span class="params">(value: <span class="type">StateRecord</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeRecords</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        previous: <span class="type">StateRecord</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        current: <span class="type">StateRecord</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        applied: <span class="type">StateRecord</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: StateRecord? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下链路，<code>MutableState</code> 能够被订阅，是因为实现了 <code>StateObject</code>，而 <code>StateObject</code> 没有直接装载目标类型对象，而是将目标类型对象放到了<code>StateRecord</code> 对象里储存。<strong><code>StateRecord</code> 是一个链表</strong>，这样做的目的是为了存多个目标类型对象 <em>(多份新旧值)</em>，因为 <code>Compose</code> 支持事务功能。 <code>firstStateRecord</code> 是这个链表里的头节点。</p>
<h4><a href="#3-get-nextreadablethisvalue-解析" class="header-anchor">#</a><span id="3-get-nextreadablethisvalue-解析">3. <code>get() = next.readable(this).value</code> 解析</span></h4>
<p>所以，<code>get() = next.readable(this).value</code> 是取出目标类型对象链表的头节点，之后调用 <code>readable()</code> 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8. androidx.compose.runtime.snapshots.Snapshot.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord&gt;</span> T.<span class="title">readable</span><span class="params">(state: <span class="type">StateObject</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> snapshot = Snapshot.current</span><br><span class="line">    snapshot.readObserver?.invoke(state)</span><br><span class="line">    <span class="keyword">return</span> readable(<span class="keyword">this</span>, snapshot.id, snapshot.invalid) ?: sync &#123;</span><br><span class="line">        <span class="keyword">val</span> syncSnapshot = Snapshot.current</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        readable(state.firstStateRecord <span class="keyword">as</span> T, syncSnapshot.id, syncSnapshot.invalid) ?: readError()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord&gt;</span> <span class="title">readable</span><span class="params">(r: <span class="type">T</span>, id: <span class="type">Int</span>, invalid: <span class="type">SnapshotIdSet</span>)</span></span>: T? &#123;</span><br><span class="line">    <span class="comment">// The readable record is the valid record with the highest snapshotId</span></span><br><span class="line">    <span class="keyword">var</span> current: StateRecord? = r</span><br><span class="line">    <span class="keyword">var</span> candidate: StateRecord? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid(current, id, invalid)) &#123;</span><br><span class="line">            candidate = <span class="keyword">if</span> (candidate == <span class="literal">null</span>) current</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidate.snapshotId &lt; current.snapshotId) current <span class="keyword">else</span> candidate</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (candidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">return</span> candidate <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readable()</code> 方法，中 <code>snapshot.readObserver?.invoke(state)</code> 用于进行记录 <code>StateObject</code>，也就是<code>MutableState</code> 对象，被这个地方使用了。这个地方也就是指调用了 <code>MutableState</code> 的 <code>get</code> 方法的地方。而这个记录行为相当于订阅行为，<code>MutableState</code> 每次被修改的时候，会遍历<br>
这些记录，将这些记录里的地方标记为失效，失效的地方在下一帧进行重组 <em>（Recompose, 再次进行组合）</em>。</p>
<p><code>readable()</code> 方法最终调用到三个入参的重载方法，该方法遍历 <code>StateRecord</code> 链表，找到一个 <strong>最新的、可用的</strong> <code>StateRecord</code>。并返回这个值。</p>
<p>所以，<code>get() = next.readable(this)</code> 的作用是，拿到头节点，遍历整个表，取出最新的、可用的 <code>StateRecord</code>，并且记录下 <code>StateObject</code>的子类被使用的地方。之后再调用 <code>.value</code> 是取出存在于 <code>StateRecord</code> 里的目标类型对象。</p>
<h4><a href="#4-set-方法解析" class="header-anchor">#</a><span id="4-set-方法解析">4. set() 方法解析</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(value) = next.withCurrent &#123;</span><br><span class="line">    <span class="keyword">if</span> (!policy.equivalent(it.value, value)) &#123;</span><br><span class="line">        next.overwritable(<span class="keyword">this</span>, it) &#123; <span class="keyword">this</span>.value = value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 9. androidx.compose.runtime.snapshots.Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord&gt;</span> <span class="title">current</span><span class="params">(r: <span class="type">T</span>)</span></span> =</span><br><span class="line">    Snapshot.current.let &#123; snapshot -&gt;</span><br><span class="line">        readable(r, snapshot.id, snapshot.invalid) ?: sync &#123;</span><br><span class="line">            Snapshot.current.let &#123; syncSnapshot -&gt;</span><br><span class="line">                readable(r, syncSnapshot.id, syncSnapshot.invalid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ?: readError()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord, R&gt;</span> T.<span class="title">withCurrent</span><span class="params">(block: (<span class="type">r</span>: <span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">    block(current(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>
<p><code>next.WithCurrent &#123;&#125;</code> 方法就是执行一下 <code>&#123;&#125;</code> 里的内容，并将 <code>current(this)</code> 的结果传递给 <code>&#123;&#125;</code>。 而 <code>current(this)</code> 方法里最终调用的 <code>readable()</code>三参数的函数，该方法遍历 <code>StateRecord</code> 链表，找到一个 <strong>最新的、可用的</strong> <code>StateRecord</code>，并返回这个值。也就是说，将当前最新的、可用的 <code>StateRecord</code> 传递给 <code>&#123;&#125;</code>。该代码块里执行，如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!policy.equivalent(it.value, value)) &#123;</span><br><span class="line">    next.overwritable(<span class="keyword">this</span>, it) &#123; <span class="keyword">this</span>.value = value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码块是比较一下新旧值是否一样，如果值没有变化，就结束；如果值有变化，就进入这个 <code>if</code> 语句内部，执行 <code>next.overwritable(this, it) &#123; this.value = value &#125;</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10. androidx.compose.runtime.snapshots.Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord, R&gt;</span> T.<span class="title">overwritable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    state: <span class="type">StateObject</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    candidate: <span class="type">T</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">T</span>.() -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> snapshot: Snapshot = snapshotInitializer</span><br><span class="line">    <span class="keyword">return</span> sync &#123;</span><br><span class="line">        snapshot = Snapshot.current</span><br><span class="line">        <span class="keyword">this</span>.overwritableRecord(state, snapshot, candidate).block()</span><br><span class="line">    &#125;.also &#123;</span><br><span class="line">        notifyWrite(snapshot, state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord&gt;</span> T.<span class="title">overwritableRecord</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    state: <span class="type">StateObject</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    snapshot: <span class="type">Snapshot</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    candidate: <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">if</span> (snapshot.readOnly) &#123;</span><br><span class="line">        <span class="comment">// If the snapshot is read-only, use the snapshot recordModified to report it.</span></span><br><span class="line">        snapshot.recordModified(state)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> id = snapshot.id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidate.snapshotId == id) <span class="keyword">return</span> candidate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> newData = sync &#123; newOverwritableRecordLocked(state) &#125;</span><br><span class="line">    newData.snapshotId = id</span><br><span class="line"></span><br><span class="line">    snapshot.recordModified(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>overwriteable()</code> 方法调用了一个 <code>overwritableRecord()</code> 方法：如果传进来的 <code>StateRecord</code> 正好对应了传进来的 <code>Snapshot</code>，则直接返回传入的 <code>StateRecord</code>。如果不对应，则生成一个 <code>StateRecord</code>，然后返回这个生成的。<br>
其中，<code>StateRecord</code> 修改前后的值都会被存起来，形成一个链表。链表上的各个节点其实都对应了某个时刻的 <code>Compose</code> 的整个内部状态， <code>Compose</code> 记录每个变量的每个状态，用的是 <code>StateRecord</code>。具体各个链表上的哪些节点共属于同一个状态由 <code>Snapshot</code> 进行记录。<code>Snapshot</code> 记录的是整个状态，可以对应多个 <code>StateRecord</code>，而一个 <code>StateRecord</code> 对应一个 <code>Snapshot</code>。</p>
<blockquote>
<p>Tips: 有了快照，在某些变量发生改变时，就不必马上进行应用并显示到界面，而是可以在跑完整个 <code>Compose</code> 流程后，在这个过程中所有改变的变量一起应用，并拿应用后的最终结果，进行布局绘制。</p>
<p>系统有多个 <code>Snapshot</code> 时，它们是有先后顺序的。<br>
同一个 <code>StateObject</code> 的每个 <code>StateRecord</code>，都有它们对应的 <code>Snapshot</code> 的 <code>id</code>。即使 <code>Snapshot</code> 和 <code>StateRecord</code> 的 <code>id</code> 不直接对应，但是只要 <code>StateRecord</code> 对应的 <code>Snapshot</code> 对刚才的那个 <code>Snapshot</code> 是有效的，那即使<code>id</code> 不相等，<code>Snapshot</code> 也可以拿到 <code>StateRecord</code>。</p>
</blockquote>
<p>总结， <code>overwritableRecord()</code> 方法，使用直接取、废物利用、直接创建再返回等方式，返回一个 <code>StateRecord</code>。</p>
<p>再返回 <code>overwritable()</code> 方法，拿到了 <code>Snapshot</code> 对应的 <code>StateRecord</code> 然后，执行 <code>block()</code>，这个 <code>block()</code> 就是 <code>set()</code> 方法里的 <code>&#123;this.value = value&#125;</code>，也就是把 <code>set(value)</code> 里的业务类型对象 <code>value</code> 赋值给新拿到的 <code>StateRecord</code>里的<code>value</code>。</p>
<p>之后，再调用 <code>notifyWrite(snapshot, state)</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10. androidx.compose.runtime.snapshots.Snapshot</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">notifyWrite</span><span class="params">(snapshot: <span class="type">Snapshot</span>, state: <span class="type">StateObject</span>)</span></span> &#123;</span><br><span class="line">    snapshot.writeCount += <span class="number">1</span></span><br><span class="line">    snapshot.writeObserver?.invoke(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，该方法用于查找该变量在哪里被读了，然后标记这块组合为失效。</p>
<p>回顾一下解析 <code>set()</code> 方法时，有如下代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord&gt;</span> T.<span class="title">readable</span><span class="params">(state: <span class="type">StateObject</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> snapshot = Snapshot.current</span><br><span class="line">    snapshot.readObserver?.invoke(state)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和刚才的 <code>snapshot.writeObserver?.invoke(state)</code> 相对应。</p>
<p><code>snapshot.readObserver?.invoke(state)</code>，相当于订阅<br>
<code>snapshot.writeObserver?.invoke(state)</code>，相当于通知</p>
<p>这两个流程加起来是一个订阅流程。</p>
<h4><a href="#5-两套订阅系统" class="header-anchor">#</a><span id="5-两套订阅系统">5. 两套订阅系统</span></h4>
<ol>
<li>
<p><code>compose</code> 先订阅 <code>Snapshot</code>，对读写 <code>StateObject</code> 分别做订阅，并且在读和写的时候进行通知，所以有两个接受者：<code>readObserver</code>、<code>writeObserver</code>。</p>
<ul>
<li>订阅时间： <code>Snapshot</code> 创建的时候</li>
<li>通知时间： 读和写的时候</li>
</ul>
</li>
<li>
<p><code>compose</code> 还会对每一个 <code>StateObject</code> 的应用做订阅。</p>
<ul>
<li>订阅时间： 第一套设阅的 <code>readObserver</code> 被调用 <em>(通知)</em> 的时候</li>
<li>通知时间： <code>StateObject</code> 新值被应用的时候</li>
</ul>
</li>
</ol>
<p><code>snapshot</code> 是允许有多个的，但是只有一个当前且全局的 <code>snapshot</code>, 当把一个非全局的 <code>snapshot</code> 应用到全局的 <code>snapshot</code>,这个改动才算生效，这个过程就叫应用。</p>
<p><code>snapshot</code> 主要用于组合过程中，<code>writeObserver</code> 是用 <strong>在组合过程中</strong>，值被改变，才标记失效</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposableDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = mutableStateOf(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    Box (modifier = Modifier.clickable &#123;</span><br><span class="line">        <span class="comment">// 步骤1</span></span><br><span class="line">        name.value = <span class="string">&quot;B&quot;</span></span><br><span class="line">    &#125;) &#123; </span><br><span class="line">        <span class="comment">// 步骤2</span></span><br><span class="line">        Text(name.value)</span><br><span class="line">        <span class="comment">// 步骤3</span></span><br><span class="line">        name.value = <span class="string">&quot;C&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在组合过程中，也就是在执行过程中:</p>
<ol>
<li>在 步骤2 中，读 <code>name</code> 值，所以被记录了，然后又在 步骤3 进行了 <code>name</code> 的写操作。由此会通知读位置失效也就是 步骤 2 、步骤 3 所在的大括号范围。</li>
<li>在步骤 1 中，点击监听中也对 <code>name</code> 值进行改变，并不是在组合过程中，所以不会通知  <code>writeObserver</code>。只有在组合过程中的写操作，才会通知  <code>writeObserver</code>，所以是通过第二套订阅系统进行的更新，也就是通过对 <code>StateObject</code> 的应用做订阅。</li>
</ol>
<h4><a href="#6-mutablestateof-总结" class="header-anchor">#</a><span id="6-mutablestateof-总结">6. mutableStateOf 总结</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. androidx.compose.runtime.SnapshotState.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SnapshotMutableStateImpl</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    value: T,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> policy: SnapshotMutationPolicy&lt;T&gt;</span><br><span class="line">) : StateObjectImpl(), SnapshotMutableState&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() = next.readable(<span class="keyword">this</span>).value</span><br><span class="line">        <span class="keyword">set</span>(value) = next.withCurrent &#123;</span><br><span class="line">            <span class="keyword">if</span> (!policy.equivalent(it.value, value)) &#123;</span><br><span class="line">                next.overwritable(<span class="keyword">this</span>, it) &#123; <span class="keyword">this</span>.value = value &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> next: StateStateRecord&lt;T&gt; = StateStateRecord(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> firstStateRecord: StateRecord</span><br><span class="line">        <span class="keyword">get</span>() = next</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><code>mutableStateOf</code> 返回一个 <code>MutableState</code> 对象，而该对象的实现为 <code>SnapshotMutableStateImpl</code>，而 <code>SnapshotMutableIntStateImpl</code> 又是 <code>StateObject</code> 的实现，<strong>能够被订阅的，实际都是 <code>SateObject</code> 的实现类。</strong></li>
<li><code>StateObject</code> 通知  <code>StateRecord</code> 来记录真实需要的业务类型对象，并通过链表的形式记录该值的一系列变化。</li>
<li><code>StateObject</code> 的<code>get</code> 方法会把读值的位置记录下来，<code>StateObject</code> 的 <code>set</code> 方法，会把所有读值的地方标记为失效。每个 <code>StateObject</code> 的新值被应用时，也会标记读该值的地方标记为失效。在这两种标记为失效的场景下，都会在下一帧重组刷新。</li>
</ol>
<h2><a href="#五-remember" class="header-anchor">#</a><span id="五-remember">五、 remember</span></h2>
<h3><a href="#1-重组作用域" class="header-anchor">#</a><span id="1-重组作用域">1. 重组作用域</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposableDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = mutableStateOf(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    Text(name.value)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到过，会在取值时记录取值的地方，并在写值的时候将该地方置为无效，并在下一帧进行重组。</p>
<p><code>Compose</code> 的编译器插件会把这些可能重新调用的代码块包起来，在包起来的代码块执行完成后，会把这个代码块保存起来，并标记到当前执行的位置，这样，当重新执行的逻辑被执行的时候，那就拿出这个代码块重新执行。注意，只有可能会被重新执行的代码才会被包起来。这种被包起来的在重组时一起执行的代码范围被叫做重组作用域 <em>（recompose scope）</em> 。</p>
<p>而如果在重组作用域里包含了状态变量的初始化，则每次重组都会把状态变量初始化，而不是使用修改之后的值。</p>
<h3><a href="#2-remember" class="header-anchor">#</a><span id="2-remember">2. remember</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposableDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line">    Text(name.toString(), Modifier.clickable &#123;name = name + <span class="number">1</span>&#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，第一行使用 <code>remember</code> 包裹了 <code>name</code> 的初始化值，之后第二行 <code>Text</code> 显示这个值并监听 <code>Text</code> 的点击事件，一旦点击就将 <code>name</code> 的值加一。<br>
通过之前的分析可以得到，上面的重组作用域是这两行代码，而第一行是 <code>name</code> 的初始化代码，如果不用 <code>remember</code> 包裹的话，则每次重组都会给 <code>name</code> 赋初值，也就达不到点击按钮原本的效果。</p>
<p><code>remember</code> 的效果，其实起到缓存作用。是在第一次被调用时，执行 <code>remember</code> 包裹的内容，并保存执行结果，等下次再调用时直接返回保存的结果。所以在重组时即使又调用了初始化操作，但是返回的其实是保存的结果。</p>
<p><strong>使用时机：</strong> 对可能进行重组的变量使用。即只有在组合里创建的变量，不想每次重组后都重新初始化，才需要 <code>remember</code></p>
<h3><a href="#3-带参数的-remember" class="header-anchor">#</a><span id="3-带参数的-remember">3. 带参数的 remember</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.compose.runtime</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">remember</span><span class="params">(<span class="keyword">crossinline</span> calculation: @<span class="type">DisallowComposableCalls</span> () -&gt; <span class="type">T</span>)</span></span>: T =</span><br><span class="line">    currentComposer.cache(<span class="literal">false</span>, calculation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">remember</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    key1: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> calculation: @<span class="type">DisallowComposableCalls</span> () -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> currentComposer.cache(currentComposer.changed(key1), calculation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面源码可以看到 <code>remember</code> 还可以带 <code>key</code> 参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RememberParamsDemo</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> length = remember(name) &#123; name.length &#125;</span><br><span class="line">    Text(length.toString())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，传递一个字符串，然后在代码块里，使用 <code>Text</code> 显示这个字符串的长度。只有当 <code>name</code> 的值改变时，才会重新进行 <code>.length</code> 的计算。<br>
注意，<strong><code>key</code> 值慎重 <em>（不要）</em> 使用引用类型</strong>，比如 <code>List</code> 等，因为 基本数据类型如 <code>String</code> 的改变方式只有一种，那就是重新赋值。但是引用类型的改变除了赋值，主要是内部元素的改变，这种内部元素的改变，不会导致引用类型的变量指向一个新的对象，也就导致<code>remember</code> 里的 <code>key</code> 进行比较时，一直使用的同一个对象进行比较。类似于进行如下比较</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u2&quot;</span>) </span><br><span class="line"><span class="keyword">val</span> oldList = list</span><br><span class="line">list.add(<span class="string">&quot;u3&quot;</span>) </span><br><span class="line"><span class="keyword">val</span> newList = list</span><br></pre></td></tr></table></figure>
<p>上面的示例中 <code>list</code> 、<code>oldList</code> 、<code>newList</code> 三个变量都指向同一个对象，所以，它们即结构化相等，也引用相等 <em>（指向同一对象）</em></p>
<p><strong>使用 key 的典型场景:</strong></p>
<blockquote>
<p>注意：key 变化很频繁会导致频繁重建（例如手势中的偏移），避免把高速变化量做 key。</p>
</blockquote>
<ol>
<li>
<p>重算/重建&quot;依赖输入&quot;的结果：当输入变更才需要重新计算，其他时候复用缓存。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> filtered = remember(query, items) &#123; items.filter &#123; it.contains(query) &#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>让&quot;内部状态&quot;随某个标识重置：切换详情页、用户、Tab 时，清空或重建子状态。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DetailScreen</span><span class="params">(userId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> note <span class="keyword">by</span> remember(userId) &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125; <span class="comment">// userId 变就重置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缓存&quot;与某个 key 绑定&quot;的对象/控制器：例如每个 Tab 一套滚动状态。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listState = remember(currentTab) &#123; androidx.compose.foundation.lazy.LazyListState() &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只在 key 变化时初始化一次的值（昂贵初始化、资源句柄等）。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colorMap = remember(themeId) &#123; buildColorMap(themeId) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>不使用 key（或更合适替代）的情况</strong></p>
<ol>
<li>
<p>仅仅是&quot;从其他 State 派生&quot;的值，优先用 derivedStateOf（自动跟踪依赖）。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text <span class="keyword">by</span> remember &#123; derivedStateOf &#123; <span class="string">&quot;<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>想跨配置变更保存值（如旋转），用 rememberSaveable 而不是靠 key。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><a href="#六-无状态与单向数据流" class="header-anchor">#</a><span id="六-无状态与单向数据流">六、无状态与单向数据流</span></h2>
<h3><a href="#1-无状态-stateless" class="header-anchor">#</a><span id="1-无状态-stateless">1. 无状态 <em><code>Stateless</code></em></span></h3>
<p>所谓状态就是控件属性，比如 <code>TextView</code>，它的 <code>getText()</code> 、<code>setText()</code> 里面操作的 <code>text</code> 就是 <code>TextView</code> 的状态信息。<br>
而，原生 <code>Compose</code> 函数具有无状态的特点，也就是说 <code>Compose</code> 是没有这些内部属性的。比如 <code>Text</code>函数，即使往里设置了文本，但是通过 <code>Text</code> 函数是没办法取出设置的这个文本的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatelessDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> length = <span class="number">2</span></span><br><span class="line">    Text(length.toString())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示， <code>Text</code> 函数是没有状态的，也就是没有内部属性，但是 <code>StatelessDemo</code> 这个函数是有状态的，它有 <code>length</code> 这个内部属性。</p>
<h3><a href="#2-状态提升" class="header-anchor">#</a><span id="2-状态提升">2. 状态提升</span></h3>
<p>如何获取一个没状态的组件的状态？关键点在于 <strong>内部</strong> 两个字，直接就不在内部去拿，而是直接拿传入这个组件的那个属性值就可以了。</p>
<p>如何获取一个有状态的组件的状态？有状态的组件变为无状态的组件，即把状态移到组件外部去，这样也就可以获取状态了。比如刚才的例子，<code>StatelessDemo</code> 组件虽然有 <code>length</code> 这个状态，但是在这个组件外部是没办法拿到这个状态的。只要把 <code>length</code> 值往外提就可以。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatelessDemo</span><span class="params">(length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    Text(length.toString())  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatelessDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> length = <span class="number">3</span></span><br><span class="line">    StatelessDemo(length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，把 <code>StatelessDemo</code> 里的状态 <code>length</code> 往外提，放到了它的父组件 <code>StatelessDemo2</code> 里，如果在父组件的范围里就可以获取到这个状态。但是注意，这此时 <code>length</code> 相当于父组件 <code>StatelessDemo2</code> 的状态，若父组件的父组件要想获取该状态，还需要把状态再往上提升。</p>
<p><strong>这种把状态往外提到父组件的行为就叫做状态提升 <em>（State Hoisting）</em>。</strong> 注意，状态尽量不往上提升，否则该状态能被其它组件修改，容易导致不可测错误。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatelessDemo3</span><span class="params">(length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;A&quot;</span></span><br><span class="line">    Text(name + length.toString())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看 <code>StatelessDemo3</code>，看 <code>length</code> 它是无状态的，但是看 <code>name</code> 它又是有状态的。所以，说有状态还是无状态，不是指的某个组件，而是看组件的具体属性是有状态还是无状态。同一个组件可能即是有状态的还是无状态的，但是属性一定是确定状态类型的。</p>
<h3><a href="#3-单向数据流" class="header-anchor">#</a><span id="3-单向数据流">3. 单向数据流</span></h3>
<p><strong>多数据来源会有数据同步性的问题。</strong> 比如，一个UI界面即会显示数据库内容，又会显示网络内容，但网络内容优先级更高，也就是说在网络请求的时候要先取数据库内容先显示，等网络数据返回了再去覆盖显示。但是要是网络请求比数据库取数据还快，就导致了旧数据覆盖新数据的问题。<br>
所以，只能 UI 界面只有一个数据源那就是数据库，网络数据在更底层，网络数据返回了去更新数据库，如果串行起来，就不会有数据错误的情况。这就是单一信息源 <em>（Single Source of Truth）</em></p>
<p><strong><code>Compose</code> 官方建议单一信息源</strong>，适用于所有界面中会用到的数据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TextFieldDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    TextField(value= name, onValueChange = &#123;</span><br><span class="line">         <span class="comment">//name = it</span></span><br><span class="line">         &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，<code>name</code> 作为一个外部变量，来充当 <code>TextField</code> 的外部状态， <code>value</code> 参数是文件输入框的显示内容， <code>onValueChange</code> 是内容监听器。<br>
按上面 <code>TextFieldDemo1</code> 所示代码，在输入框里输入内容是不显示的，因为没有在输入文字之后把新值更新给 <code>name</code>。也就是说， 上面的代码只是把文本显示的内容与文本内容来源 <code>name</code> 进行了关联，但是并没有把用户的输入行为与文本内容来源做关联。所以应该做如下修改。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TextFieldDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>)&#125;</span><br><span class="line">    TextField(value= name, onValueChange = &#123; name = it &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，在监听器里去更新文本内容来源 <code>name</code>。又因为 <code>name</code> 在重组作用域里，所以要使用 <code>remember</code>，并且为了要重组还要使用 <code>mutableStateOf</code>。</p>
<p>由上面的代码逻辑可以看到，<code>TextField</code> 的信息来源有两个，一个是外部变量 <code>name</code>，一个是用户的输入事件。<br>
因为用户的输入事件响应是封装到 <code>TextField</code> 里，对用户不可见，为了保证单一信息源，所以不会因为用户输入事件而直接改变外部的文本内容源 <code>name</code>，而是直接对外暴露了  <code>onValueChange</code> 事件，交给用户去处理 <code>TextField</code>处理后的内容是否要显示。由此不会让 <code>TextField</code> 内部作为一个信息源，而是都对外暴露出去，这样才是完全封装，用户不需要再关心内部如何实现。</p>
<p>这种 <strong>状态向下传递，事件向上传递修改状态</strong> 的模式，叫做单向数据流 <em>（Unidirectional Data Flow）</em></p>
<p>由 <code>TextField</code> 组件的使用可以得到：具有交互功能的无状态组件，把状态提到外部的同时，也要把交互功能的回调一起提出去。</p>
<h2><a href="#七-list-自动订阅-mutablestatelistof" class="header-anchor">#</a><span id="七-list-自动订阅-mutablestatelistof">七、List 自动订阅 – mutableStateListOf</span></h2>
<p>上文提到过使用 <code>mutableStateOf</code> 包裹数据，可以实现状态订阅和自动更新。基本数据类型都可以，下面实验一下 <code>List</code> 数据是否可行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums <span class="keyword">by</span> mutableStateOf(mutableListOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StateListDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Button( onClick = &#123; </span><br><span class="line">            <span class="comment">// 代码1</span></span><br><span class="line">            nums.add(nums.last() + <span class="number">1</span>)</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            Text(<span class="string">&quot;Add&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        nums.forEach &#123;</span><br><span class="line">            Text(<span class="string">&quot;第 <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，使用 <code>MutableState</code> 包裹 <code>MutableList</code> 类型数据，赋值给 <code>nums</code>，然后添加一个列表，列表顶部有一个 <code>Add</code> 按钮，点击时会给 <code>nums</code> 列表追加一个元素，在按钮之下纵向显示元素内容。</p>
<p>但是点击的结果在界面上是没有显示追加的元素的！<br>
首先回想一下之前的状态订阅和自动更新功能是因为在 <code>set()</code> 、<code>get</code> 方法添加了钩子，做了一些操作。<br>
然后分析一下取值代码, 在 <code>nums</code> 读取的位置，通过 <code>foreach</code> 函数读取所有的值，当 <code>nums</code> 更新时，该函数所在的重组作用域被标识失效，没有问题，是可以被成功订阅的。<br>
再分析一下赋值代码，在 <code>Add</code> 按钮被点击的时候 <code>nums</code> 进行更新，添加一个新元素。问题出在这里！</p>
<p>刚才说过，是给 <code>set</code> 添加了钩子，而 <strong><code>set</code> 方法是重新赋值、替换整个对象、改变引用指向</strong>。也就是说 <code>Compose</code> 的监听是对赋值行为的监听，而不会监听对象的内部状态。<br>
而 <code>nums.add()</code> 方法只改变了<code>nums</code>的内部内容。所以 <code>set</code> 方法没有被触发。</p>
<p>有两个解决方案：</p>
<p><strong>方案一：</strong></p>
<p>重新生成 <code>list</code>, 并赋值给 <code>nums</code>，按上面示例来说，可以在 代码1 处，执行完 <code>nums</code> 的内容改变后，再添加一条语句 <code>nums = nums.toMutableList()</code>，也就是将 <code>nums</code> 内容生成一个新的 <code>list</code> 再重新赋值给 <code>nums</code>，如果就触发了重新赋值的逻辑，界面也就刷新了。性能的损耗虽然不大，但是很不优雅！</p>
<p><strong>方案二：mutableStateListOf</strong></p>
<p>该关键字返回的是一个 <code>MutableList</code> 对象，但是该对象内部元素的变化会被 <code>Compose</code> 观测到，而不是对象本身被观测。如此也就可以进行更新。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = mutableStateListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StateListDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Button( onClick = &#123; </span><br><span class="line">            <span class="comment">// 代码1</span></span><br><span class="line">            nums.add(nums.last() + <span class="number">1</span>)</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            Text(<span class="string">&quot;Add&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        nums.forEach &#123;</span><br><span class="line">            Text(<span class="string">&quot;第 <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就可以在按钮点击时，正确刷新界面了。<br>
注意，<code>mutableStateListOf</code>只监听列表元素的结构性变化，也就是元素的增减和替换，而不监听元素内部的状态改变。<br>
与 <code>mutableStateListOf</code> 类似 <code>mutableStateMapOf</code> 它返回是的一个 <code>MutableMap</code>，也只监听 <code>map</code> 里元素的结构性变化，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作会引起依赖该 `Map` 的 `Composable` 重组：</span></span><br><span class="line"></span><br><span class="line">map[key] = value → 插入或更新（只要 key 对应的 value 被替换掉，就会触发）</span><br><span class="line"></span><br><span class="line">map.put(key, value) / map.putAll(...)</span><br><span class="line"></span><br><span class="line">map.remove(key)</span><br><span class="line"></span><br><span class="line">map.clear()</span><br></pre></td></tr></table></figure>
<h2><a href="#八-重组的性能优化" class="header-anchor">#</a><span id="八-重组的性能优化">八、重组的性能优化</span></h2>
<h3><a href="#1-重组的性能风险" class="header-anchor">#</a><span id="1-重组的性能风险">1. 重组的性能风险</span></h3>
<p>回顾一下触发重组的时机：</p>
<ol>
<li><code>mutableStateOf</code> 发生在变量的值被改变的时候</li>
<li><code>mutableStateListOf</code> 、<code>mutableStateMapOf</code> 监听的内部元素，内部元素增删、替换时。</li>
</ol>
<p>触发重组和重组是两个过程：</p>
<p>触发重组是某个变量发生改变之后，<code>compose</code> 把调用变量所在的重组作用域里的内容标记为失效。<br>
重组是指在下一帧里去调用这些失效的 <code>compose</code> 代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposableDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(count.toString(), Modifier.clickable &#123;count = count + <span class="number">1</span>&#125;)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，每次点击都会改变 <code>count</code> 值，而该值的改变，会触发 <code>count</code> 被调用位置的重组作用域内容的重组，从而刷新界面。<br>
假设 <code>count</code> 的重组作用域范围为 <code>Column</code> 范围，如果 <code>Column</code> 里还有其它的 <code>compose</code> 函数，那因为<code>count</code> 而触发的重组，也会导致 <code>Column</code> 里的其它函数被重新调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.compose.foundation.layout.ColumnKt</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Column</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    verticalArrangement: <span class="type">Arrangement</span>.<span class="type">Vertical</span> = Arrangement.Top,</span></span></span><br><span class="line"><span class="params"><span class="function">    horizontalAlignment: <span class="type">Alignment</span>.<span class="type">Horizontal</span> = Alignment.Start,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">ColumnScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> measurePolicy = columnMeasurePolicy(verticalArrangement, horizontalAlignment)</span><br><span class="line">    Layout(</span><br><span class="line">        content = &#123; ColumnScopeInstance.content() &#125;,</span><br><span class="line">        measurePolicy = measurePolicy,</span><br><span class="line">        modifier = modifier</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.compose.ui.layout.LayoutKt</span></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;ComposableLambdaParameterPosition&quot;</span>)</span></span><br><span class="line"><span class="meta">@UiComposable</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> @<span class="type">UiComposable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> compositeKeyHash = currentCompositeKeyHash</span><br><span class="line">    <span class="keyword">val</span> localMap = currentComposer.currentCompositionLocalMap</span><br><span class="line">    ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(</span><br><span class="line">        factory = ComposeUiNode.Constructor,</span><br><span class="line">        update = &#123;</span><br><span class="line">            <span class="keyword">set</span>(measurePolicy, SetMeasurePolicy)</span><br><span class="line">            <span class="keyword">set</span>(localMap, SetResolvedCompositionLocals)</span><br><span class="line">            <span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line">            <span class="keyword">set</span>(compositeKeyHash, SetCompositeKeyHash)</span><br><span class="line">        &#125;,</span><br><span class="line">        skippableUpdate = materializerOf(modifier),</span><br><span class="line">        content = content</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.compose.runtime.LayoutKt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span> <span class="meta">@ExplicitGroupsComposable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, <span class="keyword">reified</span> E : Applier&lt;*&gt;</span>&gt; <span class="title">ReusableComposeNode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> factory: () -&gt; <span class="type">T</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    update: @<span class="type">DisallowComposableCalls</span> <span class="type">Updater</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> skippableUpdate: @<span class="type">Composable</span> <span class="type">SkippableUpdater</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentComposer.applier !<span class="keyword">is</span> E) invalidApplier()</span><br><span class="line">    currentComposer.startReusableNode()</span><br><span class="line">    <span class="keyword">if</span> (currentComposer.inserting) &#123;</span><br><span class="line">        currentComposer.createNode(factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentComposer.useNode()</span><br><span class="line">    &#125;</span><br><span class="line">    Updater&lt;T&gt;(currentComposer).update()</span><br><span class="line">    SkippableUpdater&lt;T&gt;(currentComposer).skippableUpdate()</span><br><span class="line">    currentComposer.startReplaceableGroup(<span class="number">0x7ab4aae9</span>)</span><br><span class="line">    content()</span><br><span class="line">    currentComposer.endReplaceableGroup()</span><br><span class="line">    currentComposer.endNode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面的源码，<code>Column</code> 是一个内联函数，也就是说在编译前 <code>Column</code> 函数里的内容也就是 <code>Layout</code> 直接被放到它被调用的位置。<br>
而其中的 <code>Layout</code> 函数也是一个内联函数，也会做同样的操作，也就是 <code>ReusableComposeNode</code> 被放到调用 <code>Column</code> 的位置。<br>
<code>ReusableComposeNode</code> 也是一个内联函数，最终还是 <code>content</code> 在原来的位置， 而 <code>content</code> 就是被传入的 <code>compose</code> 函数。</p>
<p>结论，也就是在编译前 把用户写的 <code>Column</code> 里内部代码直接放到 <code>Column</code> 的位置，进而说明 <code>Column</code> 后面跟的大括号是不存在的。也就是说重组作用域并不一定在大括号的范围内。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RecomposeScopeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Recompose 范围1&quot;</span>)</span><br><span class="line">    Column &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Recompose 范围2&quot;</span>)</span><br><span class="line">        Text(count.toString(), Modifier.clickable &#123;count = count + <span class="number">1</span>&#125;)  </span><br><span class="line">    &#125;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Recompose 范围3&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，点击文本会触发重组，而重组会打印那三条日志。</p>
<p>重组范围的不可控制，逻辑上想要重组的范围之外的内容因为重组也被调用，这就导致了性能的风险。大范围的 <code>recompose</code> 就造成了计算资源的浪费，大量计算花在了需求之外上面。</p>
<h3><a href="#2-性能优化" class="header-anchor">#</a><span id="2-性能优化">2. 性能优化</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RecomposeScopeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层日志</span></span><br><span class="line">    println(<span class="string">&quot;Recompose 范围1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="comment">// 中间层日志</span></span><br><span class="line">        LogScope2()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层日志（和 count 绑定，必然会重组）</span></span><br><span class="line">        LogScope3(count) &#123; count++ &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围2&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;固定文本，不依赖外部状态&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope3</span><span class="params">(count: <span class="type">Int</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围3&quot;</span>)</span><br><span class="line">    Text(</span><br><span class="line">        count.toString(),</span><br><span class="line">        Modifier.clickable &#123; onClick() &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，在第一次组合时，会打印三条日志，但是在点击文本触发重组时，不会打印 <code>Recompose 范围2</code> 这条日志。<br>
这是因为 <code>LogScope3</code> 依赖了 <code>count</code> 这个状态，而 <code>LogScope2</code> 没有依赖。虽然在重组时调用了 <code>LogScope2</code> 这个函数，但是这个函数里面的代码没有被执行。这是因为编译器插件在修改 <code>compose</code> 函数时，不只添加了参数 <code>Composer</code>，还给函数里面的代码添加了逻辑判断，<strong>判断函数里面的状态和上一次函数被调用时的是否一致，如果一致就是说显示内容不会改变，就会跳过这个函数的内部代码。</strong><br>
而 <code>LogScope2</code> 里根本就没有状态，所以除了初次组合，之后的重组都不会再执行里面的代码。</p>
<p>如果把 <code>LogScope2</code> 里代码做如下修改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> mutableStateOf(<span class="number">1</span>) </span><br><span class="line">    println(<span class="string">&quot;Recompose 范围2&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;固定文本，不依赖外部状态 <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在点击文本时，也会打印该日志。因为 <code>LogScope2</code> 里有可被观测的状态了。</p>
<p>在前面说，当状态发生改变时触发重组，那如何判断状态改变呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StateFactoryMarker</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">mutableStateOf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    value: <span class="type">T</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    policy: <span class="type">SnapshotMutationPolicy</span>&lt;<span class="type">T</span>&gt; = structuralEqualityPolicy()</span></span></span><br><span class="line">): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy)</span><br></pre></td></tr></table></figure>
<p>通过上面源码可见，创建状态对象时默认使用 <code>structuralEqualityPolicy</code>策略，即 <code>Kotlin</code> 的 <code>Structual Equality</code> 结构性相等来判断的，即 <strong><code>kotlin</code> 的 <code>==</code></strong>。</p>
<table>
<thead>
<tr>
<th>自定义类型</th>
<th><code>==</code>（结构相等）行为</th>
<th>要点/建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>data class</td>
<td>按主构造所有属性逐一比较</td>
<td>自动生成 <code>equals/hashCode/copy</code>，适合值语义</td>
</tr>
<tr>
<td>普通类（未重写 equals）</td>
<td>等同 <code>===</code>（引用相等）</td>
<td>只有同一实例才为true</td>
</tr>
<tr>
<td>普通类（已重写 equals）</td>
<td>按你的实现逻辑</td>
<td>必须同时重写 <code>hashCode</code>；用于集合键/元素时尤为重要</td>
</tr>
</tbody>
</table>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span>  = Data(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RecomposeScopeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层日志</span></span><br><span class="line">    println(<span class="string">&quot;Recompose 范围1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="comment">// 中间层日志</span></span><br><span class="line">        LogScope2(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层日志（和 count 绑定，必然会重组）</span></span><br><span class="line">        LogScope3(count) &#123; </span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">data</span> = Data(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope2</span><span class="params">(<span class="keyword">data</span>: <span class="type">Data</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围2&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;data:<span class="subst">$&#123;data.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope3</span><span class="params">(count: <span class="type">Int</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围3&quot;</span>)</span><br><span class="line">    Text(</span><br><span class="line">        count.toString(),</span><br><span class="line">        Modifier.clickable &#123; onClick() &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Data</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码还是看 <code>LogScope2</code> 它依赖了外部状态 <code>Data</code>，该状态在文本点击的时候会被重新赋值一个新对象，但是其内部的值 <code>value</code> 在新旧对象中是一样的，符合自定义对象的结构性相等，如此 <code>compose</code> 判断，虽然状态对应的对象改变了，但是两个对象结构性相等，依然跳过 <code>LogScope2</code> 的内部代码。所以点击文本时不会打印 <em>范围2</em> 这条日志。</p>
<p>如果上面的代码大部分不动，只把数据类 <code>Data</code> 里的 <code>value</code> 属性的定义从 <code>val</code> 改为 <code>var</code>，即 <code>data class Data(var value: String)</code>,点击文本时，又会打印 <em>范围2</em> 这条日志了。<br>
这是因为当 <code>Data</code> 里的 <code>value</code> 使用 <code>var</code> 定义时，<code>compose</code> 认为 <code>Data</code> 是不可靠的类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改动1</span></span><br><span class="line"><span class="keyword">val</span> data1 = Data(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> data2 = Data(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span>  = data1</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RecomposeScopeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层日志</span></span><br><span class="line">    println(<span class="string">&quot;Recompose 范围1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="comment">// 中间层日志</span></span><br><span class="line">        LogScope2(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层日志（和 count 绑定，必然会重组）</span></span><br><span class="line">        LogScope3(count) &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 改动2</span></span><br><span class="line">            <span class="keyword">data</span> = data2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设修改 user2.value = &quot;B&quot;</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope2</span><span class="params">(<span class="keyword">data</span>: <span class="type">Data</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围2&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;data:<span class="subst">$&#123;data.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope3</span><span class="params">(count: <span class="type">Int</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围3&quot;</span>)</span><br><span class="line">    Text(</span><br><span class="line">        count.toString(),</span><br><span class="line">        Modifier.clickable &#123; onClick() &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改动3</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Data</span>(<span class="keyword">var</span> value: String)</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>Data</code> 里的 <code>value</code> 使用 <code>var</code> 定义，并声明两个 <code>data</code> 对象 <code>data1</code>、<code>data2</code>，但是对象内容一致。<code>LogScope2</code> 依赖的状态<code>data</code> 赋初值为 <code>data1</code>，然后在文本点击时 <code>data</code> 赋值为 <code>data2</code>。此时点击文本， <code>LogScope2</code> 也会被重新调用，并执行内部逻辑，打印 <em>范围2</em> 日志。<br>
假设，如果认为 <code>LogScope2</code> 依赖的状态没有改变 <em>（纯走结构化相等逻辑）</em>，也就不走内部逻辑，不打印 <em>范围2</em> 日志。此时是没有逻辑问题的。<br>
但是如果在其它位置，修改了 <code>data2</code> 的 <code>value</code> 值，因为 <code>data2</code> 不是状态变量，不会触发重组。而 <code>LogScope2</code> 因为某个内部状态变更触发了自身的重组，那它显示的 <code>data</code> 内容是不改变的，因为它一直监听的 <code>data1</code> 对象 <em>（虽然赋值 data2,但是没走内部逻辑，data2 没传入 LogScope2 里）</em>。如此，就造成了逻辑上的错误，明明赋值了 <code>data2</code>，但是一直监听的 <code>data1</code>。</p>
<p><code>var</code> 就意味着值可以被修改，也就意味着，<strong>现在两个对象是一样的，不代表未来也是一样的。因此内部的监测对象需要替换为最新的，否则会造成逻辑错误。</strong> 所以为了保证正确性， <code>compose</code> 只要判断出自定义对象里有属性使用了<code>var</code> 定义，即使结构化相等，也认为状态变更了，以此更新内部监测的对象。</p>
<p>这种 <strong>即使现在相等，但不能保证未来也一定相等的类型，就是不可靠类型。</strong></p>
<p><code>val</code> 就代表了不可修改，所以对象被创建出来后，里面的属性就不会再改变，也就是现在相等，未来也相等，这就是可靠的类型。</p>
<p>判断某个类型可靠/不可靠是 <code>compose</code> 自动行为。只要里面有 <code>var</code> 定义就判断为不可靠，有些简单粗暴。</p>
<h4><a href="#1-stable-注解" class="header-anchor">#</a><span id="1-stable-注解">1. @Stable 注解</span></h4>
<p><strong><code>@Stable</code></strong> 注解是一个稳定性标记，可以放到某个类型上，通过这个注解告诉 <code>compose</code> 这个类型是可靠的，但是要由程序员保证可靠性。</p>
<p>让程序员保证可靠性有两种方法：</p>
<ol>
<li>类型的实例在一个地方做了修改，要把结构性相等的实例做同样的修改，相当烦琐。</li>
<li>不再重写类型的<code>equals</code> 方法，默认使用的 <code>Any.equals()</code>，即只有同一个对象才相等。</li>
</ol>
<p>也就是说上面的数据类最终可以改为如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 改动1</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span>  = Data(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RecomposeScopeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层日志</span></span><br><span class="line">    println(<span class="string">&quot;Recompose 范围1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="comment">// 中间层日志</span></span><br><span class="line">        LogScope2(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层日志（和 count 绑定，必然会重组）</span></span><br><span class="line">        LogScope3(count) &#123; </span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 改动2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设修改 user2.value = &quot;B&quot;</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope2</span><span class="params">(<span class="keyword">data</span>: <span class="type">Data</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围2&quot;</span>)</span><br><span class="line">    Text(<span class="string">&quot;data:<span class="subst">$&#123;data.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LogScope3</span><span class="params">(count: <span class="type">Int</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Recompose 范围3&quot;</span>)</span><br><span class="line">    Text(</span><br><span class="line">        count.toString(),</span><br><span class="line">        Modifier.clickable &#123; onClick() &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改动3</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>(<span class="keyword">var</span> value: String)</span><br></pre></td></tr></table></figure>
<p>上面做了三处改动，首先状态 <code>data</code> 不再赋值新对象，一直使用同一对象，其次 <code>Data</code> 类由 <code>@Stable</code> 修饰表示是可靠的，然后去掉了<code>data</code> 关键字，表示 <code>Data</code> 只是一个普通类，没有重写 <code>equals</code> 方法，那就会走 <code>Any.equals()</code> 也就是对象相等逻辑。<br>
由此，文本点击时，不会打印 <em>范围2</em> 日志。而若把 <code>@Stable</code>注解去掉，还是会打印 <em>范围2</em> 日志，因为 <code>Data</code> 不可靠。</p>
<p><code>@Stable</code> 的内部源码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.compose.runtime.MutableState</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MutableState</span>&lt;<span class="type">T</span>&gt; : <span class="type">State</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> value: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compose</code> 将 <code>MutableState</code> 接口定义为可靠的，可靠性由该接口的实现类去实现，比如 <code>SnapshotMutableStateImpl</code> 类每将 <code>value</code> 值改变时，就会通知每个使用 <code>value</code> 值的地方。</p>
<h4><a href="#2-类型的公开属性加状态" class="header-anchor">#</a><span id="2-类型的公开属性加状态">2. 类型的公开属性加状态</span></h4>
<p>可靠性：</p>
<ul>
<li>现在相等就永远相等</li>
<li><strong>当公开属性改变时，通知到用到这个属性的 <code>Composition</code>，也就是要触发重组</strong>，只要符合这条，<code>compose</code> 就认为符合稳定性要求。</li>
<li>公开属性要是自定义类型时，要保证自定义类型是可靠类型</li>
</ul>
<p>为了保证第二条稳定性要求，类型可以写成如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>(value: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> value <span class="keyword">by</span> mutableStateOf(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，类型里的所有公开属性，即使使用了 <code>var</code> 定义，但是这些属性有了状态，那 <code>compose</code> 也判断该类型是可靠的。注意必须所有的 <code>var</code> 的公开属性都要有状态，否则还是不可靠。<br>
程序员推荐使用这种方式来辅助 <code>compose</code> 判断可靠性。</p>
<h4><a href="#3-总结" class="header-anchor">#</a><span id="3-总结">3. 总结</span></h4>
<p>保证稳定性有如下方式：</p>
<table>
<thead>
<tr>
<th>规范</th>
<th>合规要点</th>
<th>推荐实现/示例</th>
<th>反例/风险</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在相等就永远相等</td>
<td><code>equals/hashCode</code> 只依赖不可变字段；避免把可变字段纳入判等，或者使用默认的 <code>equals</code> 方法，不重写 <code>equals</code> 方法，让对象相等性判断即</td>
<td><code>data class User(val id: Long, val name: String)</code>；判等仅基于 <code>id</code> 等稳定标识</td>
<td><code>equals</code> 依赖 <code>var name</code>；修改后集合键失效、稳定性被破坏</td>
</tr>
<tr>
<td>当公开属性改变时，必须通知到使用它的 Composition（触发重组）</td>
<td>用可观察状态包装：<code>mutableStateOf</code>、<code>mutableStateListOf</code>、<code>StateFlow</code>、<code>LiveData</code> + <code>collectAsState</code></td>
<td><code>var user by mutableStateOf(User(...))</code>；更新：<code>user = user.copy(name = &quot;Bob&quot;)</code>；列表：<code>mutableStateListOf()</code></td>
<td>直接改普通 <code>var</code> 或原地 <code>list.add()</code>；UI 不重组或重组不及时</td>
</tr>
<tr>
<td>公开属性为自定义类型时需&quot;可靠/稳定&quot;</td>
<td>类型稳定：<code>data class</code>、字段全为稳定类型且为 <code>val</code>；必要时 <code>@Stable/@Immutable</code>；正确 <code>equals/hashCode</code></td>
<td><code>@Immutable data class Profile(val id: Long, val tags: List&lt;String&gt;)</code>（对外暴露只读 <code>List</code>）</td>
<td>暴露 <code>MutableList</code>、类型内部可变且泄露；未重写 <code>equals/hashCode</code></td>
</tr>
</tbody>
</table>
<p>简单总结</p>
<ol>
<li>不要轻易重写<code>equals</code> 方法，也就是慎用 <code>data class</code></li>
<li>使用 <code>var</code> 修饰的公开属性，要加状态进行包裹</li>
<li>如果使用特殊的方式实现自动通知，<code>compose</code> 无法自动判断是否可靠，要加注解 <code>@Stable</code></li>
</ol>
<h2><a href="#九-derivedstateof" class="header-anchor">#</a><span id="九-derivedstateof">九、derivedStateOf()</span></h2>
<h3><a href="#1-derivedstateof-将一个或多个状态对象转换为其他状态" class="header-anchor">#</a><span id="1-derivedstateof-将一个或多个状态对象转换为其他状态">1. derivedStateOf: 将一个或多个状态对象转换为其他状态</span></h3>
<p>官网：<a target="_blank" rel="noopener" href="https://developer.android.com/develop/ui/compose/side-effects?hl=zh-cn#derivedstateof">https://developer.android.com/develop/ui/compose/side-effects?hl=zh-cn#derivedstateof</a></p>
<p>当可组合项输入的变化频率超过您需要的重组频率时，就应该使用 derivedStateOf 函数。这种情况通常是指，某些内容（例如滚动位置）频繁变化，但可组合项只有在超过某个阈值时才需要对其做出响应。derivedStateOf 会创建一个新的 Compose 状态对象，您可以观察到该对象只会按照您的需要进行更新。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DerivedStateDemo</span><span class="params">(messages: <span class="type">List</span>&lt;<span class="type">Message</span>&gt;)</span></span> &#123;</span><br><span class="line">    Box &#123;</span><br><span class="line">        <span class="keyword">val</span> listState = rememberLazyListState()</span><br><span class="line"></span><br><span class="line">        LazyColumn(state = listState) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 知识点1</span></span><br><span class="line">        <span class="keyword">val</span> showButton <span class="keyword">by</span> remember &#123;</span><br><span class="line">            <span class="comment">// 知识点2</span></span><br><span class="line">            derivedStateOf &#123;</span><br><span class="line">                listState.firstVisibleItemIndex &gt; <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnimatedVisibility(visible = showButton) &#123;</span><br><span class="line">            ScrollToTopButton()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示：</p>
<p>在上面代码段中，每当第一个可见项发生变化时，<code>firstVisibleItemIndex</code> 都会跟着发生变化。当滚动屏幕时，它的值会变为 <em>0、1、2</em> 等。但是，只有当值大于 <em>0</em> 时才需要进行重组。这种更新频率的不匹配意味着，这种情形很适合使用 <em>derivedStateOf</em>。</p>
<ul>
<li>知识点1 , 使用 <code>by remember&#123;&#125;</code> 缓存 <code>rememeber</code> 大括号内的东西，只有在第一次组合时调用，后续重组时不再执行。 <code>by</code> 通过代理直接取值。</li>
<li>知识点2 , <code>derivedStateOf</code>，
<ul>
<li>它的参数是一个 <code>Lambda</code> 表达式，该函数用于返回一个 <code>State</code> 类型数据，<code>lambda</code> 的结果就是 <code>State</code> 对象包裹的数据。</li>
<li><code>lambda</code> 里使用的其它状态改变时, <code>lambda</code> 会自动重新计算，从而使 <code>State</code> 的 <code>value</code> 更新。</li>
</ul>
</li>
</ul>
<h3><a href="#2-derivedstateof-与-rememberkey-区别" class="header-anchor">#</a><span id="2-derivedstateof-与-rememberkey-区别">2. derivedStateOf 与 remember(key) 区别</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DerivedVsRememberDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：derivedStateOf（自动跟踪读取到的 state）</span></span><br><span class="line">    <span class="keyword">val</span> doubledByDerived <span class="keyword">by</span> remember &#123; derivedStateOf &#123; count * <span class="number">2</span> &#125; &#125;</span><br><span class="line">    <span class="comment">// 方式二：remember(key)（显式以 key 作为重算条件）</span></span><br><span class="line">    <span class="keyword">val</span> doubledByRemember = remember(count) &#123; count * <span class="number">2</span> &#125;</span><br><span class="line">    <span class="comment">// 方式三：不带状态，直接在重组的时候进行计算</span></span><br><span class="line">    <span class="keyword">val</span> doubleByNormal = count * <span class="number">2</span></span><br><span class="line">    Column(Modifier.padding(<span class="number">16.</span>dp), verticalArrangement = Arrangement.spacedBy(<span class="number">8.</span>dp)) &#123;</span><br><span class="line">        Text(<span class="string">&quot;count = <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;derivedStateOf: <span class="variable">$doubledByDerived</span>&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;remember(count): <span class="variable">$doubledByRemember</span>&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;doubleByNormal: <span class="variable">$doubleByNormal</span>&quot;</span>)</span><br><span class="line">        Button(onClick = &#123; count++ &#125;) &#123; Text(<span class="string">&quot;count +1&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，这三种方法都会在 <code>count</code> 变化时得到同样的结果。</p>
<ul>
<li>方法一，使用 <code>derivedStateOf</code> 方式，直接从状态 <code>count</code> 派生出了 <code>doubleByDerived</code> 状态，在按钮点击时，改变状态 <code>count</code> 值， <code>derivedStateOf</code> 因依赖了 <code>count</code> 状态，所以会重新计算，并刷新状态 <code>doubledByDerived</code> 的值，导致重组，重新调用重组作用域内的所有代码，从而显示了新值</li>
<li>方法二，使用 <code>remember(key)</code> 的方式，判断 <code>count</code> 是否改变，如果 <code>count</code> 改变才会执行 <code>remember</code> 内的 <code>lambda</code> 表达式，返回的是一个无状态的数值类型。但是因为 <code>count</code> 状态值变更了，导致重组作用域内所有代码重新执行，所以页面也刷新了 <code>remember(count)</code> 显示内容。</li>
<li>方法三，直接进行计算，不缓存也不派生对象，每次重组时都重新计算，而 <code>count</code> 状态变更，导致重组作用域所有代码都重新执行，此时 <code>doubleByNormal</code> 会计算出新值来，而下面的显示代码也被执行，从而使用了新值进行显示更新。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DerivedVsRememberDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    ProcessCount(count) &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ProcessCount</span><span class="params">(count: <span class="type">Int</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：derivedStateOf（自动跟踪读取到的 state）</span></span><br><span class="line">    <span class="keyword">val</span> doubledByDerived <span class="keyword">by</span> remember &#123; derivedStateOf &#123; count * <span class="number">2</span> &#125; &#125;</span><br><span class="line">    <span class="comment">// 方式二：remember(key)（显式以 key 作为重算条件）</span></span><br><span class="line">    <span class="keyword">val</span> doubledByRemember = remember(count) &#123; count * <span class="number">2</span> &#125;</span><br><span class="line">    Column(Modifier.padding(<span class="number">16.</span>dp), verticalArrangement = Arrangement.spacedBy(<span class="number">8.</span>dp)) &#123;</span><br><span class="line">        Text(<span class="string">&quot;count = <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;derivedStateOf: <span class="variable">$doubledByDerived</span>&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;remember(count): <span class="variable">$doubledByRemember</span>&quot;</span>)</span><br><span class="line">        Button(onClick = onClick) &#123; Text(<span class="string">&quot;count +1&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中：点击，方法一不会进行计算，方法二可以正常计算。因为进入 <code>ProcessCount</code> 函数的 <code>count</code> 是没有状态的， <code>derivedStateOf</code> 没有办法去识别，而 <code>remember</code> 直接判断的 <code>key</code> 值本身的改变。</p>
<p><strong>derivedStateOf、remember(key) 与&quot;重组时直接计算&quot;的区别与使用时机</strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>derivedStateOf</th>
<th>remember(key)</th>
<th>重组时直接计算（无状态）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>从已存在的 State 派生出新 State（自动跟踪依赖）</td>
<td>按 key 缓存/重建值或对象，key 变才重算/重建</td>
<td>在重组时直接用 State 计算出普通值</td>
</tr>
<tr>
<td><strong>重算触发</strong></td>
<td>仅当计算体内&quot;读取到的 State&quot;变化，读取 State 的快照状态</td>
<td>仅当提供的 key 变化，只将 key 进行结构化比较</td>
<td>每次其所在 Composable 重组（通常因依赖的 State 变化）</td>
</tr>
<tr>
<td><strong>输出</strong></td>
<td>State（可被下游订阅）</td>
<td>普通值或对象（非 State）</td>
<td>普通值</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>过滤/排序/格式化等派生值，缩小重组范围</td>
<td>重置内部状态、按入参重建控制器/昂贵对象</td>
<td>轻量、廉价的即时计算（如简单算术/拼接）</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>val r by remember &#123; derivedStateOf &#123; items.value.filter &#123; it.ok &#125; &#125; &#125;</code></td>
<td><code>val ctrl = remember(userId) &#123; Controller(userId) &#125;</code></td>
<td><code>val doubled = count * 2</code></td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>依赖精确、按需重算；结果可下游独立订阅</td>
<td>语义清晰、控制重建时机；适合&quot;随 key 重置&quot;</td>
<td>实现最简单、无额外状态与记忆开销</td>
</tr>
<tr>
<td><strong>注意事项</strong></td>
<td>计算体内必须读取 State，否则不会更新</td>
<td>key 高频变化会频繁重建；对引用类型的内部元素变更无感（key 不变不重建）</td>
<td>昂贵计算会在每次重组重复；无法被下游单独订阅</td>
</tr>
<tr>
<td><strong>不适用</strong></td>
<td>入参不是 State 且只需偶尔重建</td>
<td>仅从 State 派生轻量值（此时优先 derivedStateOf）</td>
<td>需要复用结果/多个下游独立订阅/需要精确控制重算</td>
</tr>
<tr>
<td><strong>组合用法</strong></td>
<td><code>remember(key) &#123; derivedStateOf &#123; compute(state, key) &#125; &#125;</code></td>
<td>与 <code>derivedStateOf</code> 搭配处理&quot;非 State 入参 + State 依赖&quot;</td>
<td>升级路径：若变慢或需订阅，再改为 <code>remember(key)</code> 或 <code>derivedStateOf</code></td>
</tr>
</tbody>
</table>
<h3><a href="#3-dervedstateof-与-rememberkey-综合使用" class="header-anchor">#</a><span id="3-dervedstateof-与-rememberkey-综合使用">3. dervedStateOf 与 remember(key) 综合使用</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 综合使用示例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">InvokeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 试验1</span></span><br><span class="line">    <span class="keyword">val</span> list = remember &#123; mutableListOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>) &#125;</span><br><span class="line">    <span class="comment">// 试验2</span></span><br><span class="line">    <span class="keyword">val</span> list2 = remember &#123; mutableStateListOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>) &#125;</span><br><span class="line">    <span class="comment">// 试验3</span></span><br><span class="line">    <span class="keyword">var</span> changeSign <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> list3 = remember(changeSign) &#123;</span><br><span class="line">        <span class="keyword">if</span> (changeSign) &#123;</span><br><span class="line">            mutableStateListOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mutableStateListOf(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Button(onClick = &#123;</span><br><span class="line">        list.add(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        list2.add(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        changeSign = !changeSign</span><br><span class="line">    &#125;) &#123; Text(<span class="string">&quot;change&quot;</span>) &#125;</span><br><span class="line">    ComprehensiveDemo(list)</span><br><span class="line">    ComprehensiveDemo(list2)</span><br><span class="line">    ComprehensiveDemo2(list3)</span><br><span class="line">    ComprehensiveDemo(list3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComprehensiveDemo</span><span class="params">(highPriorityKeywords: <span class="type">List</span>&lt;<span class="type">String</span>&gt; = listOf(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;D&quot;</span>)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> todoTasks = remember &#123; mutableStateListOf&lt;String&gt;(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> highPriorityTasks <span class="keyword">by</span> remember(highPriorityKeywords) &#123;</span><br><span class="line">        derivedStateOf &#123; todoTasks.filter &#123; highPriorityKeywords.any &#123; keyword -&gt; it.contains(keyword) &#125; &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123;</span><br><span class="line">        LazyColumn &#123;</span><br><span class="line">            items(items = highPriorityTasks) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">            items(items = todoTasks) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComprehensiveDemo2</span><span class="params">(highPriorityKeywords: <span class="type">List</span>&lt;<span class="type">String</span>&gt; = listOf(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;D&quot;</span>)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> todoTasks = remember &#123; mutableStateListOf&lt;String&gt;(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> highPriorityTasks <span class="keyword">by</span> remember &#123;</span><br><span class="line">        derivedStateOf &#123; todoTasks.filter &#123; highPriorityKeywords.any &#123; keyword -&gt; it.contains(keyword) &#125; &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123;</span><br><span class="line">        LazyColumn &#123;</span><br><span class="line">            items(items = highPriorityTasks) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">            items(items = todoTasks) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码 <code>ComprehensiveDemo</code> 功能为：维护一个可变的待办列表 <code>todoTasks</code>，并基于关键字<code>highPriorityKeywords</code> 动态派生出高优先级列表 <code>highPriorityTasks</code>，列表变化时界面自动更新。界面用 <code>LazyColumn</code> 先展示高优先级任务，再展示全部任务。</p>
<ul>
<li><code>derivedStateOf</code> 的 <code>lambda</code> 里依赖的状态有两个： <code>todoTasks</code>、<code>highPriorityKeywords</code>。<code>todoTasks</code> 是有状态的对象，而 <code>highPriorityKeywords</code> 虽然是 <code>List</code> 类型，没有状态，但是外部可以传递 <code>MutableStateList</code> 类型，因为 <code>List</code> 是 <code>MutabvleStateList</code> 的父类。</li>
<li>所以 <code>highPriorityKeywords</code> 是否有状态，取决于外部调用 <code>DerivedStateDemo2</code> 时，传入的 <code>highPriorityKeywords</code> 是否有状态。为了保证 <code>highPriorityKeywords</code> 改变时一定会触发重算，必需要要传入有状态的列表。</li>
</ul>
<p>上面三个试验，传入不同的参数，有不同的展示效果，具体见下表：</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>初始 keywords</th>
<th>点击后 keywords</th>
<th>remember 重建</th>
<th>derivedStateOf 重算</th>
<th>highPriorityTasks（前 → 后）</th>
</tr>
</thead>
<tbody>
<tr>
<td>ComprehensiveDemo(list)</td>
<td>[“A”,“B”]（普通 MutableList）</td>
<td>[“A”,“B”,“C”]（原地 add）</td>
<td>否（引用未变）</td>
<td>否（未读到 State）</td>
<td>[“A”,“B”] → [“A”,“B”]</td>
</tr>
<tr>
<td>ComprehensiveDemo(list2)</td>
<td>[“A”,“B”]（SnapshotStateList）</td>
<td>[“A”,“B”,“C”]（结构变更）</td>
<td>否（引用未变）</td>
<td>是（遍历读到状态列表）</td>
<td>[“A”,“B”] → [“A”,“B”,“C”]</td>
</tr>
<tr>
<td>ComprehensiveDemo2(list3)</td>
<td>[“C”,“D”]（由 key 构造的新实例）</td>
<td>[“A”,“B”]（切换为另一新实例）</td>
<td>否（无 key，记住了首次实例）</td>
<td>否（捕获旧实例）</td>
<td>[“C”,“D”] → [“C”,“D”]</td>
</tr>
<tr>
<td>ComprehensiveDemo(list3)</td>
<td>[“C”,“D”]</td>
<td>[“A”,“B”]</td>
<td>是（key 变更）</td>
<td>是（重建并计算）</td>
<td>[“C”,“D”] → [“A”,“B”]</td>
</tr>
</tbody>
</table>
<h2><a href="#十-compositionlocal" class="header-anchor">#</a><span id="十-compositionlocal">十、CompositionLocal</span></h2>
<p><code>CompositionLocal</code> 顾名思义是组合的局部变量，是具有穿透函数的功能的局部变量。是 <code>Jetpack Compose</code> 的“环境/上下文注入”机制：在组合树中自上而下隐式传递数据，<strong>避免通过参数层层传递</strong>。</p>
<h3><a href="#1-简单使用" class="header-anchor">#</a><span id="1-简单使用">1. 简单使用</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 定义</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">AppUser</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">val</span> LocalUser = compositionLocalOf&lt;AppUser?&gt; &#123; <span class="literal">null</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 提供</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">App</span><span class="params">(user: <span class="type">AppUser</span>, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">  CompositionLocalProvider(LocalUser provides user) &#123;</span><br><span class="line">    content()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 代码1</span></span><br><span class="line">  LocalUser.current</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 读取（任意子层级）</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> user = LocalUser.current</span><br><span class="line">  Text(text = <span class="string">&quot;Hi, <span class="subst">$&#123;user?.name ?: <span class="string">&quot;Guest&quot;</span>&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）示例</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">InvokeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = AppUser(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    App(user) &#123;</span><br><span class="line">        Greeting()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示：</p>
<p>首先，将想要传递的数据使用 <code>compositionLocalOf</code> 函数进行封装，封装为了个 <code>CompositionLocal</code> 类型的数据，并声明成一个顶级属性 <em>(为了全局可用)</em>，属性的名字前缀一般使用 <code>local</code> 方便标识这一类数据。当前示例想要传递 <code>AppUser</code> 数据。<br>
然后，使用中缀函数 <code>provides</code> 来进行定义谁传递什么数据，它的等价写法是 <code>LocalUser.provides(user)</code><br>
接着，使用 <code>CompositionLocalProvider</code> 实现数据的隐式传递<br>
最后，使用定义的那个顶级属性的 <code>current</code> 属性来获取要传递的数据，当前示例为 <code>LocalUser.current</code></p>
<p>注意，在代码1 处的调用只是去取封装时的初始值，需要看赋默认值的逻辑是否有报错处理。当前示例只是返回一个 <code>null</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> LocalUser = compositionLocalOf&lt;AppUser?&gt; &#123; error(<span class="string">&quot;没有提供值&quot;</span>) &#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">val</span> LocalUser = compositionLocalOf&lt;AppUser?&gt; &#123; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;没有提供值&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，如果是这样声明，则在作用范围外去调用 <code>current</code> 时，比如代码1处，应用会抛异常。</p>
<h3><a href="#2-覆盖使用" class="header-anchor">#</a><span id="2-覆盖使用">2. 覆盖使用</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">OverrideDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 全局提供一个用户</span></span><br><span class="line">  <span class="keyword">val</span> globalUser = AppUser(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">  App(globalUser) &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">      <span class="comment">// 使用全局提供的值 -&gt; &quot;Hi, Lee&quot;</span></span><br><span class="line">      Greeting()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在子树内局部覆写为另一个用户</span></span><br><span class="line">      CompositionLocalProvider(LocalUser provides AppUser(<span class="string">&quot;Tom&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 覆写生效 -&gt; &quot;Hi, Tom&quot;</span></span><br><span class="line">        Greeting()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还可以再次覆写 -&gt; &quot;Hi, Alice&quot;</span></span><br><span class="line">        CompositionLocalProvider(LocalUser provides AppUser(<span class="string">&quot;Alice&quot;</span>)) &#123;</span><br><span class="line">          Greeting()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回到上一层覆写 -&gt; 仍然是 &quot;Hi, Tom&quot;</span></span><br><span class="line">        Greeting()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 覆写作用域结束，恢复到全局 -&gt; &quot;Hi, Lee&quot;</span></span><br><span class="line">      Greeting()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CompositionLocalProvider</code> 是有作用范围的，子树内的 <code>CompositionLocalProvider</code> 会就近覆盖父层提供的值；离开该作用域后恢复上一层的值。</p>
<h3><a href="#3-compositionlocalof-与-staticcompositionlocalof" class="header-anchor">#</a><span id="3-compositionlocalof-与-staticcompositionlocalof">3. compositionLocalOf 与 staticCompositionLocalOf</span></h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>compositionLocalOf</th>
<th>staticCompositionLocalOf</th>
<th>适用场景考量/备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取跟踪</td>
<td>跟踪读取点</td>
<td>不跟踪读取点</td>
<td>影响重组范围</td>
</tr>
<tr>
<td>值变更时的重组</td>
<td>仅重组“实际读取它”的 Composable</td>
<td>重组该 Provider 之下的整棵子树</td>
<td>精准 vs 广域</td>
</tr>
<tr>
<td>读取开销</td>
<td>略高</td>
<td>较低</td>
<td>读取时是否记录依赖</td>
</tr>
<tr>
<td>变更开销</td>
<td>较低</td>
<td>较高</td>
<td>值变更频率高更适合前者</td>
</tr>
<tr>
<td>MutationPolicy</td>
<td>支持 SnapshotMutationPolicy</td>
<td>不支持</td>
<td>可用结构等价等策略控制重组</td>
</tr>
<tr>
<td>默认值</td>
<td>需提供安全默认值</td>
<td>需提供安全默认值</td>
<td>未提供时也能工作</td>
</tr>
<tr>
<td>典型用途</td>
<td>动态环境依赖（当前用户、A/B 开关、动态配置、日志/路由等）</td>
<td>主题 token、布局方向、密度等几乎不变的环境值</td>
<td>值是否“几乎不变”</td>
</tr>
<tr>
<td>API 示例</td>
<td><code>val LocalX = compositionLocalOf&lt;T&gt; &#123; default &#125;</code></td>
<td><code>val LocalX = staticCompositionLocalOf&lt;T&gt; &#123; default &#125;</code></td>
<td>定义方式</td>
</tr>
<tr>
<td>常见示例</td>
<td>自定义 <code>LocalUser</code>、<code>LocalNavController</code>、<code>LocalLogger</code></td>
<td><code>LocalTextStyle</code>、<code>LocalContentColor</code>、<code>LocalLayoutDirection</code>、<code>LocalDensity</code></td>
<td>Material 多为 static</td>
</tr>
<tr>
<td>使用建议</td>
<td>值会变且希望小范围重组时使用</td>
<td>值很少变且全局常量化时使用</td>
<td>不要用它传高频业务状态（用 State/ViewModel）</td>
</tr>
</tbody>
</table>
<h3><a href="#4-源码" class="header-anchor">#</a><span id="4-源码">4. 源码</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.compose.runtime.CompositionLocal</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">CompositionLocal</span>&lt;<span class="type">T</span>&gt;(defaultFactory: () -&gt; T) &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">val</span> defaultValueHolder: ValueHolder&lt;T&gt; = LazyValueHolder(defaultFactory)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatedStateOf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        value: <span class="type">ProvidedValue</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        previous: <span class="type">ValueHolder</span>&lt;<span class="type">T</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ValueHolder&lt;T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OptIn(InternalComposeApi::class)</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">val</span> current: T</span><br><span class="line">        <span class="meta">@ReadOnlyComposable</span></span><br><span class="line">        <span class="meta">@Composable</span></span><br><span class="line">        <span class="keyword">get</span>() = currentComposer.consume(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码为 <code>CompositionLocal</code> 的源码，可以看到调用 <code>current</code> 属性时，<code>get()</code> 方法上有 <code>@Composable</code> 注解，也就是说调用 <code>current</code> 属性时必须要在 <code>@Composable</code> 函数内。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.compose.runtime.CompositionLocal</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="meta">@OptIn(InternalComposeApi::class)</span></span><br><span class="line"><span class="meta">@NonSkippableComposable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CompositionLocalProvider</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">ProvidedValue</span>&lt;*&gt;, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    currentComposer.startProviders(values)</span><br><span class="line">    content()</span><br><span class="line">    currentComposer.endProviders()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码为 <code>CompositionLocalProvider</code> 的源码，可以看到可以传入多个值的，而且可以很明显看到提供的值的作用范围就是传入的 <code>@Composable</code> 函数。</p>
<h3><a href="#5-使用场景" class="header-anchor">#</a><span id="5-使用场景">5. 使用场景</span></h3>
<ul>
<li>主题与样式：颜色、排版、形状等 <em>（Material 的 Local</em>）*。</li>
<li>环境信息：<code>LocalContext</code>、<code>LocalDensity</code>、<code>LocalLayoutDirection</code>。</li>
<li>跨层级依赖：如日志通道、导航控制器、权限/配置等轻量依赖。</li>
</ul>
<h4><a href="#示例1系统提供的-materialtheme" class="header-anchor">#</a><span id="示例1系统提供的-materialtheme">示例1：系统提供的 MaterialTheme</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//androidx.compose.material3.MaterialThemeKt</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MaterialTheme</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    colorScheme: <span class="type">ColorScheme</span> = MaterialTheme.colorScheme,</span></span></span><br><span class="line"><span class="params"><span class="function">    shapes: <span class="type">Shapes</span> = MaterialTheme.shapes,</span></span></span><br><span class="line"><span class="params"><span class="function">    typography: <span class="type">Typography</span> = MaterialTheme.typography,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rememberedColorScheme = remember &#123;</span><br><span class="line">        <span class="comment">// Explicitly creating a new object here so we don&#x27;t mutate the initial [colorScheme]</span></span><br><span class="line">        <span class="comment">// provided, and overwrite the values set in it.</span></span><br><span class="line">        colorScheme.copy()</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        updateColorSchemeFrom(colorScheme)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> rippleIndication = rememberRipple()</span><br><span class="line">    <span class="keyword">val</span> selectionColors = rememberTextSelectionColors(rememberedColorScheme)</span><br><span class="line">    CompositionLocalProvider(</span><br><span class="line">        LocalColorScheme provides rememberedColorScheme,</span><br><span class="line">        LocalIndication provides rippleIndication,</span><br><span class="line">        LocalRippleTheme provides MaterialRippleTheme,</span><br><span class="line">        LocalShapes provides shapes,</span><br><span class="line">        LocalTextSelectionColors provides selectionColors,</span><br><span class="line">        LocalTypography provides typography,</span><br><span class="line">    ) &#123;</span><br><span class="line">        ProvideTextStyle(value = typography.bodyLarge, content = content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><a href="#示例2-组合式日志通道" class="header-anchor">#</a><span id="示例2-组合式日志通道">示例2 ：组合式日志通道</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 定义 Logger 与默认实现</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>, tr: <span class="type">Throwable</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> NoOpLogger : Logger &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;&#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>, tr: <span class="type">Throwable</span>?)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidLogger</span> : <span class="type">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> = android.util.Log.d(tag, msg)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>, tr: <span class="type">Throwable</span>?)</span></span> =</span><br><span class="line">    android.util.Log.e(tag, msg, tr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 定义 CompositionLocal（日志一般较少变动，可用 staticCompositionLocalOf）</span></span><br><span class="line"><span class="keyword">val</span> LocalLogger = staticCompositionLocalOf&lt;Logger&gt; &#123; NoOpLogger &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 在应用根部提供全局 Logger</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">AppRoot</span><span class="params">(content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> logger = remember &#123; AndroidLogger() &#125;</span><br><span class="line">  CompositionLocalProvider(LocalLogger provides logger) &#123;</span><br><span class="line">    content()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4) 任意子层级读取并使用</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SaveButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> logger = LocalLogger.current</span><br><span class="line">  Button(onClick = &#123;</span><br><span class="line">    logger.d(<span class="string">&quot;SaveButton&quot;</span>, <span class="string">&quot;clicked&quot;</span>)</span><br><span class="line">    <span class="comment">// ...执行保存逻辑</span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    Text(<span class="string">&quot;保存&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5) 在子树“局部覆写”为埋点 Logger（不影响外层）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnalyticsLogger</span>(<span class="keyword">private</span> <span class="keyword">val</span> send: (String, String) -&gt; <span class="built_in">Unit</span>) : Logger &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> = send(tag, msg)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>, tr: <span class="type">Throwable</span>?)</span></span> = send(tag, <span class="string">&quot;ERR: <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">AnalyticsScope</span><span class="params">(content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> analyticsLogger = remember &#123;</span><br><span class="line">    AnalyticsLogger &#123; tag, msg -&gt;</span><br><span class="line">      <span class="comment">// 发送到你的埋点/日志平台</span></span><br><span class="line">      <span class="comment">// analytics.track(tag, msg)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  CompositionLocalProvider(LocalLogger provides analyticsLogger) &#123;</span><br><span class="line">    content()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法示例 1：在应用根部全局注入并使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContent &#123;</span><br><span class="line">      AppRoot &#123;</span><br><span class="line">        Column(Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">          Text(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line">          Spacer(Modifier.height(<span class="number">8.</span>dp))</span><br><span class="line">          SaveButton() <span class="comment">// 点击时通过 LocalLogger 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法示例 2：在子树内局部覆写为埋点 Logger</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DetailScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">  Column(Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">    Text(<span class="string">&quot;详情页（局部埋点 Logger）&quot;</span>)</span><br><span class="line">    Spacer(Modifier.height(<span class="number">8.</span>dp))</span><br><span class="line">    AnalyticsScope &#123;</span><br><span class="line">      <span class="comment">// 此区域内的日志会走 AnalyticsLogger</span></span><br><span class="line">      SaveButton()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法示例 3：预览/测试中替换为自定义 TestLogger</span></span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Preview_SaveButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> testLogger = <span class="keyword">object</span> : Logger &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123; println(<span class="string">&quot;D/<span class="variable">$tag</span>: <span class="variable">$msg</span>&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>, tr: <span class="type">Throwable</span>?)</span></span> &#123; println(<span class="string">&quot;E/<span class="variable">$tag</span>: <span class="variable">$msg</span>&quot;</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  CompositionLocalProvider(LocalLogger provides testLogger) &#123;</span><br><span class="line">    SaveButton()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例功能如下：</p>
<ul>
<li>在 <code>AppRoot</code> 外层统一注入 <code>AndroidLogger</code>，日常直接用。</li>
<li>某些页面/组件内，用 <code>AnalyticsScope</code> 局部覆写，实现“日志通道”切换与叠加策略。</li>
<li>测试/预览时可提供 <code>NoOpLogger</code> 或自定义 <code>TestLogger</code> 收集输出。</li>
</ul>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2025-09-03</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Jetpack-Compose/" title="Jetpack Compose">Jetpack Compose </a><i class="fa fa-tag"></i><a class="tag" href="/tags/State/" title="State">State </a><i class="fa fa-tag"></i><a class="tag" href="/tags/状态订阅/" title="状态订阅">状态订阅 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/自动更新/" title="自动更新">自动更新 </a><span class="leancloud_visitors"></span><span>大约14991个字, 49分钟58秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2025/09/03/JetpackCompose学习系列二/,Puppet,JetpackCompose学习系列二： 状态订阅与自动更新,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2025/09/03/JetpackCompose%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="JetpackCompose学习系列三： 副作用与动画">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2025/08/23/JetpackCompose%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="JetpackCompose学习系列一：基本概念与传统 View 迁移">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><!-- Mermaid diagrams support--><script src="https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  mermaid.initialize({
    startOnLoad: true,
    securityLevel: 'loose',
    flowchart: { htmlLabels: true, useMaxWidth: true },
    classDiagram: {
      layout: 'elk',
      elk: {
        'elk.spacing.nodeNodeBetweenLayers': 200,
        'elk.spacing.nodeNode': 80
      }
    },
    theme: 'default',
    logLevel: 1
  });
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>