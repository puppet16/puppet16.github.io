<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列十二：协程四 · Puppet</title><meta name="description" content="一、前言
二、 协程与并发

1. 区分协程与线程概念
2. 协程如何处理并发

1. 借鉴 Java 的并发思路
2. 协程当中的并发思路

1. 单线程并发
2. Mutex
3. Actor


3. 反思：可变状态




三、异常原因及处理

1. 取消异常（CancellationExc"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列十二：协程四</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91">二、 协程与并发</a>
<ul>
<li><a href="#1-%E5%8C%BA%E5%88%86%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5">1. 区分协程与线程概念</a></li>
<li><a href="#2-%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91">2. 协程如何处理并发</a>
<ul>
<li><a href="#1-%E5%80%9F%E9%89%B4-java-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%80%9D%E8%B7%AF">1. 借鉴 Java 的并发思路</a></li>
<li><a href="#2-%E5%8D%8F%E7%A8%8B%E5%BD%93%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E6%80%9D%E8%B7%AF">2. 协程当中的并发思路</a>
<ul>
<li><a href="#1-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91">1. 单线程并发</a></li>
<li><a href="#2-mutex">2. Mutex</a></li>
<li><a href="#3-actor">3. Actor</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%8D%E6%80%9D%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81">3. 反思：可变状态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%A4%84%E7%90%86">三、异常原因及处理</a>
<ul>
<li><a href="#1-%E5%8F%96%E6%B6%88%E5%BC%82%E5%B8%B8cancellationexception">1. 取消异常（CancellationException）</a>
<ul>
<li><a href="#%E5%9C%BA%E6%99%AF-1cancel-%E4%B8%8D%E8%A2%AB%E5%93%8D%E5%BA%94">场景 1：cancel() 不被响应</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF-2%E7%BB%93%E6%9E%84%E8%A2%AB%E7%A0%B4%E5%9D%8F">场景 2：结构被破坏</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF-3%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86-cancellationexception">场景 3：未正确处理 CancellationException</a></li>
</ul>
</li>
<li><a href="#2-%E5%9C%A8%E5%8D%8F%E7%A8%8B%E5%BD%93%E4%B8%AD%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E7%9A%84%E5%BC%82%E5%B8%B8">2. 在协程当中处理普通的异常</a>
<ul>
<li><a href="#1-try-catch">1. try-catch</a></li>
<li><a href="#2-supervisorjob">2. SupervisorJob</a>
<ul>
<li><a href="#1-%E4%B8%8D%E8%B0%83%E7%94%A8-await-%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8">1. 不调用 await() 就不会发生异常</a></li>
<li><a href="#2-supervisorjob-%E6%BA%90%E7%A0%81">2. SupervisorJob 源码</a></li>
</ul>
</li>
<li><a href="#3-coroutineexceptionhandler">3. CoroutineExceptionHandler</a></li>
</ul>
</li>
<li><a href="#3-%E6%80%BB%E7%BB%93">3. 总结</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%AE%9E%E6%88%98%E8%AE%A9kthttp%E6%94%AF%E6%8C%81flow">四、 实战：让KtHttp支持Flow</a>
<ul>
<li><a href="#50-%E7%89%88%E6%9C%ACcallback-%E8%BD%AC-flow">5.0 版本：Callback 转 Flow</a>
<ul>
<li><a href="#1-callbackflow">1. callbackFlow</a></li>
<li><a href="#2-trysend-%E4%B8%8E-trysendblocking">2. trySend() 与 trySendBlocking()</a></li>
<li><a href="#3-callbackflow-%E7%9A%84-close">3. callbackFlow 的 close()</a></li>
</ul>
</li>
<li><a href="#60-%E7%89%88%E6%9C%AC%E7%9B%B4%E6%8E%A5%E6%94%AF%E6%8C%81-flow">6.0 版本：直接支持 Flow</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 协程中的并发以及异常原因和处理</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">朱涛老师</a>讲解的<code>Kotlin</code>系列的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程一</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程二</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程三</a>
</li>
<li>
<a href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/" title="kotlin学习系列十三：协程源码篇一">kotlin学习系列十三：协程源码篇一</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-协程与并发" class="header-anchor">#</a><span id="二-协程与并发">二、 协程与并发</span></h1>
<p><code>Kotlin</code> 的协程仍然是基于线程运行的。但是，经过一层封装以后，<code>Kotlin</code> 协程面对并发问题的时候，它的处理手段其实跟 <code>Java</code> 就大不一样。<br>
在 <code>Java</code> 世界里，并发往往需要多个线程一起工作，而多线程往往就会有共享的状态，这时候程序就要处理同步问题了。<br>
但是，不要把协程与线程的概念混淆在一起。</p>
<h2><a href="#1-区分协程与线程概念" class="header-anchor">#</a><span id="1-区分协程与线程概念">1. 区分协程与线程概念</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default 线程池</span></span><br><span class="line">    launch(Dispatchers.Default) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码里，在 <code>Default</code> 线程池上创建了一个协程，然后对变量 <em>i</em> 进行了 <em>1000</em> 次自增操作，接着又 <code>delay</code> 了一小会儿，防止程序退出，最后输出结果。<br>
那么，在面对这段代码的时候，<code>Default</code> 线程池内部是多个线程，因此就需要考虑多线程同步的问题。其实，这就是典型的把协程、线程混淆的例子。<br>
仔细分析上面的代码，会发现代码中压根就没有并发执行的任务，除了 <code>runBlocking</code>，只在 <code>launch</code> 当中创建了一个协程，所有的计算都发生在一个协程当中。所以，在这种情况下根本就不需要考虑同步的问题。<br>
再来看看多个协程并发执行的例子。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复十次</span></span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待计算完成</span></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 9972</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，创建了 <em>10</em> 个协程任务，每个协程任务都会工作在 <code>Default</code> 线程池，这 <em>10</em> 个协程任务，都会分别对 <em>i</em> 进行 <em>1000</em> 次自增操作。如果一切正常的话，代码的输出结果应该是 <em>10000</em>。但如果你实际运行这段代码，你会发现结果大概率不会是 <em>10000</em>。<br>
出现这个问题的原因也很简单，这 <em>10</em> 个协程分别运行在不同的线程之上，与此同时，这 <em>10</em> 个协程之间还共享着 <em>i</em> 这个变量，并且它们还会以并发的形式对 <em>i</em> 进行自增，所以自然就会产生同步的问题。</p>
<p>所以：<strong><code>Kotlin</code> 协程也需要处理多线程同步的问题</strong>。</p>
<h2><a href="#2-协程如何处理并发" class="header-anchor">#</a><span id="2-协程如何处理并发">2. 协程如何处理并发</span></h2>
<h3><a href="#1-借鉴-java-的并发思路" class="header-anchor">#</a><span id="1-借鉴-java-的并发思路">1. 借鉴 Java 的并发思路</span></h3>
<p>首先，由于 <code>Kotlin</code> 协程也是基于 <code>JVM</code> 的，所以，当我们面对并发问题的时候，脑子里第一时间想到的肯定是 <code>Java</code> 当中的同步手段，比如 <code>synchronized</code>、<code>Atomic</code>、<code>Lock</code>，等等。在 <code>Java</code> 当中，最简单的同步方式就是 <code>synchronized</code> 同步了。那么换到 <code>Kotlin</code> 里，就可以使用 <code>@Synchronized</code> 注解来修饰函数，也可以使用 <code>synchronized()&#123;&#125;</code>的方式来实现同步代码块。下面用 <code>synchronized</code> 来改造一下上面的 <em>代码段 2</em>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> lock = Any() <span class="comment">// 变化在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                synchronized(lock) &#123;</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 10000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，创建了一个 <code>lock</code> 对象，然后使用 <code>synchronized()&#123;&#125;</code> 将“<em>i++</em>”包裹了起来。这样就可以确保在自增的过程中不会出现同步问题。这时候，如果再运行代码，就会发现结果已经是 <em>10000</em> 了。<br>
不过，在实际生产环境中，<code>synchronized</code> 在协程当中也不是一直都很好用的。毕竟，<strong><code>synchronized</code> 是线程模型下的产物</strong>。</p>
<p>比如说，假设这里的自增操作需要一些额外的操作，需要用到挂起函数 <code>prepare()</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 模拟准备工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> lock = Any()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                synchronized(lock) &#123;</span><br><span class="line">                    <span class="comment">// 编译器报错！</span></span><br><span class="line">                    prepare()</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，就不能真地把协程看作是“<code>Java</code> 线程池的封装”，然后继续照搬 <code>Java</code> 的同步手段了。可以发现：<strong><code>synchronized()&#123;&#125;</code> 当中调用挂起函数，编译器会报错！</strong><br>
因为这里的挂起函数会被翻译成带有 <code>Continuation</code> 的异步函数，从而就造成了 <code>synchronid</code> 代码块无法正确处理同步。<br>
另外从这个例子里，也可以看出：即使 <code>Kotlin</code> 协程是基于 <code>Java</code> 线程的，但它其实已经脱离 <code>Java</code> 原本的范畴了。所以，单纯使用 <code>Java</code> 的同步手段，是无法解决 <code>Kotlin</code> 协程里所有问题的。</p>
<h3><a href="#2-协程当中的并发思路" class="header-anchor">#</a><span id="2-协程当中的并发思路">2. 协程当中的并发思路</span></h3>
<p>由于 <code>Java</code> 的线程模型是阻塞式的，比如说 <code>Thread.sleep()</code>，所以在 <code>Java</code> 当中，并发往往就意味着多线程，而多线程则往往会有状态共享，而状态共享就意味着要处理同步问题。<br>
但是，因为 <code>Kotlin</code> 协程具备挂起、恢复的能力，而且还有非阻塞的特点，所以在使用协程处理并发问题的时候，思路其实可以更宽。比如，可以使用<strong>单线程并发</strong>。</p>
<h4><a href="#1-单线程并发" class="header-anchor">#</a><span id="1-单线程并发">1. 单线程并发</span></h4>
<p>在 <code>Kotlin</code> 当中，单线程并发的实现其实非常轻松。不过如果有 <code>Java</code> 开发经验的话，也许会对这个说法产生疑问，因为在 <code>Java</code> 当中，并发往往就意味着多线程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult1</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start getResult1&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        logX(<span class="string">&quot;End getResult1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult2</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start getResult2&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        logX(<span class="string">&quot;End getResult2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start getResult3&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        logX(<span class="string">&quot;End getResult3&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> results: List&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123; getResult1() &#125;</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123; getResult2() &#125;</span><br><span class="line">        <span class="keyword">val</span> result3 = async &#123; getResult3() &#125;</span><br><span class="line"></span><br><span class="line">        results = listOf(result1.await(), result2.await(), result3.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time: <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">    println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start getResult1</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start getResult2</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start getResult3</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End getResult1</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End getResult2</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End getResult3</span></span><br><span class="line"><span class="comment">Thread:main</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Time: 1066</span></span><br><span class="line"><span class="comment">[Result1, Result2, Result3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中启动了三个协程，它们之间是并发执行的，每个协程执行耗时是 <em>1000</em> 毫秒，程序总耗时也是接近 <em>1000</em> 毫秒。而且，这几个协程是运行在同一个线程 <code>main</code> 之上的。<br>
所以，当在协程中面临并发问题的时候，首先可以考虑：<strong>是否真的需要多线程？</strong> 如果不需要的话，其实是可以不考虑多线程同步问题的。<br>
那么，对于前面<em>代码段 2</em> 的例子来说，可以把计算的逻辑分发到单一的线程之上：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mySingleDispatcher = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">        Thread(it, <span class="string">&quot;MySingleThread&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;.asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(mySingleDispatcher) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 10000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可见，在这段代码中，使用“<code>launch(mySingleDispatcher)</code>”，把所有的协程任务都分发到了单线程的 <code>Dispatcher</code> 当中，这样一来，就不必担心同步问题了。另外，如果仔细分析的话，上面创建的 <code>10</code> 个协程之间，其实仍然是并发执行的。<br>
所以这时候，运行上面的代码，就一定可以得到正确的结果了：<em>i = 10000</em>。</p>
<h4><a href="#2-mutex" class="header-anchor">#</a><span id="2-mutex">2. Mutex</span></h4>
<p>在 <code>Java</code> 当中，其实还有 <code>Lock</code> 之类的同步锁。但由于 <code>Java</code> 的锁是阻塞式的，会大大影响协程的非阻塞式的特性。所以，在 <code>Kotlin</code> 协程当中，是不推荐直接使用传统的同步锁的，甚至在某些场景下，在协程中使用 <code>Java</code> 的锁也会遇到意想不到的问题。<br>
为此，<code>Kotlin</code> 官方提供了“非阻塞式”的锁：<code>Mutex</code>。下面用 <code>Mutex</code> 来改造<em>代码段 2</em>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                mutex.lock()</span><br><span class="line">                i++</span><br><span class="line">                mutex.unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用 <code>mutex.lock()</code>、<code>mutex.unlock()</code> 包裹了需要同步的计算逻辑，这样一来，代码就可以实现多线程同步了，程序的输出结果也会是 <em>10000</em>。<br>
实际上，<code>Mutex</code> 对比 <code>JDK</code> 当中的锁，最大的优势就在于<strong>支持挂起和恢复</strong>。它的源码定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mutex</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isLocked: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     注意这里</span></span><br><span class="line">    <span class="comment">//        ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">lock</span><span class="params">(owner: <span class="type">Any</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">unlock</span><span class="params">(owner: <span class="type">Any</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Mutex</code> 是一个接口，它的 <code>lock()</code> 方法其实是一个挂起函数。而这就是实现非阻塞式同步锁的根本原因。</p>
<p>不过，在<em>代码段 7</em> 当中，对于 <code>Mutex</code> 的使用其实是错误的。因为这样的做法并不安全，有如下一个场景：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mutex.lock()</span><br><span class="line">                    i++</span><br><span class="line">                    i/<span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">                    mutex.unlock()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    println(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序无法退出</span></span><br></pre></td></tr></table></figure>
<p>以上代码会在 <code>mutex.lock()</code>、<code>mutex.unlock()</code> 之间发生异常，从而导致 <code>mutex.unlock()</code> 无法被调用。这个时候，整个程序的执行流程就会一直卡住，无法结束。</p>
<p>所以，为了避免出现这样的问题，应该使用 <code>Kotlin</code> 提供的一个扩展函数：<strong><code>mutex.withLock&#123;&#125;</code></strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                mutex.withLock &#123;</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// withLock的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Mutex.<span class="title">withLock</span><span class="params">(owner: <span class="type">Any</span>? = <span class="literal">null</span>, action: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    lock(owner)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(owner)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>withLock&#123;&#125;</code> 的本质，其实是在 <code>finally&#123;&#125;</code> 当中调用了 <code>unlock()</code>。这样一来，就再也不必担心因为异常导致 <code>unlock()</code> 无法执行的问题了。</p>
<h4><a href="#3-actor" class="header-anchor">#</a><span id="3-actor">3. Actor</span></h4>
<p><code>Actor</code>，是在很多编程语言当中都存在的一个并发同步模型。在 <code>Kotlin</code> 当中，也同样存在这样的模型，它本质上是<strong>基于 <code>Channel</code> 管道消息实现的</strong>。下面看一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Msg</span></span><br><span class="line"><span class="keyword">object</span> AddMsg : Msg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResultMsg</span>(</span><br><span class="line">    <span class="keyword">val</span> result: CompletableDeferred&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">) : Msg()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">addActor</span><span class="params">()</span></span> = actor&lt;Msg&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">                <span class="keyword">is</span> AddMsg -&gt; counter++</span><br><span class="line">                <span class="keyword">is</span> ResultMsg -&gt; msg.result.complete(counter)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> actor = addActor()</span><br><span class="line">    <span class="keyword">val</span> jobs = mutableListOf&lt;Job&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                actor.send(AddMsg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.add(job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobs.joinAll()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred = CompletableDeferred&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    actor.send(ResultMsg(deferred))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">    actor.close()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="subst">$&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，定义了 <code>addActor()</code> 这个挂起函数，而它其实调用了 <code>actor()</code> 这个高阶函数。而这个函数的返回值类型其实是 <code>SendChannel</code>。由此可见，<strong><code>Kotlin</code> 当中的 <code>Actor</code> 其实就是 <code>Channel</code> 的简单封装</strong> 。<code>Actor</code> 的多线程同步能力都源自于 <code>Channel</code>。</p>
<p>这里，借助<strong>密封类</strong>定义了两种消息类型，<code>AddMsg</code>、<code>ResultMsg</code>，然后在 <code>actor&#123;&#125;</code> 内部，处理这两种消息类型，如果收到了 <code>AddMsg</code>，则计算“<em>i++</em>”；如果收到了 <code>ResultMsg</code>，则返回计算结果。而在 <code>actor&#123;&#125;</code> 的外部，只需要发送 <em>10000</em> 次的 <code>AddMsg</code> 消息，最后再发送一次 <code>ResultMsg</code>，取回计算结果即可。</p>
<p><code>AddMsg</code>、<code>ResultMsg</code> 是在多线程并行发送的，而 <code>Channel</code> 可以保证接收到的消息可以同步接收并处理。所以，<code>Actor</code> 本质上是基于 <code>Channel</code> 管道消息实现的。</p>
<blockquote>
<p>补充：<code>Kotlin</code> 目前的 <code>Actor</code> 实现其实还比较简陋，在不远的将来，<code>Kotlin</code> 官方会对 <code>Actor API</code> 进行重构，具体可以参考这个 <a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/issues/87">链接</a> 。虽然它的 API 可能会改变，但核心理念应该是不会变的。</p>
</blockquote>
<h3><a href="#3-反思可变状态" class="header-anchor">#</a><span id="3-反思可变状态">3. 反思：可变状态</span></h3>
<p>到现在为止，已经学习了三种协程并发的思路。不过还要反思一个问题：<strong>多线程并发，一定需要同步机制吗？</strong></p>
<p>前面提到过，多线程并发，往往会有共享的可变状态，而共享可变状态的时候，就需要考虑同步问题。</p>
<p>弄清楚这一点后，其实可以找到一个新的思路：<strong>避免共享可变状态</strong>。有了这个思路以后，代码其实就非常容易实现了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferreds = mutableListOf&lt;Deferred&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> deferred = async (Dispatchers.Default) &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                    i++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@async</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        deferreds.add(deferred)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    deferreds.forEach &#123;</span><br><span class="line">        result += it.await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，不再共享可变状态 <em>i</em>，对应的，在每一个协程当中，都有一个局部的变量 <em>i</em>，同时将 <code>launch</code> 都改为了 <code>async</code>，让每一个协程都可以返回计算结果。<br>
这种方式，相当于将 <em>10000</em> 次计算，平均分配给了 <em>10</em> 个协程，让它们各自计算 <em>1000</em> 次。这样一来，每个协程都可以进行独立的计算，然后将 <em>10</em> 个协程的结果汇总起来，最后累加在一起。</p>
<p>其实，上面的思路，也是借鉴自函数式编程的思想，因为在函数式编程当中，就是追求<strong>不变性、无副作用</strong>。不过，以上代码其实还是命令式的代码，如果用函数式风格来重构的话，代码会更加简洁。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = (<span class="number">1.</span><span class="number">.10</span>).map &#123;</span><br><span class="line">        async (Dispatchers.Default) &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@async</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.awaitAll()</span><br><span class="line">        .sum()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;i = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，使用函数式风格代码重构了<em>代码段 12</em>，仍然创建了 <em>10</em> 个协程，并发了计算了 <em>10000</em> 次自增操作。<br>
函数式编程的一大优势就在于，它具有不变性、无副作用的特点，所以<strong>无惧并发编程</strong>。上面的这个代码案例，其实就体现出了 <code>Kotlin</code> 函数式编程的这个优势。</p>
<h1><a href="#三-异常原因及处理" class="header-anchor">#</a><span id="三-异常原因及处理">三、异常原因及处理</span></h1>
<p>比起 <code>Kotlin</code> 协程的语法知识点，协程的异常处理，其实更难掌握。<strong>协程就是互相协作的程序，协程是结构化的。</strong> 正因为 <code>Kotlin</code> 协程有这两个特点，这就导致它的异常处理机制与普通的程序完全不一样。</p>
<p>换句话说：<strong>如果把 <code>Java</code> 里的那一套异常处理机制，照搬到 <code>Kotlin</code> 协程里来，一定会水土不服</strong>。因为在普通的程序当中，使用 <code>try-catch</code> 就能解决大部分的异常处理问题，但是在协程当中，根据不同的协程特性，它的异常处理策略是随之变化的。</p>
<p>在 <code>Kotlin</code> 协程当中，通常把异常分为两大类，一类是取消异常 <em>（CancellationException）</em>，另一类是其他异常。之所以要这么分类，是因为在 <code>Kotlin</code> 协程当中，这两种异常的处理方式是不一样的。或者说，在 <code>Kotlin</code> 协程所有的异常当中，需要把 <code>CancellationException</code> 单独拎出来，特殊对待。</p>
<h2><a href="#1-取消异常cancellationexception" class="header-anchor">#</a><span id="1-取消异常cancellationexception">1. 取消异常（CancellationException）</span></h2>
<p>要知道，当协程任务被取消的时候，它的内部是会产生一个 <code>CancellationException</code> 的。而协程的结构化并发，最大的优势就在于：如果我们取消了父协程，子协程也会跟着被取消。但是很多初学者都会遇到一个问题，那就是协程无法被取消。这里，主要涉及了三个场景，下面来一一分析下。</p>
<h3><a href="#场景-1cancel-不被响应" class="header-anchor">#</a><span id="场景-1cancel-不被响应">场景 1：cancel() 不被响应</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">            i ++</span><br><span class="line">            println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i = 1</span></span><br><span class="line"><span class="comment">i = 2</span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">i = 4</span></span><br><span class="line"><span class="comment">i = 5</span></span><br><span class="line"><span class="comment">// 永远停不下来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，启动了一个协程，在这个协程的内部，一直对 <em>i</em> 进行自增。过了 <em>2000</em> 毫秒以后，调用了 <code>job.cancel()</code>。但通过运行的结果，可以看到协程并不会被取消。这是为什么呢？</p>
<p>因为协程是互相协作的程序。因此，对于协程任务的取消，也是需要互相协作的。协程外部取消，协程内部需要做出响应才行。具体来说，可以在协程体中加入状态判断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">            i ++</span><br><span class="line">            println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">i = 1</span></span><br><span class="line"><span class="comment">i = 2</span></span><br><span class="line"><span class="comment">i = 3</span></span><br><span class="line"><span class="comment">i = 4</span></span><br><span class="line"><span class="comment">i = 5</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这段代码里，把 <code>while</code> 循环的条件改成了 <code>while (isActive)</code>，这就意味着，只有协程处于活跃状态的时候，才会继续执行循环体内部的代码。<br>
这里，进一步分析 <em>代码段 1</em> 无法取消的原因：当调用 <code>job.cancel()</code> 以后，协程任务已经不是活跃状态了，但代码并没有把 <code>isActive</code> 作为循环条件，因此协程无法真正取消。<br>
所以到这里，就可以总结出协程异常处理的第一准则了：<strong>协程的取消需要内部的配合</strong>。</p>
<h3><a href="#场景-2结构被破坏" class="header-anchor">#</a><span id="场景-2结构被破坏">场景 2：结构被破坏</span></h3>
<p>协程是结构化的，当取消父协程的时候，子协程也会跟着被取消，如下图：</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/job_parent_3.gif" alt></p>
<p>但在某些情况下，嵌套创建的子协程并不会跟随父协程一起取消，比如下面这个案例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fixedDispatcher = Executors.newFixedThreadPool(<span class="number">2</span>) &#123;</span><br><span class="line">    Thread(it, <span class="string">&quot;MyFixedThread&quot;</span>).apply &#123; isDaemon = <span class="literal">false</span> &#125;</span><br><span class="line">&#125;.asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 父协程</span></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(fixedDispatcher) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1，注意这里</span></span><br><span class="line">        launch(Job()) &#123; <span class="comment">// 子协程1</span></span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123; <span class="comment">// 子协程2</span></span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">First i = 4</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">First i = 5</span></span><br><span class="line"><span class="comment">First i = 6</span></span><br><span class="line"><span class="comment">// 子协程1永远不会停下来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，创建了一个 <code>fixedDispatcher</code>，它是由两个线程的线程池实现的。接着，通过 <code>launch</code> 创建了三个协程，其中 <code>parentJob</code> 是父协程，随后等待 <em>2000</em> 毫秒，然后取消父协程。<br>
不过，通过程序的运行结果发现，虽然“<em>子协程 1</em> ”当中使用了 <code>while(isActive)</code> 作为判断条件，它也仍然无法被取消。其实，这里的主要原因还是在 <em>注释 1</em> 处，在创建子协程的时候，使用了 <code>launch(Job())&#123;&#125;</code>。而这种创建方式，就打破了原有的协程结构。下图描述了它们之间的父子关系。</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/exception_1.jpeg" alt></p>
<p>根据这张图，可以看到“<em>子协程 1</em> ”已经不是 <code>parentJob</code> 的子协程了，而对应的，它的父 <code>Job</code> 是在 <code>launch</code> 当中传入的 <code>Job()</code> 对象。所以，在这种情况下，调用 <code>parentJob.cancel()</code> 的时候，自然也就无法取消“<em>子协程 1</em>”了。</p>
<p>所以，如果稍微改动一下上面的代码，不传入 <code>Job()</code>，程序就可以正常运行了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(fixedDispatcher) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">First i = 4</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>parentJob</code> 与它内部的<em>子协程 1</em> 、<em>子协程 2</em> 之间是父子关系，因此它们两个都是会响应协程取消的事件的。这时候，它们之间的关系就变成了下图这样：</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/exception_2.jpeg" alt></p>
<p>那么到这里，其实就可以总结出第二条准则了：<strong>不要轻易打破协程的父子结构！</strong></p>
<h3><a href="#场景-3未正确处理-cancellationexception" class="header-anchor">#</a><span id="场景-3未正确处理-cancellationexception">场景 3：未正确处理 CancellationException</span></h3>
<p>其实，对于 <code>Kotlin</code> 提供的挂起函数，它们是可以自动响应协程的取消的，比如说，当把 <code>Thread.sleep(500)</code> 改为 <code>delay(500)</code> 以后，就不需要在 <code>while</code> 循环当中判断 <code>isActive</code> 了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(Dispatchers.Default) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 变化在这里</span></span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>实际上，对于 <code>delay()</code> 函数来说，它可以自动检测当前的协程是否已经被取消，如果已经被取消的话，它会抛出一个 <code>CancellationException</code>，从而终止当前的协程。</p>
<p>为了证明这一点，可以在以上代码的基础上，增加一个 <code>try-catch</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(Dispatchers.Default) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    delay(<span class="number">500L</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">                    println(<span class="string">&quot;Catch CancellationException&quot;</span>)</span><br><span class="line">                    <span class="comment">// 2</span></span><br><span class="line">                    <span class="keyword">throw</span> e</span><br><span class="line">                &#125;</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">Catch CancellationException</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>看<em>注释 1</em> ，在用 <code>try-catch</code> 包裹了 <code>delay()</code> 以后，就可以在输出结果中，看到“<code>Catch CancellationException</code>”，这就说明 <code>delay()</code> 确实可以自动响应协程的取消，并且产生 <code>CancellationException</code> 异常。<br>
不过，以上代码中，最重要的其实是 <em>注释 2</em> ：“<code>throw e</code>”。当捕获到 <code>CancellationException</code> 以后，还要把它重新抛出去。而如果删去这行代码的话，子协程将同样无法被取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> parentJob = launch(Dispatchers.Default) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    delay(<span class="number">500L</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">                    println(<span class="string">&quot;Catch CancellationException&quot;</span>)</span><br><span class="line">                    <span class="comment">// 1，注意这里</span></span><br><span class="line">                    <span class="comment">// throw e</span></span><br><span class="line">                &#125;</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;First i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">                i ++</span><br><span class="line">                println(<span class="string">&quot;Second i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.cancel()</span><br><span class="line">    parentJob.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">First i = 1</span></span><br><span class="line"><span class="comment">Second i = 1</span></span><br><span class="line"><span class="comment">First i = 2</span></span><br><span class="line"><span class="comment">Second i = 2</span></span><br><span class="line"><span class="comment">First i = 3</span></span><br><span class="line"><span class="comment">Second i = 3</span></span><br><span class="line"><span class="comment">Second i = 4</span></span><br><span class="line"><span class="comment">..</span></span><br><span class="line"><span class="comment">First i = 342825</span></span><br><span class="line"><span class="comment">Catch CancellationException</span></span><br><span class="line"><span class="comment">// 程序将永远无法终止</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可见，在这段代码中，把“<code>throw e</code>”这行代码注释掉，重新运行之后，程序就永远无法终止了。这主要是因为，捕获了 <code>CancellationException</code> 以后没有重新抛出去，就导致子协程无法正常取消。</p>
<p>所以到这里，可以总结出第三条准则：<strong>捕获了 <code>CancellationException</code> 以后，要考虑是否应该重新抛出来</strong>。</p>
<p>到这里，就通过协程取消异常的三个场景，总结了三条准则，来应对 <code>CancellationException</code> 这个特殊的异常。那么接下来，再来看看如何在协程当中处理普通的异常。</p>
<h2><a href="#2-在协程当中处理普通的异常" class="header-anchor">#</a><span id="2-在协程当中处理普通的异常">2. 在协程当中处理普通的异常</span></h2>
<h3><a href="#1-try-catch" class="header-anchor">#</a><span id="1-try-catch">1. try-catch</span></h3>
<p>在 <code>Kotlin</code> 协程当中，<code>try-catch</code> 并非万能的。有时候，即使你用 <code>try-catch</code> 包裹了可能抛异常的代码，软件仍然会崩溃。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">崩溃</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，使用 <code>try-catch</code> 包裹了 <code>launch&#123;&#125;</code>，在协程体内部，制造了一个异常。从运行结果这里可以看到，<code>try-catch</code> 并没有成功捕获异常，程序等待了 <code>100</code> 毫秒左右，最终还是崩溃了。</p>
<p>类似的，如果把<em>代码段 8</em> 当中的 <code>launch</code> 换成 <code>async</code>，结果也是差不多的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> deferred: Deferred&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred = async &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred?.await()</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">崩溃</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>其实，这种 <code>try-catch</code> 失效的问题，主要就是因为，当协程体当中的“<em>1/0</em> ”执行的时候，我程序已经跳出 <code>try-catch</code> 的作用域了。当然，要解决这两个问题也很容易。对于<em>代码段 8</em> 来说，可以挪动一下 <code>try-catch</code> 的位置，比如说这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">            println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Catch: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>也就是说，可以把 <code>try-catch</code> 挪到 <code>launch&#123;&#125;</code> 协程体内部。这样一来，它就可以正常捕获到 <code>ArithmeticException</code> 这个异常了。而对于<em>代码段 9</em> 的 <code>async</code> 的这个例子，其实有两种解决手段，其中一种跟上面的做法一样，把 <code>try-catch</code> 挪到了 <code>async&#123;&#125;</code> 协程体内部，比如这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> deferred: Deferred&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    deferred = async &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">            println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred?.await()</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，可以总结出第四条准则了：<strong>不要用 <code>try-catch</code> 直接包裹 <code>launch</code>、<code>async</code>。</strong></p>
<h5><a href="#谣言一使用-try-catch-包裹deferredawait" class="header-anchor">#</a><span id="谣言一使用-try-catch-包裹deferredawait">谣言一：使用 try-catch 包裹“deferred.await()”</span></h5>
<p>接下来，再看看 <code>async</code> 避免异常的另外一种手段，可以使用 <code>try-catch</code> 包裹“<code>deferred.await()</code>”。来看看是否可行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Catch: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>那么，根据以上程序的运行结果可以看到，<strong>这样做其实是行不通的。</strong></p>
<h5><a href="#谣言二await-如果不调用的话async-当中的异常甚至不会发生" class="header-anchor">#</a><span id="谣言二await-如果不调用的话async-当中的异常甚至不会发生">谣言二：await() 如果不调用的话，async 当中的异常甚至不会发生</span></h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可见，<code>async</code> 当中产生异常，即使不调用 <code>await()</code> 同样是会导致程序崩溃的。</p>
<h3><a href="#2-supervisorjob" class="header-anchor">#</a><span id="2-supervisorjob">2. SupervisorJob</span></h3>
<h4><a href="#1-不调用-await-就不会发生异常" class="header-anchor">#</a><span id="1-不调用-await-就不会发生异常">1. 不调用 await() 就不会发生异常</span></h4>
<p>实际上，如果要使用 <code>try-catch</code> 包裹“<code>deferred.await()</code>”的话，还需要配合 <code>SupervisorJob</code> 一起使用。也就是说，借助 <code>SupervisorJob</code> 来改造<em>代码段 13</em> 的话，就可以实现“不调用 <code>await()</code> 就不会产生异常而崩溃”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(SupervisorJob())</span><br><span class="line">    scope.async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当使用 <code>SupervisorJob</code> 创建一个 <code>scope</code> 以后，用 <code>scope.async&#123;&#125;</code>启动协程后，只要不调用“<code>deferred.await()</code>”，程序就不会因为异常而崩溃。</p>
<p>所以同样的，也能用类似的办法来改造<em>代码段 12</em> 当中的逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(SupervisorJob())</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> deferred = scope.async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Catch: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Catch: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，仍然使用“<code>scope.async &#123;&#125;</code>”创建了协程，同时也用 <code>try-catch</code> 包裹“<code>deferred.await()</code>”，这样一来，这个异常就成功地被捕获了。</p>
<h4><a href="#2-supervisorjob-源码" class="header-anchor">#</a><span id="2-supervisorjob-源码">2. SupervisorJob 源码</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">SupervisorJob</span><span class="params">(parent: <span class="type">Job</span>? = <span class="literal">null</span>)</span></span> : CompletableJob </span><br><span class="line">                    = SupervisorJobImpl(parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletableJob</span> : <span class="type">Job</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">complete</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">completeExceptionally</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上代码，可以看到，<code>SupervisorJob()</code> 其实不是构造函数，它只是一个普通的顶层函数。而这个方法返回的对象，是 <code>Job</code> 的子类。</p>
<p><code>SupervisorJob</code> 与 <code>Job</code> 最大的区别就在于，当它的子 <code>Job</code> 发生异常的时候，其他的子 <code>Job</code> 不会受到牵连。下图演示普通 <code>Job</code> 与 <code>SupervisorJob</code> 之间的差异。</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/exception_3.gif" alt></p>
<p>这个是普通 <code>Job</code>，对于子 <code>Job</code> 出现异常时的应对策略。可以看到，由于 <code>parentJob</code> 是一个普通的 <code>Job</code> 对象，当 <code>job1</code> 发生异常之后，它会导致 <code>parentJob</code> 取消，进而导致 <code>job2</code>、<code>job3</code> 也受到牵连。而这时候，如果把 <code>parentJob</code> 改为 <code>SupervisorJob</code>，<code>job1</code> 发生异常的的话，就不会影响到其他的 <code>Job</code> 了。</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/exception_4.jpeg" alt></p>
<p>所以，可以总结出第五条准则：<strong>灵活使用 <code>SupervisorJob</code>，控制异常传播的范围。</strong></p>
<blockquote>
<p>提示：并非所有情况下，都应该使用 <code>SupervisorJob</code>，有时候 <code>Job</code> 会更合适，这要结合实际场景分析。</p>
</blockquote>
<h3><a href="#3-coroutineexceptionhandler" class="header-anchor">#</a><span id="3-coroutineexceptionhandler">3. CoroutineExceptionHandler</span></h3>
<p>由于协程是结构化的，当协程任务出现复杂的层级时，这两种手段其实都无法很好的应对。所以这个时候，就需要 <code>CoroutineExceptionHandler</code> 出场了。</p>
<p>对于 <code>CoroutineExceptionHandler</code>，它是 <code>CoroutineContext</code> 的元素之一，在创建协程的时候，可以指定对应的 <code>CoroutineExceptionHandler</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(coroutineContext)</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line"></span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">                <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，模拟了一个复杂的协程嵌套场景。对于这样的情况，其实很难一个个在每个协程体里面去写 <code>try-catch</code>。所以这时候，为了捕获到异常，就可以使用 <code>CoroutineExceptionHandler</code> 了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> myExceptionHandler = CoroutineExceptionHandler &#123; _, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Catch exception: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(coroutineContext + Job() + myExceptionHandler)</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line"></span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">                <span class="number">1</span> / <span class="number">0</span> <span class="comment">// 故意制造异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Catch exception: ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，定义了一个 <code>CoroutineExceptionHandler</code>，然后把它传入了 <code>scope</code> 当中，这样一来，就可以捕获其中所有的异常了。</p>
<h5><a href="#coroutineexceptionhandler不起作用的情景" class="header-anchor">#</a><span id="coroutineexceptionhandler不起作用的情景">CoroutineExceptionHandler不起作用的情景</span></h5>
<p>如果使用错误的话，<code>CoroutineExceptionHandler</code> 会不起作用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> myExceptionHandler = CoroutineExceptionHandler &#123; _, throwable -&gt;</span><br><span class="line">       println(<span class="string">&quot;Catch exception: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 不再传入myExceptionHandler</span></span><br><span class="line">   <span class="keyword">val</span> scope = CoroutineScope(coroutineContext)</span><br><span class="line">   scope.launch &#123;</span><br><span class="line">       async &#123;</span><br><span class="line">           delay(<span class="number">100L</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       launch &#123;</span><br><span class="line">           delay(<span class="number">100L</span>)</span><br><span class="line">           <span class="comment">// 变化在这里</span></span><br><span class="line">           launch(myExceptionHandler) &#123;</span><br><span class="line">               delay(<span class="number">100L</span>)</span><br><span class="line">               <span class="number">1</span> / <span class="number">0</span> </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       delay(<span class="number">100L</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   delay(<span class="number">1000L</span>)</span><br><span class="line">   println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意上面的注释，把自定义的 <code>myExceptionHandler</code>，放到出现异常的 <code>launch</code> 那里传了进去。按理说，程序的执行结果是不会发生变化才对的。但实际上，<code>myExceptionHandler</code> 并不会起作用，异常不会被它捕获。<br>
对比<em>代码段 18</em> 和<em>代码段 19</em> 发现，<code>myExceptionHandler</code> 直接定义在发生异常的位置反而不生效，而定义在最顶层却可以生效！</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/exception_5.gif" alt></p>
<p>其实，出现这种现象的原因，就是因为：<code>CoroutineExceptionHandler</code> 只在顶层的协程当中才会起作用。也就是说，当子协程当中出现异常以后，它们都会统一上报给顶层的父协程，然后顶层的父协程才会去调用 <code>CoroutineExceptionHandler</code>，来处理对应的异常。</p>
<p>那么到这里，就可以总结出第六条准则了：<strong>使用 <code>CoroutineExceptionHandler</code> 处理复杂结构的协程异常，它仅在顶层协程中起作用。</strong></p>
<h2><a href="#3-总结" class="header-anchor">#</a><span id="3-总结">3. 总结</span></h2>
<p>在 <code>Kotlin</code> 协程当中，异常主要分为两大类，一类是协程取消异常 <em>（CancellationException）</em> ，另一类是其他异常。为了处理这两大类问题，一共总结出了 <strong>6</strong> 大准则：</p>
<ul>
<li>第一条准则：<strong>协程的取消需要内部的配合。</strong></li>
<li>第二条准则：<strong>不要轻易打破协程的父子结构！</strong> 这一点，其实不仅仅只是针对协程的取消异常，而是要贯穿于整个协程的使用过程中。协程的优势在于结构化并发，它的许多特性都是建立在这个特性之上的，如果无意中打破了它的父子结构，就会导致协程无法按照预期执行。</li>
<li>第三条准则：<strong>捕获了 <code>CancellationException</code> 以后，要考虑是否应该重新抛出来。</strong> 在协程体内部，协程是依赖于 <code>CancellationException</code> 来实现结构化取消的，有的时候出于某些目的需要捕获 <code>CancellationException</code>，但捕获完以后，还需要思考是否需要将其重新抛出来。</li>
<li>第四条准则：<strong>不要用 <code>try-catch</code> 直接包裹 <code>launch</code>、<code>async</code>。</strong> 考虑到协程代码的执行顺序与普通程序不一样，直接使用 <code>try-catch</code> 包裹 <code>launch</code>、<code>async</code>，是不会有任何效果的。</li>
<li>第五条准则：<strong>灵活使用 <code>SupervisorJob</code>，控制异常传播的范围。</strong> <code>SupervisorJob</code> 是一种特殊的 <code>Job</code>，它可以控制异常的传播范围。普通的 <code>Job</code>，它会因为子协程当中的异常而取消自身，而 <code>SupervisorJob</code> 则不会受到子协程异常的影响。在很多业务场景下，都不希望子协程影响到父协程，所以 <code>SupervisorJob</code> 的应用范围也非常广。比如说 <code>Android</code> 当中的 <code>viewModelScope</code>，它就使用了 <code>SupervisorJob</code>，这样一来，<code>App</code> 就不会因为某个子协程的异常导致整个应用的功能出现紊乱。</li>
<li>第六条准则：<strong>使用 <code>CoroutineExceptionHandler</code> 处理复杂结构的协程异常，它仅在顶层协程中起作用。</strong> 传统的 <code>try-catch</code> 在协程当中并不能解决所有问题，尤其是在协程嵌套层级较深的情况下。这时候，<code>Kotlin</code> 官方提供了 <code>CoroutineExceptionHandler</code> 作为补充。有了它，可以轻松捕获整个作用域内的所有异常。</li>
</ul>
<p>当遇到问题的时候，首先要分析是 <code>CancellationException</code> 导致的，还是其他异常导致的。接着就可以根据实际情况去思考，该用哪种处理手段了。</p>
<p>另外总结出的 <em>6</em> 大准则，其实都跟协程的结构化并发有着密切联系。由于协程之间存在父子关系，因此它的异常处理也是遵循这一规律的。而协程的异常处理机制之所以这么复杂，也是因为它的结构化并发特性。所以，除了这 <em>6</em> 大准则以外，还可以总结出一个核心理念：<strong>因为协程是“结构化的”，所以异常传播也是“结构化的”。</strong></p>
<h1><a href="#四-实战让kthttp支持flow" class="header-anchor">#</a><span id="四-实战让kthttp支持flow">四、 实战：让KtHttp支持Flow</span></h1>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">在kotlin学习系列十的第六章第四节中</a>
<p><code>KtHttp</code> <em>4.0</em> 版本，为了支持挂起函数，有两种思路，一种是改造内部，另一种是扩展外部。同理，为了让 <code>KtHttp</code> 支持 <code>Flow</code>，这次的实战也是这两种思路。</p>
<ul>
<li><em>5.0</em> 版本，基于 <em>4.0</em> 版本的代码，从 <code>KtHttp</code> 的<strong>外部扩展</strong> 出 <code>Flow</code> 的能力。</li>
<li><em>6.0</em> 版本，<strong>修改 <code>KtHttp</code> 内部</strong> ，让它支持 <code>Flow API</code>。</li>
</ul>
<p>这两种思路对应两种情况，在实际的工作中，往往没有权限修改第三方提供的 <code>SDK</code>，那么这时候，如果想要让 <code>SDK</code> 获得 <code>Flow</code> 的能力，就只能借助 <code>Kotlin</code> 的扩展函数，为它扩展出 <code>Flow</code> 的能力。而对于工程内部的代码，希望某个功能模块获得 <code>Flow</code> 的能力，就可以直接修改它的源代码，让它直接支持 <code>Flow</code>。</p>
<h2><a href="#50-版本callback-转-flow" class="header-anchor">#</a><span id="50-版本callback-转-flow">5.0 版本：Callback 转 Flow</span></h2>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">在kotlin学习系列十的第六章中</a>
<p>在 <em>3.0</em> 版本里，实现了 <code>KtHttp</code> 的异步 <code>Callback</code> 请求。之后在 <em>4.0</em>版本里，并没有改动 <code>KtHttp</code> 的源代码，而是直接在 <code>KtCall</code> 的基础上扩展了挂起函数的支持。回顾一下之前的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line"><span class="comment">//      暴露挂起函数的continuation</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>)</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//          响应取消事件</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            println(<span class="string">&quot;Call cancelled!&quot;</span>)</span><br><span class="line">            call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面这种做法非常适合针对第三方 <code>SDK</code> 的扩展，而这一切，都要归功于 <code>Kotlin</code> 的<strong>扩展函数</strong>特性。现在希望 <code>KtHttp</code> 支持 <code>Flow</code>，其实也同样可以借助扩展函数来实现。<code>Kotlin</code> 官方提供了一个 <code>API</code>：<strong><code>callbackFlow</code></strong>，它就是专门用于将 <code>Callback</code> 转为 <code>Flow</code> 的。</p>
<h3><a href="#1-callbackflow" class="header-anchor">#</a><span id="1-callbackflow">1. callbackFlow</span></h3>
<p><code>Callback</code> 转 <code>Flow</code>，用法跟 <code>Callback</code> 转挂起函数是差不多的。如果你去分析<em>代码段 1</em> 当中的代码模式，会发现 <code>Callback</code> 转挂起函数，主要有三个步骤。</p>
<ul>
<li>第一步：使用 <code>suspendCancellableCoroutine</code> 执行 <code>Callback</code> 代码，等待 <code>Callback</code> 回调；</li>
<li>第二步：将 <code>Callback</code> 回调结果传出去，<code>onSuccess</code> 的情况就传结果，<code>onFail</code> 的情况就传异常；</li>
<li>第三步：响应协程取消事件 <code>invokeOnCancellation&#123;&#125;</code>。</li>
</ul>
<p>所以使用 <code>callbackFlow</code>，也是这样三个步骤。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            trySend(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中发现，<code>callbackFlow</code> 的底层用到了 <code>Channel</code>，所以你可以使用 <code>trySend()</code> 这样的 <code>API</code>。这个 <code>API</code> 其实就是 <code>Channel.send()</code> 的<strong>非挂起函数</strong> 版本的 <code>API</code>。但，它仍然还有优化空间。</p>
<h3><a href="#2-trysend-与-trysendblocking" class="header-anchor">#</a><span id="2-trysend-与-trysendblocking">2. trySend() 与 trySendBlocking()</span></h3>
<p><em>注释 1</em>，这里使用 <code>trySend()</code>，虽然在这个案例当中用这个 <code>API</code> 确实没问题，但在大部分场景下，它其实是不够稳妥的。通过查看它的源码文档，会看到它的返回值类型是 <strong><code>ChannelResult</code></strong>，代表 <code>trySend()</code> 的执行结果是成功还是失败。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">trySend</span><span class="params">(element: <span class="type">E</span>)</span></span>: ChannelResult&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果往 <code>Channel</code> 当中成功地添加了元素，那么 <code>trySend()</code> 的返回值就是成功，如果当前的 <code>Channel</code> 管道已经满了，那么 <code>trySend()</code> 的返回值就是失败。<br>
其实，当 <code>Channel</code> 管道容量已满的时候，更希望 <code>trySend()</code> 可以多等等，直到管道容量空闲以后再返回成功。所以这时候，可以使用 <strong><code>trySendBlocking()</code></strong> 来替代它。它是 <em><code>Kotlin</code> 协程 1.5</em> 出现的一个新的 <code>API</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1，变化在这里</span></span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，这里仅仅只是改为 <code>trySendBlocking()</code> 仍然还不够，运行一下程序：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV5</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .asFlow()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出正常</span></span><br><span class="line"><span class="comment">程序不会终止</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，程序不会终止，其实，问题的原因也很简单，由于 <code>callbackFlow</code> 的底层是 <code>Channel</code> 实现的，在用完它以后，应该主动将其关闭或者释放。不然的话，它就会一直占用<strong>计算机资源</strong>。所以这时候，可以进一步完善 <code>trySendBlocking()</code> 这部分的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 1，变化在这里</span></span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123; close(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            close(throwable)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">输出正常</span></span><br><span class="line"><span class="comment">程序等待一会后自动终止</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的 <code>onSuccess</code>、<code>onFailure</code> 其实就相当于回调，在这里，不管是成功还是失败，都主动把 <code>callbackFlow</code> 当中的 <code>Channel</code> 关闭。这样一来，程序就可以正常终止了。</p>
<blockquote>
<p>提示：在大部分场景下 <code>trySendBlocking()</code> 会比 <code>trySend()</code> 更稳妥一些，因为它会尽可能发送成功。但在某些特殊情况下，<code>trySend()</code> 也有它的优势，因为它不会出现阻塞问题。</p>
</blockquote>
<p>现在为止，<em>5.0</em> 版本的代码已经算是合格了。</p>
<h3><a href="#3-callbackflow-的-close" class="header-anchor">#</a><span id="3-callbackflow-的-close">3. callbackFlow 的 close()</span></h3>
<p>下面介绍下 <code>callbackFlow</code> 的一些使用细节：<code>close()</code> 与 <code>close(throwable)</code>。</p>
<p><code>close()</code> 这个方法，既可以传入异常，也可以不传入。不过，这两者在 <code>callbackFlow</code> 当中是有差异的。如果将<em>代码段 6</em> 当中所有的 <code>close(throwable)</code> 都改为不传异常的话，程序代码也会出现问题。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"><span class="comment">// 错误示范！错误示范！错误示范！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .asFlow()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    <span class="comment">// 变化在这里</span></span><br><span class="line">                    close()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 变化在这里</span></span><br><span class="line">            close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断网执行以上代码：</span></span><br><span class="line"><span class="comment">不会有任何结果，连异常信息都没有</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在以上代码中，断网执行了这段程序，但在控制台上看不到任何异常的输出信息。这就是因为，调用 <code>close()</code> 的时候没有传入异常信息。</p>
<p>所以，在 <code>callbackFlow</code> 当中的异常分支里，如果使用 <code>close()</code>，一定要带上对应的异常，就像<em>代码段 6</em> 的那样“<code>close(throwable)</code>”。或者，为了防止在开发的过程中忘记传入异常信息，可以使用 <code>cancel()</code> 方法。就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    <span class="comment">// 变化在这里</span></span><br><span class="line">                    cancel(CancellationException(<span class="string">&quot;Send channel fail!&quot;</span>, it))</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 变化在这里</span></span><br><span class="line">            cancel(CancellationException(<span class="string">&quot;Request fail!&quot;</span>, throwable))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断网执行</span></span><br><span class="line"><span class="comment">Catch: java.util.concurrent.CancellationException: Request fail!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据这里的运行结果，可以看到，把 <code>close()</code> 改成 <code>cancel()</code> 以后，程序运行结果也符合预期。而 <code>cancel</code> 其实还有一个优势：就算不小心忘记传 <code>throwable</code>，还是可以看到一个 <code>CancellationException</code>。<br>
不过总的来说，只要可以记住传入异常信息，<code>close()</code> 和 <code>cancel()</code> 两者的差别并不大。<br>
另外还有一点，如果在 <code>callbackFlow</code> 当中还启动了其他的协程任务，<code>close()</code> 和 <code>cancel()</code> 也同样可以取消对应的协程。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .asFlow() <span class="comment">// 注意这里</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">asFlow</span><span class="params">()</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine start&quot;</span>)</span><br><span class="line">        delay(<span class="number">3000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Coroutine end&quot;</span>) <span class="comment">// 没有机会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.invokeOnCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine completed <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            trySendBlocking(<span class="keyword">data</span>)</span><br><span class="line">                .onSuccess &#123; close() &#125;</span><br><span class="line">                .onFailure &#123;</span><br><span class="line">                    cancel(CancellationException(<span class="string">&quot;Send channel fail!&quot;</span>, it))</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            cancel(CancellationException(<span class="string">&quot;Request fail!&quot;</span>, throwable))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    awaitClose &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断网执行</span></span><br><span class="line"><span class="comment">Coroutine start</span></span><br><span class="line"><span class="comment">Coroutine completed java.util.concurrent.CancellationException: Request fail!</span></span><br><span class="line"><span class="comment">Catch: java.util.concurrent.CancellationException: Request fail!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，由于协程是结构化的，所以，当取消 <code>callbackFlow</code> 的时候，在它内部创建的协程 <code>job</code>，也会跟着被取消。而且，它的异常信息也是一样的。<br>
不过，如果把上面的 <code>launch&#123;&#125;</code> 改成了“<code>launch(Job())&#123;&#125;</code>”，那么，协程任务就不会跟随 <code>callbackFlow</code> 一起被取消了。这是因为，<strong>它们的协程的父子关系已经被破坏了！</strong><br>
最后，<code>awaitClose&#123;&#125;</code> 这个挂起函数，它的作用其实就是监听 <code>callbackFlow</code> 的生命周期，当它被关闭或者取消的时候，应该同时把 <code>OkHttp</code> 当中的网络请求也取消掉。它的作用，跟<em>代码段 1</em> 当中的 <em>continuation.invokeOnCancellation{}</em> 是类似的。</p>
<h2><a href="#60-版本直接支持-flow" class="header-anchor">#</a><span id="60-版本直接支持-flow">6.0 版本：直接支持 Flow</span></h2>
<p>实际上，对于 <code>KtHttp</code> 来说，<em>4.0</em> 版本、<em>5.0</em> 版本都只是外部扩展，对 <code>KtHttp</code> 的内部源代码并没有做改动。</p>
<p>而对于 <em>6.0</em> 版本的开发，其实是希望 <code>KtHttp</code> 可以直接支持返回 <code>Flow</code> 类型的数据，也就是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV5</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reposFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Flow&lt;RepoList&gt; <span class="comment">// 注意这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>留意上面的代码注释，在 <code>ApiServiceV5</code> 当中，定义了一个接口方法 <code>reposFlow()</code>，它的返回值类型是 <code>Flow</code>，而不是之前的 <code>KtCall</code>。这样一来，在 <code>main()</code> 函数当中使用它的时候，就不需要使用 <code>asFlow()</code> 这个扩展函数了。就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        <span class="comment">// 注意这里不需要asFlow，因为reposFlow()返回值类型就是Flow</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当把 <code>reposFlow()</code> 的返回值类型定义成 <code>Flow</code> 以后，就需要改动 <code>KtHttp</code> 的源代码了。因为，它的内部需要根据这种情况做一些特殊的判断。</p>
<p>其实，在前面 <em>3.0</em> 版本的开发中，就已经做过一次判断了。当时，特地判断了一下，返回值类型是 <code>KtCall</code> 还是<code>T</code>。重新回顾一下当时的代码细节：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (isKtCallReturn(method)) &#123;</span><br><span class="line">        <span class="comment">// 返回值类型是KtCall&lt;RepoList&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">        KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值类型是 RepoList</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">        <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">        <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">        gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到上面的代码，可以反应过来，如果要支持 <code>Flow</code>，只需要在这里判断一下，返回值类型是不是 <code>Flow</code> 即可。比如说：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">            KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 直接返回Flow</span></span><br><span class="line">            flow&lt;T&gt; &#123;</span><br><span class="line">                <span class="comment">// 请求API</span></span><br><span class="line">                <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                <span class="keyword">val</span> result = gson.fromJson&lt;T&gt;(json, genericReturnType)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 传出结果</span></span><br><span class="line">                emit(result)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">            <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">            gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断返回值类型是不是 Flow&lt;T&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isFlowReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        getRawType(method.genericReturnType) == Flow::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure>
<p>由于<em>代码段 12</em> 当中已经有了 <code>if</code>、<code>else</code> 两个条件分支了，再增加一个分支的话，选择了 <code>when</code> 表达式。这里，增加了一个 <code>isFlowReturn(method)</code> 的分支，意思就是判断返回值类型是不是 <code>Flow</code>，如果是的话，就直接使用 <code>flow&#123;&#125;</code> 创建一个 <code>Flow</code> 返回了。</p>
<p>至此， <em>6.0</em> 版本的开发工作，其实就已经完成了。对比起 <code>Callback</code> 转 <code>Flow</code>，让 <code>KtHttp</code> 直接支持 <code>Flow</code> 确实要简单很多。从这一点上，也可以看到 <code>Flow</code> 的强大和易用性。</p>
<p>那么在这时候，就可以写一些简单的测试代码，来验证代码是否可靠了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">            KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 增加日志</span></span><br><span class="line">            logX(<span class="string">&quot;Start out&quot;</span>)</span><br><span class="line">            flow&lt;T&gt; &#123;</span><br><span class="line">                logX(<span class="string">&quot;Start in&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                <span class="keyword">val</span> result = gson.fromJson&lt;T&gt;(json, genericReturnType)</span><br><span class="line">                logX(<span class="string">&quot;Start emit&quot;</span>)</span><br><span class="line">                emit(result)</span><br><span class="line">                logX(<span class="string">&quot;End emit&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">            <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">            gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .flowOn(Dispatchers.IO) <span class="comment">//切换线程</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;<span class="subst">$&#123;it.count&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start out</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start in</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start emit</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">End emit</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，增加了一些日志，同时在调用处增加了“<code>flowOn(Dispatchers.IO)</code>”。可以看到，这样一来整个网络请求就执行在了 <code>DefaultDispatcher</code> 这个线程池当中，而其他部分的代码，仍然执行在 <code>main()</code> 线程。这也是符合预期的。</p>
<p>然后，可以通过断网来模拟出现异常的情况：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start out</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start in</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Catch: java.net.UnknownHostException:  nodename nor servname provided, or not known</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，程序的运行结果仍然是符合预期的。</p>
<p>下面，再来看看 <em>6.0</em> 完整的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV5</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注释1</span></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reposFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Flow&lt;RepoList&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV5 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> okHttpClient: OkHttpClient = OkHttpClient()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gson: Gson = Gson()</span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://baseUrl.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            service.classLoader,</span><br><span class="line">            arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line">            <span class="keyword">val</span> annotations = method.annotations</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> annotations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">annotation</span> <span class="keyword">is</span> GET) &#123;</span><br><span class="line">                    <span class="keyword">val</span> url = baseUrl + <span class="keyword">annotation</span>.value</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> invoke&lt;T&gt;(url, method, args!!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> url = path</span><br><span class="line">        <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                    <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                    <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                        url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> call = okHttpClient.newCall(request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">            &#125;</span><br><span class="line">            isFlowReturn(method) -&gt; &#123;</span><br><span class="line">                logX(<span class="string">&quot;Start out&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注释2</span></span><br><span class="line">                flow&lt;T&gt; &#123;</span><br><span class="line">                    logX(<span class="string">&quot;Start in&quot;</span>)</span><br><span class="line">                    <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">                    <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">                    <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                    <span class="keyword">val</span> result = gson.fromJson&lt;T&gt;(json, genericReturnType)</span><br><span class="line">                    logX(<span class="string">&quot;Start emit&quot;</span>)</span><br><span class="line">                    emit(result)</span><br><span class="line">                    logX(<span class="string">&quot;End emit&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">                <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">                gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTypeArgument</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        (method.genericReturnType <span class="keyword">as</span> ParameterizedType).actualTypeArguments[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isKtCallReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        getRawType(method.genericReturnType) == KtCall::<span class="keyword">class</span>.java</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isFlowReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">        getRawType(method.genericReturnType) == Flow::<span class="keyword">class</span>.java</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    testFlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow</span><span class="params">()</span></span> =</span><br><span class="line">    KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;<span class="subst">$&#123;it.count&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最后，再来分析一下，为什么 <em>6.0</em> 的代码可以这么简单。这里有两个关键的地方：</p>
<p><em>注释 1</em> 处的 <code>reposFlow()</code> 方法的定义，它其实是一个普通的函数，并不是挂起函数。换言之，虽然它的返回值类型是 <code>Flow</code>，但并不要求它在协程当中被调用。<br>
另外，在<em>注释 2</em> 处，<code>flow&#123;&#125;</code> 这个高阶函数，它也只是一个普通函数，同样也不是挂起函数，这就意味着，它可以在普通函数里面直接调用。可以看看 <code>flow&#123;&#125;</code> 的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是挂起函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; = SafeFlow(block)</span><br></pre></td></tr></table></figure>
<p>所以，正因为以上这两点，就使得 <code>Flow</code> 的易用性非常高。<br>
在 <a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一文章的Flow章节里</a>，<br>
有一张<code>Flow</code>“上游、下游”的示意图，现在可以进一步完善它，如下图：</p>
<p><img src="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/exception_6.jpeg" alt></p>
<p>也就是说，对于 <code>Flow</code> 的<strong>上游、中间操作符</strong> 而言，它们其实根本就不需要协程作用域，只有在下游调用 <code>collect&#123;&#125;</code> 的时候，才需要协程作用域。</p>
<p>因此，前面在写 <code>main()</code> 函数的时候，也可以换成这样的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 协程作用域外</span></span><br><span class="line">    <span class="keyword">val</span> flow = KtHttpV5.create(ApiServiceV5::<span class="keyword">class</span>.java)</span><br><span class="line">        .reposFlow(lang = <span class="string">&quot;Kotlin&quot;</span>, since = <span class="string">&quot;weekly&quot;</span>)</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;Catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// 协程作用域内</span></span><br><span class="line">        flow.collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;<span class="subst">$&#123;it.count&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，正因为 <code>Flow</code> 的上游不需要协程作用域，才可以轻松完成 <em>6.0</em> 版本的代码。</p>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/并发/" title="并发">并发 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/异常原因及处理/" title="异常原因及处理">异常原因及处理 </a><span class="leancloud_visitors"></span><span>大约13417个字, 44分钟43秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2023/05/25/kotlin学习系列十二/,Puppet,kotlin学习系列十二：协程四,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/" title="kotlin学习系列十三：协程源码篇一">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/05/16/Kotlin%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" title="Kotlin编程规范">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>