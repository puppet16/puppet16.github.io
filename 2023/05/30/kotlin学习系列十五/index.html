<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列十五：协程源码篇三 协程运行 · Puppet</title><meta name="description" content="一、前言
二、 Dispatchers是如何工作的

1. Dispatchers
2. CoroutineDispatcher 拦截器
3. Dispatchers 小结


三、CoroutineScope 是如何管理协程的

1.


源码



#一、前言

本文主要讲述Kotlin 协程中"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列十五：协程源码篇三 协程运行</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-dispatchers%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">二、 Dispatchers是如何工作的</a>
<ul>
<li><a href="#1-dispatchers">1. Dispatchers</a></li>
<li><a href="#2-coroutinedispatcher-%E6%8B%A6%E6%88%AA%E5%99%A8">2. CoroutineDispatcher 拦截器</a></li>
<li><a href="#3-dispatchers-%E5%B0%8F%E7%BB%93">3. Dispatchers 小结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-coroutinescope-%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%8D%8F%E7%A8%8B%E7%9A%84">三、CoroutineScope 是如何管理协程的</a>
<ul>
<li><a href="#1">1.</a></li>
</ul>
</li>
<li><a href="#%E6%BA%90%E7%A0%81">源码</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 协程中的Dispatchers</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">朱涛老师</a>讲解的<code>Kotlin</code>系列的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li><strong>Kotlin协程源码：<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines">https://github.com/Kotlin/kotlinx.coroutines</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a> 
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程一</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程二</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程三</a>
</li>
<li>
<a href="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/" title="kotlin学习系列十二：协程四">kotlin学习系列十二：协程四</a>
</li>
<li>
<a href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/" title="kotlin学习系列十三：协程源码篇一">kotlin学习系列十三：协程源码篇一</a>
</li>
<li>
<a href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/" title="kotlin学习系列十四：协程源码篇二 协程创建">kotlin学习系列十四：协程源码篇二 协程创建</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-dispatchers是如何工作的" class="header-anchor">#</a><span id="二-dispatchers是如何工作的">二、 Dispatchers是如何工作的</span></h1>
<p>上一章里提到，<code>Kotlin</code> 的 <code>launch</code> 会调用 <code>startCoroutineCancellable()</code>，接着又会调用 <code>createCoroutineUnintercepted()</code>，最终会调用编译器生成 <code>SuspendLambda</code> 实现类当中的 <code>create()</code> 方法。这样，协程就创建出来了。<br>
接着，来探究一下协程是如何运行的。协程无法脱离线程运行，<code>Kotlin</code> 当中所有的协程，最终都是运行在线程之上的。那么，协程创建出来以后，它又是如何跟线程产生关联的？</p>
<h2><a href="#1-dispatchers" class="header-anchor">#</a><span id="1-dispatchers">1. Dispatchers</span></h2>
<p><code>launch&#123;&#125;</code>本质上是调用了<span id="jumpStartCoroutineCode"> <code>startCoroutineCancellable()</code> </span>当中的 <code>createCoroutineUnintercepted()</code> 方法创建了协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">//                                        注意这里</span></span><br><span class="line">    <span class="comment">//                                           ↓</span></span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么下面，继续分析 <code>createCoroutineUnintercepted(completion)</code> 之后的 <code>intercepted()</code> 方法。</p>
<p>首先弄清楚 <code>Dispatchers</code>、<code>CoroutineDispatcher</code>、<code>ContinuationInterceptor</code>、<code>CoroutineContext</code> 之间的关系。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dispatchers</code> 是一个单例对象，它当中的 <code>Default</code>、<code>Main</code>、<code>Unconfined</code>、<code>IO</code>，类型都是 <code>CoroutineDispatcher</code>，而它本身就是 <code>CoroutineContext</code>。所以，它们之间的关系就可以用下面这个图来描述。</p>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%94/kotlin15_dispatchers.jpeg" alt></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testLaunch()</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch&#123;</span><br><span class="line">        logX(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台输出带协程信息的log</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">logX</span><span class="params">(any: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    println(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">================================</span></span><br><span class="line"><span class="string"><span class="variable">$any</span></span></span><br><span class="line"><span class="string">Thread:<span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">================================&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，没有为 <code>launch()</code> 传入任何 <code>CoroutineContext</code> 参数，但通过执行结果，发现协程代码居然执行在 <code>DefaultDispatcher</code>，并没有运行在 <code>main</code> 线程之上。这是为什么呢？</p>
<p>回过头来分析下 <a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Builders.common.kt"><code>launch</code> 的源代码</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>launch</code> 的第一个参数，<code>context</code>，它的默认值是 <code>EmptyCoroutineContext</code>。<code>CoroutineContext</code> 就相当于 <code>Map</code>，而 <code>EmptyCoroutineContext</code> 则相当于一个空的 <code>Map</code>。所以，可以认为，这里的 <code>EmptyCoroutineContext</code> 传了也相当于没有传，它的目的只是为了让 <code>context</code> 参数不为空而已。这其实也体现出了 <code>Kotlin</code> 的空安全思维，<code>Kotlin</code> 官方用 <code>EmptyCoroutineContext</code> 替代了 <code>null</code>。</p>
<p><em>注释 1</em> 处这行代码会调用 <code>newCoroutineContext(context)</code>，将传入的 <code>context</code> 参数重新包装一下，然后返回。它具体的逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> combined = coroutineContext.foldCopiesForChildCoroutine() + context</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>注释 1</em>，由于 <code>newCoroutineContext()</code> 是 <code>CoroutineScope</code> 的扩展函数，因此，可以直接访问 <code>CoroutineScope</code> 的 <code>coroutineContext</code> 对象，它其实就是 <code>CoroutineScope</code> 对应的上下文。<code>foldCopiesForChildCoroutine()</code> 的作用，其实就是将 <code>CoroutineScope</code> 当中的所有上下文元素都拷贝出来，然后跟传入的 <code>context</code> 参数进行合并。 <strong>这行代码，可以让子协程继承父协程的上下文元素。</strong></li>
<li><em>注释 2</em>，它的作用是在调试模式下，为协程对象增加唯一的 <code>ID</code>。在 <em>代码段 3</em> 的输出结果中看到的 <em>“@coroutine#1”</em>，其中的 <em>数字“1”</em> 就是在这个阶段生成的。</li>
<li><em>注释 3</em>，如果合并过后的 <code>combined</code> 当中没有 <code>CoroutineDispatcher</code>，那么，就会默认使用 <code>Dispatchers.Default</code>。</li>
</ul>
<blockquote>
<p>Tips: 上面的代码可以延伸出一个问题，为什么协程默认的线程池是 <code>Dispatchers.Default</code>，而不是 <code>Main</code> 呢？<br>
答案其实也很简单，因为 <code>Kotlin</code> 协程是支持多平台的，<code>Main</code> 线程只在 <code>UI</code> 编程平台才有可用。因此，当协程没有指定 <code>Dispatcher</code> 的时候，就只能使用 <code>Dispatchers.Default</code> 了。毕竟，协程是无法脱离线程执行的。</p>
</blockquote>
<p>所以 <em>代码段 3</em> 当中的协程执行在 <code>Dispatchers.Default</code> 的原因也就找到了：由于定义的 <code>scope</code> 没有指定 <code>Dispatcher</code>，同时 <code>launch</code> 的参数也没有传入 <code>Dispatcher</code>，最终在 <code>newCoroutineContext()</code> 的时候，会被默认指定为 <code>Default</code> 线程池。</p>
<h2><a href="#2-coroutinedispatcher-拦截器" class="header-anchor">#</a><span id="2-coroutinedispatcher-拦截器">2. CoroutineDispatcher 拦截器</span></h2>
<p>上一节开始提到的 <a href="#jumpStartCoroutineCode"><code>startCoroutineCancellable()</code>源码</a>，其中的 <code>createCoroutineUnintercepted()</code> 方法，它的返回值类型就是 <code>Continuation</code>。<strong>而 <code>intercepted()</code> 方法，其实就是 <code>Continuation</code> 的扩展函数。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="comment">// Cancellable.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">//                                        注意这里</span></span><br><span class="line">    <span class="comment">//                                           ↓</span></span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntrinsicsJvm.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContinuationImpl.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span>(</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _context: CoroutineContext?</span><br><span class="line">) : BaseContinuationImpl(completion) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(completion: Continuation&lt;Any?&gt;?) : <span class="keyword">this</span>(completion, completion?.context)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，可以看到，<code>startCoroutineCancellable()</code> 当中的 <code>intercepted()</code> 最终会调用 <code>BaseContinuationImpl</code> 的 <code>intercepted()</code> 方法。<br>
注意 <em>注释 1</em> 处，<code>intercepted()</code> 方法首先会判断它的成员变量 <code>intercepted</code> 是否为空，如果为空，就会调用 c<code>ontext[ContinuationInterceptor]</code>，获取上下文当中的 <code>Dispatcher</code> 对象。以 <em>代码段 3</em> 当中的逻辑为例，这时候的 <code>Dispatcher</code> 肯定是 <code>Default</code> 线程池。<br>
然后，如果继续跟进 <code>interceptContinuation(this)</code> 方法的话，会发现程序最终会调用 <code>CoroutineDispatcher</code> 的 <code>interceptContinuation()</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <em>注释 1</em>，<code>interceptContinuation()</code> 直接返回了一个 <code>DispatchedContinuation</code> 对象，并且将 <code>this、continuation</code> 作为参数传了进去。这里的 <code>this</code>，其实就是这个抽象类<code>CoroutineDispatcher</code>, 以 <em>代码段 3</em> 当中的逻辑为例，其实就是 <code>Dispatchers.Default</code>。</p>
<p>所以，如果把 <code>startCoroutineCancellable()</code> 改写一下，它实际上会变成下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="comment">//  ↓</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> continuation = createCoroutineUnintercepted(completion)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> dispatchedContinuation = continuation.intercepted()</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    dispatchedContinuation.resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， <em>注释 1，2</em> 都已经分析完了，现在只剩下 <em>注释 3</em> 了。这里的 <code>resumeCancellableWith()</code>，其实就是真正将协程任务分发到线程上的逻辑。继续跟进分析源代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 省略，留到后面分析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是，<code>DispatchedContinuation</code> 是实现了 <code>Continuation</code> 接口，同时，它使用了“类委托”的语法，将接口的具体实现委托给了它的成员属性 continuation。通过之前 <em>代码段 7</em> 的分析，可知它的成员属性 <strong><code>dispatcher</code> 对应的就是 <code>Dispatcher.Default</code></strong>，而成员属性 <strong><code>continuation</code> 对应的则是 <code>launch</code> 当中传入的 <code>SuspendLambda</code> 实现类</strong>。</p>
<p>另外，<code>DispatchedContinuation</code> 还继承自 <code>DispatchedTask</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DispatchedTask</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">public</span> <span class="keyword">var</span> resumeMode: <span class="built_in">Int</span></span><br><span class="line">) : SchedulerTask() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">typealias</span> SchedulerTask = Task</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Task</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> submissionTime: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> taskContext: TaskContext</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>, NonBlockingContext)</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">val</span> mode: <span class="built_in">Int</span> <span class="keyword">get</span>() = taskContext.taskMode <span class="comment">// TASK_XXX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>DispatchedContinuation</code> 继承自 <code>DispatchedTask</code>，而 <code>DispatchedTask</code> 则是 <code>SchedulerTask</code> 的子类，<code>SchedulerTask</code> 是 <code>Task</code> 的类型别名，而 <code>Task</code> 实现了 <code>Runnable</code> 接口。因此，<strong><code>DispatchedContinuation</code> 不仅是一个 <code>Continuation</code>，同时还是一个 <code>Runnable</code></strong>, 也就意味着它可以被分发到 <code>Java</code> 的线程当中去执行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="comment">// 默认是true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">isDispatchNeeded</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> Unconfined : CoroutineDispatcher() &#123;</span><br><span class="line">    <span class="comment">// 只有Unconfined会重写成false</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isDispatchNeeded</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>注释 1</em>，<code>dispatcher.isDispatchNeeded()</code>，通过查看 <code>CoroutineDispatcher</code> 的源代码，发现它的返回值始终都是 <code>true</code>。在它的子类当中，只有 <code>Dispatchers.Unconfined</code> 会将其重写成 <code>false</code>。这也就意味着，除了 <code>Unconfined</code> 以外，其他的 <code>Dispatcher</code> 都会返回 <code>true</code>。对于 <em>代码段 3</em> 当中的代码而言， <code>Dispatcher</code> 是默认的 <code>Default</code>，所以，代码将会进入<code>注释 2</code> 对应的分支。</li>
<li><em>注释 2</em>，<code>dispatcher.dispatch(context, this)</code>，这里其实就相当于将代码的执行流程分发到 <code>Default</code> 线程池。<code>dispatch()</code> 的第二个参数要求是 <code>Runnable</code>，这里传入的是 <code>this</code>，这是因为 <code>DispatchedContinuation</code> 本身就间接实现了 <code>Runnable</code> 接口。</li>
<li><em>注释 3</em>，<code>executeUnconfined&#123;&#125;</code>，它其实就对应着 <code>Dispather</code> 是 <code>Unconfined</code> 的情况，这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。</li>
</ul>
<p>继续沿着 <em>注释 2</em> 进行分析，这里的 <code>dispatcher.dispatch()</code> 其实就相当于调用了 <code>Dispatchers.Default.dispatch()</code>。看看它的逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> DefaultScheduler : SchedulerCoroutineDispatcher(</span><br><span class="line">    CORE_POOL_SIZE, MAX_POOL_SIZE,</span><br><span class="line">    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，可以看到，<code>Dispatchers.Default</code> 本质上是一个单例对象 <code>DefaultScheduler</code>，它是 <code>SchedulerCoroutineDispatcher</code> 的子类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SchedulerCoroutineDispatcher</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> corePoolSize: <span class="built_in">Int</span> = CORE_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxPoolSize: <span class="built_in">Int</span> = MAX_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> idleWorkerKeepAliveNs: <span class="built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> schedulerName: String = <span class="string">&quot;CoroutineScheduler&quot;</span>,</span><br><span class="line">) : ExecutorCoroutineDispatcher() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> coroutineScheduler = createScheduler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Unit</span> = coroutineScheduler.dispatch(block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上代码，可以看到 <code>Dispatchers.Default.dispatch()</code> 最终会调用 <code>SchedulerCoroutineDispatcher</code> 的 <code>dispatch()</code> 方法，而它实际上调用的是 <code>coroutineScheduler.dispatch()</code>。</p>
<p><code>CoroutineScheduler</code> 的源代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CoroutineScheduler</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> corePoolSize: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> maxPoolSize: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> idleWorkerKeepAliveNs: <span class="built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME</span><br><span class="line">) : Executor, Closeable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(command: <span class="type">Runnable</span>)</span></span> = dispatch(command)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">        trackTask() </span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">val</span> task = createTask(block, taskContext)</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">val</span> currentWorker = currentWorker()</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)</span><br><span class="line">        <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;<span class="variable">$schedulerName</span> was terminated&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> skipUnpark = tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">            signalCpuWork()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            signalBlockingWork(skipUnpark = skipUnpark)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">currentWorker</span><span class="params">()</span></span>: Worker? = (Thread.currentThread() <span class="keyword">as</span>? Worker)?.takeIf &#123; it.scheduler == <span class="keyword">this</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 Worker</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() : Thread() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CoroutineScheduler</code> 其实是 <code>Java</code> 并发包下的 <code>Executor</code> 的子类，它的 <code>execute()</code> 方法也被转发到了 <code>dispatch()</code>。</p>
<ul>
<li><em>注释 1</em>，将传入的 <code>Runnable</code> 类型的 <code>block</code><em>（也就是 <code>DispatchedContinuation</code>）</em>，包装成 <code>Task</code>。</li>
<li><em>注释 2</em>，<code>currentWorker()</code>，拿到当前执行的线程。这里的 <code>Worker</code> 其实是一个内部类，它本质上仍然是 <code>Java</code> 的 <code>Thread</code>。</li>
<li><em>注释 3</em>，<code>currentWorker.submitToLocalQueue()</code>，将当前的 <code>Task</code> 添加到 <code>Worker</code> 线程的本地队列，等待执行。</li>
</ul>
<p>接下来分析 <code>Work</code> 是如何执行 <code>Task</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() : Thread() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = runWorker()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">var</span> mayHaveLocalTasks = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rescanned = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">val</span> task = findTask(mayHaveLocalTasks)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                rescanned = <span class="literal">false</span></span><br><span class="line">                minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">                <span class="comment">// 2</span></span><br><span class="line">                executeTask(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mayHaveLocalTasks = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minDelayUntilStealableTaskNs != <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rescanned) &#123;</span><br><span class="line">                    rescanned = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rescanned = <span class="literal">false</span></span><br><span class="line">                    tryReleaseCpu(WorkerState.PARKING)</span><br><span class="line">                    interrupted()</span><br><span class="line">                    LockSupport.parkNanos(minDelayUntilStealableTaskNs)</span><br><span class="line">                    minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tryPark()</span><br><span class="line">        &#125;</span><br><span class="line">        tryReleaseCpu(WorkerState.TERMINATED)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Worker</code> 重写 <code>Thread</code> 的 <code>run()</code> 方法，然后把执行流程交给 <code>runWorker()</code></p>
<ul>
<li><em>注释 1</em>，在 <code>while</code> 循环当中，会一直尝试从 <code>Worker</code> 的本地队列取 <code>Task</code> 出来，如果存在需要执行的 <code>Task</code>，就会进入下一步。</li>
<li><em>注释 2</em>，<code>executeTask(task)</code>，其实就是执行对应的 <code>Task</code>。</li>
</ul>
<p>接下来的逻辑，就是 <strong>最关键的部分</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() : Thread() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> taskMode = task.mode</span><br><span class="line">        idleReset(taskMode)</span><br><span class="line">        beforeTask(taskMode)</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        runSafely(task)</span><br><span class="line">        afterTask(taskMode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runSafely</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        task.run()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="keyword">val</span> thread = Thread.currentThread()</span><br><span class="line">        thread.uncaughtExceptionHandler.uncaughtException(thread, e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unTrackTask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Task</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> submissionTime: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> taskContext: TaskContext</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>, NonBlockingContext)</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">val</span> mode: <span class="built_in">Int</span> <span class="keyword">get</span>() = taskContext.taskMode <span class="comment">// TASK_XXX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Worker</code> 的 <code>executeTask()</code> 方法当中，会调用 <code>runSafely()</code> 方法，而在这个方法当中，最终会调用 <code>task.run()</code>。前面提到过 <code>Task</code> 本质上就是 <code>Runnable</code>，而 <code>Runnable.run()</code> 其实就代表了协程任务真正执行了！</p>
<p><code>task.run()</code> 是执行的 <code>DispatchedTask.run()</code>。这里的 <code>DispatchedTask</code> 实际上是 <code>DispatchedContinuation</code> 的父类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">        <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line">            <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line">            withContinuationContext(continuation, delegate.countOrElement) &#123;</span><br><span class="line">                <span class="keyword">val</span> context = continuation.context</span><br><span class="line">                <span class="keyword">val</span> state = takeState() </span><br><span class="line">                <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">                <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">                    <span class="comment">// 1</span></span><br><span class="line">                    <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">                    cancelCompletedResult(state, cause)</span><br><span class="line">                    continuation.resumeWithStackTrace(cause)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2</span></span><br><span class="line">                        continuation.resumeWithException(exception)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 3</span></span><br><span class="line">                        continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line"></span><br><span class="line">            fatalException = e</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">            handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>注释 1</em>，在协程代码执行之前，它首先会判断当前协程是否已经取消。如果已经取消的话，就会调用 <code>continuation.resumeWithStackTrace(cause)</code> 将具体的原因传出去。</li>
<li><em>注释 2</em>，判断协程是否发生了异常，如果已经发生了异常，则需要调用 <code>continuation.resumeWithException(exception)</code> 将异常传递出去。</li>
<li><em>注释 3</em>，如果一切正常，则会调用 <code>continuation.resume(getSuccessfulResult(state))</code>，这时候，协程才会正式启动，并且执行 <code>launch</code> 当中传入的 <code>Lambda</code> 表达式。</li>
</ul>
<h2><a href="#3-dispatchers-小结" class="header-anchor">#</a><span id="3-dispatchers-小结">3. Dispatchers 小结</span></h2>
<p><code>Dispatchers</code> 是协程框架中与线程交互的关键，这里面主要涉及以下几个步骤：</p>
<ul>
<li>
<p>第一步，<code>createCoroutineUnintercepted(completion)</code> 创建了协程的 <code>Continuation</code> 实例，紧接着就会调用它的 <code>intercepted()</code> 方法，将其封装成 <code>DispatchedContinuation</code> 对象。</p>
</li>
<li>
<p>第二步，<code>DispatchedContinuation</code> 会持有 <code>CoroutineDispatcher</code>、以及前面创建的 <code>Continuation</code> 对象。例子中的 <code>CoroutineDispatcher</code> 实际上就是 <code>Default</code> 线程池。</p>
</li>
<li>
<p>第三步，执行 <code>DispatchedContinuation</code> 的 <code>resumeCancellableWith()</code> 方法，这时候，就会执行 <code>dispatcher.dispatch()</code>，这就会将协程的 <code>Continuation</code> 封装成 <code>Task</code> 添加到 <code>Worker</code> 的本地任务队列，等待执行。这里的 <code>Worker</code> 本质上就是 <code>Java</code> 的 <code>Thread</code>。在这一步，协程就已经完成了线程的切换。</p>
</li>
<li>
<p>第四步，<code>Worker</code> 的 <code>run()</code> 方法会调用 <code>runWork()</code>，它会从本地的任务队列当中取出 <code>Task</code>，并且调用 <code>task.run()</code>。而它实际上调用的是 <code>DispatchedContinuation</code> 的 <code>run()</code> 方法，在这里，会调用 <code>continuation.resume()</code>，它将执行原本 <code>launch</code> 当中生成的 <code>SuspendLambda</code> 子类。这时候，<code>launch</code> 协程体当中的代码，就在线程上执行了。</p>
</li>
</ul>
<h1><a href="#三-coroutinescope-是如何管理协程的" class="header-anchor">#</a><span id="三-coroutinescope-是如何管理协程的">三、CoroutineScope 是如何管理协程的</span></h1>
<h2><a href="#1" class="header-anchor">#</a><span id="1">1.</span></h2>
<h1><a href="#源码" class="header-anchor">#</a><span id="源码">源码</span></h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Builders.common.kt">CoroutineScope.launch</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/CoroutineContext.kt">CoroutineScope.newCoroutineContext</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt">Dispatchers.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/intrinsics/Cancellable.kt">Cancellable.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/src/kotlin/coroutines/intrinsics/IntrinsicsJvm.kt">IntrinsicsJvm.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/src/kotlin/coroutines/jvm/internal/ContinuationImpl.kt">ContinuationImpl.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt">CoroutineDispatcher.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt">DispatchedContinuation.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedTask.kt">DispatchedTask.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/CoroutineScheduler.kt">CoroutineScheduler.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/Tasks.kt">Tasks.kt</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Runnable.kt">Runnable.kt</a></li>
</ul>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-05-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码/" title="源码">源码 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Dispatchers/" title="Dispatchers">Dispatchers </a><i class="fa fa-tag"></i><a class="tag" href="/tags/CoroutineScope/" title="CoroutineScope">CoroutineScope </a><span class="leancloud_visitors"></span><span>大约3907个字, 13分钟1秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2023/05/30/kotlin学习系列十五/,Puppet,kotlin学习系列十五：协程源码篇三 协程运行,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2025/01/04/Jetpack%20Compose%20%E6%8E%A5%E5%85%A5%E6%97%A7%E5%BA%93%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="Jetpack Compose 接入旧库时遇到的问题">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/" title="kotlin学习系列十四：协程源码篇二 协程创建">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>