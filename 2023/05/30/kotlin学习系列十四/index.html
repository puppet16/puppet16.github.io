<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列十四：协程源码篇二 协程创建 · Puppet</title><meta name="description" content="一、前言
二、 图解挂起函数

1. CPS 转换背后的细节

1. CPS 参数变化
2. CPS 返回值变化


2. 挂起函数的反编译

1. 函数能够挂起的情况
2. 协程未挂起的情况


3. 思考与实战

1. “挂起函数”与 CoroutineContext 的紧密联系
2. KtHt"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列十四：协程源码篇二 协程创建</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E5%9B%BE%E8%A7%A3%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">二、 图解挂起函数</a>
<ul>
<li><a href="#1-cps-%E8%BD%AC%E6%8D%A2%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%86%E8%8A%82">1. CPS 转换背后的细节</a>
<ul>
<li><a href="#1-cps-%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96">1. CPS 参数变化</a></li>
<li><a href="#2-cps-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8F%98%E5%8C%96">2. CPS 返回值变化</a></li>
</ul>
</li>
<li><a href="#2-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91">2. 挂起函数的反编译</a>
<ul>
<li><a href="#1-%E5%87%BD%E6%95%B0%E8%83%BD%E5%A4%9F%E6%8C%82%E8%B5%B7%E7%9A%84%E6%83%85%E5%86%B5">1. 函数能够挂起的情况</a></li>
<li><a href="#2-%E5%8D%8F%E7%A8%8B%E6%9C%AA%E6%8C%82%E8%B5%B7%E7%9A%84%E6%83%85%E5%86%B5">2. 协程未挂起的情况</a></li>
</ul>
</li>
<li><a href="#3-%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E6%88%98">3. 思考与实战</a>
<ul>
<li><a href="#1-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E4%B8%8E-coroutinecontext-%E7%9A%84%E7%B4%A7%E5%AF%86%E8%81%94%E7%B3%BB">1. “挂起函数”与 CoroutineContext 的紧密联系</a></li>
<li><a href="#2-kthttp-%E6%94%AF%E6%8C%81%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">2. KtHttp 支持挂起函数</a></li>
</ul>
</li>
<li><a href="#4-%E6%80%BB%E7%BB%93">4. 总结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%85%83%E7%B4%A0">三、深入理解协程基础元素</a>
<ul>
<li><a href="#1-continuation-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95">1. Continuation 的两种用法</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">1. 实现挂起函数</a></li>
<li><a href="#2-%E8%B0%83%E7%94%A8%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">2. 调用挂起函数</a></li>
<li><a href="#3-%E5%9C%A8-java-%E5%BD%93%E4%B8%AD%E8%B0%83%E7%94%A8-kotlin-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">3. 在 Java 当中调用 Kotlin 挂起函数</a></li>
</ul>
</li>
<li><a href="#2-suspendcoroutine">2. suspendCoroutine{}</a>
<ul>
<li><a href="#1-suspendcoroutineuninterceptedorreturn">1. suspendCoroutineUninterceptedOrReturn</a></li>
<li><a href="#2-suspendcoroutineuninterceptedorreturn-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8">2. suspendCoroutineUninterceptedOrReturn 的功能和作用</a></li>
</ul>
</li>
<li><a href="#3-%E5%B0%8F%E7%BB%93">3. 小结</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8-launch-sync">四、深入理解协程的创建与启动–launch、sync</a>
<ul>
<li><a href="#1-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E5%9F%BA%E7%A1%80-api">1. 协程启动的基础 API</a></li>
<li><a href="#2-startcoroutine-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">2. startCoroutine() 实现原理</a></li>
<li><a href="#3-launch-%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E5%8D%8F%E7%A8%8B%E7%9A%84">3. <code>launch</code> 是如何启动协程的</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%8F%82%E8%80%83">五、参考</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 协程中的集合操作符及协程源码结构</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">朱涛老师</a>讲解的<code>Kotlin</code>系列的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程一</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程二</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程三</a>
</li>
<li>
<a href="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/" title="kotlin学习系列十二：协程四">kotlin学习系列十二：协程四</a>
</li>
<li>
<a href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/" title="kotlin学习系列十三：协程源码篇一">kotlin学习系列十三：协程源码篇一</a>
</li>
<li>
<a href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%94/" title="kotlin学习系列十五：协程源码篇三 协程运行">kotlin学习系列十五：协程源码篇三 协程运行</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-图解挂起函数" class="header-anchor">#</a><span id="二-图解挂起函数">二、 图解挂起函数</span></h1>
<p>挂起函数，是整个 <code>Kotlin</code> 协程的核心。也正是因为挂起函数的原因，才可以使用协程简化异步任务。</p>
<h2><a href="#1-cps-转换背后的细节" class="header-anchor">#</a><span id="1-cps-转换背后的细节">1. CPS 转换背后的细节</span></h2>
<p>在前面的章节里初步介绍过挂起函数的用法：挂起函数，只是比普通的函数多了 <code>suspend</code> 关键字。有了这个 <code>suspend</code> 关键字以后，<code>Kotlin</code> 编译器就会特殊对待这个函数，将其转换成一个带有 <code>Callback</code> 的函数，这里的 <code>Callback</code> 就是 <code>Continuation</code> 接口。</p>
<p>而这个过程，称之为 <code>CPS</code> 转换：</p>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/suspend_1.gif" alt></p>
<p>以上的 <code>CPS</code> 转换过程中，函数的类型发生了变化：<code>suspend ()-&gt;String</code> 变成了 <code>(Continuation)-&gt; Any?</code>。这意味着，如果在 <code>Java</code> 里访问一个 <code>Kotlin</code> 挂起函数 <code>getUserInfo()</code>，会看到 <code>getUserInfo()</code> 的类型是 <code>(Continuation)-&gt; Object</code>，也就是：接收 <code>Continuation</code> 为参数，返回值是 <code>Object</code>。</p>
<p>而在这里，函数签名的变化可以分为两个部分：<strong>函数参数</strong> 的变化和<strong>函数返回值</strong> 的变化。</p>
<h3><a href="#1-cps-参数变化" class="header-anchor">#</a><span id="1-cps-参数变化">1. CPS 参数变化</span></h3>
<p><code>CPS</code> 参数变化即 <code>suspend()</code> 变成 <code>(Continuation)</code> 的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    <span class="keyword">val</span> friendList = getFriendList(user)</span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(user, friendList)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFeedList</span><span class="params">(user: <span class="type">String</span>, list: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;FeedList..&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，<code>testCoroutine()</code> 是一个挂起函数，它的内部依次调用了三个挂起函数。而如果从 <code>Java</code> 的角度来看待 <code>testCoroutine()</code> 的话，代码中所有的参数都会发生变化。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                 变化在这里</span></span><br><span class="line"><span class="comment">//                     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">(continuation: <span class="type">Continuation</span>)</span></span>: Any? &#123;</span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                              ↓</span></span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo(continuation)</span><br><span class="line"><span class="comment">//                                        变化在这里</span></span><br><span class="line"><span class="comment">//                                            ↓</span></span><br><span class="line">    <span class="keyword">val</span> friendList = getFriendList(user, continuation)</span><br><span class="line"><span class="comment">//                                          变化在这里</span></span><br><span class="line"><span class="comment">//                                              ↓</span></span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(friendList, continuation)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在这里的 <code>testCoroutine()</code> 当中，每一次函数调用的时候，<code>continuation</code> 都会作为最后一个参数传到挂起函数里。不过这一步是 <code>Kotlin</code> 编译器做的，开发者是无感知的。<br>
为什么挂起函数可以调用挂起函数，普通函数则不能？<br>
其实，这个问题的答案，从 <em>代码段 2</em> 就可以看出来。如果 <code>testCoroutine()</code> 只是一个普通函数，那它就不会有 <code>continuation</code> 这个参数了，这样 <code>getUserInfo()</code>、<code>getFriendList()</code>、<code>getFeedList()</code> 这几个挂起函数自然也就无法被调用了。</p>
<h3><a href="#2-cps-返回值变化" class="header-anchor">#</a><span id="2-cps-返回值变化">2. CPS 返回值变化</span></h3>
<p>接下来看看 <code>getUserInfo()</code> 的返回值类型的变化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                                  变化在这里</span></span><br><span class="line"><span class="comment">//                                     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(cont: <span class="type">Continuation</span>)</span></span>: Any? &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码里，可以看到 <code>getUserInfo()</code> 的返回值类型从 <code>String</code> 变成“<code>Any?</code>”。<code>Kotlin</code> 官方之所以要弄这一套 <code>CPS</code> 转换规则，它必然是“<strong>等价转换</strong>”。也就是说，<code>String</code> 这个原本的返回值类型肯定不会消失，而是会换一种形式存在。</p>
<p>只是 <code>String</code> 存在的形式，经过 <code>Kotlin</code> <strong>反编译成 <code>Java</code> 之后会丢失</strong>。如果直接在 <code>Java</code> 当中调用 <code>getUserInfo()</code> 的话，就会发现 <code>String</code> 这个返回值类型成为了 <code>Continuation</code> 的泛型类型。</p>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/suspend_2.jpeg" alt></p>
<p>所以，对于 <code>getUserInfo()</code> 这个方法，经过 <code>CPS</code> 转换后，它完整的函数签名应该是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                                变化在这里</span></span><br><span class="line"><span class="comment">//                                    ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(cont: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any? &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/suspend_3.gif" alt></p>
<p>挂起函数原本的返回值类型 <code>String</code> 只是挪了个地方，所以，<code>Kotlin</code> 编译器的 <code>CPS</code> 转换仍然是等价的转换。也就是：<code>suspend () -&gt; String</code> 转换成 <code>(Continuation) -&gt; Any?</code>。不过，<strong>这里的“<code>Any?</code>”又是干什么的呢？</strong></p>
<p>其实，挂起函数经过 <code>CPS</code> 转换后，它的返回值有一个重要作用：<strong>标志该挂起函数有没有被挂起</strong>。这听起来有点绕：挂起函数，就是可以被挂起的函数，它还能不被挂起吗？<br>
是的，挂起函数也能不被挂起。</p>
<p>首先理清几个概念。只要有 <code>suspend</code> 修饰的函数，它就是挂起函数，比如前面的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>getUserInfo()</code> 执行到 <code>withContext&#123;&#125;</code> 的时候，就会返回 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code> 表示函数被挂起了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// suspend 修饰</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">noSuspendFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="comment">// 函数体跟普通函数一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法，它的方法体跟普通函数一样。它跟一般的挂起函数有个区别：在执行的时候，它并不会被挂起，因为它就是个普通函数。当写出以下这样的代码后，<code>IDE</code> 也会提示，<code>suspend</code> 是多余的：</p>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/suspend_4.jpeg" alt></p>
<p>也就是，当调用 <code>noSuspendFriendList()</code> 这个挂起函数的时候，它不会真正挂起，而是会直接返回 <code>String</code> 类型：“<code>no suspend</code>”。针对这样的挂起函数，你可以把它看作是<strong>伪挂起函数</strong> 。</p>
<p>所以到这里，挂起函数经过 <code>CPS</code> 转换后，返回值变成“<code>Any?</code>”的原因也就清晰了：由于 <code>suspend</code> 修饰的函数，既可能返回 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>，也可能返回实际结果 “<code>no suspend</code>”，甚至可能返回 <code>null</code>，为了适配所有的可能性，<code>CPS</code> 转换后的函数返回值类型就只能是 <code>Any?</code> 了。</p>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/suspend_5.gif" alt></p>
<h2><a href="#2-挂起函数的反编译" class="header-anchor">#</a><span id="2-挂起函数的反编译">2. 挂起函数的反编译</span></h2>
<p>通过查看 <code>Kotlin</code> 反编译后的字节码，可以帮助理解 <code>Kotlin</code> 的底层原理。</p>
<p>不过，下面不会直接贴反编译后的代码，因为它的逻辑比较复杂。为了方便理解，接下来贴出的代码是用 <code>Kotlin</code> 翻译后大致等价的代码，改善了可读性，抹掉了不必要的细节。</p>
<h3><a href="#1-函数能够挂起的情况" class="header-anchor">#</a><span id="1-函数能够挂起的情况">1. 函数能够挂起的情况</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    log(user)</span><br><span class="line">    <span class="keyword">val</span> friendList = getFriendList(user)</span><br><span class="line">    log(friendList)</span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(friendList)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析 <code>testCoroutine()</code> 的函数体，它相当复杂，涉及到三个挂起函数的调用。</p>
<p>首先，在 <code>testCoroutine()</code> 函数里，会多出一个 <code>ContinuationImpl</code> 的子类，它是整个协程挂起函数的核心。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// TestContinuation本质上是匿名内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TestContinuation</span>(completion: Continuation&lt;Any?&gt;?) : ContinuationImpl(completion) &#123;</span><br><span class="line">        <span class="comment">// 表示协程状态机当前的状态</span></span><br><span class="line">        <span class="keyword">var</span> label: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 协程返回结果</span></span><br><span class="line">        <span class="keyword">var</span> result: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于保存之前协程的计算结果</span></span><br><span class="line">        <span class="keyword">var</span> mUser: Any? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> mFriendList: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokeSuspend 是协程的关键</span></span><br><span class="line">        <span class="comment">// 它最终会调用 testCoroutine(this) 开启协程状态机</span></span><br><span class="line">        <span class="comment">// 状态机相关代码就是后面的 when 语句</span></span><br><span class="line">        <span class="comment">// 协程的本质，可以说就是 CPS + 状态机</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(_result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">            result = _result</span><br><span class="line">            label = label or <span class="built_in">Int</span>.Companion.MIN_VALUE</span><br><span class="line">            <span class="keyword">return</span> testCoroutine(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的这个 <code>TestContinuation</code> 类，是 <code>Kotlin</code> 编译器创建的匿名内部类，这里为了方便才用的 <code>TestContinuation</code> 这个名称。在这个类当中定义了几个成员变量：</p>
<ul>
<li><code>label</code> 是用来代表协程状态机当中状态的；</li>
<li><code>result</code> 是用来存储当前挂起函数执行结果的；</li>
<li><code>mUser</code>、<code>mFriendList</code> 则是用来存储历史挂起函数执行结果的；</li>
<li><code>invokeSuspend</code> 这个函数，是整个状态机的入口，它会将执行流程转交给 <code>testCoroutine()</code> 进行再次调用。恢复协程是调用的 <code>continuation.resumeWith</code>，这个会调用 <code>invokeSuspend</code></li>
</ul>
<p>接下来是要判断 <code>testCoroutine</code> 是不是初次运行，如果是初次运行，就要创建一个 <code>TestContinuation</code> 的实例对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                    ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCoroutine</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">if</span> (completion <span class="keyword">is</span> TestContinuation) &#123;</span><br><span class="line">        completion</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//                作为参数</span></span><br><span class="line">        <span class="comment">//                   ↓</span></span><br><span class="line">        TestContinuation(completion)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是：</p>
<ul>
<li><code>invokeSuspend</code> 最终会调用 <code>testCoroutine</code>，然后走到这个判断语句；</li>
<li>如果是初次运行，会创建一个 <code>TestContinuation</code> 对象，<code>completion</code> 作为参数；</li>
<li>这相当于用一个 <strong>新的</strong> <code>Continuation</code> 包装了 <strong>旧的</strong> <code>Continuation</code>；</li>
<li>如果不是初次运行，直接将 <code>completion</code> 赋值给 <code>continuation</code>；</li>
<li>这说明 <code>continuation</code> 在整个运行期间，只会产生一个实例，这能极大地节省内存开销 <em>（对比 CallBack）</em>。</li>
</ul>
<p>接下来是几个变量的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个变量，对应原函数的三个变量</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user: String</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> friendList: String</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> feedList: String</span><br><span class="line"></span><br><span class="line"><span class="comment">// result 接收协程的运行结果</span></span><br><span class="line"><span class="keyword">var</span> result = continuation.result</span><br><span class="line"></span><br><span class="line"><span class="comment">// suspendReturn 接收挂起函数的返回值</span></span><br><span class="line"><span class="keyword">var</span> suspendReturn: Any? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CoroutineSingletons 是个枚举类</span></span><br><span class="line"><span class="comment">// COROUTINE_SUSPENDED 代表当前函数被挂起了</span></span><br><span class="line"><span class="keyword">val</span> sFlag = CoroutineSingletons.COROUTINE_SUSPENDED</span><br></pre></td></tr></table></figure>
<p>上面的代码，分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。接着，来看看协程状态机的核心逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (continuation.label) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">// 检测异常</span></span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="comment">// 将 label 置为 1，准备进入下一次状态</span></span><br><span class="line">        continuation.label = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 getUserInfo</span></span><br><span class="line">        suspendReturn = getUserInfo(continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 user 值</span></span><br><span class="line">        user = result <span class="keyword">as</span> String</span><br><span class="line">        log(user)</span><br><span class="line">        <span class="comment">// 将协程结果存到 continuation 里</span></span><br><span class="line">        continuation.mUser = user</span><br><span class="line">        <span class="comment">// 准备进入下一个状态</span></span><br><span class="line">        continuation.label = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 getFriendList</span></span><br><span class="line">        suspendReturn = getFriendList(user, continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        user = continuation.mUser <span class="keyword">as</span> String</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 friendList 的值</span></span><br><span class="line">        friendList = result <span class="keyword">as</span> String</span><br><span class="line">        log(friendList)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将协程结果存到 continuation 里</span></span><br><span class="line">        continuation.mUser = user</span><br><span class="line">        continuation.mFriendList = friendList</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备进入下一个状态</span></span><br><span class="line">        continuation.label = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 getFeedList</span></span><br><span class="line">        suspendReturn = getFeedList(user, friendList, continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> -&gt; &#123;</span><br><span class="line">        throwOnFailure(result)</span><br><span class="line"></span><br><span class="line">        user = continuation.mUser <span class="keyword">as</span> String</span><br><span class="line">        friendList = continuation.mFriendList <span class="keyword">as</span> String</span><br><span class="line">        feedList = continuation.result <span class="keyword">as</span> String</span><br><span class="line">        log(feedList)</span><br><span class="line">        loop = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>testCoroutine()</code> 这个方法体当中，一共调用了三个挂起函数，这三个挂起函数把整个方法体分割成了 <em>4</em> 个部分，这四个部分就是上面 <code>when</code> 表达式当中的 4 种情况。</p>
<ul>
<li><code>when</code> 表达式实现了协程状态机；</li>
<li><code>continuation.label</code> 是状态流转的关键，<code>continuation.label</code> 改变一次，就代表了挂起函数被调用了一次；</li>
<li>每次挂起函数执行完后，都会检查是否发生异常；</li>
<li><code>testCoroutine</code> 里的原本的代码，被拆分到状态机里各个状态中，<strong>分开执行</strong>；</li>
<li><code>getUserInfo(continuation)</code>、<code>getFriendList(user, continuation)</code>、<code>getFeedList(friendList, continuation)</code> 三个函数调用的是同一个 <code>continuation</code> 实例；</li>
<li>如果一个函数被挂起了，它的返回值会是 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>；</li>
<li>在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 <code>continuation</code> 中。</li>
</ul>
<h3><a href="#2-协程未挂起的情况" class="header-anchor">#</a><span id="2-协程未挂起的情况">2. 协程未挂起的情况</span></h3>
<p>要验证也很简单，将其中一个挂起函数改成 <strong>伪挂起函数</strong>即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// “伪”挂起函数</span></span><br><span class="line"><span class="comment">// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数</span></span><br><span class="line"><span class="comment">//  ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">noSuspendFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testNoSuspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    log(user)                  </span><br><span class="line">    <span class="comment">//                  变化在这里</span></span><br><span class="line">    <span class="comment">//                      ↓</span></span><br><span class="line">    <span class="keyword">val</span> friendList = noSuspendFriendList(user)</span><br><span class="line">    log(friendList)</span><br><span class="line">    <span class="keyword">val</span> feedList = getFeedList(friendList)</span><br><span class="line">    log(feedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>testNoSuspend()</code> 这样的一个函数体，反编译后的代码结构 <strong>跟前面的 <code>testCoroutine()</code> 是一致的，只是函数名字变了而已，<code>Kotlin</code> 编译器 <code>CPS</code> 转换的逻辑只认 <code>suspend</code> 关键字。</strong> 就算挂起函数内部并没有挂起的逻辑，<code>Kotlin</code> 编译器也照样会进行 <code>CPS</code> 转换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (continuation.label) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//               变化在这里</span></span><br><span class="line">        <span class="comment">//                   ↓</span></span><br><span class="line">        suspendReturn = noSuspendFriendList(user, continuation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否挂起</span></span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">//go to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 <code>testNoSuspend()</code> 的协程状态机如下， <em>continuation.label = 0, 2, 3</em> 的情况都是不变的，唯独在 <em>label = 1</em> 的时候，<em>suspendReturn == sFlag</em> 这里会有区别。</p>
<p>对于“<strong>伪挂起函数</strong>”，<code>suspendReturn == sFlag</code> 是会走 <code>else</code> 分支的，在 <code>else</code> 分支里，协程状态机会直接进入下一个状态。</p>
<p>现在只剩最后一个问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 具体代码是如何实现的？</span></span><br><span class="line">    <span class="comment">//       ↓</span></span><br><span class="line">    <span class="comment">//go to next state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案其实也很简单：如果你看协程状态机的字节码反编译后的 <code>Java</code>，会看到很多 <code>label</code>。协程状态机底层字节码，是通过 <code>label</code> 来实现这个 <em>go to next state</em> 的。由于 <code>Kotlin</code> 没有类似 <code>goto</code> 的语法，下面我伪代码来表示 <em>go to next state</em> 的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="comment">// Kotlin 没有这样的语法</span></span><br><span class="line"><span class="comment">// ↓      ↓</span></span><br><span class="line">label: whenStart</span><br><span class="line"><span class="keyword">when</span> (continuation.label) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        suspendReturn = noSuspendFriendList(user, continuation)</span><br><span class="line">        <span class="keyword">if</span> (suspendReturn == sFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendReturn</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = suspendReturn</span><br><span class="line">            <span class="comment">// 让程序跳转到 label 标记的地方</span></span><br><span class="line">            <span class="comment">// 从而再执行一次 when 表达式</span></span><br><span class="line">            goto: whenStart</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：以上只是伪代码，它只是跟协程状态机字节码逻辑上“<strong>大致等价</strong>”。真实的字节码反编译出来的 <code>Java</code> 代码，它的可读性要差很多，也更难理解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看不懂也没关系，有个印象即可</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> Object testCoroutine(<span class="meta">@NotNull</span> Continuation $completion) &#123;</span><br><span class="line">    Object $continuation;</span><br><span class="line">    label37: &#123;</span><br><span class="line">        <span class="keyword">if</span> ($completion instanceof &lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;) &#123;</span><br><span class="line">            $continuation = (&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$completion;</span><br><span class="line">            <span class="keyword">if</span> ((((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label &amp; Integer.MIN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label -= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">break</span> label37;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $continuation = new ContinuationImpl($completion) &#123;</span><br><span class="line">            <span class="comment">// $FF: synthetic field</span></span><br><span class="line">            Object result;</span><br><span class="line">            int label;</span><br><span class="line">            Object L$<span class="number">0</span>;</span><br><span class="line">            Object L$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">                <span class="keyword">this</span>.result = $result;</span><br><span class="line">                <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">return</span> TestSuspendKt.testCoroutine(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object var10000;</span><br><span class="line">    label31: &#123;</span><br><span class="line">        String user;</span><br><span class="line">        String friendList;</span><br><span class="line">        Object var6;</span><br><span class="line">        label30: &#123;</span><br><span class="line">            Object $result = ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).result;</span><br><span class="line">            var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">            switch(((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label) &#123;</span><br><span class="line">                case <span class="number">0</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                    ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label = <span class="number">1</span>;</span><br><span class="line">                    var10000 = getUserInfo((Continuation)$continuation);</span><br><span class="line">                    <span class="keyword">if</span> (var10000 == var6) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var6;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                case <span class="number">1</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                case <span class="number">2</span>:</span><br><span class="line">                    user = (String)((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span>;</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span> label30;</span><br><span class="line">                case <span class="number">3</span>:</span><br><span class="line">                    friendList = (String)((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">1</span>;</span><br><span class="line">                    user = (String)((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span>;</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span> label31;</span><br><span class="line">                default:</span><br><span class="line">                    <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            user = (String)var10000;</span><br><span class="line">            log(user);</span><br><span class="line">            ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span> = user;</span><br><span class="line">            ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label = <span class="number">2</span>;</span><br><span class="line">            var10000 = getFriendList(user, (Continuation)$continuation);</span><br><span class="line">            <span class="keyword">if</span> (var10000 == var6) &#123;</span><br><span class="line">                <span class="keyword">return</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        friendList = (String)var10000;</span><br><span class="line">        log(friendList);</span><br><span class="line">        ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">0</span> = user;</span><br><span class="line">        ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).L$<span class="number">1</span> = friendList;</span><br><span class="line">        ((&lt;TestSuspendKt$testCoroutine$<span class="number">1</span>&gt;)$continuation).label = <span class="number">3</span>;</span><br><span class="line">        var10000 = getFeedList(friendList, (Continuation)$continuation);</span><br><span class="line">        <span class="keyword">if</span> (var10000 == var6) &#123;</span><br><span class="line">            <span class="keyword">return</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String feedList = (String)var10000;</span><br><span class="line">    log(feedList);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上来说，<code>Kotlin</code> 协程就是通过 <code>label</code> 代码段嵌套，配合 <code>switch</code> 巧妙构造出一个状态机结构，这种逻辑比较复杂，相对难懂一些。毕竟 <code>Java</code> 的 <code>label</code> 在实际开发中用的很少。</p>
<blockquote>
<p>注意：<code>Kotlin</code> 挂起函数反编译出来的 <code>Java</code> 代码，会因为实际开发环境的不同出现细微差异。随着 <code>Kotlin</code> 编译器的发展，将来可能会对这部分逻辑进一步优化，但它的核心状态机思想是不会轻易改变的。</p>
</blockquote>
<p>好，到现在，就已经彻底弄懂挂起函数的实现原理了。接下来，结合刚刚学习的内容，来进一步思考实战一下。</p>
<h2><a href="#3-思考与实战" class="header-anchor">#</a><span id="3-思考与实战">3. 思考与实战</span></h2>
<h3><a href="#1-挂起函数与-coroutinecontext-的紧密联系" class="header-anchor">#</a><span id="1-挂起函数与-coroutinecontext-的紧密联系">1. “挂起函数”与 CoroutineContext 的紧密联系</span></h3>
<p><code>Kotlin</code> 协程的源代码其实分为三层，其中基础层当中的“基础概念”尤为重要。那么，<code>Kotlin</code> 官方提供了哪些与挂起函数相关的基础元素呢</p>
<p>首先想到的，肯定就是 <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>，在这里面，确实也可以找到一些跟挂起函数相关的基础元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;WRONG_MODIFIER_TARGET&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;Implemented as intrinsic&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最熟悉的就是 <code>Continuation</code> 这个接口了，除此之外，还有一个顶层的变量值得注意：<code>suspend inline val coroutineContext</code>。要知道，从来都是用 <code>suspend</code> 修饰函数的，从未见过 <code>suspend</code> 修饰变量的情况。</p>
<p>如果开发者自己依葫芦画瓢，创建一个类似的顶层变量的话，编译器甚至会报错：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="keyword">val</span> test: CoroutineContext</span><br><span class="line">    <span class="keyword">get</span>() = TODO()</span><br></pre></td></tr></table></figure>
<p>由此可见，<code>suspend</code> 的这种用法只是一种特殊用法。结合“<code>public suspend inline val</code>”这几个关键字来看，其实可以大致推测出它的作用：它是一个只有在挂起函数作用域下，才能访问的顶层的不可变的变量。这里的 <code>inline</code>，意味着它的具体实现会被直接复制到代码的调用处。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.coroutineContext</span><br><span class="line"></span><br><span class="line"><span class="comment">//                        挂起函数能可以访问协程上下文吗？</span></span><br><span class="line"><span class="comment">//                                 ↓                              </span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testContext</span><span class="params">()</span></span> = coroutineContext</span><br></pre></td></tr></table></figure>
<p>如果将上面的代码反编译成 <code>Java</code> 的话，它就会变成这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> Object testContext(Continuation $completion) &#123;</span><br><span class="line">  <span class="keyword">return</span> $completion.getContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，<em>代码段 17</em> 当中的“<code>suspend inline val coroutineContext</code>”，本质上就是 <code>Kotlin</code> 官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是 <code>Kotlin</code> 编译器来完成的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.coroutineContext</span><br><span class="line"></span><br><span class="line"><span class="comment">//                  Continuation当中的coroutineContext</span></span><br><span class="line"><span class="comment">//                                 ↓                              </span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testContext</span><span class="params">()</span></span> = coroutineContext</span><br></pre></td></tr></table></figure>
<p><strong>在挂起函数当中无法直接访问 <code>Continuation</code> 对象，但可以访问到 <code>Continuation</code> 当中的 <code>coroutineContext</code>。</strong> 正常情况下，想要访问 <code>Continuation.coroutineContext</code>，首先是要拿到 <code>Continuation</code> 对象的。但是，<code>Kotlin</code> 官方通过“<code>suspend inline val coroutineContext</code>”这个顶层变量，让开发者能直接拿到 <code>coroutineContext</code>，却对 <code>Continuation</code> 毫无感知。</p>
<p>所以，挂起函数与 <code>CoroutineContext</code> 确实有着紧密的联系。每个挂起函数当中都会有 <code>Continuation</code>，而每个 <code>Continuation</code> 当中都会有 <code>coroutineContext</code>。并且，在挂起函数当中，就可以直接访问当前的 <code>coroutineContext</code>。</p>
<h3><a href="#2-kthttp-支持挂起函数" class="header-anchor">#</a><span id="2-kthttp-支持挂起函数">2. KtHttp 支持挂起函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="comment">// 1，挂起函数</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">reposSuspend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;lang&quot;</span>)</span> lang: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;since&quot;</span>)</span> since: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2，支持挂起函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3，判断是不是挂起函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSuspend</span><span class="params">(method: <span class="type">Method</span>)</span></span> = method.kotlinFunction?.isSuspend ?: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4，真正执行网络请求的方法</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">realCall</span><span class="params">(call: <span class="type">Call</span>, gson: <span class="type">Gson</span>, type: <span class="type">Type</span>)</span></span>: T = suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">okhttp3</span>.<span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> t = gson.fromJson&lt;T&gt;(response.body?.string(), type)</span><br><span class="line">                continuation.resume(t)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    continuation.invokeOnCancellation &#123;</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码一共有 <em>4</em> 个注释：</p>
<ul>
<li><em>注释 1</em>，这其实就是希望达到的效果，可以在 <code>ApiServiceV</code> 接口当中直接定义挂起函数。</li>
<li><em>注释 2</em>，在 <em>KtHttp 6.0</em> 版本的基础上，我们在 <code>invoke()</code> 的 <code>when</code> 表达式里增加了一个分支：<code>isSuspend()</code>。</li>
<li><em>注释 3</em>，<code>isSuspend()</code> 的实现有一个细节，这里使用了“<code>method.kotlinFunction</code>”，将 <code>Java</code> 的 <code>method</code> 转换成了 <code>kotlinFunction</code>，这样一来，它就变成了一个 <code>Kotlin</code> 反射的对象了。因此，就可以查询到一些 <code>Kotlin</code> 相关的信息，比如说，它是不是一个挂起函数。</li>
<li><em>注释 4</em>，为了直接在挂起函数里执行网络请求，将 <code>KtCall</code> 当中的部分代码逻辑挪了进来。这个 <code>realCall()</code> 方法，它被定义成了一个挂起函数。</li>
</ul>
<p>基于以上的分析，其实只需要借助反射，完成<em>注释 2</em> 处的代码逻辑，然后调用 <code>realCall()</code> 这个挂起函数就行了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1，反射获取类型信息</span></span><br><span class="line">            <span class="comment">// 2，调用realCall()</span></span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，接下来要做的事情大致可以分为两个部分。</p>
<p>第一个部分，获取类型信息，准备请求网络，这个部分其实很简单。但在第二个部分“支持挂起函数”这里会遇到问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 报错！！</span></span><br><span class="line">            realCall&lt;T&gt;()</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码报错的原因也很容易理解，<code>realCall()</code> 是一个挂起函数，它无法在普通函数里被调用！所以这里就面临了一个问题：<strong>如何在普通 Kotlin 函数当中调用挂起函数</strong>？那么，首先可以想到的解决办法，就是强制类型转换：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> continuation = args.last() <span class="keyword">as</span>? Continuation&lt;T&gt;</span><br><span class="line">            <span class="comment">// 1，将挂起函数类型转换成，带Continuation的类型，报错</span></span><br><span class="line">            <span class="keyword">val</span> func = ::realCall <span class="keyword">as</span> (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any?</span><br><span class="line">            func.invoke(call, gson, genericReturnType, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>留意代码中的 <em>注释 1</em>，尝试使用“函数引用”的方式，将 <code>realCall()</code> 转换成了带有 <code>Continuation</code> 的函数类型，这样就可以通过传入 <code>Continuation</code>，来调用 <code>realCall()</code> 这个挂起函数了。</p>
<p>不过，事与愿违，这种方法并不能奏效，因为这行代码会报错，原因是 <code>realCall()</code> 带有泛型，而 <code>Kotlin</code> 暂时不支持“函数引用带泛型”的语法。</p>
<p>所以在这里，为了让这个 <code>Demo</code> 能运行起来，可以定义一个临时方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> continuation = args.last() <span class="keyword">as</span>? Continuation&lt;T&gt;</span><br><span class="line">            <span class="comment">// 1，使用临时方法消除泛型</span></span><br><span class="line">            <span class="keyword">val</span> func = ::temp <span class="keyword">as</span> (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any?</span><br><span class="line">            func.invoke(call, gson, genericReturnType, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">temp</span><span class="params">(call: <span class="type">Call</span>, gson: <span class="type">Gson</span>, type: <span class="type">Type</span>)</span></span> = realCall&lt;RepoList&gt;(call, gson, type)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用了一个临时方法消除了泛型 <code>T</code>，写死了返回值类型 <code>RepoList</code>。这样的代码，在 <code>Demo</code> 当中是可以运行的，这从侧面也能印证上面代码中的类型转换是成功的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = KtHttpV7.create(ApiServiceV7::<span class="keyword">class</span>.java).reposSuspend(</span><br><span class="line">        lang = <span class="string">&quot;Kotlin&quot;</span>,</span><br><span class="line">        since = <span class="string">&quot;weekly&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">正常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>不过，这种做法明显<strong>不具备普适性</strong> ，为了让 <code>KtHttp</code> 支持所有类型的 <code>API</code> 请求，必须要想其他的办法。具体来说，可以这样做：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        isSuspend(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 支持挂起函数</span></span><br><span class="line">            <span class="keyword">val</span> genericReturnType = method.kotlinFunction?.returnType?.javaType ?: <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            <span class="keyword">val</span> call = okHttpClient!!.newCall(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> continuation = args.last() <span class="keyword">as</span>? Continuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> func = KtHttpV7::<span class="keyword">class</span>.getGenericFunction(<span class="string">&quot;realCall&quot;</span>)</span><br><span class="line">            <span class="comment">// 反射调用realCall()</span></span><br><span class="line">            func.call(<span class="keyword">this</span>, call, gson, genericReturnType, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        isKtCallReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        isFlowReturn(method) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2，获取方法的反射对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> KClass<span class="type">&lt;*&gt;</span>.<span class="title">getGenericFunction</span><span class="params">(name: <span class="type">String</span>)</span></span>: KFunction&lt;*&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> members.single &#123; it.name == name &#125; <span class="keyword">as</span> KFunction&lt;*&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实，这种思路跟前面的思路是类似的，仍然是对 <code>realCall()</code> 的类型进行了转换，只不过是通过反射来实现的而已。所以最重要的，还是要弄清楚 <code>Kotlin</code> 挂起函数 <code>CPS</code> 转换的细节。</p>
<h2><a href="#4-总结" class="header-anchor">#</a><span id="4-总结">4. 总结</span></h2>
<p>通过研究挂起函数的反编译代码，发现了 <strong><code>Kotlin</code> 的挂起函数，本质上就是一个状态机</strong>。其中主要涉及到下面几个知识点，需要重点掌握好。</p>
<ul>
<li><code>Kotlin</code> 挂起函数的 <code>CPS</code> 转换，它的函数签名变化主要分为两个部分，第一部分是 <strong>参数的变化</strong>，挂起函数经过 <code>Kotlin</code> 编译器转换以后，它会多出一个 <code>Continuation</code> 类型的参数。第二部分是 <strong>返回值类型的变化</strong>，挂起函数原本的返回值类型，会被挪到 <code>Continuation</code> 当中作为泛型参数，比如 <code>Continuation&lt;String&gt;</code>，而转换过后的函数返回值类型会变成“<code>Any?</code>”类型。</li>
<li>当挂起函数经过反编译以后，它会变成 <strong>由 <code>switch</code> 和 <code>label</code> 组成的状态机结构</strong>。</li>
<li>为了便于研究，上面提供了大致等价的协程状态机代码：其中，<code>when</code> 表达式实现了协程状态机，而 <code>continuation.label</code> 则代表了当前状态机的具体状态，<code>continuation.label</code> 改变一次，就代表了挂起函数被调用了一次；</li>
<li>在一个挂起函数被调用的时候，它的返回值可能是具体的结果，也可能会是 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>，这时候就代表了这个函数被挂起了。</li>
</ul>
<p>如何在<code>Java</code> 代码中调用 <code>Kotlin</code> 的挂起函数？</p>
<p>比如，下面这个函数，如何在 Java 当中调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> SuspendFromJavaExample &#123;</span><br><span class="line">    <span class="comment">// 在Java当中如何调用这个方法？</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(id: <span class="type">Long</span>)</span></span>:String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法一：</strong> 当挂起函数通过 <code>Kotlin</code> 编译器进行 <code>CPS</code> 转换后，对应的挂起函数就被转换成了带 <code>Callback</code> 参数 <em>（<code>Continuation</code> 接口）</em> 的普通函数，只要传入 <code>Continuation</code> 接口的实现就可以了。</p>
<p><strong>方法二：</strong> 在<code>Java</code>中的<code>getContext()</code>中可考虑传入<code>EmptyCoroutineContext.INSTANCE</code></p>
<h1><a href="#三-深入理解协程基础元素" class="header-anchor">#</a><span id="三-深入理解协程基础元素">三、深入理解协程基础元素</span></h1>
<p><code>Kotlin</code> 协程的基础元素大致有这些：<code>Continuation</code>、<code>SafeContinuation</code>、<code>CoroutineContext</code>、<code>CombinedContext</code>、<code>CancellationException</code>、<code>intrinsics</code>。</p>
<p><img src="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/coroutine_base_1.jpeg" alt></p>
<p>其中的 <code>CoroutineContext</code>、<code>CancellationException</code> 前面已介绍过，另外的 <code>CombinedContext</code>，就是 <code>CoroutineContext</code> 的一个实现类，而 <code>SafeContinuation</code> 则是 <code>Continuation</code> 的实现类。<br>
所以，在整个协程基础元素当中，最需要关心的，其实就是 <code>Continuation</code> 和 <code>intrinsics</code>。在 <code>intrinsics</code> 里，有一个重要的高阶函数 <code>suspendCoroutineUninterceptedOrReturn&#123;&#125;</code>。</p>
<h2><a href="#1-continuation-的两种用法" class="header-anchor">#</a><span id="1-continuation-的两种用法">1. Continuation 的两种用法</span></h2>
<h3><a href="#1-实现挂起函数" class="header-anchor">#</a><span id="1-实现挂起函数">1. 实现挂起函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 注意这里</span></span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 注意这里</span></span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            println(<span class="string">&quot;Call cancelled!&quot;</span>)</span><br><span class="line">            call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上代码实现了一个具有取消支持的挂起函数。在这段代码中，使用<code>suspendCancellableCoroutine</code>函数创建了一个挂起函数。在<code>onSuccess</code>回调中，使用<code>continuation.resume(data)</code>来恢复挂起的协程并传递数据。在<code>onFail</code>回调中，使用<code>continuation.resumeWithException(throwable)</code>来恢复挂起的协程并传递异常信息。此外，还使用<code>continuation.invokeOnCancellation</code>来注册一个取消回调，以确保在协程取消时取消网络请求。</p>
<p>当想要实现挂起函数的时候，可以使用 <code>suspendCoroutine&#123;&#125;</code>、<code>suspendCancellableCoroutine&#123;&#125;</code>这两个高阶函数，在它们的 <code>Lambda</code> 当中，可以使用它暴露出来的 <code>continuation</code> 对象，把程序的执行结果或异常传到外部去。这种方式，往往是用于实现挂起函数内部逻辑的。</p>
<h3><a href="#2-调用挂起函数" class="header-anchor">#</a><span id="2-调用挂起函数">2. 调用挂起函数</span></h3>
<p>用 <code>suspendCoroutine&#123;&#125;</code>写一个更加简单的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = getLengthSuspend(<span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLengthSuspend</span><span class="params">(text: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = suspendCoroutine &#123; continuation-&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        continuation.resume(text.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码里，使用 <code>suspendCoroutine&#123;&#125;</code>实现了挂起函数，然后在它的内部，使用 <code>continuation.resume()</code> 的方式，传出了挂起函数的返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> func = ::getLengthSuspend <span class="keyword">as</span> (String, Continuation&lt;<span class="built_in">Int</span>&gt;) -&gt; Any?</span><br><span class="line"></span><br><span class="line">    func(<span class="string">&quot;Kotlin&quot;</span>, <span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(result.getOrNull())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止程序提前结束</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLengthSuspend</span><span class="params">(text: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = suspendCoroutine &#123; continuation-&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        continuation.resume(text.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码里，把 <code>getLengthSuspend()</code> 这个函数强转成了带有 <code>Continuation</code> 的函数类型，然后通过匿名内部类的方式，创建了一个 <code>Continuation</code> 对象传了进去。最终，程序的执行结果和 <em>代码段 2</em> 是一致的。</p>
<p><strong>挂起函数的本质，就是 <code>Callback</code>!</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    func(<span class="string">&quot;Kotlin&quot;</span>, <span class="keyword">object</span>: Callback&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(result: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            println(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止程序提前结束</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func</span><span class="params">(text: <span class="type">String</span>, callback: <span class="type">Callback</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        callback.resume(text.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，当把 <code>Continuation</code> 改成 <code>Callback</code> 以后，整个代码就变成了最熟悉的异步回调代码了。调用方，可以使用匿名内部类创建 <code>Callback</code> 用于接收异步结果；异步函数内部，使用 <code>callback.resume()</code> 将结果传出去。</p>
<p>综上所述，<code>Kotlin</code> 协程当中的 <code>Continuation</code>，作用其实就相当于 <code>Callback</code>，它既可以用于 <strong>实现挂起函数</strong>，往挂起函数的外部传递结果；也可以用于 <strong>调用挂起函数</strong>，可以创建 <code>Continuation</code> 的匿名内部类，来接收挂起函数传递出来的结果。</p>
<h3><a href="#3-在-java-当中调用-kotlin-挂起函数" class="header-anchor">#</a><span id="3-在-java-当中调用-kotlin-挂起函数">3. 在 Java 当中调用 Kotlin 挂起函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在Java中调用的Kotlin挂起函数</span></span><br><span class="line"><span class="keyword">object</span> SuspendFromJavaExample &#123;</span><br><span class="line">    <span class="comment">// 在Java当中如何调用这个方法？</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(id: <span class="type">Long</span>)</span></span>:String &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数，可以在 Java 当中调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    SuspendFromJavaExample.INSTANCE.getUserInfo(<span class="number">100L</span>, <span class="keyword">new</span> <span class="title class_">Continuation</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> &#123;</span><br><span class="line">            System.out.println(o+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止程序提前结束</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Kotlin</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这段代码演示了 <strong>在<code>Java</code>中调用<code>Kotlin</code>的挂起函数</strong>。通过创建<code>SuspendFromJavaExample</code>的单例对象，然后调用其<code>getUserInfo</code>方法，传入一个实现了<code>Continuation</code>接口的匿名内部类。在这个内部类中，通过重写<code>resumeWith</code>方法来处理挂起函数的返回结果，在这里将结果打印出来。</p>
<p>可以发现，在实现挂起函数逻辑的时候，总是离不开 <code>suspendCoroutine&#123;&#125;</code>、<code>suspendCancellableCoroutine&#123;&#125;</code>。</p>
<h2><a href="#2-suspendcoroutine" class="header-anchor">#</a><span id="2-suspendcoroutine">2. suspendCoroutine{}</span></h2>
<p><code>suspendCoroutine&#123;&#125;</code>、<code>suspendCancellableCoroutine&#123;&#125;</code>这两个高阶函数的实现原理是类似的，所以这里就主要探究下 <code>suspendCoroutine&#123;&#125;</code>。</p>
<p><code>suspendCoroutine&#123;&#125;</code>的源代码，在<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>文件当中。</p>
<h3><a href="#1-suspendcoroutineuninterceptedorreturn" class="header-anchor">#</a><span id="1-suspendcoroutineuninterceptedorreturn">1. suspendCoroutineUninterceptedOrReturn</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutine</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;</span><br><span class="line">        <span class="keyword">val</span> safe = SafeContinuation(c.intercepted())</span><br><span class="line">        block(safe)</span><br><span class="line">        safe.getOrThrow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，高阶函数 <code>suspendCoroutineUninterceptedOrReturn&#123;&#125;</code>其实就是实现 <code>suspendCoroutine&#123;&#125;</code>的关键。除了它之外，其他部分的代码都很好理解：</p>
<ul>
<li><code>SafeContinuation(c.intercepted())</code> 这行代码的作用，就是把原本的 <code>Continuation</code> 包裹一遍。</li>
<li><code>block(safe)</code> 这行代码，其实就是在调用 <code>Lambda</code> 当中的逻辑。</li>
<li><code>safe.getOrThrow()</code>，就是在取出 <code>block(safe)</code> 的运行结果，<code>Continuation</code> 当中是可以存储 <code>result</code> 的。这个 <code>Result</code> 可能是正确的结果，也可能是异常。</li>
</ul>
<p>下面重点来看看 <code>suspendCoroutineUninterceptedOrReturn&#123;&#125;</code>这个高阶函数的作用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutineUninterceptedOrReturn</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Any</span>?)</span></span>: T &#123;</span><br><span class="line">    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;</span><br><span class="line">    <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上<code>suspendCoroutineUninterceptedOrReturn</code>源码可以看到，<strong>这个高阶函数的源代码会是抛出了一个异常</strong>。异常内容：<em>“Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic.”</em>。理解这句话的关键在于 <em>“intrinsic”</em> 这个单词，它有“固有”“本质”的意思，不过在上面这句话的语境下，这里的 <code>intrinsic</code> 其实是指编译器领域的一个术语，可以把它理解为 <strong>“内建”</strong>。因此，上面看到的异常提示信息的意思就是：<code>suspendCoroutineUninterceptedOrReturn</code> 是一个编译器内建函数，<strong>它是由 Kotlin 编译器来实现的。</strong><br>
<code>Kotlin</code> 编译器当中的逻辑源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/1.6.0/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt">coroutineCodegenUtil.kt</a></p>
<h3><a href="#2-suspendcoroutineuninterceptedorreturn-的功能和作用" class="header-anchor">#</a><span id="2-suspendcoroutineuninterceptedorreturn-的功能和作用">2. suspendCoroutineUninterceptedOrReturn 的功能和作用</span></h3>
<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个高阶函数，会接收一个 <code>Lambda</code>，类型是<code>(Continuation) -&gt; Any?</code>，这里的 <strong>“<code>Any?</code>”</strong> 类型，其实就能代表当前这个挂起函数是否真正挂起。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = testNoSuspendCoroutine()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testNoSuspendCoroutine</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt; &#123;</span><br><span class="line">        continuation -&gt;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@suspendCoroutineUninterceptedOrReturn</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，直接使用 <code>suspendCoroutineUninterceptedOrReturn</code> 实现了挂起函数，并且，在它的 <code>Lambda</code> 当中，并没有调用 <code>continuation.resume()</code>，而是直接返回了结果 <em>“Hello!”</em>。根据程序的运行结果，在挂起函数的外部确实也可以接收到这个结果。</p>
<p>上面的代码反编译后的代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> Object testNoSuspendCoroutine(Continuation $completion) &#123;</span><br><span class="line">  int var2 = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;Hello!&quot;</span> == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">     DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从反编译的结果来看，<code>testNoSuspendCoroutine()</code> 这个函数其实就是一个伪挂起函数，它的内部并不会真正挂起，而是直接返回结果。这样，当从外部调用这个函数的时候，这个函数会立即返回结果 <em>“Hello!”</em>。</p>
<p>真正的挂起函数如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = testSuspendCoroutine()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspendCoroutine</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        continuation.resume(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@suspendCoroutineUninterceptedOrReturn</span> kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">等待1秒</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这一次，并没有使用 <code>return</code> 返回结果，而是使用了 <code>continuation.resume()</code>。通过程序运行结果，可以看到挂起函数的外部也能接收到这个结果。</p>
<p>反编译对应的 <code>Java</code> 代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> Object testSuspendCoroutine(Continuation $completion) &#123;</span><br><span class="line">    int var2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    ThreadsKt.thread$default(<span class="literal">false</span>, <span class="literal">false</span>, (ClassLoader)<span class="literal">null</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (Function0)(new CoroutineBasicElementsKt$testSuspendCoroutine$<span class="number">2</span>$<span class="number">1</span>($completion)), <span class="number">31</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    Object var10000 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    <span class="keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">     DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> var10000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CoroutineBasicElementsKt</span>$<span class="title">testSuspendCoroutine</span>$2$1 <span class="title">extends</span> <span class="title">Lambda</span> <span class="title">implements</span> <span class="title">Function0</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Continuation $it;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object invoke() &#123;</span><br><span class="line">      <span class="keyword">this</span>.invoke();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void invoke() &#123;</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">      Continuation var1 = <span class="keyword">this</span>.$it;</span><br><span class="line">      String var2 = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">      Companion var3 = Result.Companion;</span><br><span class="line">      var1.resumeWith(Result.<span class="keyword">constructor</span>-impl(var2));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   CoroutineBasicElementsKt$testSuspendCoroutine$<span class="number">2</span>$<span class="number">1</span>(Continuation var1) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">this</span>.$it = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><em>注释 1、4</em> ，创建了一个新的线程，执行了 <code>thread&#123;&#125;</code> 当中的代码。</li>
<li><em>注释 2</em>，将 <code>var10000</code> 赋值为 <code>COROUTINE_SUSPENDED</code> 这个挂起标志位。</li>
<li><em>注释 3</em>，返回挂起标志位，代表 <code>testSuspendCoroutine()</code> 这个函数会真正挂起。</li>
</ul>
<p>所以，这两个例子也从侧面证明了一个结论：由于 <code>suspend</code> 修饰的函数，既可能返回 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>，也可能返回实际结果，甚至可能返回 <code>null</code>，为了适配所有的可能性，<code>CPS</code> 转换后的函数返回值类型就只能是 <code>Any?</code> 了。</p>
<p>那么现在，也就可以总结出 <strong><code>suspendCoroutineUninterceptedOrReturn&#123;&#125;</code>这个高阶函数的作用了</strong>：它可以将挂起函数当中的 <code>Continuation</code> 以参数的形式暴露出来，在它的 <code>Lambda</code> 当中，可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，也可以返回 <code>COROUTINE_SUSPENDED</code> 这个挂起标志位，然后使用 <code>continuation.resume()</code> 传递结果。</p>
<p>相应的，<code>suspendCoroutine&#123;&#125;</code>、<code>suspendCancellableCoroutine&#123;&#125;</code>这两个高阶函数，只是对它的一种封装而已。</p>
<h2><a href="#3-小结" class="header-anchor">#</a><span id="3-小结">3. 小结</span></h2>
<p><code>Continuation</code> 是整个协程当中最重要的基础元素，可以将其看做是一个 <code>Callback</code>。它主要有两个使用场景:</p>
<ul>
<li>一种是在实现挂起函数的时候，用于传递挂起函数的执行结果；</li>
<li>另一种是在调用挂起函数的时候，以匿名内部类的方式，用于接收挂起函数的执行结果。</li>
</ul>
<p>借助这种思路，也完全可以在 <code>Java</code> 当中调用挂起函数。当想要实现挂起函数的时候，需要使用 <code>suspendCoroutine&#123;&#125;</code>、<code>suspendCancellableCoroutine&#123;&#125;</code>这两个高阶函数。它们两个都是对 <code>suspendCoroutineUninterceptedOrReturn&#123;&#125;</code>的封装，这个高阶函数的作用其实就是暴露挂起函数的 <code>Continuation</code> 对象。在它的 <code>Lambda</code> 当中，既可以直接返回执行结果，也可以返回 <code>COROUTINE_SUSPENDED</code> 这个挂起标志位，然后使用 <code>continuation.resume()</code> 传递结果。</p>
<h1><a href="#四-深入理解协程的创建与启动launch-sync" class="header-anchor">#</a><span id="四-深入理解协程的创建与启动launch-sync">四、深入理解协程的创建与启动–launch、sync</span></h1>
<h2><a href="#1-协程启动的基础-api" class="header-anchor">#</a><span id="1-协程启动的基础-api">1. 协程启动的基础 API</span></h2>
<p>在<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>这个文件当中，有两个重要的扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，<code>createCoroutine&#123;&#125;</code>、<code>startCoroutine&#123;&#125;</code>这两个函数，就是 <code>Kotlin</code> 协程当中最基础的两个创建协程的 <code>API</code>。</p>
<p>启动协程有三种常见的方式：<code>launch</code>、<code>runBlocking</code>、<code>async</code>。它们其实属于协程中间层提供的 <code>API</code>，而它们的底层都在某种程度上调用了“基础层”的协程 <code>API</code>。也就是说，<strong>使用协程的基础层 <code>API</code>，也可以创建协程</strong>。</p>
<p><code>createCoroutine&#123;&#125;</code>、<code>startCoroutine&#123;&#125;</code>，它们都是扩展函数，其扩展接收者类型是一个函数类型：<code>suspend () -&gt; T</code>，代表了“无参数，返回值为 <code>T</code> 的挂起函数或者 <code>Lambda</code>”。而对于函数本身，它们两个都接收一个 <code>Continuation&lt;T&gt;</code> 类型的参数，其中一个函数，还会返回一个 <code>Continuation&lt;Unit&gt;</code> 类型的返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testStartCoroutine()</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> block = <span class="keyword">suspend</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    <span class="string">&quot;Result&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testStartCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">object</span> : Continuation&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Result is: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block.startCoroutine(continuation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">Result is: Result</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，定义了一个 <code>Lambda</code> 表达式 <code>block</code>，它的类型就是 <code>suspend () -&gt; T</code>。这样一来，就可以用 <code>block.startCoroutine()</code> 来启动协程了。这里，还创建了一个匿名内部类对象 <code>continuation</code>，作为 <code>startCoroutine()</code> 的参数。<br>
上文中提到过， <code>Continuation</code> 主要有两种用法，一种是在实现挂起函数的时候，用于 <strong>传递挂起函数的执行结果</strong>；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于 <strong>接收挂起函数的执行结果</strong>。而 <em>代码段 3</em> 中 <code>Continuation</code> 的作用，则明显属于后者。</p>
<p>从 <em>代码段 3</em> 的执行结果中，可以看出来，<code>startCoroutine()</code> 的作用其实就是创建一个新的协程，并且执行 <code>block</code> 当中的逻辑，等协程执行完毕以后，将结果返回给 <code>Continuation</code> 对象。而这个逻辑，使用 <code>createCoroutine()</code> 这个方法其实也可以实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">代码段<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testCreateCoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">object</span> : Continuation&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Result is: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutine = block.createCoroutine(continuation)</span><br><span class="line"></span><br><span class="line">    coroutine.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">Result is: Result</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据以上代码，可以看到，<code>createCoroutine()</code> 的作用其实就是创建一个协程，并暂时先不启动它。等想要启动它的时候，直接调用 <code>resume()</code> 即可。进一步分析 <em>代码段 2</em> 当中的源代码，会发现 <code>createCoroutine()</code>、<code>startCoroutine()</code> 的源代码差别也并不大，只是前者没有调用 <code>resume()</code>，而后者调用了 <code>resume()</code>。</p>
<p>换句话说，<code>startCoroutine()</code> 之所以可以创建并同时启动协程的原因就在于，它在源码中直接调用了 <code>resume(Unit)</code>，所以，在 <em>代码段 3</em> 当中就不需要自己调用 <code>resume()</code> 方法了。</p>
<h2><a href="#2-startcoroutine-实现原理" class="header-anchor">#</a><span id="2-startcoroutine-实现原理">2. startCoroutine() 实现原理</span></h2>
<p>下面，以 <code>startCoroutine()</code> 为例，来研究下它的实现原理。把 <em>代码段 3</em> 反编译成 <code>Java</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">        testStartCoroutine();</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> Function1&lt;Continuation&lt;? <span class="keyword">super</span> String&gt;, Object&gt; block = new LaunchUnderTheHoodKt$block$<span class="number">1</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Function1&lt;Continuation&lt;? <span class="keyword">super</span> String&gt;, Object&gt; getBlock() &#123;</span><br><span class="line">        <span class="keyword">return</span> block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">block</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function1</span>&lt;<span class="type">Continuation&lt;? super String</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">        int label;</span><br><span class="line"></span><br><span class="line">        LaunchUnderTheHoodKt$block$<span class="number">1</span>(Continuation $completion) &#123;</span><br><span class="line">          <span class="keyword">super</span>(<span class="number">1</span>, $completion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">          Object <span class="keyword">object</span> = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">          switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">              System.<span class="keyword">out</span></span><br><span class="line">                .println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">              <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>) == <span class="keyword">object</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">object</span>; </span><br><span class="line">              DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>);</span><br><span class="line">              System.<span class="keyword">out</span></span><br><span class="line">                .println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">              System.<span class="keyword">out</span>.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@NotNull</span> Continuation&lt;? <span class="keyword">super</span> LaunchUnderTheHoodKt$block$<span class="number">1</span>&gt; $completion) &#123;</span><br><span class="line">          <span class="keyword">return</span> (Continuation&lt;<span class="built_in">Unit</span>&gt;)new LaunchUnderTheHoodKt$block$<span class="number">1</span>($completion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@Nullable</span> Continuation&lt;?&gt; p1) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((LaunchUnderTheHoodKt$block$<span class="number">1</span>)create(p1)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> void testStartCoroutine() &#123;</span><br><span class="line">        LaunchUnderTheHoodKt$testStartCoroutine$continuation$<span class="number">1</span> continuation = new LaunchUnderTheHoodKt$testStartCoroutine$continuation$<span class="number">1</span>();</span><br><span class="line">        ContinuationKt.startCoroutine(block, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">testStartCoroutine</span>$<span class="title">continuation</span>$1 <span class="title">implements</span> <span class="title">Continuation</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext getContext() &#123;</span><br><span class="line">          <span class="keyword">return</span> (CoroutineContext)EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> void resumeWith(<span class="meta">@NotNull</span> Object result) &#123;</span><br><span class="line">          System.<span class="keyword">out</span>.println(Intrinsics.stringPlus(<span class="string">&quot;Result is: &quot;</span>, Result.isFailure-impl(result) ? <span class="literal">null</span> : result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuspendLambda</span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> arity: <span class="built_in">Int</span>,</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : ContinuationImpl(completion), FunctionBase&lt;Any?&gt;, SuspendFunction &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><em>注释 1</em>，是 <code>main()</code> 函数。由于它本身只是一个普通的函数，因此反编译之后，逻辑并没有什么变化。</li>
<li><em>注释 2、3</em>，它们是 <code>Kotlin</code> 为 <code>block</code> 变量生成的静态变量以及方法。</li>
<li><em>注释 4</em>，<code>LaunchUnderTheHoodKt$block$1</code>，其实就是 <code>block</code> 具体的实现类。这个类继承自 <code>SuspendLambda</code>，而 <code>SuspendLambda</code> 是 <code>ContinuationImpl</code> 的子类，因此它也间接实现了 <code>Continuation</code> 接口。其中的 <code>invokeSuspend()</code>，也就是之前分析过的协程状态机逻辑。除此之外，它还有一个 <code>create()</code> 方法。</li>
<li><em>注释 5</em>，它对应了 <code>testStartCoroutine()</code> 这个方法，原本的 <code>block.startCoroutine(continuation)</code> 变成了“<code>ContinuationKt.startCoroutine(block, continuation)</code>”，这其实就体现出了扩展函数的原理。</li>
<li><em>注释 6</em>，其实就是 <code>continuation</code> 变量对应的匿名内部类。</li>
</ul>
<p><strong>接下来，对照着反编译代码，来分析整个代码的执行流程:</strong></p>
<p>首先，<code>main()</code> 函数会调用 <code>testStartCoroutine()</code> 函数，接着，就会调用 <code>startCoroutine()</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//        注意这里</span></span><br><span class="line"><span class="comment">//           ↓</span></span><br><span class="line">createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <em>代码段 6</em> 里，可以看到，在 <code>startCoroutine()</code> 当中，首先会调用 <code>createCoroutineUnintercepted()</code> 方法。它的源代码只存在一个声明，并没有具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    注意这里</span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中的 <strong><code>expect</code></strong>，可以把它理解为一种声明，由于 <code>Kotlin</code> 是面向多个平台的，具体的实现，就需要在特定的平台实现。所以在这里，就需要打开 <code>Kotlin</code> 的源代码，找到 <code>JVM</code> 平台 <em><a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/src/kotlin/coroutines/intrinsics/IntrinsicsJvm.kt">IntrinsicsJvm</a></em> 对应的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    1，注意这里</span></span><br><span class="line"><span class="comment">//       ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="comment">//             2，注意这里</span></span><br><span class="line">    <span class="comment">//               ↓</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注释 1</em> ，这个 <strong><code>actual</code></strong>，代表了 <code>createCoroutineUnintercepted()</code> 在 <code>JVM</code> 平台的实现。另外，可以看到，<code>createCoroutineUnintercepted()</code> 仍然还是一个扩展函数，</p>
<p><em>注释 2</em> 处的 <code>this</code>，其实就代表了前面 <em>代码段 3</em> 当中的 <code>block</code> 变量。结合 <em>代码段 5</em> 反编译出来的 <code>LaunchUnderTheHoodKt$block$1</code>，可以知道 <code>block</code> 其实就是 <code>SuspendLambda</code> 的子类，而 <code>SuspendLambda</code> 则是 <code>ContinuationImpl</code> 的子类。</p>
<p>因此，<em>注释 2</em> 处的 <code>(this is BaseContinuationImpl)</code> 条件一定是为 <code>true</code> 的。这时候，它就会调用 <code>create(probeCompletion)</code>。</p>
<p>然后，查看 <code>create()</code> 的源代码，会看到这样的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(completion: <span class="type">Continuation</span>&lt;*&gt;)</span></span>: Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;create(Continuation) has not been overridden&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在默认情况下，这个 <code>create()</code> 方法是会抛出异常的，它的提示信息是：<code>create()</code> 方法没有被重写！潜台词就是，<code>create()</code> 方法应该被重写！如果不被重写，就会抛出异常。<br>
那么，<code>create()</code> 方法是在哪里被重写的呢？答案其实就在 <em>代码段 5</em> 的<code>“LaunchUnderTheHoodKt$block$1”</code>这个 <code>block</code> 的实现类当中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">block</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function1</span>&lt;<span class="type">Continuation&lt;? super String</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    LaunchUnderTheHoodKt$block$<span class="number">1</span>(Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">1</span>, $completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">      Object <span class="keyword">object</span> = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">          <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>) == <span class="keyword">object</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span>; </span><br><span class="line">          DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span>.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1，注意这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@NotNull</span> Continuation&lt;? <span class="keyword">super</span> LaunchUnderTheHoodKt$block$<span class="number">1</span>&gt; $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Continuation&lt;<span class="built_in">Unit</span>&gt;)new LaunchUnderTheHoodKt$block$<span class="number">1</span>($completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@Nullable</span> Continuation&lt;?&gt; p1) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((LaunchUnderTheHoodKt$block$<span class="number">1</span>)create(p1)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，注意代码里的 <em>注释 1</em>，这个其实就是重写之后的 <code>create()</code> 方法。换句话说，<em>代码段 8</em> 当中的 <code>create(probeCompletion)</code>，最终会调用 <em>代码段 10</em> 的 <code>create()</code> 方法，它最终会返回 <code>“LaunchUnderTheHoodKt$block$1”</code>这个 <code>block</code> 实现类，对应的 <code>Continuation</code> 对象。</p>
<p><strong>这行代码，其实就对应着协程被创建的时刻。</strong></p>
<p>协程创建的逻辑就分析完了，再回到 <code>startCoroutine()</code> 的源码，看看它后续的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//                                           注意这里</span></span><br><span class="line"><span class="comment">//                                             ↓</span></span><br><span class="line">createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，<code>intercepted()</code> 这个方法的源代码，也需要去 <code>Kotlin</code> 的源代码当中找到对应的 <code>JVM</code> 实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>它是将 <code>Continuation</code> 强转成了 <code>ContinuationImpl</code>，调用了它的 <code>intercepted()</code>。由于 <code>this</code> 的类型是<code>“LaunchUnderTheHoodKt$block$1”</code>，它是 <code>ContinuationImpl</code> 的子类，所以这个类型转换一定可以成功。</p>
<p>接下来，看看 <code>ContinuationImpl</code> 的源代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span>(</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _context: CoroutineContext?</span><br><span class="line">) : BaseContinuationImpl(completion) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实就是通过 <code>ContinuationInterceptor</code>，对 <code>Continuation</code> 进行拦截，从而将程序的执行逻辑派发到特定的线程之上。</p>
<p>再看 <code>startCoroutine()</code> 的源码，看看它的最后一步 <code>resume(Unit)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//                                                   注意这里</span></span><br><span class="line"><span class="comment">//                                                      ↓</span></span><br><span class="line">createCoroutineUnintercepted(completion).intercepted().resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>resume(Unit)</code>，作用其实就相当于启动了协程。</p>
<p>现在为止 <code>startCoroutine()</code> 这个协程的基础 <code>API</code> 是启动协程的原理已明了。</p>
<h2><a href="#3-launch-是如何启动协程的" class="header-anchor">#</a><span id="3-launch-是如何启动协程的">3. <code>launch</code> 是如何启动协程的</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testLaunch()</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">World!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>反编译后代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">    testLaunch();</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> void testLaunch() &#123;</span><br><span class="line">    CoroutineScope scope = CoroutineScopeKt.CoroutineScope((CoroutineContext)JobKt.Job$default(<span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>));</span><br><span class="line">    BuildersKt.launch$default(scope, <span class="literal">null</span>, <span class="literal">null</span>, new LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>(<span class="literal">null</span>), <span class="number">3</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LaunchUnderTheHoodKt</span>$<span class="title">testLaunch</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function2</span>&lt;<span class="type">CoroutineScope, Continuation&lt;? super Unit</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>(Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">2</span>, $completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">      Object <span class="keyword">object</span> = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">          <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>) == <span class="keyword">object</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span>; </span><br><span class="line">          DelayKt.delay(<span class="number">1000L</span>, (Continuation)<span class="keyword">this</span>);</span><br><span class="line">          System.<span class="keyword">out</span></span><br><span class="line">            .println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);</span><br><span class="line">          System.<span class="keyword">out</span>.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation&lt;? <span class="keyword">super</span> LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>&gt; $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Continuation&lt;<span class="built_in">Unit</span>&gt;)new LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>($completion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@NotNull</span> CoroutineScope p1, <span class="meta">@Nullable</span> Continuation&lt;?&gt; p2) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((LaunchUnderTheHoodKt$testLaunch$<span class="number">1</span>)create(p1, p2)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>“LaunchUnderTheHoodKt$testLaunch$1”</code>这个类，它其实对应的就是 <code>launch</code> 当中的 <code>Lambda</code>。</p>
<p>为了让它们之间的对应关系更加明显，可以换一种写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    <span class="keyword">val</span> block: <span class="keyword">suspend</span> CoroutineScope.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    scope.launch(block = block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中的 <code>block</code>，其实就对应着<code>“LaunchUnderTheHoodKt$testLaunch$1”</code>这个类。这里的 <code>block</code>， <strong>本质上仍然是一个 <code>Continuation</code></strong>。</p>
<p>接下来，看看 <a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Builders.common.kt"><code>launch&#123;&#125;</code> 的源代码</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@file:JvmMultifileClass</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;BuildersKt&quot;</span>)</span><br><span class="line"><span class="meta">@file:OptIn</span>(ExperimentalContracts::<span class="keyword">class</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> kotlinx.coroutines</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码一共有三个注释：<br>
<em>注释 1</em>，<code>launch</code> 会根据传入的 <code>CoroutineContext</code> 创建出新的 <code>Context</code>。<br>
<em>注释 2</em>，<code>launch</code> 会根据传入的启动模式来创建对应的协程对象。这里有两种，一种是标准的，一种是懒加载的。<br>
<em>注释 3</em>，尝试启动协程。</p>
<p>跟进 <code>coroutine.start()</code> 这个方法，会进入 <code>AbstractCoroutine</code> 这个抽象类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCoroutine</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    initParentJob: <span class="built_in">Boolean</span>,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，其实就能看到，<code>Java</code> 当中有 <code>Thread.java</code> 对应线程的逻辑，而 <code>Kotlin</code> 协程当中，也有 <code>AbstractCoroutine.kt</code> <code>这个类对应协程的抽象逻辑。AbstractCoroutine</code> 有一个 <code>start()</code> 方法，专门用于启动协程。</p>
<p>继续跟进 <code>start(block, receiver, this)</code>，就会进入 <code>CoroutineStart.invoke()</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">CoroutineStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">invoke</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">T</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            DEFAULT -&gt; block.startCoroutineCancellable(completion)</span><br><span class="line">            ATOMIC -&gt; block.startCoroutine(completion)</span><br><span class="line">            UNDISPATCHED -&gt; block.startCoroutineUndispatched(completion)</span><br><span class="line">            LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 <code>invoke()</code> 方法当中，它会根据 <code>launch</code> 传入的启动模式，以不同的方式启动协程。当启动模式是 <code>ATOMIC</code> 的时候，就会调用 <code>block.startCoroutine(completion)</code>。而这个，其实就是研究过的 <code>startCoroutine()</code> 这个协程基础 <code>API</code>。</p>
<p>而另外两个方法，<code>startCoroutineUndispatched(completion)</code> 和 <code>startCoroutineCancellable(completion)</code>，它们只是在 <code>startCoroutine()</code> 的基础上增加了一些额外的功能而已。前者代表启动协程以后就不会被分发，后者代表启动以后可以响应取消。</p>
<p>然后，对于 <em>代码段 15</em> 的 <code>launch</code> 逻辑而言，由于没有传入特定的启动模式，因此，这里会执行默认的模式，也就是调用<code>“startCoroutineCancellable(completion)”</code>这个方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，通过查看 <code>startCoroutineCancellable()</code> 的源代码，可以发现，它最终还是会调用之前分析过的 <code>createCoroutineUnintercepted()</code>，而在它的内部，仍然会像之前分析过的，去调用 <code>create(probeCompletion)</code>，然后最终会调用 <em>代码段 16</em> 当中 <code>“LaunchUnderTheHoodKt$testLaunch$1”</code>的 <code>create()</code> 方法。</p>
<p>至此，<code>launch</code> 启动协程的整个过程，就已经分析完了。其实，<code>launch</code> 这个 <code>API</code>，只是对协程的基础元素 <code>startCoroutine()</code> 等方法进行了一些封装而已。</p>
<h1><a href="#五-参考" class="header-anchor">#</a><span id="五-参考">五、参考</span></h1>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/1.6.0/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt">coroutineCodegenUtil</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/src/kotlin/coroutines/intrinsics/IntrinsicsJvm.kt">JVM平台 IntrinsicsJvm</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Builders.common.kt">launch</a></p>
</li>
</ul>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-05-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码/" title="源码">源码 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/挂起函数/" title="挂起函数">挂起函数 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/launch/" title="launch">launch </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程基础元素/" title="协程基础元素">协程基础元素 </a><span class="leancloud_visitors"></span><span>大约13228个字, 44分钟5秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2023/05/30/kotlin学习系列十四/,Puppet,kotlin学习系列十四：协程源码篇二 协程创建,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%94/" title="kotlin学习系列十五：协程源码篇三 协程运行">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/" title="kotlin学习系列十三：协程源码篇一">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>