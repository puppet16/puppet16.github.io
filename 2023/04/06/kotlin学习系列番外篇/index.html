<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列番外篇 · Puppet</title><meta name="description" content="二、协程基本概念

3. kotlin协程的示例

1. 常规网络接口请求处理流程
2. 使用协程改造异步程序

1. 网络请求`API中添加挂起函数
2. 替换call.equeue方法
3. 通过多个用户名获取多个用户的数组






三、 协程的常见实现

1. 协程分类
2. 其它语言的常"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列番外篇</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%BA%8C-%E5%8D%8F%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">二、协程基本概念</a>
<ul>
<li><a href="#3-kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%A4%BA%E4%BE%8B">3. <code>kotlin</code>协程的示例</a>
<ul>
<li><a href="#1-%E5%B8%B8%E8%A7%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">1. 常规网络接口请求处理流程</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E6%94%B9%E9%80%A0%E5%BC%82%E6%AD%A5%E7%A8%8B%E5%BA%8F">2. 使用协程改造异步程序</a>
<ul>
<li><a href="#1-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82api%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">1. 网络请求`API中添加挂起函数</a></li>
<li><a href="#2-%E6%9B%BF%E6%8D%A2callequeue%E6%96%B9%E6%B3%95">2. 替换<code>call.equeue</code>方法</a></li>
<li><a href="#3-%E9%80%9A%E8%BF%87%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E5%90%8D%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%95%B0%E7%BB%84">3. 通过多个用户名获取多个用户的数组</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0">三、 协程的常见实现</a>
<ul>
<li><a href="#1-%E5%8D%8F%E7%A8%8B%E5%88%86%E7%B1%BB">1. 协程分类</a></li>
<li><a href="#2-%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0">2. 其它语言的常见协程实现</a>
<ul>
<li><a href="#1-python%E7%9A%84generator">1. <code>Python</code>的<code>Generator</code></a></li>
<li><a href="#2-lua%E7%9A%84coroutine">2. <code>Lua</code>的<code>Coroutine</code></a></li>
<li><a href="#3-go%E7%9A%84routine">3. <code>Go</code>的<code>routine</code></a></li>
<li><a href="#4-asyncawait%E5%85%B3%E9%94%AE%E5%AD%97">4. <code>async/await</code>关键字</a>
<ul>
<li><a href="#1-javascript%E7%9A%84%E4%BD%BF%E7%94%A8">1. JavaScript的使用</a></li>
<li><a href="#2-asyncawait%E5%92%8Csuspend%E7%9A%84%E5%8C%BA%E5%88%AB">2. <code>async/await</code>和<code>suspend</code>的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0">四、<code>Kotlin</code>协程的基本要素</a>
<ul>
<li><a href="#1-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D">1. 协程的挂起和恢复</a>
<ul>
<li><a href="#1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E">1. 相关概念说明</a></li>
<li><a href="#2-%E5%9C%A8%E6%8C%82%E8%B5%B7%E6%97%B6%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E5%90%84%E8%87%AA%E6%93%8D%E4%BD%9C">2. 在挂起时线程和协程各自操作</a></li>
<li><a href="#3-%E6%8C%82%E8%B5%B7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">3. 挂起实现原理</a></li>
<li><a href="#4-suspend%E6%8C%82%E8%B5%B7%E6%80%BB%E7%BB%93">4. <code>suspend</code>挂起总结</a></li>
</ul>
</li>
<li><a href="#2-continuation">2. <code>Continuation</code></a>
<ul>
<li><a href="#1-continuation%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81">1. <code>Continuation</code>部分源码</a></li>
<li><a href="#2-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E4%B8%8Econtinuation%E5%85%B3%E7%B3%BB">2. 挂起函数与<code>Continuation</code>关系</a></li>
<li><a href="#3-%E5%B0%86%E5%9B%9E%E8%B0%83%E8%BD%AC%E4%B8%BA%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">3. 将回调转为挂起函数</a></li>
</ul>
</li>
<li><a href="#3-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">3. 协程的创建</a>
<ul>
<li><a href="#1-createcoroutine%E6%96%B9%E6%B3%95">1. <code>createCoroutine()</code>方法</a></li>
</ul>
</li>
<li><a href="#4-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8">4. 协程启动</a>
<ul>
<li><a href="#1-resume">1. <code>resume</code></a></li>
<li><a href="#2-startcoroutine">2. <code>startCoroutine</code></a></li>
</ul>
</li>
<li><a href="#5-%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87">5. 协程上下文</a>
<ul>
<li><a href="#1-continuationinterceptor">1. <code>ContinuationInterceptor</code></a></li>
</ul>
</li>
<li><a href="#6-continuation%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F">6. <code>Continuation</code>执行示意</a>
<ul>
<li><a href="#1-suspendlambda">1. <code>SuspendLambda</code></a></li>
<li><a href="#2-safecontinuation">2. <code>SafeContinuation</code></a></li>
<li><a href="#3-%E5%8A%A0%E5%85%A5intetcepted%E6%8B%A6%E6%88%AA%E5%99%A8">3. 加入<code>Intetcepted</code>拦截器</a></li>
<li><a href="#4-%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E6%81%A2%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F">4. 协程挂起恢复执行示意</a></li>
</ul>
</li>
<li><a href="#7-%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6">7. 协程的线程调度</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E5%99%A8sequence%E5%AE%9E%E7%8E%B0generator">五、示例–使用标准库的序列生成器<code>Sequence</code>实现<code>Generator</code></a>
<ul>
<li><a href="#1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">1. 代码实现</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8sequence%E5%AE%9E%E7%8E%B0">2. 使用<code>sequence</code>实现</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E7%A4%BA%E4%BE%8B-%E4%BB%BF-lua-%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8D%8F%E7%A8%8B-api">六、 示例-- 仿 <code>Lua</code> 协程实现非对称协程 <code>API</code></a></li>
<li><a href="#%E4%B8%83-%E7%A4%BA%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8D%8F%E7%A8%8Bapi%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%B0%E5%8D%8F%E7%A8%8B">七、 示例-- 基于非对称协程<code>API</code>实现对称协程</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">1. 实现思路</a></li>
<li><a href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2. 代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E7%A4%BA%E4%BE%8B-%E4%BB%BFgo%E7%9A%84channel%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E9%80%9A%E4%BF%A1">八、 示例–仿<code>Go</code>的<code>channel</code>实现协程通信</a></li>
<li><a href="#%E5%85%AB-%E7%A4%BA%E4%BE%8B-%E4%BB%BFjs%E5%AE%9E%E7%8E%B0async-await">八、 示例–仿<code>Js</code>实现<code>async await</code></a></li>
<li><a href="#%E4%B9%9D-%E5%BB%B6%E4%BC%B8-%E6%8F%AD%E7%A7%98-suspend-fun-main">九、延伸–揭秘 <code>suspend fun main</code></a>
<ul>
<li><a href="#1-%E6%99%AE%E9%80%9A%E7%9A%84main%E5%87%BD%E6%95%B0">1. 普通的<code>main</code>函数</a></li>
<li><a href="#2-%E5%8F%AF%E6%8C%82%E8%B5%B7%E7%9A%84main%E5%87%BD%E6%95%B0">2. 可挂起的<code>main</code>函数</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">十、参考文章</a></li>
<li><a href="#%E4%BA%8C-%E7%A4%BA%E4%BE%8B-%E4%BB%BF%E5%AE%98%E6%96%B9%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0launch">二、示例–仿官方框架实现<code>launch</code></a>
<ul>
<li><a href="#1-%E5%8D%8F%E7%A8%8B%E5%9B%9E%E9%A1%BE">1. 协程回顾</a>
<ul>
<li><a href="#1-%E5%8D%8F%E7%A8%8B%E5%88%9B%E5%BB%BA">1. 协程创建</a></li>
<li><a href="#2-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8">2. 协程启动</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#二-协程基本概念" class="header-anchor">#</a><span id="二-协程基本概念">二、协程基本概念</span></h1>
<h2><a href="#3-kotlin协程的示例" class="header-anchor">#</a><span id="3-kotlin协程的示例">3. <code>kotlin</code>协程的示例</span></h2>
<p><span id="jumpNetSample"></span></p>
<h3><a href="#1-常规网络接口请求处理流程" class="header-anchor">#</a><span id="1-常规网络接口请求处理流程">1. 常规网络接口请求处理流程</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//网络接口请求返回数据</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: String, <span class="keyword">val</span> name: String, <span class="keyword">val</span> url: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//网络请求API</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubApi</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserCallback</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;login&quot;</span>)</span> login: <span class="type">String</span>)</span></span>: Call&lt;User&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建retrofit网络请求实例</span></span><br><span class="line"><span class="keyword">val</span> githubApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .client(OkHttpClient.Builder().addInterceptor(Interceptor &#123;</span><br><span class="line">                it.proceed(it.request()).apply &#123;</span><br><span class="line">                    println(<span class="string">&quot;request: <span class="variable">$code</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build())</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubApi::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//请求结果处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showUser</span><span class="params">(user:<span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    println(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求结果处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">    t.printStackTrace(System.<span class="keyword">out</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> call = githubApi.getUserCallback(<span class="string">&quot;puppet16&quot;</span>)</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            showError(t)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">            response.body()?.let(::showUser) ?: showError(NullPointerException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>创建了一个名为<code>GitHubApi</code>的网络请求<code>API</code>，其中有一个<code>getUser()</code>方法用于获取<code>GitHub</code>的用户信息，该方法返回一个带泛型<code>User</code>的<code>Call</code>。若要拿到<code>User</code>数据，则有两种方法：一是使用<code>enqueue</code>方法，也就是传进一个<code>Callback</code>回调；二是阻塞的调用，但是在主线程是明显不合适。</li>
<li>通过<code>retrofit</code>创建网络请求<code>API</code>的实例<code>githubApi</code>，其中添加拦截器用于打印网络请求返回码，设置了网络请求地址域名为<code>https://api.github.com</code>，再设置了返回的结果使用<code>Gson</code>解析。</li>
<li>再创建了两个请求结果处理函数<code>showUser()</code>、<code>showError()</code>，用于处理接口请求成功及请求失败的逻辑</li>
<li>最后在<code>main()</code>函数中，通过<code>githubApi</code>获取网络请求返回的<code>Call</code>，再调用<code>Call</code>的<code>equeue</code>方法，传入一个<code>Callback</code>，再在<code>Callback</code>的两个方法中分别调用请求结果处理函数<code>showUser()</code>、<code>showError()</code></li>
<li><code>call.equeue()</code>方法是个异步方法，该异步方法回调到主流程后会调用<code>showUser()</code>或是调用<code>showError()</code>，如此异步方法将主流程分裂成了两个分支</li>
</ol>
<p><strong>问题：</strong> 如果传入多个<code>GitHub</code>的用户名称，使用<code>forEach</code>方法每个名称调用一次网络请求，可以获取多个对应<code>User</code>的结果，但是传入的是名称的数组，无法将多个<code>User</code>放到一个数组中</p>
<h3><a href="#2-使用协程改造异步程序" class="header-anchor">#</a><span id="2-使用协程改造异步程序">2. 使用协程改造异步程序</span></h3>
<h4><a href="#1-网络请求api中添加挂起函数" class="header-anchor">#</a><span id="1-网络请求api中添加挂起函数">1. 网络请求`API中添加挂起函数</span></h4>
<p>在网络请求<code>API</code>，添加如下方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubApi</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserSuspend</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;login&quot;</span>)</span> login: <span class="type">String</span>)</span></span>: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>添加了一个<code>getUserSuspend()</code>方法，该方法使用了关键字 <strong><code>suspend</code></strong> 修饰，表示该方法为 <strong>挂起函数</strong></li>
<li>该函数返回结果为<code>User</code>对象</li>
</ol>
<h4><a href="#2-替换callequeue方法" class="header-anchor">#</a><span id="2-替换callequeue方法">2. 替换<code>call.equeue</code>方法</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = githubApi.getUserSuspend(name)</span><br><span class="line">    showUser(user)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    showError(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>使用如上方法替换之前的网络请求</li>
<li><code>githubApi.getUserSuspend()</code>是一个挂起函数，调用到该条语句时该函数会挂起，直到返回结果再回到该线程中。此时已经获得了网络请求的结果，若请求正常返回了<code>user</code>，则直接显示信息，否则显示错误信息</li>
<li>如此网络请求的后的异步操作变成了同步操作</li>
</ol>
<h4><a href="#3-通过多个用户名获取多个用户的数组" class="header-anchor">#</a><span id="3-通过多个用户名获取多个用户的数组">3. 通过多个用户名获取多个用户的数组</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = arrayOf(<span class="string">&quot;abreslav&quot;</span>,<span class="string">&quot;udalov&quot;</span>, <span class="string">&quot;yole&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> users = names.map &#123; name -&gt;</span><br><span class="line">    githubApi.getUserSuspend(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>通过<code>map</code>方法，每个用户名都进行一次网络操作，之后将网络操作的结果组合成一个列表返回</li>
</ol>
<h1><a href="#三-协程的常见实现" class="header-anchor">#</a><span id="三-协程的常见实现">三、 协程的常见实现</span></h1>
<h2><a href="#1-协程分类" class="header-anchor">#</a><span id="1-协程分类">1. 协程分类</span></h2>
<ul>
<li>按调用栈
<ul>
<li>有栈协程：每个协程会分配单独的调用栈，类似线程的调用栈，可以在任意函数嵌套中挂起</li>
<li>无栈协程：不会分配单独的调用栈，挂起点状态通过闭包或对象保存，只能在当前函数中挂起，无法嵌套函数实现挂起</li>
</ul>
</li>
<li>按调用关系
<ul>
<li>对称协程：调度权可以转移给任意协程，协程之间是对等关系</li>
<li>非对称协程：调度权只能转移给调用自己的协程，协程存在父子关系</li>
</ul>
</li>
</ul>
<p><strong><code>Kotlin</code>中的是无栈的非对称协程</strong></p>
<h2><a href="#2-其它语言的常见协程实现" class="header-anchor">#</a><span id="2-其它语言的常见协程实现">2. 其它语言的常见协程实现</span></h2>
<p><strong>协程的关键：</strong> 挂起、恢复</p>
<p><span id="jumpGenerator"></span></p>
<h3><a href="#1-python的generator" class="header-anchor">#</a><span id="1-python的generator">1. <code>Python</code>的<code>Generator</code></span></h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numbers</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen = numbers()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[0]<span class="subst">&#123;<span class="built_in">next</span>(gen)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[1]<span class="subst">&#123;<span class="built_in">next</span>(gen)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]<span class="number">0</span></span><br><span class="line">[<span class="number">1</span>]<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Python</code>因其语法简单，不需要额外配置环境等而号称是最简单的语言</li>
<li><code>Python</code>通过缩进定义作用域</li>
<li>定义了一个函数<code>numbers()</code>，函数中创建一个死循环，<code>yield</code>函数有挂起的含义，表示不再执行下面的代码，该条语句后面是将<code>i</code>自加1</li>
<li>调用函数<code>numbers()</code>返回的是一个<code>generator</code>，<code>generator</code>有<code>next()</code>方法，在<code>python</code>中<code>next(gen)</code>语句表示调用<code>generator</code>的<code>next()</code>方法，调用这条语句时才会真正执行<code>numbers()</code>里的代码</li>
<li>执行到第一条打印语句时，才会真正开始执行<code>numbers()</code>里的代码：先给<code>i</code>赋值为0，再进入死循环，之后执行到<code>yield i</code>，将这个函数挂起，再将<code>i</code>的值抛给了调用的位置，即<code>next(gen)</code>得到的是<code>i</code>的值，此时<code>i</code>的值为0</li>
<li>之后开始执行第二条打印语句，如此又开始执行<code>numbers()</code>函数里的<code>yield i</code>语句后的代码，将<code>i</code>值加一，因在列循环中，所以再次执行到了<code>yield i</code>，如此第二条打印语句的<code>next(gen)</code>得到了<code>i</code>的值，此时<code>i</code>的值为1</li>
<li><code>Python</code>的<code>Generator</code>是无栈的非对称协程</li>
</ol>
<p><span id="jumpLua"></span></p>
<h3><a href="#2-lua的coroutine" class="header-anchor">#</a><span id="2-lua的coroutine">2. <code>Lua</code>的<code>Coroutine</code></span></h3>
<ul>
<li>创建协程：<code>coroutine.create(&lt;function&gt;)</code>，传入一个函数</li>
<li>查询协程：<code>coroutine.status(&lt;Coroutine-Object&gt;)</code>，传入一个协程对象</li>
<li>挂起协程：<code>coroutine.yield(&lt;Values-to-Yield&gt;)</code>，可以传入一些值</li>
<li>恢复协程：<code>coroutine.resume(&lt;Coroutine-Object&gt;)</code>，传入协程对象</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send&quot;</span>..i)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End Producer&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;receive&quot;</span>..value)</span><br><span class="line">        value = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">    <span class="keyword">until</span>(<span class="keyword">not</span> value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;EndConsumer&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producerCoroutine = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(producer)</span><br><span class="line">consumerCoroutine = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(consumer)</span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">status</span>,product = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(producerCoroutine)</span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(consumerCoroutine,product)</span><br><span class="line"><span class="keyword">until</span>(<span class="keyword">not</span> <span class="built_in">status</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End Main&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">send0</span><br><span class="line">receive0</span><br><span class="line">send1</span><br><span class="line">receive1</span><br><span class="line">send2</span><br><span class="line">receive2</span><br><span class="line">send3</span><br><span class="line">receive3</span><br><span class="line">End Producer</span><br><span class="line">EndConsumer</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义了函数<code>producer()</code>，其中创建一个循环四次的<code>for</code>循环<code>yeild</code>值<code>i</code></li>
<li>定义了函数<code>consumer()</code>，该函数接收值<code>value</code>，创建一个条件循环当没有<code>value</code>值时停止循环，循环体内打印该值，然后将协程的<code>yield()</code>携带的值赋值给<code>value</code></li>
<li>主调用中操作：
<ol>
<li>先根据那两个函数创建出两个协程：<code>producerCoroutine</code>、<code>consumerCoroutine</code></li>
<li>创建一个条件循环，直到<code>status</code>为<code>false</code>时停止</li>
<li>循环体内先执行协程<code>producerCoroutine</code>中的函数<code>producer</code>：执行函数<code>producer</code>中的<code>for</code>循环，每次循环都打印信息，再通过<code>coroutine.yield(i)</code>方法将当前协程挂起并将<code>i</code>值丢出去</li>
<li>此时因为协程<code>producerCoroutine</code>还没执行完，所以<code>status</code>为<code>true</code>，而<code>product</code>值是<code>yield</code>出来的<code>i</code>值</li>
<li>之后执行协程<code>consumerCoroutine</code>中的函数<code>consumer</code>，并将<code>product</code>值作为入参传入函数中：进入函数内的循环，打印接收的值，之后将当前协程挂起</li>
<li>此时<code>status</code>值还是<code>true</code>，再次开始主调用循环：即再次执行协程<code>producerCoroutine</code>中的函数<code>producer</code>。走到函数<code>producer</code>中的循环执行完毕，<code>status</code>的值变为<code>false</code>，主调用结束</li>
</ol>
</li>
<li>调用<code>resume</code>时，会将<code>resume</code>的其它参数作为入参传入到协程的函数中</li>
<li><code>Lua</code>中<code>..</code>有拼接字符串的意思</li>
<li><code>Lua</code>的协程是 <strong>有栈的非对称协程</strong></li>
</ol>
<p><span id="jumpGoRoutine"></span></p>
<h3><a href="#3-go的routine" class="header-anchor">#</a><span id="3-go的routine">3. <code>Go</code>的<code>routine</code></span></h3>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决<br>
非对称协程的调度权只能转移给调用自己的协程，而对称协程的调度权可以转移给任意协程。<br>
对称协程是基于非对称协程的实现：在两个非对称协程中添加一个中间层调度中心就可以实现对称协程</p>
</blockquote>
<ol>
<li>
<p><code>Go</code>语言的<code>Coroutine</code>是对称协程，它实现对称协程的中间层<code>channel</code>。</p>
</li>
<li>
<p><code>Channel</code>是<code>Go</code>中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯。</p>
</li>
<li>
<p><code>Channel</code>的操作符是箭头 <strong>&lt;-</strong>。该操作符代表channel的方向。如果没有指定方向，那么<code>Channel</code>就是双向的，既可以接收数据，也可以发送数据</p>
</li>
<li>
<p>使用 <code>go</code> 语句开启一个新的运行期线程，即 <code>goroutine</code>，以一个不同的、新创建的 <code>goroutine</code> 来执行一个函数。 同一个程序中的所有 <code>goroutine</code> 共享同一个地址空间</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送值v到Channel ch中</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从Channel ch中接收数据，并将数据赋值给v</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="type">int</span> = channel</span><br><span class="line">    <span class="keyword">var</span> writeChannel <span class="keyword">chan</span> &lt;- <span class="type">int</span> = channel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;write&quot;</span>,i)</span><br><span class="line">            writeChannel &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(writeChannel)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;read end&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    now := time.Now()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    latency := time.Since(now).Seconds()</span><br><span class="line">    fmt.Println(latency)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wait <span class="keyword">for</span> read</span><br><span class="line">write <span class="number">0</span></span><br><span class="line">write <span class="number">1</span></span><br><span class="line">read <span class="number">0</span></span><br><span class="line">read <span class="number">1</span></span><br><span class="line">write <span class="number">2</span></span><br><span class="line">read <span class="number">2</span></span><br><span class="line">read end</span><br><span class="line"><span class="number">5.000133976</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>:=</code>是赋值符号。<code>make(chan int)</code>语句创建了一个<code>channel</code>，该<code>channel</code>类型是<code>int</code>，即<code>channel</code>可以传递的元素是<code>int</code>，没有指定方向，这个<code>channel</code>是双向的</li>
<li>声明一个变量<code>readChannel</code>，类型是一个单向的<code>channel</code>，<code>channel</code>只可以发送数据，即只能取到<code>channel</code>里的数据</li>
<li>声明一个变量<code>writeChannel</code>，类型是一个单向的<code>channel</code>，<code>channel</code>只可以接收数据，即只能往<code>channel</code>里放数据</li>
<li>定义了两个函数，并直接使用<code>go</code>语句开启两个新的运行期线程来分别执行这两个函数</li>
<li>第一个函数功能：定义一个<code>for</code>循环，循环体先打印信息，再将<code>i</code>的值放到<code>writeChannel</code>中，最后关闭</li>
<li>第二个函数功能：先打印信息。再定义了一个<code>for</code>循环，循环内打印从<code>writeChannel</code>取出的数据</li>
<li>因为主程序退出的太快了，所以最后添加了一个5秒的延时，否则两个协程的信息打印不出来。</li>
<li>结论：
<ol>
<li>每个<code>go routine</code> 都是并发或并行执行</li>
<li>无<code>Buffer</code>的<code>Channel</code>写时会挂起，直到读取，反之亦然</li>
<li><strong><code>go routine</code> 可以认为是一种有栈对称协程的实现</strong></li>
</ol>
</li>
</ol>
<p><span id="jumpJsAsync"></span></p>
<h3><a href="#4-asyncawait关键字" class="header-anchor">#</a><span id="4-asyncawait关键字">4. <code>async/await</code>关键字</span></h3>
<blockquote>
<p>支持这两个关键字的语言有：JavaScript Es 2016(ES7)、C# 5.0、Python 3.5、Rust 1.39.0等等</p>
</blockquote>
<h4><a href="#1-javascript的使用" class="header-anchor">#</a><span id="1-javascript的使用">1. JavaScript的使用</span></h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常调用该网络请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> userPromise = <span class="title function_">getUser</span>(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    userPromise.<span class="title function_">then</span>(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用这两个关键字调用网络请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义一个名为<code>getUser()</code>的函数，入参为<code>name</code>，用于获取<code>GitHub</code>上某用户的公开信息</li>
<li><code>Axios</code> 是一个基于 <code>promise</code> 的 <code>HTTP</code> 库，返回类型为<code>Promise&lt;AxiosResponse&lt;T&gt;&gt;</code>，类似于<code>Retrofit</code>。官网：<a target="_blank" rel="noopener" href="http://www.axios-js.com/">http://www.axios-js.com/</a></li>
<li>若要正常调用网络请求的函数<code>getUser()</code>，需要使用<code>.then()</code>和<code>.catch()</code>添加回调，这是一个异步的调用</li>
<li>而使用关键字<code>async</code>和<code>await</code>调用网络请求函数<code>getUser()</code>，这是个同步的操作，不需要添加回调</li>
<li>关于<code>async/await</code>的总结：
<ol>
<li>可以多层嵌套，但必须为<code>async function</code></li>
<li><strong><code>async/await</code>是一种无线非对称的协程实现</strong></li>
<li><code>async/await</code>是目前各类语言支持最广泛的特性</li>
</ol>
</li>
</ol>
<h4><a href="#2-asyncawait和suspend的区别" class="header-anchor">#</a><span id="2-asyncawait和suspend的区别">2. <code>async/await</code>和<code>suspend</code>的区别</span></h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js中使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin中使用</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> user = githubApi.getUserSuspend(name)</span><br><span class="line">        showUser(user)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>kotlin</code>中使用修饰于函数上的关键字<code>suspend</code>实现调用网络请求时的同步操作，而<code>sync/await</code>需要两个关键字</li>
</ol>
<h1><a href="#四-kotlin协程的基本要素" class="header-anchor">#</a><span id="四-kotlin协程的基本要素">四、<code>Kotlin</code>协程的基本要素</span></h1>
<h2><a href="#1-协程的挂起和恢复" class="header-anchor">#</a><span id="1-协程的挂起和恢复">1. 协程的挂起和恢复</span></h2>
<h3><a href="#1-相关概念说明" class="header-anchor">#</a><span id="1-相关概念说明">1. 相关概念说明</span></h3>
<p><strong>挂起函数：</strong> 即使用<code>suspend</code>关键字修饰的函数。</p>
<ol>
<li><code>suspend</code> 是有暂停的意思，但在协程中应该理解为：当线程执行到协程的 <code>suspend</code> 函数的时候，暂时不继续执行协程代码了。</li>
<li>挂起函数只能在 <strong>其他挂起函数</strong> 或 <strong>协程</strong> 中调用</li>
<li>协程在执行到某一个<code>suspend</code>函数的时候，这个<strong>协程会被挂起 <em>(即挂起的对象是协程)</em></strong>，也就是说 <strong>这个协程从正在执行它的线程上脱离</strong>，此时当前线程不再关心协程进行什么操作</li>
<li>挂起函数调用时包含了协程 <strong>挂起</strong>的语义</li>
<li>挂起函数返回时包含了协程 <strong>恢复</strong>的语义</li>
<li>挂起函数的类型是在一般函数类型前加一个<code>suspend</code>
<table>
<thead>
<tr>
<th>函数</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>suspend fun foo(){}</td>
<td>suspend () -&gt; Unit</td>
</tr>
<tr>
<td>suspend fun bar(a:Int):String { <br>      return “Hello”<br>}</td>
<td>suspend (Int) -&gt; String</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p><strong>挂起点：</strong> 挂起函数的调用处称为挂起点，在<code>Android Studio</code>中，挂起点位置有如下图标显示：<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/starting_point_pic.png" alt></p>
<p><strong>协程：</strong> 可以使用 <code>launch</code> 或者 <code>async</code> 函数启动一个协程，协程其实就是这两个函数中 <strong>闭包的代码块</strong></p>
<h3><a href="#2-在挂起时线程和协程各自操作" class="header-anchor">#</a><span id="2-在挂起时线程和协程各自操作">2. 在挂起时线程和协程各自操作</span></h3>
<p><strong>在挂起点时线程操作：</strong></p>
<ol>
<li>线程执行到了协程的代码块中的 <code>suspend</code> 函数时，就暂时不再执行剩余的协程代码，跳出协程的代码块。</li>
<li>此时若线程是一个后台线程，则跟 <code>Java</code> 线程池里的线程在工作结束之后是完全一样的：回收或者再利用。</li>
<li>若线程是一个<code>Android</code>主线程，那它接下来就会继续执行本职工作：也就是一秒钟60次的界面刷新任务</li>
</ol>
<p><strong>在挂起点时协程操作：</strong></p>
<ol>
<li>线程的代码在到达 <code>suspend</code> 函数的时候被掐断，接下来协程会从这个 <code>suspend</code> 函数开始继续往下执行，不过是在 <code>suspend</code> 函数指定的线程中执行。</li>
<li><code>suspend</code> 函数通过<code>Dispatchers</code> 调度器来指定线程。<code>Dispatchers</code>调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行</li>
<li>常用的 <code>Dispatchers</code>有以下三种
<ul>
<li><code>Dispatchers.Main</code>：<code>Android</code> 中的主线程</li>
<li><code>Dispatchers.IO</code>：针对磁盘和网络 <code>IO</code> 进行了优化，适合 <code>IO</code> 密集型的任务，比如：读写文件，操作数据库以及网络请求</li>
<li><code>Dispatchers.Default</code>：适合 <code>CPU</code> 密集型的任务，比如计算</li>
</ul>
</li>
<li>在 <code>suspend</code> 函数执行完成之后，<strong>协程会自动帮我们把线程再切回来</strong></li>
</ol>
<p><strong>挂起时线程和协程操作流程总结：</strong></p>
<ol>
<li>我们的协程原本是运行在某线程的。当代码遇到 <code>suspend</code> 函数的时候，会被 <code>suspend</code> 也就是被挂起，而所谓的被挂起，就是线程切换，根据 <code>Dispatchers</code> 切换到其它线程执行<code>suspend</code>函数。当这个<code>suspend</code>函数执行完毕后，协程会重新切换回一开始的线程</li>
<li>切回原线程的操作在 <code>Kotlin</code> 里叫做 <strong>恢复 <em>(resume)</em></strong>， 也就是协程会帮我们再 <code>post</code> 一个 <code>Runnable</code>，让协程中剩下的代码继续回到一开始的线程中执行</li>
<li>简单来讲，在 <code>Kotlin</code> 中所谓的 <strong>挂起，就是一个稍后会被自动切回来的线程调度操作</strong></li>
<li>挂起之后需要恢复，而 <strong>恢复这个功能是协程的</strong>，如果你不在协程里面调用，恢复这个功能没法实现，所以挂起函数必须在协程或者另一个挂起函数里被调用</li>
<li>因为一个挂起函数要么在协程里被调用，要么在另一个挂起函数里被调用，所以它其实直接或者间接地，总是会在一个协程里被调用</li>
<li>所以要求 <code>suspend</code> 函数只能在协程里或者另一个 <code>suspend</code> 函数里被调用，是为了要让协程能够在 <code>suspend</code> 函数切换线程之后再切回来，若在一般函数中调用了<code>suspend</code>函数，<code>IDE</code>会报错：<code>Suspend function 'XXX' should be called only from a coroutine or another suspend function</code></li>
<li>挂想和恢复可以控制执行流程的转移</li>
<li>异步逻辑可以用同步代码的形式写出</li>
<li>同步代码比异步代码更灵活，更容易实现复杂业务</li>
</ol>
<h3><a href="#3-挂起实现原理" class="header-anchor">#</a><span id="3-挂起实现原理">3. 挂起实现原理</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendingPrint</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    println(<span class="string">&quot;Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上声明了一个挂起函数<code>suspendingPrint()</code>，函数功能是打印当前线程</li>
<li><code>withContext()</code>函数是一个挂起函数，接收一个 <code>Dispatcher</code> 参数，依赖这个 <code>Dispatcher</code> 参数的指示，协程被挂起，然后切到别的线程</li>
<li>真正挂起协程是 <code>Kotlin</code> 的协程框架帮我们实现的。所以我们想要自己写一个挂起函数，除了加上 <code>suspend</code> 关键字还要函数内部直接或间接地调用到 <code>Kotlin</code> 协程框架自带的 <code>suspend</code> 函数才行</li>
</ol>
<h3><a href="#4-suspend挂起总结" class="header-anchor">#</a><span id="4-suspend挂起总结">4. <code>suspend</code>挂起总结</span></h3>
<ol>
<li><code>suspend</code> 关键字并不是用来操作挂起的，挂起的操作依赖的是挂起函数里面的实际代码。该关键字其实是函数的创建者对函数的使用者的提醒：这是一个耗时函数，它被创建者用挂起的方式放在后台运行，所以请在协程里调用该函数</li>
<li>若创建了 <code>suspend</code> 函数但它内部不包含真正的挂起逻辑，<code>IDE</code>会给你提示一个警告：<code>redundant suspend modifier</code> <em>(冗余的“redundant”修饰符)</em></li>
<li><code>suspend</code> 关键字限制函数只能在协程里被调用，如果在非协程的代码中调用，就会编译不通过</li>
<li>创建一个 <code>suspend</code> 函数，为了让它包含真正挂起的逻辑，要在它内部直接或间接调用 <code>Kotlin</code> 自带的 <code>suspend</code> 函数，自定义的 <code>suspend</code> 函数才是有意义的</li>
<li><code>suspend</code> 函数用于处理比较耗时也就是要等的操作。耗时操作一般分为两类：<code>I/O</code> 操作和 <code>CPU</code> 计算工作。比如文件的读写、网络交互、图片的模糊处理，都是耗时的，通通可以把它们写进 <code>suspend</code> 函数里</li>
<li><code>suspend</code> 函数的另一个应用场景是操作本身做起来并不慢，但它需要等待，比如 5 秒钟之后再做这个操作</li>
<li><code>withContext()</code>函数是在挂起函数里功能最简单直接：把线程自动切走和切回</li>
<li><code>delay()</code>函数等待一段时间后再继续往下执行代码</li>
<li><strong>挂起，就是一个稍后会被自动切回来的线程调度操作</strong></li>
<li>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cpcpcp123/article/details/111724079">kotlin协程的挂起suspend</a></li>
</ol>
<h2><a href="#2-continuation" class="header-anchor">#</a><span id="2-continuation">2. <code>Continuation</code></span></h2>
<p>因为 <strong><code>Kotlin</code>中的协程是无栈的</strong>，没有栈去保存挂起点的状态，而是通过<code>Continuation</code>接口实现了挂起点状态的保存，实现这个接口的类，具有可以暂停和继续的能力。</p>
<h3><a href="#1-continuation部分源码" class="header-anchor">#</a><span id="1-continuation部分源码">1. <code>Continuation</code>部分源码</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin.coroutines</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">    resumeWith(Result.success(value))</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">    resumeWith(Result.failure(exception))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Continuation</code> 定义了一个回调方法：<code>resumeWith()</code>：恢复执行相应的协程，将成功或失败的结果传递给挂起点返回值</li>
<li><code>Continuation</code>接口有两个扩展方法：
<ol>
<li><code>resume()</code>：恢复执行相应的协程，传递对应值作为挂起点的返回值。</li>
<li><code>resumeWithException()</code>：恢复执行相应的协程，以便在挂起点之后立即重新抛出错误</li>
<li><code>resume()</code>与<code>resumeWithException()</code>都调用的<code>resumeWith()</code>方法</li>
</ol>
</li>
<li>该源码是<code>1.3</code>版本之后的</li>
</ol>
<h3><a href="#2-挂起函数与continuation关系" class="header-anchor">#</a><span id="2-挂起函数与continuation关系">2. 挂起函数与<code>Continuation</code>关系</span></h3>
<p>每个挂起函数编译后会增加一个 <code>Continuation</code> 类型的参数。每个挂起函数都有一个回调自己的 <code>Continuation</code> 实现类，并且这个类会被传递给这个挂起函数所调用的其它挂起函数，这些子方法可以通过 <code>Continuation</code> 回调父方法以恢复暂停的程序</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">(a:<span class="type">Int</span>)</span></span>:String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的两个函数本质上其内容如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(continuation:<span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span>:Any&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">(a:<span class="type">Int</span>, continuation:<span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>:Any&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>一开始两个函数的类型分别为<code>suspend () -&gt; Unit</code>、<code>suspend (Int) -&gt; String</code></li>
<li>如上挂起函数在编译后会增加一个 <code>Continuation</code>类型的入参，<code>Continuation</code>中的泛型是挂起函数的返回值类型，而挂起函数的返回值类型变为了<code>Any</code>，<code>Any</code>有两层含义：
<ol>
<li>若该挂起函数没有挂起，跟普通函数没有区别，则<code>Any</code>是承载真正的返回值结果的</li>
<li>若该挂起函数挂起，需要通过回调返回结果，则<code>Any</code>返回的是一个挂起标志：<code>COROUTINE_SUSPENDED</code></li>
</ol>
</li>
<li>如此调用挂起函数时一定要传入一个<code>Continuation</code>参数，而传递<code>Continuation</code>参数是编译器完成的，所以当前调用挂起函数的位置一定要有一个<code>Continuation</code>参数实例才可被作为参数传入，因此 <strong>挂起函数只能在挂起函数或协程中调用</strong></li>
</ol>
<h3><a href="#3-将回调转为挂起函数" class="header-anchor">#</a><span id="3-将回调转为挂起函数">3. 将回调转为挂起函数</span></h3>
<p>通过将 <a href="#jumpNetSample">常规网络接口请求处理流程章节</a> 中的异步网络请求改为同步来直观展示<code>Continuation</code>的使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserSuspend</span><span class="params">(name: <span class="type">String</span>)</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    githubApi.getUserCallback(name).enqueue(<span class="keyword">object</span>: Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> =</span><br><span class="line">                continuation.resumeWithException(t)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">User</span>&gt;)</span></span> =</span><br><span class="line">                response.takeIf &#123; it.isSuccessful &#125;?.body()?.let(continuation::resume)</span><br><span class="line">                        ?: continuation.resumeWithException(HttpException(response))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>githubApi.getUserCallback()</code>方法返回的是一个<code>Call&lt;User&gt;</code>，它可以通过<code>equeue</code>方法来实现网络的请求。</li>
<li><code>getUserSuspend()</code>函数有<code>suspend</code>修饰符，则该函数是有一个<code>Continuation</code>对象的，正常使用是无法使用该<code>Continuation</code>对象，可以借助<code>suspendCoroutine</code></li>
<li><code>suspendCoroutine</code>函数可以获取当前挂起函数中的<code>Continuation</code>实例，并且在该函数中可以调用<code>Continuation</code>的<code>resume()</code>和<code>resumeWithException()</code>方法</li>
<li>在回调成功的分支中使用<code>Continuation.resume(value)</code>，在回调失败的分支中使用<code>Continuation.resumeWithException(e)</code></li>
<li><strong>真正的挂起</strong> 必须异步调用<code>resume</code>，包括：
<ul>
<li>切换到其他线程<code>resume</code></li>
<li>单线程事件循环异步执行</li>
</ul>
</li>
<li><strong>没有真正挂起</strong> 的情况：一开始直接<code>return</code>；在<code>suspendCoroutine</code>中直接调用<code>resume</code>。以上两种情况都没有切换线程</li>
<li>而<code>Call&lt;User&gt;</code>的<code>equeue</code>方法会将线程切换到<code>IO</code>线程去请求网络，所以<code>getUserSuspend()</code>函数实现了真正的挂起</li>
</ol>
<h2><a href="#3-协程的创建" class="header-anchor">#</a><span id="3-协程的创建">3. 协程的创建</span></h2>
<h3><a href="#1-createcoroutine方法" class="header-anchor">#</a><span id="1-createcoroutine方法">1. <code>createCoroutine()</code>方法</span></h3>
<p>协程是一段可执行的程序，它的创建通常需要一个函数即挂起函数，且需要使用<code>createCoroutine()</code>来进行创建</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(completion: Continuation&lt;T&gt;): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(receiver: R, completion: Continuation&lt;T&gt;): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>createCoroutine()</code>方法是挂起函数的扩展方法，也就是说只有挂起函数才能创建协程</li>
<li>提供了两个<code>createCoroutine()</code>方法，一个带<code>receiver</code>，一个不带<code>receiver</code>，这取决于调用该方法的挂起函数是否有<code>receiver</code></li>
<li><code>createCoroutine()</code>方法中传入了一个<code>Continuation</code>类型的参数<code>completion</code>，这个<code>Continuation</code>是作为协程执行完毕后返回的<code>Continuation</code></li>
<li><code>createCoroutine()</code>方法返回结果是一个<code>Continuation</code>，这个<code>Continuation</code>是协程创建出来的本体，该<code>Continuation</code>中的所有<code>resume()</code>方法执行完毕之后，就会调用入参传入的那个<code>Continuation</code>类型参数<code>completion</code></li>
<li>一个协程需要两个<code>Continuation</code>：
<ul>
<li>一个是协程的本体即挂起函数本身执行需要一个<code>Continuation</code>实例在恢复时调用，即<code>createCoroutine()</code>方法中传入的参数<code>completion</code></li>
<li><code>createCoroutine()</code>方法的返回值<code>Continuation&lt;Unit&gt;</code>，是创建出来的协程的载体，该方法的<code>receiver</code>即挂载函数会被传给该实例作为协程的实际执行体</li>
</ul>
</li>
</ol>
<h2><a href="#4-协程启动" class="header-anchor">#</a><span id="4-协程启动">4. 协程启动</span></h2>
<h3><a href="#1-resume" class="header-anchor">#</a><span id="1-resume">1. <code>resume</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;Coroutine End with <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).resume(<span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>suspend &#123;&#125;</code>创建了一个匿名的挂起函数，该匿名挂起函数又调用了<code>createCoroutine()</code>方法创建一个该匿名挂起函数包装的<code>Continuation</code></li>
<li>而<code>createCoroutine()</code>方法中传入的<code>Continuation</code>是在协程执行完成后调用</li>
<li>调用<code>resume(Unit)</code>方法启动协程</li>
</ol>
<h3><a href="#2-startcoroutine" class="header-anchor">#</a><span id="2-startcoroutine">2. <code>startCoroutine</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(receiver: R, completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>startCoroutine()</code>方法作用是创建协程，并在创建后启动协程，相当于<code>createCoroutine()</code>加上<code>resume(Unit)</code></p>
</li>
<li>
<p>如此上一节代码可写为如下样式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;.startCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Unit</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;Coroutine End with <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>协程在启动和执行结束的时候都会调用一次<code>resume</code>方法，协程中如果有N个挂起点，即调用了N个挂起函数且 <strong>挂起函数真正实现了挂起 <em>(即切换了线程)</em></strong>，则总共调用了 <strong>N + 2</strong> 次<code>resume</code>方法</p>
</li>
</ol>
<h2><a href="#5-协程上下文" class="header-anchor">#</a><span id="5-协程上下文">5. 协程上下文</span></h2>
<ul>
<li>
<p><strong>协程上下文</strong> 存放了协程执行过程中需要携带的数据</p>
</li>
<li>
<p><strong>协程上下文</strong> 是一组用于定义协程行为的元素。由如下几项构成：</p>
<ul>
<li>Job: 控制协程的生命周期</li>
<li>CoroutineDispatcher: <a target="_blank" rel="noopener" href="http://xn--Dispatchers-ep9ss63am7r8q4n.IO">调度器如Dispatchers.IO</a></li>
<li>CoroutineName: 协程的名称，调试的时候很有用</li>
<li>CoroutineExceptionHandler: 用于处理未被捕捉的异常</li>
</ul>
</li>
<li>
<p><strong>协程上下文</strong> 简单来说是一个数据集合，索引是<code>CoroutineContext.Key</code>，元素是<code>CoroutineContext.Element</code>，实现接口<code>CoroutineContext.Element</code>的类，即可存放于协程上下文中，实现该接口的类如下图：<br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/continuation_context_impl_class.png" alt></p>
</li>
</ul>
<h3><a href="#1-continuationinterceptor" class="header-anchor">#</a><span id="1-continuationinterceptor">1. <code>ContinuationInterceptor</code></span></h3>
<p>拦截器<code>ContinuationInterceptor</code>是协程上下文的一类元素，它可以对协程上下文所在协程的<code>Continuation</code>进行拦截、篡改</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>ContinuationInterceptor</code>接口中的<code>interceptContinuation()</code>方法，传入了一个<code>Continuation</code>，返回了一个<code>Continuation</code></li>
<li>该拦截器与<code>OkHttp</code>里面<code>addInterceptor</code>的时候在这里面更改<code>Interceptor</code>然后在返回是一样的原理</li>
</ol>
<h2><a href="#6-continuation执行示意" class="header-anchor">#</a><span id="6-continuation执行示意">6. <code>Continuation</code>执行示意</span></h2>
<h3><a href="#1-suspendlambda" class="header-anchor">#</a><span id="1-suspendlambda">1. <code>SuspendLambda</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;.startCoroutine(...)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>通过<code>startCoroutine()</code>创建出一个协程，而协程真正执行的逻辑就是该方法的<code>receiver</code>，即匿名挂起函数<code>suspend &#123;...&#125;</code>，这个匿名挂起函数创建成功后会生成一个类<code>SuspendLambda</code>，这是一个<code>Continuation</code>的实现类，如下图：<br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/continuation_run_1.png" alt></li>
</ol>
<h3><a href="#2-safecontinuation" class="header-anchor">#</a><span id="2-safecontinuation">2. <code>SafeContinuation</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;.startCoroutine(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    thread &#123;</span><br><span class="line">        it.resume(<span class="built_in">Unit</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>若该匿名挂起函数内有挂起函数的调用，则会用<code>SafeContinuation</code>将<code>SuspendLambda</code>进行包装</li>
<li>只要使用了<code>suspendCoroutine</code>，就会将<code>SuspendLambda</code>包装起来，如下图：<br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/continuation_run_2.png" alt></li>
<li><code>suspendCoroutine()</code>函数中有一个参数<code>Continuation</code>，可以用<code>it</code>来表示该参数。而<code>it</code>代表的<code>Continuation</code>是<code>SafeContinuation</code>的一个实例。则<code>it.resume()</code>实际上调用的是<code>SafeContinuation</code>的<code>resume</code>，最终会调到<code>SuspendLambda</code>的<code>resume</code>，如此恢复到匿名挂起函数的执行</li>
<li><code>SafeContinuation</code>的作用就是确保：
<ol>
<li><code>SuspendLambda</code>只被调用一次</li>
<li>如果在当前线程调用栈上直接调用则不会挂起</li>
</ol>
</li>
</ol>
<h3><a href="#3-加入intetcepted拦截器" class="header-anchor">#</a><span id="3-加入intetcepted拦截器">3. 加入<code>Intetcepted</code>拦截器</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;.startCoroutine(...)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>拦截器其实是将<code>SuspendLambda</code>包装了一次，如下图：<br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/continuation_run_3.png" alt></li>
<li><code>SafeContinuation</code>真正调用<code>resume</code>时，会调用了拦截器<code>Intetcepted</code>中返回的<code>Continuation</code>的<code>resume</code>，在拦截器返回的<code>Continuation</code>的<code>resume</code>方法中可以做切换线程操作，切换线程后，再调用<code>SuspendLambda</code>，如此实现了线程切换</li>
<li>拦截器最重要的一个功能就是线程切换</li>
<li>协程体是一个用<code>suspend</code>关键字修饰的一个无参、无返回值的函数类型。</li>
<li>调用顺序注意点：
<ol>
<li><code>SafeContinuation</code>仅在挂起点时出现</li>
<li>拦截器在每次 <em>(恢复)</em> 执行协程体时调用</li>
<li><strong><code>SuspendLambda</code>是协程函数体</strong></li>
</ol>
</li>
</ol>
<h3><a href="#4-协程挂起恢复执行示意" class="header-anchor">#</a><span id="4-协程挂起恢复执行示意">4. 协程挂起恢复执行示意</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span> <span class="keyword">implements</span> <span class="title class_">Continuation</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mLabel</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Continuation&lt;Unit&gt; mCompletion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ContinuationImpl</span><span class="params">(Continuation&lt;Unit&gt; completion)</span> &#123;</span><br><span class="line">        mCompletion = completion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> o;</span><br><span class="line">            <span class="keyword">switch</span> (mLabel) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    Logger.debug(<span class="number">1</span>);</span><br><span class="line">                    result = ConsoleMainKt.returnSuspend(<span class="built_in">this</span>);</span><br><span class="line">                    mLabel++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    Logger.debug(result);</span><br><span class="line">                    Logger.debug(<span class="number">2</span>);</span><br><span class="line">                    result = DelayKt.delay(<span class="number">1000</span>, <span class="built_in">this</span>);</span><br><span class="line">                    mLabel++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    Logger.debug(<span class="number">3</span>);</span><br><span class="line">                    result = ConsoleMainKt.returnImmediately(<span class="built_in">this</span>);</span><br><span class="line">                    mLabel++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                    Logger.debug(result);</span><br><span class="line">                    Logger.debug(<span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mCompletion.resumeWith(Unit.INSTANCE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            mCompletion.resumeWith(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSuspended</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">Logger.debug(<span class="number">1</span>)</span><br><span class="line">Logger.debug(returnSuspend())</span><br><span class="line">Logger.debug(<span class="number">2</span>)</span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">Logger.debug(<span class="number">3</span>)</span><br><span class="line">Logger.debug(returnImmediately())</span><br><span class="line">Logger.debug(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>介绍：</strong></p>
<ol>
<li>如上<code>Java</code>代码是仿照<code>Kotlin</code>中协程的调用逻辑写出的一个类<code>ContinuationImpl</code>，其本质上就是<code>SuspendLambda</code>：
<ol>
<li><code>ContinuationImpl#resumeWith()</code>方法执行的就是<code>SuspendLambda</code>中<code>Lambda</code>表达式真正传进去的东西</li>
<li><code>ContinuationImpl#isSuspended()</code>方法用于判断某个对象是否为挂起标记，</li>
</ol>
</li>
<li>如上<code>Kotlin</code>代码是协程启动后挂起函数执行的逻辑即<code>SuspendLambda</code>中<code>Lambda</code>表达式内容，启动的协程就是上述的<code>Java</code>代码类<code>ContinuationImpl</code>，每遇到一个挂起点都会有一个<code>SafeContinuation</code>，而<code>SafeContinuation</code> <code>resume</code>之后，会继续执行挂起函数里后续逻辑</li>
<li><code>Kotlin</code>代码中有三个挂起点：
<ul>
<li><code>Logger.debug(returnSuspend())</code></li>
<li><code>delay(1000)</code></li>
<li><code>Logger.debug(returnImmediately())</code></li>
</ul>
</li>
<li>假定：
<ol>
<li>挂起函数<code>returnSuspend()</code>有切换线程的操作</li>
<li>挂起函数<code>returnImmediately()</code>直接在该挂起函数中<code>return</code>、或没有切换线程即没有调用<code>SafeContinuation</code>的<code>resume</code></li>
</ol>
</li>
</ol>
<p><strong>执行逻辑说明：</strong></p>
<ol>
<li>执行<code>Kotlin</code>中第一行代码：<code>Logger.debug(1)</code>，纯打印语句没有执行挂起之类的操作时，就是执行对应到<code>Continu  ationImpl#resumeWith()</code>方法，第一次调用<code>resumeWith()</code>时，<code>mLabel</code>为0，所以执行值为0的分支：执行<code>Logger.debug(1)</code></li>
<li>之后执行第二行代码：<code>Logger.debug(returnSuspend())</code>，因为上一条语句没有挂起之类的操作，所以还是在分支0中：
<ol>
<li>调用挂起函数<code>ConsoleMainKt.returnSuspend(this)</code>，该挂起函数有切换线程的操作，所以要实现真正的挂起</li>
<li><code>mLabel</code>自加1</li>
<li>再通过函数<code>isSuspended()</code>判断该挂起函数的返回值<code>result</code>是一个 <strong>挂起标记</strong>，直接<code>return</code>，这就是非阻塞式的挂起，不卡当前线程。此时</li>
<li>此时等待该挂起函数恢复</li>
<li>当挂起函数<code>returnSuspend()</code>恢复时会再次调用<code>ContinuationImpl#resumeWith()</code>方法，因<code>mLabel</code>之前已经自加，所以此时走到了<code>mLabel</code>值为1的分支中，而恢复时传递回来的真正结果的打印也是在该分支中进行</li>
</ol>
</li>
<li>之后执行第三行代码：<code>Logger.debug(2)</code>，纯打印语句，直接执行</li>
<li>之后执行第四行代码：<code>delay(1000)</code>，是<code>Kotlin</code>提供的挂起函数，功能是延时一秒，此时继续执行<code>mLabel</code>值为1的分支：
<ol>
<li>执行<code>DelayKt.delay(1000, this)</code></li>
<li><code>mLabel</code>自加1</li>
<li>通过函数<code>isSuspended()</code>判断该挂起函数的返回值<code>result</code>是一个 <strong>挂起标记</strong>，直接<code>return</code></li>
<li>等待延时结束后恢复</li>
<li>当延时恢复后，会再次调用<code>ContinuationImpl#resumeWith()</code>方法，此时<code>mLabel</code>已经自加到了2</li>
</ol>
</li>
<li>之后执行第五行代码：<code>Logger.debug(3)</code>，纯打印语句，直接执行</li>
<li>之后执行第六行代码：<code>Logger.debug(returnImmediately())</code>，继续执行<code>mLabel</code>值为2的分支：
<ol>
<li>调用挂起函数<code>ConsoleMainKt.returnImmediately(this);</code>，该挂起函数没有切换线程之类的操作，不需要实现真正的挂起</li>
<li><code>mLabel</code>自加1</li>
<li>通过函数<code>isSuspended()</code>判断该挂起函数的返回值<code>result</code> <strong>不是</strong> <strong>挂起标记</strong>，<strong>此时不会<code>return</code></strong>，而是继续执行下个分支的语句</li>
<li>此时执行<code>mLabel</code>值为3的分支：打印出<code>returnImmediately()</code>函数的返回值</li>
</ol>
</li>
<li>之后执行第七行代码：<code>Logger.debug(4)</code>，纯打印语句，直接执行</li>
<li>如此，创建协程时返回的<code>Contiuation</code>中<code>resume</code>全部执行完毕，此时执行创建协程时传入的<code>Continuation</code>即<code>mCompletion</code>的<code>resumeWith()</code>方法，将<code>Unit</code>传入其中</li>
<li>若是以上流程有错误的话，则会执行<code>catch(Execption e)</code>分支中的<code>mCompletion.resumeWith(e);</code>，即将错误信息返回</li>
<li>如此以<code>Kotlin</code>代码中的几条代码为<code>SuspendLambda</code>中<code>Lambda</code>而创建的协程执行完毕</li>
</ol>
<p><strong>协程挂起恢复的要点总结：</strong></p>
<ul>
<li>协程体内的代码都是通过<code>Continuation.resumeWith</code>调用来实现恢复</li>
<li>每调用一次<code>resumeWith</code>则<code>mLabel</code>加1，<code>mLabel</code>表示挂起次数，每个分支是挂起<code>mLabel</code>次后执行的代码，即每一个挂点对应一个<code>case</code>分支</li>
<li>挂起函数返回<code>COROUTINE_SUSPENDED</code>时才是真正的挂起</li>
</ul>
<p><span id="jumpThreadSwitch"></span></p>
<h2><a href="#7-协程的线程调度" class="header-anchor">#</a><span id="7-协程的线程调度">7. 协程的线程调度</span></h2>
<p><code>suspend</code>函数会将整个协程挂起，而不仅仅是这个<code>suspend</code>函数，也就是说一个协程中有多个挂起函数时，它们是顺序执行的。而协程每次<code>resume</code>都会<code>resume</code>一开始的<code>SuspendLambda</code>，如此只要将这个<code>resume</code>拦截就可以进行线程调度</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;.startCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Unit</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = DispatcherContext(HandlerDispatcher)</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: ()-&gt;<span class="type">Unit</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">DispatcherContext</span>(<span class="keyword">private</span> <span class="keyword">val</span> dispatcher: Dispatcher = DefaultDispatcher) : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line">            = DispatchedContinuation(continuation, dispatcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> delegate: Continuation&lt;T&gt;, <span class="keyword">val</span> dispatcher: Dispatcher) : Continuation&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = delegate.context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        dispatcher.dispatch &#123;</span><br><span class="line">            delegate.resumeWith(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>整体实现原理是：添加拦截器，拦截了<code>SuspendLambda</code>并返回了自己的<code>Continuation</code>，在自己的<code>Continuation</code>被调用时先切换线程，再去调用<code>SuspendLambda</code>的<code>resume</code>。如此实现了线程切换。这也是自定义类<code>DispatcherContext</code>实现的功能</li>
</ol>
<h1><a href="#五-示例使用标准库的序列生成器sequence实现generator" class="header-anchor">#</a><span id="五-示例使用标准库的序列生成器sequence实现generator">五、示例–使用标准库的序列生成器<code>Sequence</code>实现<code>Generator</code></span></h1>
<p><code>Generator</code>是<code>Python</code>中的协程特性，<code>Generator</code>的使用请看之前的章节：<a href="#jumpGenerator">Pyhton的Generator</a></p>
<h2><a href="#1-代码实现" class="header-anchor">#</a><span id="1-代码实现">1. 代码实现</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GeneratorScope</span>&lt;<span class="type">T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> parameter: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NotReady</span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;): State()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Ready</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;, <span class="keyword">val</span> nextValue: T): State()</span><br><span class="line">    <span class="keyword">object</span> Done: State()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="built_in">Unit</span>, <span class="keyword">private</span> <span class="keyword">val</span> parameter: T): Generator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> GeneratorIterator(block, parameter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">generator</span><span class="params">(block: <span class="type">suspend</span> <span class="type">GeneratorScope</span>&lt;<span class="type">T</span>&gt;.(<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; parameter: T -&gt;</span><br><span class="line">        GeneratorImpl(block, parameter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorIterator</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="built_in">Unit</span>, <span class="keyword">override</span> <span class="keyword">val</span> parameter: T)</span><br><span class="line">    : GeneratorScope&lt;T&gt;(), Iterator&lt;T&gt;, Continuation&lt;Any?&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state: State</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> coroutineBlock: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="built_in">Unit</span> = &#123; block(parameter) &#125;</span><br><span class="line">        <span class="keyword">val</span> start = coroutineBlock.createCoroutine(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">        state = State.NotReady(start)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span> = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        continuation -&gt;</span><br><span class="line">        state = <span class="keyword">when</span>(state) &#123;</span><br><span class="line">            <span class="keyword">is</span> State.NotReady -&gt; State.Ready(continuation, value)</span><br><span class="line">            <span class="keyword">is</span> State.Ready&lt;*&gt; -&gt;  <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot yield a value while ready.&quot;</span>)</span><br><span class="line">            State.Done -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot yield a value while done.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(<span class="keyword">val</span> currentState = state) &#123;</span><br><span class="line">            <span class="keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        resume()</span><br><span class="line">        <span class="keyword">return</span> state != State.Done</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span>(<span class="keyword">val</span> currentState = state) &#123;</span><br><span class="line">            <span class="keyword">is</span> State.NotReady -&gt; &#123;</span><br><span class="line">                resume()</span><br><span class="line">                <span class="keyword">return</span> next()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;</span><br><span class="line">                state = State.NotReady(currentState.continuation)</span><br><span class="line">                (currentState <span class="keyword">as</span> State.Ready&lt;T&gt;).nextValue</span><br><span class="line">            &#125;</span><br><span class="line">            State.Done -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">&quot;No value left.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        state = State.Done</span><br><span class="line">        result.getOrThrow()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nums = generator &#123; start: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.5</span>) &#123;</span><br><span class="line">            yield(start + i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> seq = nums(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> seq) &#123;</span><br><span class="line">        println(j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p><strong>代码说明：</strong></p>
<ol>
<li>定义抽象类<code>GeneratorScope</code>：
<ol>
<li>将该抽象类的构造函数声明为模块内可见</li>
<li>定义一个泛型<code>T</code>类型的参数<code>parameter</code></li>
<li>定义一个抽象的挂起函数<code>yield()</code>，接收一个泛型<code>T</code>类型的参数</li>
<li>该抽象类用于限制挂起函数<code>yield()</code>的使用范围：仅限于以该抽象类为<code>receiver</code>的<code>Lambda</code>表达式</li>
</ol>
</li>
<li>定义密封类<code>State</code>，用于标识协程运行情况：
<ol>
<li><strong>不带值的状态建议使用枚举，带值的状态建议使用密封类</strong></li>
<li><code>NotReady</code>状态：还没有准备好值，需要一个协程继续执行协程体</li>
<li><code>Ready</code>状态：已经有值了，此时内部已经<code>yield</code>，所以需要协程挂起，并将值传入</li>
<li><code>Done</code>状态：协程体已执行完毕不会有新的值了</li>
</ol>
</li>
<li>定义类<code>GeneratorIterator</code>：
<ol>
<li>主构造器上添加两个类内属性：一个是名为<code>block</code>的挂起函数——该挂起函数的<code>receiver</code>是<code>GeneratorScope</code>类、入参是泛型、返回结果是<code>Unit</code>；另一个是名为<code>parameter</code>的泛型参数</li>
<li>创建一个记录状态的属性<code>state</code></li>
<li>添加一个初始化代码块：
<ol>
<li>启动协程时的<code>SuspendLambda</code>是没有参数的，但是该类传入的是一个带参数的挂起函数，所以声明一个名为<code>coroutineBlock</code>的无参挂起函数，在挂起函数体中将该类传入的泛型类型的参数作为入参调用传入的那个挂起函数</li>
<li>通过<code>coroutineBlock</code>创建协程，因不需要马上启动，所以使用<code>createCoroutine()</code>方法创建，该方法需要传入两个参数：第一个参数是<code>receiver</code>，因该类实现了<code>GeneratorScope</code>抽象类，所以写<code>this</code>；第二个参数是协程执行完毕后的回调，因为该类实现了<code>Continuation</code>接口，所以写<code>this</code></li>
<li>状态初始化为<code>NotReady</code>，并传入上一条语句创建的协程</li>
</ol>
</li>
<li>实现接口<code>Iterator</code>用于迭代：
<ol>
<li>定义一个<code>resume()</code>方法，用于判断如果当前状态是<code>NotReady</code>，调用一下状态中协程的<code>resume()</code>方法，以此来判断协程是否能<code>yield</code>值</li>
<li><code>hasNext()</code>方法：用于判断是否有下一个值。先执行一下自定义的<code>resume()</code>方法——若状态是<code>NotReady</code>去调用协程的<code>resume()</code>方法，之后判断若状态为<code>Done</code>，表示协程执行完毕没有值了返回<code>false</code>，其它状态返回<code>true</code></li>
<li><code>next()</code>方法返回下一次<code>yield()</code>返回的值。将当前状态<code>state</code>赋值给另一个属性<code>currentState</code>，判断<code>currentState</code>：
<ol>
<li>若<code>currentState</code>是<code>NotReady</code>，则调用一下自定义的<code>resume()</code>方法，看一下是否还有值，之后再调用一下<code>next()</code>方法</li>
<li>若<code>currentState</code>是<code>Ready</code>，先将<code>state</code>切换为<code>NotReady</code>状态，之后将<code>curentState</code>强转为<code>Ready</code>状态，之后调用<code>Ready#nextValue()</code>方法，得到<code>yield()</code>的值</li>
<li>若<code>currentState</code>是<code>Done</code>，抛出异常：下标越界</li>
</ol>
</li>
</ol>
</li>
<li>实现接口<code>Continuation</code>用于协程：
<ol>
<li>因为本次实现的功能不需要<code>CoroutineContext</code>，所以为<code>CoroutineContext</code>类型的属性<code>context</code>赋值为<code>EmptyCoroutineContext</code>对象</li>
<li><code>resumeWith()</code>方法会在协程结束时调用，此时将状态置为<code>Done</code>，<code>result.getOrThrow()</code>语句表示若有异常则抛出异常，否则不做操作</li>
</ol>
</li>
<li>继承抽象类<code>GeneratorScope</code>：实现<code>yield()</code>方法，该方法是一个挂起函数，需要通过<code>suspendCoroutine</code>拿到它的<code>Continuation</code>，之后根据当前状态<code>state</code>重新为<code>state</code>赋值:
<ol>
<li>若当前状态是<code>NotReady</code>，调用了<code>yield()</code>方法表示值已经准备好了，所以将当前置为<code>Ready</code>状态。创建<code>Ready</code>实例时将<code>yield()</code>之后继续执行的<code>Continuation</code>即通过<code>suspendCoroutine</code>拿到的<code>Continuation</code>传入进去，也将<code>yield()</code>方法的入参<code>value</code>传入进去</li>
<li>若当前状态是<code>Ready</code><em>(判断时<code>Ready</code>后加星投影是因为运行时这个类型不会真正存在)</em>，抛出异常：在<code>Ready</code>状态不能<code>yield</code>值了</li>
<li>若当前状态是<code>Done</code>状态，抛出异常：不能在<code>Done</code>状态<code>yield</code>值</li>
</ol>
</li>
</ol>
</li>
<li>定义接口<code>Generator</code>，该接口中定义了一个重载运算符的函数<code>iterator()</code>、返回一个迭代器</li>
<li>定义实现类<code>GeneratorImpl</code>，它实现了接口<code>Generator</code>：
<ol>
<li>主构造器上添加两个类内属性：一个是名为<code>block</code>的挂起函数——该挂起函数的<code>receiver</code>是<code>GeneratorScope</code>类、入参是泛型、返回结果是<code>Unit</code>；另一个是名为<code>parameter</code>的泛型参数</li>
<li>在实现<code>iterator()</code>方法中直接返回<code>GeneratorIterator</code>类的对象</li>
</ol>
</li>
<li>定义一个生成器函数<code>generator</code>：
<ol>
<li>入参是一个挂起函数——该挂起函数的<code>receiver</code>是<code>GeneratorScope</code>类、入参是泛型、返回结果是<code>Unit</code></li>
<li>返回结果是一个函数——该函数有一个泛型入参、返回结果是接口<code>Generator</code>类型对象</li>
<li>函数体直接<code>return</code>了一个<code>Lambda</code>表达式，入参是泛型<code>T</code>类型的<code>parameter</code>，返回是一个接口<code>Generator</code>的实现类<code>GeneratorImpl</code>的对象</li>
</ol>
</li>
</ol>
<p><strong>执行流程说明：</strong></p>
<ol>
<li><code>generator</code>函数创建一个<code>Lambda</code>表达式即创建一个新函数，新函数接收一个参数返回一个<code>GeneratorImpl</code>实例</li>
<li><code>GeneratorImpl</code>实现了<code>iterator</code>运算符即可以迭代了</li>
<li>每次迭代先通过<code>hasNext()</code>函数判断是否有值，这个值就是<code>yield()</code>函数中的入参，其中若状态是<code>NotReady</code>则 <strong>会恢复协程</strong></li>
<li>恢复协程会执行执行<code>yield()</code>函数，若状态是<code>NotReady</code>状态会将状态置为<code>Ready</code>并 <strong>将协程挂起</strong> 后交给状态对象<code>state</code></li>
<li>之后执行<code>next()</code>函数取值，若是<code>Ready</code>状态，则将状态置为<code>NotReady</code>并将状态对象中的协程传给<code>NotReady</code>以便于下次该状态下恢复协程，如此实现了协程的挂起和恢复</li>
</ol>
<h2><a href="#2-使用sequence实现" class="header-anchor">#</a><span id="2-使用sequence实现">2. 使用<code>sequence</code>实现</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sequence = sequence &#123;</span><br><span class="line">        yield(<span class="number">1</span>)</span><br><span class="line">        yield(<span class="number">2</span>)</span><br><span class="line">        yield(<span class="number">3</span>)</span><br><span class="line">        yield(<span class="number">4</span>)</span><br><span class="line">        yieldAll(listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(seq <span class="keyword">in</span> sequence)&#123;</span><br><span class="line">        println(seq)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>直接使用<code>sequence</code>实现了<code>Python</code>中的<code>Generator</code>功能</li>
<li>每次<code>yield</code>都会挂起，也可以对<code>sequence</code>迭代</li>
<li>但是上一节自定义的代码中可以输入一个初始值，而<code>sequence</code>不行</li>
</ol>
<p><span id="jumpLuaAPI"></span></p>
<h1><a href="#六-示例-仿-lua-协程实现非对称协程-api" class="header-anchor">#</a><span id="六-示例-仿-lua-协程实现非对称协程-api">六、 示例-- 仿 <code>Lua</code> 协程实现非对称协程 <code>API</code></span></h1>
<p>非对称协程：非对称协程的调度权只能转移给调用自己的协程，<a href="#jumpLua">Lua的Coroutine</a>就是非对称协程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Created</span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;): Status()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Yielded</span>&lt;<span class="type">P</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;P&gt;): Status()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Resumed</span>&lt;<span class="type">R</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;R&gt;): Status()</span><br><span class="line">    <span class="keyword">object</span> Dead: Status()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.N)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coroutine</span>&lt;<span class="type">P, R</span>&gt; (</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> Coroutine&lt;P, R&gt;.CoroutineBody.(P) -&gt; R</span><br><span class="line">): Continuation&lt;R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;P, R&gt;</span> <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">            block: <span class="type">suspend</span> <span class="type">Coroutine</span>&lt;<span class="type">P</span>, R&gt;.CoroutineBody.(P)</span></span> -&gt; R</span><br><span class="line">        ): Coroutine&lt;P, R&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Coroutine(context, block)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">CoroutineBody</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> parameter: P? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">            <span class="keyword">val</span> previousStatus = status.getAndUpdate &#123;</span><br><span class="line">                <span class="keyword">when</span>(it) &#123;</span><br><span class="line">                    <span class="keyword">is</span> Status.Created -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Never started!&quot;</span>)</span><br><span class="line">                    <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already yielded!&quot;</span>)</span><br><span class="line">                    <span class="keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)</span><br><span class="line">                    Status.Dead -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already dead!&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (previousStatus <span class="keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> body = CoroutineBody()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> status: AtomicReference&lt;Status&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = status.<span class="keyword">get</span>() != Status.Dead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> coroutineBlock: <span class="keyword">suspend</span> CoroutineBody.() -&gt; R = &#123; block(parameter!!) &#125;</span><br><span class="line">        <span class="keyword">val</span> start = coroutineBlock.createCoroutine(body, <span class="keyword">this</span>)</span><br><span class="line">        status = AtomicReference(Status.Created(start))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">R</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> previousStatus = status.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span>(it) &#123;</span><br><span class="line">                <span class="keyword">is</span> Status.Created -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Never started!&quot;</span>)</span><br><span class="line">                <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already yielded!&quot;</span>)</span><br><span class="line">                <span class="keyword">is</span> Status.Resumed&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    Status.Dead</span><br><span class="line">                &#125;</span><br><span class="line">                Status.Dead -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already dead!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (previousStatus <span class="keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> previousStatus = status.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span>(it) &#123;</span><br><span class="line">                <span class="keyword">is</span> Status.Created -&gt; &#123;</span><br><span class="line">                    body.parameter = value</span><br><span class="line">                    Status.Resumed(continuation)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    Status.Resumed(continuation)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already resumed!&quot;</span>)</span><br><span class="line">                Status.Dead -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already dead!&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span>(previousStatus)&#123;</span><br><span class="line">            <span class="keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了下一章节对称协程调用API时特殊添加</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;SymT&gt;</span> SymCoroutine<span class="type">&lt;SymT&gt;</span>.<span class="title">yield</span><span class="params">(value: <span class="type">R</span>)</span></span>: P &#123;</span><br><span class="line">        <span class="keyword">return</span> body.yield(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dispatcher</span>: <span class="type">ContinuationInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key = ContinuationInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newSingleThreadExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> DispatcherContinuation(continuation, executor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DispatcherContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;, <span class="keyword">val</span> executor: Executor): Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        executor.execute &#123;</span><br><span class="line">            continuation.resumeWith(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.N)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> producer = Coroutine.create&lt;<span class="built_in">Unit</span>, <span class="built_in">Int</span>&gt;(Dispatcher()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>)&#123;</span><br><span class="line">            log(<span class="string">&quot;send&quot;</span>, i)</span><br><span class="line">            yield(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> consumer = Coroutine.create&lt;<span class="built_in">Int</span>, <span class="built_in">Unit</span>&gt;(Dispatcher()) &#123; param: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>, param)</span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> value = yield(<span class="built_in">Unit</span>)</span><br><span class="line">            log(<span class="string">&quot;receive&quot;</span>, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive)&#123;</span><br><span class="line">        <span class="keyword">val</span> result = producer.resume(<span class="built_in">Unit</span>)</span><br><span class="line">        consumer.resume(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(<span class="keyword">vararg</span> msg: <span class="type">Any</span>?)</span></span> = println(<span class="string">&quot;Coroutine: <span class="subst">$&#123;msg.joinToString(<span class="string">&quot; &quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Coroutine: send <span class="number">0</span></span><br><span class="line">Coroutine: start <span class="number">0</span></span><br><span class="line">Coroutine: send <span class="number">1</span></span><br><span class="line">Coroutine: receive <span class="number">1</span></span><br><span class="line">Coroutine: send <span class="number">2</span></span><br><span class="line">Coroutine: receive <span class="number">2</span></span><br><span class="line">Coroutine: send <span class="number">3</span></span><br><span class="line">Coroutine: receive <span class="number">3</span></span><br><span class="line">Coroutine: receive <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>创建密封类<code>Status</code>，用于协程的状态：
<ol>
<li><code>Created</code>：创建状态</li>
<li><code>Yielded</code>：挂起状态，<code>yield</code>时的值定义为泛型类型<code>&lt;P&gt;</code></li>
<li><code>Resumed</code>：恢复状态，</li>
<li><code>Dead</code>：销毁状态</li>
</ol>
</li>
<li>创建类<code>Coroutine</code>：
<ol>
<li>该类有两个泛型参数：<code>P</code>表示需要的参数；<code>R</code>表示返回值，也就是<code>yield</code>时传出的值</li>
<li>创建伴生对象，在伴生对象中创建可静态调用的方法<code>create()</code>,用于创建<code>Coroutine</code>类的对象</li>
<li>创建内部类<code>CoroutineBody</code>，用于约束<code>yield</code>方法只能在该协程<code>lambda</code>中使用：
<ol>
<li>创建一个泛型<code>P</code>类型的参数<code>parameter</code>，初始值为<code>null</code></li>
<li>创建一个挂起函数<code>yield</code>，该函数接收的入参为泛型<code>R</code>类型<code>value</code>，返回值为泛型<code>P</code>类型</li>
</ol>
</li>
<li>该类主构造器中有两个参数：一个是带默认参数的<code>CoroutineContext</code>类型的<code>context</code>，若不需要在多线程下运行不传该值直接使用默认值<code>EmptyCoroutineContext</code>；一个是挂起函函数<code>block</code>，该函数必须以<code>CoroutineBody</code>为<code>receiver</code>、以泛型<code>P</code>为入参、以泛型<code>R</code>为返回值</li>
<li>该类实现<code>Continuation</code>的接口，用于监听协程结束，在协程结束后会调用<code>resumeWith()</code>方法，在该方法中更新状态：
<ol>
<li>创建状态属性<code>previousStatus</code>，调用<code>status</code>的<code>getAndUpdate()</code>方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的<code>it</code>即为当前状态，也就是更新之前的状态</li>
<li>添加<code>when</code>语句进行状态判断</li>
<li>若为<code>Created</code>状态，抛非法异常：从没开始过</li>
<li>若为<code>Yielded</code>状态，抛非法异常：已经<code>yield</code>了</li>
<li>若为<code>Resumed</code>状态，返回<code>Dead</code>状态</li>
<li>若为<code>Dead</code>状态，抛非法异常：已经销毁</li>
<li>切换完状态后，将<code>previousStatus</code>强转为<code>Resumed</code>状态，之后每步都加非空判断，调用该状态的协程的<code>resumeWith()</code>方法将<code>result</code>传入</li>
</ol>
</li>
<li>创建名为<code>body</code>的<code>CoroutineBody</code>对象</li>
<li>创建名为<code>status</code>的<code>Status</code>对象，但是使用了<code>AtomicReference</code>将对象包裹。<strong><code>AtomicReference</code>是可以原子更新的对象引用</strong>，以保证线程安全</li>
<li>创建布尔型的属性<code>isActive</code>，用于判断协程是否还在活动，覆写该属性的<code>get()</code>方法，比较<code>status</code>是否是<code>Dead</code>状态</li>
<li>创建初始代码块：
<ol>
<li>创建名为<code>coroutineBlock</code>的用于创建协程的<code>SuspendLambda</code>，它的类型为以<code>CoroutinBody</code>为<code>receiver</code>的无入参、返回值为泛型<code>R</code>类型的挂起函数，其函数体是将强转为非空的<code>parameter</code>参数为入参调用的挂起函数<code>block</code></li>
<li>通过<code>coroutineBlock</code>创建名为<code>start</code>的协程，因不需要马上启动，所以使用<code>createCoroutine()</code>方法创建。<code>createCoroutine()</code>方法需要传入两个参数：第一个参数是<code>receiver</code>即<code>SuspendLambda</code>的<code>receiver</code>，所以写<code>CoroutinBody</code>的实例<code>body</code>；第二个参数是协程执行完毕后的回调，因为类<code>Coroutine</code>实现了<code>Continuation</code>接口，所以写<code>this</code></li>
<li>初始化状态<code>status</code>，为其赋值为<code>Created</code>状态，并将创建的<code>start</code>传入</li>
</ol>
</li>
<li>创建<code>resume()</code>方法，该方法是一个挂起函数，传入泛型<code>P</code>类型的参数，返回泛型<code>R</code>，需要通过<code>suspendCoroutine</code>拿到它的<code>Continuation</code>，然后进行状态的流转:
<ol>
<li>创建状态属性<code>previousStatus</code>，调用<code>status</code>的<code>getAndUpdate()</code>方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的<code>it</code>即为当前状态，也就是更新之前的状态</li>
<li>添加<code>when</code>语句进行状态判断</li>
<li>若为<code>Created</code>状态，将<code>body</code>中的<code>parameter</code>赋值为<code>value</code>，作为函数调用的第一个参数。之后状态流转为<code>resume</code>,并将控制外部流程的<code>continuation</code>传递进去</li>
<li>若为<code>Yielded</code>状态，状态流转为<code>resume</code>,并将控制外部流程的<code>continuation</code>传递进去</li>
<li>若为<code>Resumed</code>状态，抛非法异常：已经<code>resumed</code>了</li>
<li>若为<code>Dead</code>状态，抛非法异常：已经销毁</li>
<li>切换完状态后，判断<code>previousStatus</code>状态：
<ol>
<li>若为<code>Created</code>状态，将之前的挂起点执行一下，之所以不在上一条的<code>when</code>语句中执行，是因为<code>getAndUpdate</code>中的<code>lambda</code>可能会执行多次。因此，等状态流转成功后再执行。这是协程刚被创建，第一次执行<code>resume</code>方法的场景，所以<code>resume()</code>方法不需要传进去参数</li>
<li>若为<code>Yielded</code>状态，将<code>previousStatus</code>强转为<code>P</code>泛型的<code>Yielded</code>类型，之后执行它的<code>continuation</code>的<code>resume()</code>方法，并将<code>value</code>值传递进去</li>
</ol>
</li>
</ol>
</li>
<li>创建<code>yield()</code>方法，该方法是一个挂起函数，传入泛型<code>R</code>类型的参数，返回泛型<code>P</code>，需要通过<code>suspendCoroutine</code>拿到它的<code>Continuation</code>，然后进行状态的流转。</li>
</ol>
</li>
<li>创建类<code>DispatcherContinuation</code>，用于进行<code>continuation</code>的分发
<ol>
<li>其主构造器中传入两个参数，一个是要执行的<code>continuation</code>，一个是要执行<code>continuation</code>的<code>executor</code></li>
<li>该类实现使用<code>Continuation</code>代理，如果只需要实现需要修改的方法即可，其它与<code>Continuation</code>一致</li>
</ol>
</li>
<li>创建类<code>Dispatcher</code>，实现<code>ContinuationInterceptor</code>接口，用于切换线程：
<ol>
<li>其中<code>key</code>若是实现协程拦截器，则赋值<code>ContinuationInterceptor</code></li>
<li>在拦截协程方法中返回分发协程类对象，其中传入的执行器是使用<code>newSingleThreadExecutor()</code>创建的新执行器</li>
</ol>
</li>
<li>创建<code>main()</code>函数验证代码：
<ol>
<li>创建一个名为<code>producer</code>的<code>Coroutine</code>，其中
<ol>
<li>第一个形参是<code>CoroutineContext</code>类型，传入的是<code>Dispatcher</code>类实例，该类实现<code>ContinuationInterceptor</code>接口，而该接口继承自<code>CoroutineContext</code></li>
<li>第二个形参是<code>receiver</code>为<code>CoroutineBody</code>的<code>lambda</code>表达式，该表达式入参为<code>Unit</code>即无入参，返回结果为<code>Int</code>类型。此时<code>lambda</code>表达式功能为执行<code>fori</code>循环，执行四次，从0开始到3结束，每次打印日志发送出去的值，并将<code>i</code>通过<code>yield()</code>方法传递出去</li>
</ol>
</li>
<li>创建名为<code>consumer</code>的<code>Coroutine</code>，其中
<ol>
<li>第一个形参是<code>CoroutineContext</code>类型，传入的是<code>Dispatcher</code>类实例，该类实现<code>ContinuationInterceptor</code>接口，而该接口继承自<code>CoroutineContext</code></li>
<li>第二个形参是<code>receiver</code>为<code>CoroutineBody</code>的<code>lambda</code>表达式，该表达式入参为<code>Int</code>类型，返回结果为<code>Unit</code>类型。此时<code>lambda</code>表达式功能为打印传递进来的参数，之后执行<code>fori</code>循环，执行四次，从0开始到3结束，每次通过<code>yield()</code>方法取到生产者发送的值，并打印接收到的值</li>
</ol>
</li>
<li>创建一个循环，如果生产者和消费者都处于活跃状态则执行循环体：通过生产者的<code>resume()</code>方法取到生产的值，将通过消费者的<code>resume()</code>方法将值传递给消费者</li>
</ol>
</li>
<li>问题：使用<code>Executor</code>的<code>newSingleThreadExecutor()</code>方法创建的线程不是幽灵线程，该线程会一直在后台等待<code>execute()</code>方法传递的任务。所以主线程执行完毕后，<code>executor</code>创建的线程还在后台运行，因此不能正常结束</li>
</ol>
<h1><a href="#七-示例-基于非对称协程api实现对称协程" class="header-anchor">#</a><span id="七-示例-基于非对称协程api实现对称协程">七、 示例-- 基于非对称协程<code>API</code>实现对称协程</span></h1>
<h2><a href="#1-实现思路" class="header-anchor">#</a><span id="1-实现思路">1. 实现思路</span></h2>
<p>基于非对称协程实现对称协程只需要 <strong>添加一个中间层调度中心</strong>即可实现。</p>
<p><img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/symmetric_coroutine.png" alt></p>
<p>如上图所示：</p>
<ol>
<li>若从协程A转到协程B，若是非对称协程直接在协程A中<code>yield()</code>或是<code>resume(coroutineB)</code>即可</li>
<li>而若是对称协程，协程A<code>yield()</code>之后将调度权转给调度中心，而调度中心再调用<code>resume(coroutineB)</code>,如此来通过非对称实现对称。</li>
<li><strong>调度中心可以是单独的一个协程，它只负责分发转移调度权。</strong> 而调度协程如何知道调度权转移给谁呢？只需要调用<code>yield()</code>方法时将要转到的协程作为参数传入调度协程即可，如下图所示：<br><br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/symmetric_coroutine2.png" alt></li>
</ol>
<h2><a href="#2-代码实现" class="header-anchor">#</a><span id="2-代码实现">2. 代码实现</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//sym全拼为symmetric</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SymCoroutine</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> SymCoroutine&lt;T&gt;.SymCoroutineBody.(T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : Continuation&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> main: SymCoroutine&lt;Any?&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(block: <span class="type">suspend</span> <span class="type">SymCoroutine</span>&lt;<span class="type">Any</span>?&gt;.<span class="type">SymCoroutineBody</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">            SymCoroutine&lt;Any?&gt; &#123; block() &#125;.also &#123; main = it &#125;.start(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">            block: <span class="type">suspend</span> <span class="type">SymCoroutine</span>&lt;<span class="type">T</span>&gt;.<span class="type">SymCoroutineBody</span>.(<span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: SymCoroutine&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> SymCoroutine(context, block)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Parameter</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> coroutine: SymCoroutine&lt;T&gt;, <span class="keyword">val</span> value: T)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isMain: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">this</span> == main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> body = SymCoroutineBody()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutine = Coroutine&lt;T, Parameter&lt;*&gt;&gt;(context) &#123;</span><br><span class="line">        Parameter(<span class="keyword">this</span><span class="symbol">@SymCoroutine</span>, <span class="keyword">suspend</span> &#123;</span><br><span class="line">            block(body, it)</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span><span class="symbol">@SymCoroutine</span>.isMain) <span class="built_in">Unit</span> <span class="keyword">else</span> <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;SymCoroutine cannot be dead.&quot;</span>)</span><br><span class="line">        &#125;() <span class="keyword">as</span> T)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">SymCoroutineBody</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">tailrec</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;P&gt;</span> <span class="title">transferInner</span><span class="params">(symCoroutine: <span class="type">SymCoroutine</span>&lt;<span class="type">P</span>&gt;, value: <span class="type">Any</span>?)</span></span>: T&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span><span class="symbol">@SymCoroutine</span>.isMain)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">if</span>(symCoroutine.isMain)&#123;</span><br><span class="line">                    value <span class="keyword">as</span> T</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> parameter = symCoroutine.coroutine.resume(value <span class="keyword">as</span> P)</span><br><span class="line">                    transferInner(parameter.coroutine, parameter.value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span><span class="symbol">@SymCoroutine</span>.coroutine.run &#123;</span><br><span class="line">                   <span class="keyword">return</span> yield(Parameter(symCoroutine, value <span class="keyword">as</span> P))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;P&gt;</span> <span class="title">transfer</span><span class="params">(symCoroutine: <span class="type">SymCoroutine</span>&lt;<span class="type">P</span>&gt;, value: <span class="type">P</span>)</span></span>: T &#123;</span><br><span class="line">           <span class="keyword">return</span> transferInner(symCoroutine, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;SymCoroutine cannot be dead!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">(value: <span class="type">T</span>)</span></span>&#123;</span><br><span class="line">        coroutine.resume(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> SymCoroutines &#123;</span><br><span class="line">    <span class="keyword">val</span> coroutine0: SymCoroutine&lt;<span class="built_in">Int</span>&gt; = SymCoroutine.create&lt;<span class="built_in">Int</span>&gt; &#123; param: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        log(<span class="string">&quot;coroutine-0&quot;</span>, param)</span><br><span class="line">        <span class="keyword">var</span> result = transfer(coroutine2, <span class="number">0</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutine-0 1&quot;</span>, result)</span><br><span class="line">        result = transfer(SymCoroutine.main, <span class="built_in">Unit</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutine-0 1&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutine1: SymCoroutine&lt;<span class="built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        log(<span class="string">&quot;coroutine-1&quot;</span>, param)</span><br><span class="line">        <span class="keyword">val</span> result = transfer(coroutine0, <span class="number">1</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutine-1 1&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutine2: SymCoroutine&lt;<span class="built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        log(<span class="string">&quot;coroutine-2&quot;</span>, param)</span><br><span class="line">        <span class="keyword">var</span> result = transfer(coroutine1, <span class="number">2</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutine-2 1&quot;</span>, result)</span><br><span class="line">        result = transfer(coroutine0, <span class="number">2</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutine-2 2&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    SymCoroutine.main &#123;</span><br><span class="line">        log(<span class="string">&quot;main&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> result = transfer(SymCoroutines.coroutine2, <span class="number">3</span>)</span><br><span class="line">        log(<span class="string">&quot;main end&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码说明：</strong></p>
<ol>
<li>该章节代码是基于<a href="#jumpLuaAPI">上一章节非对称协程代码</a>开发的</li>
<li><strong>对称协程要求在运行结束后主动将调度权转移，而不是执行完毕</strong>。即不允许在不确定的协程里运行结束，以避免意想不到的结果。</li>
<li>创建类<code>SymCoroutine</code>：
<ol>
<li>该类只有一个泛型参数：<code>T</code>表示需要的参数；因为是对称协程没有返回值的说法</li>
<li>创建伴生对象，在伴生对象中做如下操作：
<ol>
<li>创建<code>SymCoroutine</code>类型的属性<code>main</code>，用于保存调度中心的协程，以判断当前协程是否为调度中心</li>
<li>创建挂起函数<code>main</code>，该函数入参类型为以<code>SymCoroutinBody</code>为<code>receiver</code>的无入参、返回值为<code>Unit</code>类型的挂起函数，<code>main</code>函数体将传入的挂起函数启动</li>
<li>创建可静态调用的方法<code>create()</code>，用于创建<code>SymCoroutine</code>类的对象</li>
</ol>
</li>
<li>创建类<code>Parameter</code>，用于包含<code>yield()</code>和<code>resume()</code>方法中所有入参，即<code>SymCoroutine</code>类型的协程对象，和该协程对象所需要的类型为泛型<code>T</code>的参数<code>value</code>，也是为了复用<a href="#jumpLuaAPI">上一章节非对称协程代码</a></li>
<li>创建属性<code>isMain</code>，返回值类型为<code>Boolean</code>，用于判断当前协程是否为调度中心协程即是是否为<code>main</code>协程</li>
<li>创建<code>SymCoroutineBody</code>类型对象<code>body</code></li>
<li>创建非对称协程对象<code>coroutine</code>，即为<a href="#jumpLuaAPI">上一章节非对称协程代码</a>中的<code>Coroutine</code>类对象，其中需要的参数为泛型<code>T</code>，返回的参数为<code>Parameter</code>。传入真正执行的<code>lambda</code>表达式，该<code>lambda</code>表达式返回一个<code>Parameter</code>实例对象。
<ol>
<li><code>parameter</code>对象第一个入参是要转移的目标协程，传当前协程即可</li>
<li><code>parameter</code>对象另一个参数是目标协程所需要参数，创建一个<code>suspend lambda</code>表达式，在表达式中运行<code>block</code>表达式以得到结果，<code>block</code>表达式中首先传入上一步创建的<code>body</code>对象，再传入泛型参数，因为<a href="#jumpLuaAPI">上一章节非对称协程代码</a>中的<code>Coroutine</code>类对象中的语句<code>private val block: suspend Coroutine&lt;P, R&gt;.CoroutineBody.(P) -&gt; R</code>入参中<code>CoroutineBody</code>有一个入参<code>P</code>,因此可以直接使用<code>it</code>来代指。</li>
<li>执行完<code>block</code>表达式后，判断当前协程是否为<code>main</code>，如果是<code>main</code>协程则返回一个<code>Unit</code>，否则抛出异常：<code>SymCoroutine</code>不能执行完毕</li>
</ol>
</li>
<li>创建内部类<code>SymCoroutineBody</code>，用于约束<code>transfer</code>方法只能在该协程<code>lambda</code>中使用：
<ol>
<li>创建一个挂起函数<code>transfer</code>：
<ol>
<li>一个入参类型为<code>SymCoroutine</code>的协程对象，即转移的目标协程，该协程接收一个泛型为<code>P</code>类型的参数</li>
<li>另一个入参类型为泛型<code>P</code>的<code>value</code>值，该值为上一个入参协程对象所需要的参数</li>
<li>返回值为泛型<code>T</code>类型，用于流转到该协程时所要传入参数</li>
</ol>
</li>
<li>创建挂起函数<code>transferInner</code>，用于实现函数<code>transfer</code>的功能：
<ol>
<li>
<p>满足尾递归条件的函数前面加<code>tailrec</code>修饰，编译器会优化该递归成一个快速而高效的基于循环的版本，减少栈消耗。尾递归条件：1. 最后一条语句是函数调用语句；2. 调用的函数是自身</p>
</li>
<li>
<p>第一个入参类型与<code>transfer()</code>函数一致</p>
</li>
<li>
<p>第二个入参类型为<code>Any?</code></p>
</li>
<li>
<p>先判断当前<code>SymCoroutineBody</code>的<code>SymCoroutine</code>是否为<code>main</code>协程</p>
</li>
<li>
<p>若是<code>main</code>协程，因为每次转换调度权都会回到<code>main</code>协程中，因此要再判断转移目标协程是否为<code>main</code>协程</p>
<ol>
<li>若转移目标协程是<code>main</code>协程，直接将<code>value</code>值返回</li>
<li>若转移目标协程不是<code>main</code>协程，即不是转移给<code>main</code>协程的，则需要获取<code>yield()</code>出来的两个参数，通过<code>symCoroutine.coroutine</code>取到非对称协程的对象并调用其<code>resume()</code>方法获取该协程返回的结果，其中<code>resume()</code>方法入参就是该协程需要的参数，即<code>value</code>,将其强转为泛型<code>P</code>。之后再调用<code>transferInner()</code>方法，将转移的目标协程及目标协程需要的参数传递进去</li>
</ol>
</li>
<li>
<p>若当前<code>SymCoroutineBody</code>的<code>SymCoroutine</code>不是<code>main</code>协程，即协程A到协程B的过程中，协程A还没有<code>yield</code>,因此需要执行一下协程A的<code>yield()</code>方法，但是<code>this@SymCoroutine.coroutine</code>中只有它的<code>CoroutineBody</code>里才有<code>yield()</code>方法，因此我们需要改造<a href="#jumpLuaAPI">上一章节的代码</a>在<code>Coroutine</code>类中添加如下方法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;SymT&gt;</span> SymCoroutine<span class="type">&lt;SymT&gt;</span>.<span class="title">yield</span><span class="params">(value: <span class="type">R</span>)</span></span>: P &#123;</span><br><span class="line">                <span class="keyword">return</span> body.yield(value)</span><br><span class="line">            &#125;</span><br><span class="line">            ````</span><br><span class="line"></span><br><span class="line">            之后调用`<span class="keyword">this</span><span class="symbol">@SymCoroutine</span>.coroutine`的`run`方法，并将`symCoroutine`和`value`拼装成`Parameter`对象，再将该对象作为入参调用`yield()`方法</span><br><span class="line"></span><br><span class="line">   <span class="number">8.</span> 创建方法`start()`，用于启动该调度中心的协程`main`，在该方法体中调用非对称协程的`resume()`方法。该方法在`SymCoroutine`的伴生对象里的`main()`方法中被调用</span><br><span class="line">   <span class="number">9.</span> 创建带名伴生对象`SymCoroutines`，在该伴生对象中创建三个对称协程，在各自的函数中调用`transfer()`方法进行协程的切换，并打印日志</span><br><span class="line">   <span class="number">10.</span> 创建程序入口`main()`函数，在该函数中调用`SymCoroutine.main()`方法，用于创建并启动调度中心的协程`main`，并在该`main`协程中开始进行协程的切换并打印日志</span><br><span class="line"></span><br><span class="line">**打印结果：**</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">Coroutine: main <span class="number">0</span></span><br><span class="line">Coroutine: coroutine-<span class="number">2</span> <span class="number">3</span></span><br><span class="line">Coroutine: coroutine-<span class="number">1</span> <span class="number">2</span></span><br><span class="line">Coroutine: coroutine-<span class="number">0</span> <span class="number">1</span></span><br><span class="line">Coroutine: coroutine-<span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">Coroutine: coroutine-<span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">Coroutine: main end kotlin.<span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>执行流程说明：</strong></p>
<p>上述例子中协程调用流程如下图所示：<br><br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/symmetric_coroutine3.png" alt><br>
<br></p>
<ol>
<li>程序开始首先启动调度中心的协程即协程<code>main</code></li>
<li>打印信息<code>main 0</code>然后再将调度权转给协程2，并传入值3</li>
<li>之后进入协程2，打印信息<code>coroutine-2 3</code>，接着将调度权转移给协程1，并传入值2</li>
<li>之后进入协程1，打印信息<code>coroutine-1 2</code>，接着将调度权转移给协程0，并传入值1</li>
<li>之后进入协程0，打印信息<code>coroutine-0 1</code>，接着将调度权转移给协程2，并传入值0</li>
<li>之后进入协程2，运行调用其第一个挂起函数<code>transfer()</code>之后的语句，打印信息<code>coroutine-2 1 0</code>，接着将调度权转移给协程0，并传入值2</li>
<li>之后进入协程0，打印信息<code>coroutine-0 1 2</code>，接着将调度权转移给了调度中心的协程<code>main</code>，表示要结束协程调度</li>
<li>之后进入协程<code>main</code>，运行调用其挂起函数<code>transfer()</code>之后的语句，打印信息<code>main end kotlin.Unit</code>，程序结束</li>
<li>若第6步，打印信息后，将调度权转移给协程1，即<code>result = transfer(coroutine0, 2)</code>替换为<code>result = transfer(coroutine1, 2)</code>，则会进入协程1，运行调用其挂起函数<code>transfer()</code>之后的语句，打印信息<code>coroutine-1 1 2</code>，之后协程里<code>lambda</code>运行完毕了，并会走到如下语句<code>if(this@SymCoroutine.isMain) Unit else throw IllegalStateException(&quot;SymCoroutine cannot be dead.&quot;)</code>，因为该协程不是协程<code>main</code>，则程序会触发断言，抛出异常。由此将协程切换限制到在协程<code>main</code>开始，最后到协程<code>main</code>里结束</li>
</ol>
<h1><a href="#八-示例仿go的channel实现协程通信" class="header-anchor">#</a><span id="八-示例仿go的channel实现协程通信">八、 示例–仿<code>Go</code>的<code>channel</code>实现协程通信</span></h1>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:RequiresApi</span>(Build.VERSION_CODES.N)</span><br><span class="line"><span class="keyword">package</span> cn.ltt.projectcollection.kotlin.coroutinesLab.go</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.RequiresApi</span><br><span class="line"><span class="keyword">import</span> cn.ltt.projectcollection.kotlin.coroutinesLab.lua.log</span><br><span class="line"><span class="keyword">import</span> cn.ltt.projectcollection.kotlin.coroutinesLab.primary.dispatcher.DispatcherContext</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Channel</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClosedException</span>(message: String) : Exception(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleChannel</span>&lt;<span class="type">T</span>&gt; : <span class="type">Channel</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.javaClass.simpleName</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">object</span> None : Element()</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Producer</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T, <span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;) : Element()</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Consumer</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;) : Element()</span><br><span class="line">        <span class="keyword">object</span> Closed : Element()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> state = AtomicReference&lt;Element&gt;(Element.None)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(value: <span class="type">T</span>)</span></span> = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> prev = state.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                Element.None -&gt; Element.Producer(value, continuation)</span><br><span class="line">                <span class="keyword">is</span> Element.Producer&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot send new element while previous is not consumed.&quot;</span>)</span><br><span class="line">                <span class="keyword">is</span> Element.Consumer&lt;*&gt; -&gt; Element.None</span><br><span class="line">                Element.Closed -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot send after closed.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (prev <span class="keyword">as</span>? Element.Consumer&lt;T&gt;)?.continuation?.resume(value)?.let &#123; continuation.resume(<span class="built_in">Unit</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: T = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> prev = state.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                Element.None -&gt; Element.Consumer(continuation)</span><br><span class="line">                <span class="keyword">is</span> Element.Producer&lt;*&gt; -&gt; Element.None</span><br><span class="line">                <span class="keyword">is</span> Element.Consumer&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot receive new element while previous is not provided.&quot;</span>)</span><br><span class="line">                <span class="keyword">is</span> Element.Closed -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot receive new element after closed.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (prev <span class="keyword">as</span>? Element.Producer&lt;T&gt;)?.let &#123;</span><br><span class="line">            it.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            continuation.resume(it.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> prev = state.getAndUpdate &#123; Element.Closed &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev <span class="keyword">is</span> Element.Consumer&lt;*&gt;) &#123;</span><br><span class="line">            prev.continuation.resumeWithException(ClosedException(<span class="string">&quot;Channel is closed.&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev <span class="keyword">is</span> Element.Producer&lt;*&gt;) &#123;</span><br><span class="line">            prev.continuation.resumeWithException(ClosedException(<span class="string">&quot;Channel is closed.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plainChannelSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = SimpleChannel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    go(<span class="string">&quot;producer&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.6</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;send&quot;</span>, i)</span><br><span class="line">            channel.send(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go(<span class="string">&quot;consumer&quot;</span>, channel::close)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.5</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;receive-i:<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> got = channel.receive()</span><br><span class="line">            log(<span class="string">&quot;got&quot;</span>, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;&quot;</span>, completion: () -&gt; <span class="type">Unit</span> = &#123;&#125;, block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    block.startCoroutine(<span class="keyword">object</span> : Continuation&lt;Any&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context = DispatcherContext()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">            log(<span class="string">&quot;end <span class="variable">$name</span>&quot;</span>, result)</span><br><span class="line">            completion()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    plainChannelSample()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//blockingChannelSample()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>go routine</code>的详细内容可以看前而讲到的<a href="#jumpGoRoutine">Go routine示例</a></li>
<li>因工程里设置的最小<code>API</code>版本为16，而<code>AtomicReference#getAndUpdate()</code>方法需要的<code>API</code>版本为<strong>24</strong>， 所以需要添加注解来标识，因此使用**<code>@file</code>** 来为整个文件添加注解而不需要再在每个方法上添加</li>
<li>定义接口<code>Channel</code>，用于规范协程间通信的管道。在接口中定义三个方法：
<ol>
<li>挂起函数<code>send()</code>方法，用于发送参数</li>
<li>挂起函数<code>receive()</code>方法，用于接收参数</li>
<li>函数<code>close()</code>，用于关闭管道</li>
</ol>
</li>
<li>定义类<code>CosedException</code>，用于显示关闭管道异常信息</li>
<li>定义类<code>SimpleChannel</code>，实现接口<code>channel</code>，该类 <strong>不支持队列</strong>，只能发送接收，不能发送发送再接收接收：
<ol>
<li>创建密封类<code>Element</code>，用于规范管道的几种状态：
<ol>
<li><code>None</code>状态，即没有发送的也没有接收的</li>
<li><code>Producer</code>状态，即已经发送了，但还没有接收</li>
<li><code>Consumer</code>状态，即已经开始接收了，但还没有发送</li>
<li><code>Closed</code>状态，管道关闭</li>
</ol>
</li>
<li>创建状态属性<code>state</code>，类型为<code>AtomicReference</code>类型的<code>Element</code>，初始值为<code>Element.None</code></li>
<li>实现挂起函数<code>send()</code>，通过<code>suspendCoroutine</code>函数可以获取当前挂起函数中的<code>Continuation</code>实例，并且在该函数中可以调用<code>Continuation</code>方法。
<ol>
<li><code>send()</code>方法是发送数据，不需要返回数据，所以<code>suspendCoroutine</code>后的泛型写<code>Unit</code></li>
<li>创建状态属性<code>prev</code>，调用<code>state</code>的<code>getAndUpdate()</code>方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的<code>it</code>即为当前状态，也就是更新之前的状态
<ol>
<li>添加<code>when</code>语句进行状态判断</li>
<li>若为<code>None</code>状态，则将<code>state</code>更新为<code>Producer</code>状态，并将传入的<code>value</code>和当前的<code>coroutine</code>作为参数传进去，等接收人将<code>value</code>取走，并调用这个<code>coroutine</code>来将这个协程恢复执行</li>
<li>若为<code>Producer</code>状态，抛非法异常。因为此时已经是发送待接收状态了不能再发送了</li>
<li>若为<code>Consumer</code>状态，意味着已经在等待发送数据，将数据发送出去，再将<code>state</code>更新为<code>None</code>状态</li>
<li>若为<code>Closed</code>状态，抛非法异常，关闭了就不能再发送了</li>
</ol>
</li>
<li>切换完状态后，将<code>prev</code>判空强转为<code>Consumer</code>状态，意味着已经在等待发送数据，之后每步都加非空判断，调用该状态的协程的<code>resume()</code>方法将<code>value</code>发送出去，之后调用<code>continuation</code>的<code>resume()</code>方法恢复当前协程</li>
</ol>
</li>
<li>实现挂起函数<code>receive()</code>，依然是通过通过<code>suspendCoroutine</code>函数获取当前挂起函数中的<code>Continuation</code>实例，并且在该函数中调用<code>Continuation</code>方法。
<ol>
<li><code>receive()</code>方法用于接收数据，该方法返回接收到的数据，所以<code>suspendCoroutine</code>后的泛型写<code>T</code></li>
<li>创建状态属性<code>prev</code>，调用<code>state</code>的<code>getAndUpdate()</code>方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的<code>it</code>即为当前状态，也就是更新之前的状态
<ol>
<li>添加<code>when</code>语句进行状态判断</li>
<li>若为<code>None</code>状态，则将<code>state</code>更新为<code>Consumer</code>状态，并将当前的<code>coroutine</code>作为参数传进去，</li>
<li>若为<code>Producer</code>状态，意味着已经是发送待接收状态，因此要将数据接收，再将<code>state</code>更新为<code>None</code>状态</li>
<li>若为<code>Consumer</code>状态，抛非法异常。因为此时已经是等待发送状态了，不能接收了。不支持队列</li>
<li>若为<code>Closed</code>状态，抛非法异常，关闭了就不能再发送了</li>
</ol>
</li>
<li>切换完状态后，将<code>prev</code>判空强转为<code>Producer</code>状态，意味着已经发送数据等待接收，之后每步都加非空判断，因为该状态是发送者，不需要返回结果，调用该状态的协程的<code>resume()</code>方法将<code>Unit</code>发送回去，之后调用<code>continuation</code>的<code>resume()</code>方法将发送过来的值传递进去来获取</li>
</ol>
</li>
<li>实现挂起函数<code>close()</code>：
<ol>
<li>创建状态属性<code>prev</code>，调用<code>state</code>的<code>getAndUpdate()</code>方法，将<code>state</code>切换为<code>closed</code>状态，并将切换之前的状态值赋值给<code>prev</code></li>
<li>判断切换之前的状态值：如果是<code>Consumer</code>状态或是<code>Producer</code>状态，调用该状态的<code>continuation</code>的<code>resumeWithException()</code>方法。也就是在关闭过程中管道还在发送或是接收数据，抛出异常管道已经关闭啦不要再用啦</li>
</ol>
</li>
</ol>
</li>
<li>定义函数<code>go()</code>，用于模仿<code>go</code>语言中的<code>routine</code>样式，
<ol>
<li>有三个入参：
<ol>
<li>第一个参数是一个<code>String</code>类型，默认为空，只做打印日志使用</li>
<li>第二个参数是无入参返回值为<code>Unit</code>的函数<code>completion</code>，默认是空函数</li>
<li>第三个参数是无入参返回值为<code>Unit</code>的挂起函数<code>block</code></li>
</ol>
</li>
<li>函数体内调用<code>block</code>的<code>startCoroutine()</code>方法来运行挂起函数：
<ol>
<li>每次运行挂起函数都会创建一个<code>DispatcherContext()</code>，由此实现每个协程都单独运行在自己的线程上。具体实现见<a href="#jumpThreadSwitch">协程间的线程调度</a></li>
<li>在<code>resumeWith()</code>方法中打印信息，并执行传进来的方法<code>completion()</code></li>
</ol>
</li>
</ol>
</li>
<li>定义函数<code>plainChannelSample()</code>，用于非队列非阻塞式管道示例：
<ol>
<li>定义属性<code>channel</code>，赋值为<code>SimpleChannel</code>类的实例，泛型传入<code>Int</code></li>
<li>调用<code>go()</code>函数
<ol>
<li>第一个参数传入<code>producer</code></li>
<li>第二个参数不传</li>
<li>第三个参数传入一个挂起函数，挂起函数体为一个<code>fori</code>循环，从0到6执行7次，每次循环都打印信息，并通过调用<code>channel.send()</code>方法将循环下标值传递出去</li>
</ol>
</li>
<li>调用<code>go()</code>函数：
<ol>
<li>第一个参数传入<code>consumer</code></li>
<li>第二个参数传入匿名函数，函数中调用<code>channel::close</code>，该方法用于关闭管道，即接收完所有数据后调用该方法关闭管道</li>
<li>第三个参数传入一个挂起函数，挂起函数体为一个<code>fori</code>循环，从0到5执行6次，每次循环打印信息，并通过调用<code>channel.receive()</code>方法获取管道发送的值，之后打印该值</li>
</ol>
</li>
</ol>
</li>
<li>创建<code>main()</code>入口函数，在函数中调用<code>plainChannelSample()</code>方法</li>
</ol>
<p><strong>打印结果：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">913</span> [DefaultDispatcher-worker-<span class="number">1</span>] receive</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">913</span> [DefaultDispatcher-worker-<span class="number">0</span>] send <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">0</span>] send <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">2</span>] got <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">2</span>] receive</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">2</span>] got <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">3</span>] send <span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">2</span>] receive</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">2</span>] got <span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">2</span>] receive</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">946</span> [DefaultDispatcher-worker-<span class="number">4</span>] send <span class="number">3</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">4</span>] send <span class="number">4</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">5</span>] got <span class="number">3</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">5</span>] receive</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">5</span>] got <span class="number">4</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">5</span>] receive</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">6</span>] send <span class="number">5</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">6</span>] send <span class="number">6</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">947</span> [DefaultDispatcher-worker-<span class="number">7</span>] got <span class="number">5</span></span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">948</span> [DefaultDispatcher-worker-<span class="number">7</span>] end consumer Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line"><span class="number">16</span>:<span class="number">49</span>:<span class="number">16</span>:<span class="number">949</span> [DefaultDispatcher-worker-<span class="number">8</span>] end producer Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br></pre></td></tr></table></figure>
<p><strong>打印结果说明：</strong></p>
<ol>
<li>最后在<code>go()</code>函数中，协程执行完毕后会打印信息，结果显示<code>consumer</code>协程成功结束，但是<code>producer</code>协程是异常结束，之所以异常是因为<code>consumer</code>只循环了6次，且在最后一次循环后将管道关闭了，而在<code>producer</code>中循环了7次，最后一次循环时管道已经关闭了，抛出异常，因此<code>producer</code>是异常结束</li>
</ol>
<p><strong>定义使用队列的可阻塞式的管道</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueChannel</span>&lt;<span class="type">T</span>&gt; : <span class="type">Channel</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T, <span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">ElementList</span> &#123;</span><br><span class="line">        <span class="keyword">object</span> Nil : ElementList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsElementList</span>&lt;<span class="type">T</span>&gt; : <span class="type">ElementList</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> list = mutableListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">new</span><span class="params">()</span></span>: AbsElementList&lt;T&gt;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">offer</span><span class="params">(element: <span class="type">T</span>)</span></span>: ElementList &#123;</span><br><span class="line">                <span class="keyword">return</span> new().also &#123; it.list += <span class="keyword">this</span>.list + element &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">take</span><span class="params">()</span></span>: ElementList &#123;</span><br><span class="line">                <span class="keyword">val</span> newList = <span class="keyword">this</span>.list - <span class="keyword">this</span>.list.first()</span><br><span class="line">                <span class="keyword">if</span> (newList.isEmpty()) <span class="keyword">return</span> Nil</span><br><span class="line">                <span class="keyword">return</span> new().also &#123; it.list += newList &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T = list.first()</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">elements</span><span class="params">()</span></span>: List&lt;T&gt; = Collections.unmodifiableList(list)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">ProducerList</span>&lt;<span class="type">T</span>&gt; : <span class="type">AbsElementList</span>&lt;<span class="type">Producer&lt;T</span>&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">new</span><span class="params">()</span></span> = ProducerList&lt;T&gt;()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">ConsumerList</span>&lt;<span class="type">T</span>&gt; : <span class="type">AbsElementList</span>&lt;<span class="type">Consumer&lt;T</span>&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">new</span><span class="params">()</span></span> = ConsumerList&lt;T&gt;()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">object</span> Closed : ElementList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> state = AtomicReference&lt;ElementList&gt;(ElementList.Nil)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(value: <span class="type">T</span>)</span></span> = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> prev = state.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                ElementList.Nil -&gt; ElementList.ProducerList&lt;T&gt;().offer(Producer(value, continuation))</span><br><span class="line">                <span class="keyword">is</span> ElementList.ProducerList&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    (it <span class="keyword">as</span> ElementList.ProducerList&lt;T&gt;).offer(Producer(value, continuation))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> ElementList.ConsumerList&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    (it <span class="keyword">as</span> ElementList.ConsumerList&lt;T&gt;).take()</span><br><span class="line">                &#125;</span><br><span class="line">                ElementList.Closed -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot send after closed.&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (prev <span class="keyword">as</span>? ElementList.ConsumerList&lt;T&gt;)?.peek()?.continuation?.resume(value)?.run &#123; continuation.resume(<span class="built_in">Unit</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: T = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> prev = state.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                ElementList.Nil -&gt; ElementList.ConsumerList&lt;T&gt;().offer(Consumer(continuation))</span><br><span class="line">                <span class="keyword">is</span> ElementList.ProducerList&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    (it <span class="keyword">as</span> ElementList.ProducerList&lt;T&gt;).take()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> ElementList.ConsumerList&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    (it <span class="keyword">as</span> ElementList.ConsumerList&lt;T&gt;).offer(Consumer(continuation))</span><br><span class="line">                &#125;</span><br><span class="line">                ElementList.Closed -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Cannot receive after closed.&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (prev <span class="keyword">as</span>? ElementList.AbsElementList&lt;Producer&lt;T&gt;&gt;)?.peek()?.let &#123;</span><br><span class="line">            it.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            continuation.resume(it.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> prev = state.getAndUpdate &#123; ElementList.Closed &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev <span class="keyword">is</span> ElementList.ConsumerList&lt;*&gt;) &#123;</span><br><span class="line">            prev.elements().forEach &#123;</span><br><span class="line">                it.continuation.resumeWithException(ClosedException(<span class="string">&quot;Channel is closed.&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev <span class="keyword">is</span> ElementList.ProducerList&lt;*&gt;) &#123;</span><br><span class="line">            prev.elements().forEach &#123;</span><br><span class="line">                it.continuation.resumeWithException(ClosedException(<span class="string">&quot;Channel is closed.&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">blockingChannelSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = QueueChannel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (n <span class="keyword">in</span> <span class="number">0.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        go(<span class="string">&quot;producer <span class="variable">$n</span>&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> n..n + <span class="number">5</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;send&quot;</span>, i)</span><br><span class="line">                channel.send(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go(<span class="string">&quot;consumer&quot;</span>, channel::close) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.11</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> got = channel.receive()</span><br><span class="line">            log(<span class="string">&quot;got&quot;</span>, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义实现接口<code>Channel</code>的实现类<code>QueueChannel</code>，用于实现队列的可阻塞式的管道
<ol>
<li>定义类<code>Producer</code>，有两个入参</li>
<li>定义类<code>Consumer</code>，有一个入参</li>
<li>定义密封类<code>ElementList</code>，通过列表实现队列功能：
<ol>
<li>定义<code>Nil</code>状态，</li>
<li>定义抽象类<code>AbsElementList</code>:
<ol>
<li>定义可变列表属性<code>list</code></li>
<li>定义抽象方法<code>new()</code>，返回<code>AbsElementList</code>对象</li>
<li>定义方法<code>offer()</code>，入参是泛型<code>T</code>类型的元素，返回结果是一个<code>ElementList</code>对象，函数体中返回的是一个新创建的列表，新列表添加了之前列表的所有内容，并添加了传入的元素</li>
<li>定义开放方法<code>take()</code>，返回一个<code>ElementList</code>对象，函数体操作：先创建属性<code>newList</code>用于存储之前列表去除头部元素后的列表，如果新列表是空的，则返回<code>Nil</code>，否则返回一个新创建的列表，该列表添加了<code>newList</code>中所有元素</li>
<li>定义<code>peek()</code>方法，用于返回当前列表的头部元素</li>
<li>定义<code>elements()</code>方法，用于返回一个只读的元素列表</li>
</ol>
</li>
</ol>
</li>
<li>定义类<code>ProducerList</code>，继承抽象类<code>AbsElementList</code>，重写<code>new()</code>方法，返回一个<code>ProducerList</code>对象</li>
<li>定义类<code>ConsumerList</code>，继承抽象类<code>AbsElementList</code>，重写<code>new()</code>方法，返回一个<code>ConsumerList</code>对象</li>
<li>定义单例类<code>Closed</code></li>
<li>定义属性<code>state</code>，用于保存管道状态，初始化为<code>Nil</code>状态</li>
<li>重写挂起函数<code>send()</code>方法，通过<code>suspendCoroutine</code>函数可以获取当前挂起函数中的<code>Continuation</code>实例，并且在该函数中可以调用<code>Continuation</code>方法。
<ol>
<li><code>send()</code>方法是发送数据，不需要返回数据，所以<code>suspendCoroutine</code>后的泛型写<code>Unit</code></li>
<li>创建状态属性<code>prev</code>，调用<code>state</code>的<code>getAndUpdate()</code>方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的<code>it</code>即为当前状态，也就是更新之前的状态
<ol>
<li>添加<code>when</code>语句进行状态判断</li>
<li>若为<code>Nil</code>状态，则将<code>state</code>更新为<code>ProducerList</code>状态，先将传入的<code>value</code>和当前的<code>coroutine</code>组合为对象<code>Producer</code>，再调用密封类<code>ElementList</code>的子类<code>ProducerList</code>的<code>offer()</code>方法，将组合好的对象<code>Producer</code>作为参数传进去</li>
<li>若为<code>ProducerList</code>状态，不切换状态，当前虽然已经处于已发送待接收状态，但因为使用了列表可以继续发送。先强转为<code>ProucerList</code>状态，然后再调用<code>ProducerList</code>的<code>offer()</code>方法，将传入的<code>value</code>和当前的<code>coroutine</code>这两个参数 组合的对象<code>Producer</code>作为参数传进去</li>
<li>若为<code>ConsumerList</code>状态，当前是等待发送状态，需要将生产者列表中的头元素发送出去，因此需要更新消费者列表去掉头元素，若去掉头元素后列表变为空了，则将状态切换为<code>Nil</code></li>
<li>若为<code>Closed</code>状态，抛非法异常，关闭了就不能再发送了</li>
<li>若为其它状态，则抛非法异常</li>
</ol>
</li>
<li>切换完状态后，将<code>prev</code>判空强转为<code>ConsumerList</code>状态，意味着已经在等待发送数据，之后每步都加非空判断，通过<code>peek()</code>方法取出消费者列表中的第一个消费者，再调用该消费者的协程的<code>resume()</code>方法将<code>value</code>发送出去，之后调用<code>continuation</code>的<code>resume()</code>方法恢复当前协程</li>
</ol>
</li>
<li>重写挂起函数<code>receive()</code>，依然是通过<code>suspendCoroutine</code>函数获取当前挂起函数中的<code>Continuation</code>实例，并且在该函数中调用<code>Continuation</code>方法。
<ol>
<li><code>receive()</code>方法用于接收数据，该方法返回接收到的数据，所以<code>suspendCoroutine</code>后的泛型写<code>T</code></li>
<li>创建状态属性<code>prev</code>，调用<code>state</code>的<code>getAndUpdate()</code>方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的<code>it</code>即为当前状态，也就是更新之前的状态
<ol>
<li>添加<code>when</code>语句进行状态判断</li>
<li>若为<code>Nil</code>状态，则将<code>state</code>更新为<code>ConsumerList</code>状态，先以当前的<code>coroutine</code>为参数创建对象<code>Consumer</code>，再调用密封类<code>ElementList</code>的子类<code>ConsumerList</code>的<code>offer()</code>方法，将组合好的对象<code>Consumer</code>作为参数传进去</li>
<li>若为<code>ProducerList</code>状态，当前处于已发送待接收状态，此时可以接收生产者列表中的头元素，然后更新消费者列表去掉头元素，若去掉头元素后列表变为空，则将状态切换为<code>Nil</code></li>
<li>若为<code>ConsumerList</code>状态，不切换状态，当前虽然是等待发送状态，但还可以继续添加消费者。先强转为<code>ConsumerList</code>状态，然后再调用<code>ConsumerList</code>的<code>offer()</code>方法，将以当前的<code>coroutine</code>为参数创建对象<code>Consumer</code>，再调用<code>offer()</code>方法，将对象<code>Consumer</code>放到消费者列表中</li>
<li>若为<code>Closed</code>状态，抛非法异常，关闭了就不能再接收了</li>
<li>若为其它状态，抛非法异常</li>
</ol>
</li>
<li>切换完状态后，将<code>prev</code>判空强转为以<code>Producer</code>为元素的抽象类<code>AbsElementList</code>的子类列表，此时意味着已经在等待接收数据，之后每步都加非空判断，通过<code>peek()</code>方法取出生产者列表中的第一个生产者，因生产者不需要返回结果，所以调用该生产者的协程的<code>resume()</code>方法时传递的是<code>Unit</code>，之后调用当前<code>continuation</code>的<code>resume()</code>方法将发送过来的值传递进去来获取</li>
</ol>
</li>
<li>重写函数<code>close()</code>：
<ol>
<li>创建存储状态的属性<code>prev</code>，调用<code>state</code>的<code>getAndUpdate()</code>方法，将<code>state</code>切换为<code>closed</code>状态，并将切换之前的状态值赋值给<code>prev</code></li>
<li>判断切换之前的状态值：如果是<code>ConsumerList</code>状态或是<code>ProducerList</code>状态，通过<code>prev</code>的<code>elements</code>方法取到该状态中元素列表，使用<code>foreach</code>循环调用每个元素的<code>continuation</code>的<code>resumeWithException()</code>方法。也就是在关闭过程中管道还在发送或是接收数据，抛出异常管道已经关闭啦不要再用啦</li>
</ol>
</li>
</ol>
</li>
<li>定义函数<code>blockingChannelSample()</code>，用于非队列非阻塞式管道示例：
<ol>
<li>定义属性<code>channel</code>，赋值为<code>QueueChannel</code>类的实例，泛型传入<code>Int</code></li>
<li>创建一个<code>fori</code>循环，循环下标<code>n</code>从0到5共执行6次，每次循环都会调用<code>go()</code>函数：
<ol>
<li><code>go()</code>函数第一个参数传入<code>producer</code>加上当前循环下标值</li>
<li>第二个参数不传</li>
<li>第三个参数传入一个挂起函数，挂起函数体为一个<code>fori</code>循环，循环下标<code>i</code>是从外层循环下标当前值<code>n</code>开始，到<code>n+5</code>结束，共执行6次，每次循环都打印信息，并通过调用<code>channel.send()</code>方法将内循环下标<code>i</code>值传递出去</li>
</ol>
</li>
<li>调用<code>go()</code>函数：
<ol>
<li>第一个参数传入<code>consumer</code></li>
<li>第二个参数传入匿名函数，函数中调用<code>channel::close</code>，该方法用于关闭管道，即接收完所有数据后调用该方法关闭管道</li>
<li>第三个参数传入一个挂起函数，挂起函数体为一个<code>fori</code>循环，从0到11执行12次，每次循环打印信息，并通过调用<code>channel.receive()</code>方法获取管道发送的值，之后打印该值</li>
</ol>
</li>
</ol>
</li>
<li>最后在<code>main()</code>入口函数中调用<code>blockingChannelSample()</code>方法</li>
</ol>
<p><strong>打印结果：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">691</span> [DefaultDispatcher-worker-<span class="number">1</span>] send <span class="number">1</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">691</span> [DefaultDispatcher-worker-<span class="number">5</span>] send <span class="number">5</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">691</span> [DefaultDispatcher-worker-<span class="number">3</span>] send <span class="number">3</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">691</span> [DefaultDispatcher-worker-<span class="number">4</span>] send <span class="number">4</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">691</span> [DefaultDispatcher-worker-<span class="number">2</span>] send <span class="number">2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">691</span> [DefaultDispatcher-worker-<span class="number">0</span>] send <span class="number">0</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">721</span> [DefaultDispatcher-worker-<span class="number">1</span>] send <span class="number">2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">721</span> [DefaultDispatcher-worker-<span class="number">7</span>] got <span class="number">1</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">721</span> [DefaultDispatcher-worker-<span class="number">5</span>] send <span class="number">6</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">721</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">5</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">721</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">4</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">9</span>] send <span class="number">5</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">3</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">10</span>] send <span class="number">4</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">11</span>] send <span class="number">3</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">0</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">12</span>] send <span class="number">1</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">13</span>] send <span class="number">3</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">6</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">722</span> [DefaultDispatcher-worker-<span class="number">14</span>] send <span class="number">7</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">5</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">15</span>] send <span class="number">6</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">4</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">15</span>] send <span class="number">5</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">3</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">4</span>] send <span class="number">4</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">8</span>] got <span class="number">1</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">723</span> [DefaultDispatcher-worker-<span class="number">4</span>] send <span class="number">2</span></span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">724</span> [DefaultDispatcher-worker-<span class="number">8</span>] end consumer Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">725</span> [DefaultDispatcher-worker-<span class="number">7</span>] end producer <span class="number">2</span> Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">725</span> [DefaultDispatcher-worker-<span class="number">5</span>] end producer <span class="number">0</span> Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">725</span> [DefaultDispatcher-worker-<span class="number">3</span>] end producer <span class="number">1</span> Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">725</span> [DefaultDispatcher-worker-<span class="number">0</span>] end producer <span class="number">5</span> Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">725</span> [DefaultDispatcher-worker-<span class="number">2</span>] end producer <span class="number">3</span> Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br><span class="line"><span class="number">17</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">725</span> [DefaultDispatcher-worker-<span class="number">8</span>] end producer <span class="number">4</span> Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel <span class="keyword">is</span> closed.)</span><br></pre></td></tr></table></figure>
<p><strong>打印结果说明：</strong></p>
<ol>
<li>因是多协程操作，每次运行的打印结果都不一样</li>
<li>最后在<code>go()</code>函数中，协程执行完毕后会打印信息，结果显示<code>consumer</code>协程成功结束，但是5个<code>producer</code>协程都是异常结束，之所以异常是因为<code>consumer</code>只循环了12次，且在最后一次循环后将管道关闭了，而有6个生产者且每个生产者发送了6条数据给<code>consumer</code>，而<code>consumer</code>只循环了12次，不能把各生产者发送的值都接收到，所以抛出异常，因此<code>producer</code>是异常结束，将<code>consumer</code>协程里的循环改为到35结束，即循环36次，将生产者们发送的值都接收到，如此生产者们就不会异常结束了</li>
</ol>
<h1><a href="#八-示例仿js实现async-await" class="header-anchor">#</a><span id="八-示例仿js实现async-await">八、 示例–仿<code>Js</code>实现<code>async await</code></span></h1>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AsyncScope</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> AsyncScope.<span class="title">await</span><span class="params">(block: () -&gt; <span class="type">Call</span>&lt;<span class="type">T</span>&gt;)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    <span class="keyword">val</span> call = block()</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback&lt;T&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(response.isSuccessful)&#123;</span><br><span class="line">                response.body()?.let(continuation::resume) ?: continuation.resumeWithException(NullPointerException())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                continuation.resumeWithException(HttpException(response))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">async</span><span class="params">(context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="type">suspend</span> <span class="type">AsyncScope</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> completion = AsyncCoroutine(context)</span><br><span class="line">    block.startCoroutine(completion, completion)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncCoroutine</span>(<span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext): Continuation&lt;<span class="built_in">Unit</span>&gt;, AsyncScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        result.getOrThrow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    async() &#123;</span><br><span class="line">        <span class="keyword">val</span> user = await &#123; githubApi.getUserCallback(<span class="string">&quot;puppet16&quot;</span>) &#125;</span><br><span class="line">        log(user)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request: <span class="number">200</span></span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">56</span>:<span class="number">395</span> [OkHttp https:<span class="comment">//api.github.com/...] User(id=14159272, name=Puppet16, url=https://api.github.com/users/puppet16)</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>js</code>的<code>async await</code>的详细内容可以看前面讲到的<a href="#jumpJsAsync"><code>async/await</code>关键字</a></li>
<li>定义一个接口<code>AsyncScope</code>，用于约束<code>async()</code>、<code>await()</code>这两个函数的使用范围</li>
<li>创建类<code>AsyncCoroutine</code>，实现接口<code>Continuation</code>和接口<code>AsyncScope</code>：
<ol>
<li>重写<code>ConroutineContext</code>类型的<code>context</code>，默认值为<code>EmptyCoroutinContext</code></li>
<li>重写<code>resumeWith()</code>方法，在该方法中如果结果有异常则抛出异常</li>
</ol>
</li>
<li>定义函数<code>async()</code>：
<ol>
<li>第一个入参是<code>CoroutineContext</code>类型的变量<code>context</code>，它的默认值是<code>EmptyCoroutineContext</code></li>
<li>第二个入参是挂起函数的<code>lambda</code>表达式<code>block</code>，必须是限制必须是<code>AsyncScope</code>的扩展函数</li>
<li>创建名为<code>completion</code>的<code>AsyncCoroutine</code>类的实例，将<code>context</code>传入其中</li>
<li>之后调用<code>startCoroutine()</code>启动<code>block</code>协程，该方法需要的<code>receiver</code>和协程结束时调用的<code>completion</code>都传入上一步创建的<code>completion</code></li>
</ol>
</li>
<li>定义挂起函数<code>await()</code>，该函数传入一个<code>lambda</code>表达式，该表达式没有入参、出参是一个<code>Call</code>对象。之后通过<code>suspendCoroutine</code>函数获取当前挂起函数中的<code>Continuation</code>实例
<ol>
<li>创建属性<code>call</code>，用于保存<code>block()</code>返回的结果</li>
<li>调用<code>call</code>的异步请求方法<code>enqueue()</code>，该方法需要有一个<code>Callback</code>类对象，因此使用 <strong><code>object:</code>关键字创建<code>Callback</code>类的匿名内部对象</strong>，之后重写该类中方法
<ol>
<li>在<code>onFailure()</code>方法中通过<code>resumeWithException()</code>方法给协程抛出异常</li>
<li>在<code>onResponse()</code>方法中，先判断网络请求是否成功，若未成功则抛出异常；若成功则取<code>response</code>的<code>body</code>对象，若有<code>body</code>对象则通过函数引用，直接调用协程的<code>resume()</code>方法；若没有<code>body</code>对象则调用<code>resumeWithException()</code>方法抛出空指针异常</li>
</ol>
</li>
</ol>
</li>
<li>由此<code>async</code>本身没有异步的能力，异步是由<code>call</code>的<code>enqueue()</code>方法提供的</li>
</ol>
<h1><a href="#九-延伸揭秘-suspend-fun-main" class="header-anchor">#</a><span id="九-延伸揭秘-suspend-fun-main">九、延伸–揭秘 <code>suspend fun main</code></span></h1>
<h2><a href="#1-普通的main函数" class="header-anchor">#</a><span id="1-普通的main函数">1. 普通的<code>main</code>函数</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自<code>Kotlin 1.3</code>之后可省略参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//since kotlin 1.3</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-可挂起的main函数" class="header-anchor">#</a><span id="2-可挂起的main函数">2. 可挂起的<code>main</code>函数</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挂起<code>main</code>函数看起来函数类型为：<code>suspend () -&gt; Unit</code>。但其实该函数传入了一个<code>Continuation</code>，并且返回了一个<code>Any?</code>，即实际上类型为<code>(Continuation&lt;Unit&gt;) -&gt; Any?</code>，本质上挂起<code>main</code>函数为如下样式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而定义为如上形式也就不是入口函数了，可以使用<code>runSuspend()</code>方法运行如上形式函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main1</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Unit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runSuspend(::main1 <span class="keyword">as</span> <span class="keyword">suspend</span> () -&gt; <span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> kotlin.coroutines.jvm.<span class="keyword">internal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.Continuation</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.CoroutineContext</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.EmptyCoroutineContext</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.startCoroutine</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrapper for `suspend fun main` and `<span class="doctag">@Test</span> suspend fun testXXX` functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">runSuspend</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> run = RunSuspend()</span><br><span class="line">    block.startCoroutine(run)</span><br><span class="line">    run.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RunSuspend</span> : <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result: Result&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="keyword">this</span> <span class="keyword">as</span> Object).notifyAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span> = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">val</span> result = <span class="keyword">this</span>.result) &#123;</span><br><span class="line">                <span class="literal">null</span> -&gt; <span class="meta">@Suppress(<span class="string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="keyword">this</span> <span class="keyword">as</span> Object).wait()</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    result.getOrThrow() <span class="comment">// throw up failure</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在入口<code>main()</code>函数中使用<code>runSuspend()</code>方法运行<code>main1()</code>方法，其中将<code>main1()</code>函数类型引用强转为<code>suspend () -&gt; Unit</code></li>
<li>函数<code>runSuspend()</code>是标准库中的源码函数，该函数被<code>internal</code>，没办法直接调用，因此直接将该函数代码从源码中提取出来</li>
<li><code>runSuspend()</code>函数，入参为标准的无参返回值为<code>Unit</code>的挂起函数<code>block</code>，在函数体中创建<code>RunSuspend</code>类的对象<code>run</code>，调用<code>block</code>的<code>startCoroutine()</code>方法开启协程，并将<code>run</code>作为<code>completion</code>传递进去，最后再调用<code>await()</code>方法</li>
<li><code>RunSuspend</code>类实现接口<code>Continuation</code>:
<ol>
<li><code>context</code>为<code>EmptyCoroutineContext</code></li>
<li>定义结果属性<code>result</code>，设置初始值为<code>null</code>，<code>Result</code>作为特殊类型，编译器不允许它作为返回值的类型，而声明为<code>var</code>的属性有<code>getter</code>，所以该行会报错：<code>'kotlin.Result' cannot be used as a return type</code>。<br>
而要解决该报错，只需要在<code>module</code>的<code>build.gradle</code>文件中<code>kotlinOptions</code>中配置如下代码：<code>freeCompilerArgs = [&quot;-Xallow-result-return-type&quot;]</code>，如下图所示：<br>
<img src="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/coroutine_freecompilerargs.png" alt></li>
<li>重写<code>resumeWith()</code>方法，将协程返回的结果赋值给属性<code>result</code></li>
<li>定义<code>await()</code>方法，添加<code>synchronized</code>关键字保证线程安全，添加一个<code>while</code>死循环，在循环体内判断如果<code>result</code>为<code>null</code>，则调用<code>object</code>的<code>wait()</code>方法继续等待；而如果<code>result</code>不为<code>null</code>，则直接将其取到并返回</li>
</ol>
</li>
<li><code>wait()、notify/notifyAll()</code>方法延伸：
<ol>
<li><code>wait()</code>使当前线程阻塞，前提是 <strong>必须先获得锁</strong>，一般配合<code>synchronized</code> 关键字使用，即一般在<code>synchronized</code> 同步代码块里使用 <code>wait()、notify/notifyAll()</code> 方法</li>
<li>由于 <code>wait()、notify/notifyAll()</code> 在<code>synchronized</code> 代码块执行，说明当前线程一定是获取了锁</li>
<li>当线程执行<code>wait()</code>方法时候，会释放当前的锁，然后让出<code>CPU</code>，进入等待状态。只有当 <code>notify/notifyAll()</code> 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完<code>synchronized</code> 代码块的代码或是中途遇到<code>wait()</code> ，再次释放锁。<br>
也就是说，<strong><code>notify/notifyAll()</code> 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况</strong>。所以在编程中，尽量在使用了<code>notify/notifyAll()</code> 后立即退出临界区，以唤醒其他线程让其获得锁</li>
<li><code>wait()</code> 需要被<code>try catch</code>包围，以便发生异常中断也可以使<code>wait</code>等待的线程唤醒</li>
<li><code>notify</code> 和<code>wait</code> 的顺序不能错，如果 <strong>A</strong> 线程先执行<code>notify</code>方法，<strong>B</strong> 线程在执行<code>wait</code>方法，那么 <strong>B</strong> 线程是无法被唤醒的</li>
<li><code>notify</code> 和 <code>notifyAll</code>的区别：
<ol>
<li><code>notify</code>方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现</li>
<li><code>notifyAll</code> 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用<code>notifyAll</code> 方法</li>
</ol>
</li>
</ol>
</li>
<li>如果先调用的<code>resumeWith()</code>，再调用的<code>await()</code>，则<code>result</code>值不会为<code>null</code>，则会在<code>await()</code>方法中将<code>result</code>值抛出去；如果先调用<code>await()</code>，再调用<code>resumeWith()</code>，此时<code>result</code>值为<code>null</code>，会调用<code>wait</code>方法，将线程阻塞在这里，直到其它线程调用了<code>resumeWith()</code>方法，并在该方法中调用了<code>notifyAll</code>,将刚才阻塞的线程唤醒，又执行了一次循环，此时<code>result</code>不为<code>null</code>，如此将<code>result</code>值抛出去</li>
</ol>
<h1><a href="#十-参考文章" class="header-anchor">#</a><span id="十-参考文章">十、参考文章</span></h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cpcpcp123/article/details/111724079">kotlin协程的挂起suspend</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e6835573a9c">Kotlin协程简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42063726/article/details/106198212">Kotlin协程-协程的内部概念Continuation</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/z974656361/article/details/110247463">AtomicReference源码详解</a></li>
</ol>
<h1><a href="#二-示例仿官方框架实现launch" class="header-anchor">#</a><span id="二-示例仿官方框架实现launch">二、示例–仿官方框架实现<code>launch</code></span></h1>
<h2><a href="#1-协程回顾" class="header-anchor">#</a><span id="1-协程回顾">1. 协程回顾</span></h2>
<h3><a href="#1-协程创建" class="header-anchor">#</a><span id="1-协程创建">1. 协程创建</span></h3>
<ul>
<li>协程是一段可执行的程序</li>
<li>协程的创建通常 <strong>需要一个函数</strong>，即 <strong><code>suspend function</code></strong></li>
<li>协程的创建也需要一个<code>API</code>，即<code>createCoroutine</code>：只创建不执行、<code>startCoroutine</code>：创建后执行</li>
</ul>
<h3><a href="#2-协程启动" class="header-anchor">#</a><span id="2-协程启动">2. 协程启动</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;.startCoroutine(<span class="keyword">object</span>:Continuation&lt;<span class="built_in">Unit</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        prinln(<span class="string">&quot;Coroutine End with <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>使用<code>startCoroutine</code>协程创建后会被立即执行</li>
<li><code>suspend function</code>在编译完成之后会被包装成一个<code>continuation</code>，这个<code>continuation</code>即为协程的本体，协程挂起恢复调用<code>resume()</code>时也是调用这个<code>continuation</code>的<code>resume()</code></li>
<li><code>startCoroutine()</code>方法中传入形参名为<code>completion</code>的<code>continuation</code>, 在协程执行完成后会调用该<code>continuation</code>的<code>resumeWith()</code>方法</li>
</ol>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-04-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><span class="leancloud_visitors"></span><span>大约23266个字, 17分钟33秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2023/04/06/kotlin学习系列番外篇/,Puppet,kotlin学习系列番外篇,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/05/16/Java%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" title="Java编程规范">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>