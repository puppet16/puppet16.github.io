{"pages":[{"title":"tags","text":"#TAGS","link":"/tags/index.html"},{"title":"留言","text":"#欢迎大家留言讨论，共同进步!","link":"/guestbook/index.html"},{"title":"关于博客","text":"#兴之所至，心之所安； 尽其在我，顺其自然。","link":"/about/index.html"}],"posts":[{"title":"ADB常用命令","text":"一、查看当前连接设备 二、为命令指定目标设备 三、断开无线连接的设备 四、应用管理 1. 查看应用列表 2. 安装APK 3. 卸载应用 4. 清除应用数据与缓存 5. 查看顶部Activity 6. 查看应用详细信息 7. 强制停止应用 五、文件管理 1. 复制设备里的文件到电脑 2. 复制电脑里的文件到设备 六、查看设备信息 1. 查看型号 2. 电池状况 3. 屏幕分辨率 4. 屏幕密度 5. 显示屏参数 6. IP 地址 7. 更多硬件与系统属性 #一、查看当前连接设备 命令格式： adb devices #二、为命令指定目标设备 如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s 指定相应 serialNumber 号的设备/模拟器为命令目标 其中serialNumber使用adb devices命令获取，如下 1234localhost:zs_student_android ltt$ adb devicesList of devices attachede68e6c20 device10.201.62.78:5555 device 输出里的 e68e6c20、10.201.62.78:5555 即为 serialNumber。示例如下: adb -s 10.201.62.78:5555 install test.apk #三、断开无线连接的设备 命令格式： adb disconnect &lt;device-ip-address&gt; #四、应用管理 #1. 查看应用列表 命令格式： adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 包名包含 字符串 #2. 安装APK 命令格式： adb install [-lrtsdg] &lt;path_to_apk&gt; 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=“true” 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后成功输出如下： 123localhost:zs_student_android ltt$ adb -d install -r debug.apk Performing Streamed InstallSuccess #3. 卸载应用 命令格式： adb uninstall [-k] &lt;packagename&gt; 说明： 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录 #4. 清除应用数据与缓存 命令格式： adb shell pm clear &lt;packagename&gt; 说明： 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 #5. 查看顶部Activity adb shell dumpsys activity top #6. 查看应用详细信息 命令格式： adb shell dumpsys package &lt;packagename&gt; 说明：输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 #7. 强制停止应用 命令格式： adb shell am force-stop &lt;packagename&gt; #五、文件管理 #1. 复制设备里的文件到电脑 命令格式： adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 说明：其中 电脑上的目录 参数可以省略，默认复制到当前目录。 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 #2. 复制电脑里的文件到设备 命令格式： adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 #六、查看设备信息 #1. 查看型号 命令格式： adb shell getprop ro.product.model 输出示例： 123localhost:zs_student_android ltt$ adb -d shellnatrium:/ $ getprop ro.product.modelMI 5s Plus #2. 电池状况 命令格式： adb shell dumpsys battery 输出示例： 123456789101112131415161718localhost:zs_student_android ltt$ adb -d shellnatrium:/ $ dumpsys batteryCurrent Battery Service state: AC powered: false USB powered: true Wireless powered: false Max charging current: 500000 Max charging voltage: 5000000 Charge counter: 3057193 status: 2 health: 2 present: true level: 100 scale: 100 voltage: 4322 temperature: 355 technology: Li-polynatrium:/ $ #3. 屏幕分辨率 命令格式： adb shell wm size 输出示例: 123natrium:/ $ wm size Physical size: 1080x1920natrium:/ $ #4. 屏幕密度 命令格式： adb shell wm density 输出示例: 123natrium:/ $ wm densityPhysical density: 480natrium:/ $ #5. 显示屏参数 命令格式： adb shell dumpsys window displays 输出示例: 12345natrium:/ $ dumpsys window displaysWINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 480dpi cur=1080x1920 app=1080x1920 rng=1080x1008-1920x1848 deferred=false mLayoutNeeded=false mTouchExcludeRegion=SkRegion((0,0,1080,1920)) #6. IP 地址 命令格式： adb shell ifconfig | grep Mask 输出示例: 123456789101112131415161718192021222324252627282930313233|natrium:/ $ ifconfiglo Link encap:UNSPEC inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope: Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:36944 errors:0 dropped:0 overruns:0 frame:0 TX packets:36944 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:3245483 TX bytes:3245483 dummy0 Link encap:UNSPEC inet6 addr: fe80::b4e7:cfff:fef9:4fae/64 Scope: Link UP BROADCAST RUNNING NOARP MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:166 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 TX bytes:11620 wlan0 Link encap:UNSPEC Driver cnss_wlan_pci inet addr:10.211.56.115 Bcast:10.211.63.255 Mask:255.255.248.0 inet6 addr: fe80::c60b:cbff:fe82:a158/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:7718005 errors:0 dropped:0 overruns:0 frame:0 TX packets:867328 errors:0 dropped:3 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:2542947775 TX bytes:120155558 rmnet_ipa0 Link encap:UNSPEC UP RUNNING MTU:2000 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 TX bytes:0 #7. 更多硬件与系统属性 命令格式： adb shell cat /system/build.prop 说明： 这会输出很多信息，包括前面几个小节提到的「型号」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 输出示例： :/ # cat /system/build.prop # begin build properties # autogenerated by buildinfo.sh ro.build.id=PQ3A.190801.002 ro.build.display.id=lineage_natrium-userdebug 9 PQ3A.190801.002 cd6bf65336 ro.build.version.incremental=cd6bf65336 ro.build.version.sdk=28 ro.build.version.preview_sdk=0 ro.build.version.codename=REL ro.build.version.all_codenames=REL ro.build.version.release=9 ro.build.version.security_patch=2019-11-05 ro.build.version.base_os= ro.build.version.min_supported_target_sdk=17 ro.build.date=Tue Dec 10 11:41:15 UTC 2019 ro.build.date.utc=1575978075 ro.build.type=userdebug ro.build.user=buildkite-agent ro.build.host=lineageos-buildkite ro.build.tags=release-keys ro.build.flavor=lineage_natrium-userdebug ro.product.model=MI 5s Plus ro.product.brand=Xiaomi ro.product.name=natrium ro.product.device=natrium # ro.product.cpu.abi and ro.product.cpu.abi2 are obsolete, # use ro.product.cpu.abilist instead. ro.product.cpu.abi=arm64-v8a ro.product.cpu.abilist=arm64-v8a,armeabi-v7a,armeabi ro.product.cpu.abilist32=armeabi-v7a,armeabi ro.product.cpu.abilist64=arm64-v8a ro.product.manufacturer=Xiaomi ro.product.locale=en-US ro.wifi.channels= # ro.build.product is obsolete; use ro.product.device ro.build.product=natrium # Do not try to parse description, fingerprint, or thumbprint ro.build.description=natrium-user 7.0 NRD90M V9.6.2.0.NBGMIFD release-keys ro.build.fingerprint=Xiaomi/natrium/natrium:7.0/NRD90M/V9.6.2.0.NBGMIFD:user/release-keys ro.build.characteristics=default ro.lineage.device=natrium # end build properties # # ADDITIONAL_BUILD_PROPERTIES # ro.treble.enabled=false persist.sys.dalvik.vm.lib.2=libart.so dalvik.vm.isa.arm64.variant=kryo dalvik.vm.isa.arm64.features=default dalvik.vm.isa.arm.variant=kryo dalvik.vm.isa.arm.features=default dalvik.vm.lockprof.threshold=500 net.bt.name=Android dalvik.vm.stack-trace-dir=/data/anr ro.lineage.version=16.0-20191210-NIGHTLY-natrium ro.lineage.releasetype=NIGHTLY ro.lineage.build.version=16.0 ro.modversion=16.0-20191210-NIGHTLY-natrium ro.lineagelegal.url=https://lineageos.org/legal ro.lineage.display.version=16.0-20191210-NIGHTLY-natrium ro.lineage.build.version.plat.sdk=9 ro.lineage.build.version.plat.rev=0 ro.build.expect.modem=2018-11-21 10:46:10,8.11.23 ro.expect.recovery_id=0xdba5ab1265429e5480be01f327fb9860e39a1735000000000000000000000000 小提示：没有root可能会提示cat: /system/build.prop: Permission denied，这时在adb shell 里直接执行su就会看到用户命令提示符由”$”变成了”#”表示adb shell获取了root权限(仅限手机已root，且有su包) 参考：玩转ADB命令（ADB命令使用大全）https://blog.csdn.net/zhonglunshun/article/details/78362439","link":"/2020/06/01/ADB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Android使用FFmpeg之旅","text":"一、前言 1.1 如何在 Android 里使用 FFmpeg 二、下载资源 2.1 FFmpeg 源码下载 2.2 NDK 下载 三、编译 FFmpeg 3.1 配置 NDK 环境变量 3.2 修改原始脚本 3.2.1 修改 so 文件后缀 3.3 编写自己的脚本 3.4 运行自己的脚本 四、在 Android 中使用 FFmpeg 4.1 添加 FFmpeg 库文件 4.2 编写自己的 JNI 代码 4.3 配置 CMakeLists.txt 文件 遇到的问题 1 FFmpeg 与 NDK 版本不兼容 2 cpp 文件里链接不到对应的库 3 不显示打印的日志 4 codec permission defined 5 ERROR: x264 not found using pkg-config 6 时间戳非单调递增 #一、前言 FFmpeg 是一个跨平台的多媒体库，也是目前音视频领域应用最广泛的库。包括 libavcodec、libavformat、libavutil、libavdevice、libavfilter、libswscale、libswresample、libpostproc 等模块。 avcodec 用于编解码 avformat 用于解封装 avutil 是提供工具类 avdevice 用于各平台的设备接入 avfilter 提供滤镜操作 swscale 提供图像缩放与像素格式转换 swresample提供音频重采样 postproc提供高级处理 #1.1 如何在 Android 里使用 FFmpeg 第一步，编译 FFmpeg FFmpeg 是一个用C编写的开源多媒体框架，Android 无法直接使用，需要将其编译为 Android 支持的动态库 ( .so文件)。 编译时需要针对 Android 的 CPU 架构 (如ARMv7、ARM64、x86等) 进行交叉编译。 第二步，集成到 Android 项目，通过 JNI 调用 FFmpeg 在 Android 项目中，Java 代码无法直接调用 C 代码，需要通过 JNI 实现 Java/Kotlin 与 C 的交互。 编写 JNI 层代码，封装 FFmpeg 的功能，供 Java/kotlin 调用。 将编译好的 FFmpeg 库和 JNI 代码集成到 Android Studio 项目中。 使用 CMake 或 NDK-Build 配置项目的构建过程。 #二、下载资源 编译 FFmpeg 前，要下载两个东西：FFmpeg 源码、NDK。 我所使用的版本： FFmpeg源码：7.1.1 NDK：22.1.7171670 #2.1 FFmpeg 源码下载 下载源码有两种方式： 直接去官网下载，官网地址：https://ffmpeg.org/download.html 使用 git 命令：git clone https://github.com/FFmpeg/FFmpeg.git #2.2 NDK 下载 下载 NDK 有两种方式： 去 Android 官网下载 ndk 源码，官网地址：https://developer.android.com/ndk/downloads?hl=zh-cn 使用 Android Studio 下载NDK 如上图所示，先打开 File -&gt; Setting 对话框，然后按 1 --&gt; 2 --&gt; 3 --&gt; 4 步骤进行操作。 #三、编译 FFmpeg 编译 FFmpeg 需要 NDK 的参与，因此要先配置 NDK 环境变量 #3.1 配置 NDK 环境变量 在编译 FFmpeg 前，要先配置 NDK 的环境变量。以 Mac 为例，有如下步骤： 使用 vim ~/.bash_profile 命令，打开 bash_profile 文件 然后按 E 打开文件的编辑模式，再按 I 打开插入模式，此时就可以向文件里输入内容了 在文件里添加 export NDK_PATH=/Users/luck/Library/Android/sdk/ndk/22.1.7171670 按 esc 键 退出插入模式，然后输入 :wq 保存并退出文件 #3.2 修改原始脚本 在 FFmpeg 源码目录有个 configure 配置脚本，使用 ./configure --help 可以查看命令相关内容。 #3.2.1 修改 so 文件后缀 修改原始脚本的目的是为了修改 so 文件的后缀。默认编译出来的 so 库包括 avcodec 、avformat、avutil、avdevice、avfilter、swscale、 swresample 等，编译出来的 so 是个软链接，真正 so 名字后缀带有一长串主版本号与子版本号，这样的 so 名字在 Adnroid 平台无法识别。所以我们需要修改一下。 首先打开 configure 文件，然后全局搜索 SLIBNAME，会出来如下内容： 1234567SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)' 将其替换为 1234567SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'SLIB_INSTALL_LINKS='$(SLIBNAME)' #3.3 编写自己的脚本 在 FFmpeg 源码根目录创建一个 shell 脚本，比如命名为buildff.sh，以 mac 编译环境为例，下面例子是采用 ndk 新版的 clang 进行编译。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/bin/bashmake cleanset -earchbit=64if [ $archbit -eq 64 ];thenecho &quot;build for 64bit&quot;ARCH=aarch64CPU=armv8-aAPI=21PLATFORM=aarch64ANDROID=androidCFLAGS=&quot;&quot;LDFLAGS=&quot;&quot;elseecho &quot;build for 32bit&quot;ARCH=armCPU=armv7-aAPI=16PLATFORM=armv7aANDROID=androideabiCFLAGS=&quot;-mfloat-abi=softfp -march=$CPU&quot;LDFLAGS=&quot;-Wl,--fix-cortex-a8&quot;fiexport NDK=/Users/luck/Library/Android/sdk/ndk/22.1.7171670export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64/binexport SYSROOT=$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysrootexport CROSS_PREFIX=$TOOLCHAIN/$ARCH-linux-$ANDROID-export CC=$TOOLCHAIN/$PLATFORM-linux-$ANDROID$API-clangexport CXX=$TOOLCHAIN/$PLATFORM-linux-$ANDROID$API-clang++export PREFIX=./ffmpeg-android/$CPUfunction build_android { ./configure \\ --prefix=$PREFIX \\ --cross-prefix=$CROSS_PREFIX \\ --target-os=android \\ --arch=$ARCH \\ --cpu=$CPU \\ --cc=$CC \\ --cxx=$CXX \\ --nm=$TOOLCHAIN/$ARCH-linux-$ANDROID-nm \\ --strip=$TOOLCHAIN/$ARCH-linux-$ANDROID-strip \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=&quot;$CFLAGS&quot; \\ --extra-ldflags=&quot;$LDFLAGS&quot; \\ --extra-ldexeflags=-pie \\ --enable-runtime-cpudetect \\ --disable-static \\ --enable-shared \\ --disable-ffprobe \\ --disable-ffplay \\ --disable-ffmpeg \\ --disable-debug \\ --disable-doc \\ --enable-avfilter \\ --enable-decoders \\ --enable-jni \\ --enable-mediacodec \\ --enable-decoder=h264_mediacodec \\ --enable-decoder=hevc_mediacodec \\ --enable-decoder=mpeg4_mediacodec \\ --enable-hwaccel=h264_mediacodec $ADDITIONAL_CONFIGURE_FLAG make make install}build_android 如上所示，shell脚本分为 4 个阶段： 第一段，make clean 清除缓存，set -e 设置编译出错后马上退出，archbit=xx 指定 cpu 架构是 32 位还是 64 位 第二段，if...else...fi 用来条件编译不同 cpu 架构对应字段的值 第三段，用 export 关键字声明宏定义，其中 PREFIX 是指定输出文件路径 第四段，是一个执行函数，按照 ffmpeg 的 configure 规范进行编写。函数里面的 enable 代表开启，disable 代表关闭，也就是对 ffmpeg 进行剪裁，根据我们需要的功能进行 enable。 make 命令是执行编译，make install 命令是执行安装 最后的 build_android 是执行函数 #3.4 运行自己的脚本 初次执行 shell 脚本，需要修改脚本权限，使用 linux 命令：chmod 777 buildff.sh。 执行脚本只需要一行命令, 即在命令行输入./buildff.sh。编译过程中，命令行会不断打印编译日志，等待命令行输出 INSTALL xxx 关键字代表编译完成。 编译后会在目标目录下生成一个目录，目录名为前面指定的 CPU 架构，在这个架构目录下才是真正产出的内容。如下图所示： lib, 该目录内存放的是 so 文件 include, 该目录内存放的是库的头文件 #四、在 Android 中使用 FFmpeg 由于 FFmpeg 是 c 语言写的代码，所以要在 Android Studio 中调用 FFmpeg 的核心思路是将 FFmpeg 编译为 Android 可用的库 (.so文件) 然后通过 JNI (Java Native Interface) 调用 FFmpeg 的功能。经过上面的步骤，已经将 FFmpeg 编译好了，下面就是将其添加到工程里 JNI 是 Java 本地接口，定义 Android 从应用代码 (以 Java 或 kotlin 编程语言编写) 到本地代码 (C/C++ 编写) 交互编译成字节码的一种方式 #4.1 添加 FFmpeg 库文件 创建目录及文件 如上所示，首先在 app/src/main 下创建一个 cpp 目录，用于编写 JNI 代码以及存放 FFmpeg 库文件，然后创建如下内容： arm64-v8a 目录，该目录名称要写支持的 CPU 架构，还要与 FFmpeg 编译时选用的 CPU 架构一致。该目录存放的是编译出来的一系列的 so 文件 include 目录，该目录下存放的各库一系列的头文件，也就是编译产物里 include 目录下的内容 创建 CMakeLists.txt 文件，该文件是 CMake 构建系统的核心配置文件，用于定义项目的编译规则、依赖管理和平台适配等 配置 gradle 文件 我的 gradle 文件使用的 kts，所以配置内容如下： 12345678910111213141516android { // ... defaultConfig { // ... externalNativeBuild { cmake { cppFlags.add(&quot;-std=c++11&quot;) abiFilters.add(&quot;arm64-v8a&quot;)// 根据你的需求选择 ABI } } ndk { abiFilters.add(&quot;arm64-v8a&quot;) // 同上 ldLibs?.add(&quot;android&quot;) ?: mutableListOf(&quot;log&quot;) } }} #4.2 编写自己的 JNI 代码 在 C++ 中，通常将代码分为头文件 （.h 或 .hpp） 和源文件 （.cpp） 两种类型。在实际开发中，头文件主要用于暴露接口和声明，而源文件用于实现具体的功能。 所以，在 cpp 目录下创建C代码所需文件： native-lib.h、native-lib.cpp 两个文件。然后在 java 层创建一个 RecorderHelper 的文件，用于调用 C 编写的代码 下面以获取 FFmpeg 版本号为例，进行代码撰写 首先在 Java/kotlin 代码层去创建一个获取版本号的方法 1234567class RecorderHelper { init { System.loadLibrary(&quot;native-lib&quot;) } external fun getFFmpegVersion(): String} 调用 C 层代码的方法，在 kotlin 语法里，要添加 external 关键字；Java 语法里，使用 native 关键字 最关键的是，要通过System.loadLibrary() 方法，添加 C 代码所在的库 然后在 native-lib.h 文件里对获取版本号方法进行声明 12345678910111213#include &lt;jni.h&gt;#ifndef _Included_cn_luck_screenrecord_ffmpeg_RecorderHelper#define _Included_cn_luck_screenrecord_ffmpeg_RecorderHelper#ifdef __cplusplusextern &quot;C&quot; {#endifJNIEXPORT jstring JNICALL Java_cn_luck_screenrecord_ffmpeg_RecorderHelper_getFFmpegVersion__(JNIEnv *, jobject);#ifdef __cplusplus}#endif#endif 最后在 native-lib.cpp 文件里对方法进行实现 123456789101112131415#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; { #include &quot;libavutil/version.h&quot; JNIEXPORT jstring JNICALL Java_cn_luck_screenrecord_ffmpeg_RecorderHelper_getFFmpegVersion__(JNIEnv *env, jobject obj) { char version[100]; snprintf(version, sizeof(version), &quot;FFmpeg version %d.%d.%d&quot;, LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO); LOGI(&quot;ffmpeg version: %s&quot;, version); return (*env).NewStringUTF(version); }} #4.3 配置 CMakeLists.txt 文件 配置内容如下： 123456789101112131415161718192021222324252627282930313233343536373839cmake_minimum_required(VERSION 3.10)set(CMAKE_CXX_STANDARD 11)# 设置 FFmpeg 头文件路径include_directories(include)# 设置 FFmpeg 库路径set(FFMPEG_LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/${ANDROID_ABI})# 添加 FFmpeg 库add_library(avcodec SHARED IMPORTED)set_target_properties(avcodec PROPERTIES IMPORTED_LOCATION ${FFMPEG_LIB_DIR}/libavcodec.so)add_library(avformat SHARED IMPORTED)set_target_properties(avformat PROPERTIES IMPORTED_LOCATION ${FFMPEG_LIB_DIR}/libavformat.so)add_library(avutil SHARED IMPORTED)set_target_properties(avutil PROPERTIES IMPORTED_LOCATION ${FFMPEG_LIB_DIR}/libavutil.so)add_library(swresample SHARED IMPORTED)set_target_properties(swresample PROPERTIES IMPORTED_LOCATION ${FFMPEG_LIB_DIR}/libswresample.so)add_library(swscale SHARED IMPORTED)set_target_properties(swscale PROPERTIES IMPORTED_LOCATION ${FFMPEG_LIB_DIR}/libswscale.so)# 创建你的本地库add_library(native-muxer SHARED native-muxer.cpp)# 查找 log 库find_library(log-lib log)# 创建你的本地库add_library(native-lib SHARED native-lib.cpp)# 链接 FFmpeg 库target_link_libraries(native-lib avcodec avformat avutil swresample swscale ${log-lib})# 确保 native-lib 可以使用 FFmpeg 头文件target_include_directories(native-lib PRIVATE include) #遇到的问题 #1 FFmpeg 与 NDK 版本不兼容 少张报错图 报错如图所示，找不到 ``，发现是因为在新版本的 NDK 中移除了该命令，一步步试错，最终确定 NDK 版本为 22.1.7171670 时，版本兼容了 #2 cpp 文件里链接不到对应的库 少张报错图 报错如上图所示，在 Android Studio 里点击能够导航到对应的头文件，但是运行就是报错，这是因为 #include 必须要放到 extern &quot;C&quot; {} 内，如下代码所示导入，就正常了。 123456789101112131415extern &quot;C&quot; {#include &quot;libavutil/pixdesc.h&quot;#include &quot;libavutil/version.h&quot;#include &quot;libavutil/time.h&quot;#include &lt;libavutil/opt.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libavcodec/avcodec.h&gt;#include &lt;libswscale/swscale.h&gt;#include &lt;libswresample/swresample.h&gt;#include &quot;libavutil/imgutils.h&quot;// 代码逻辑 。。。} #3 不显示打印的日志 #4 codec permission defined 使用 avcodec_open2() 创建 videoCodec 时，返回值经过转换后信息为 ：Permission denied。经过检查发现，使用 codec 权限被拒，是因为编译的 FFmpeg 里没有添加 x264 库。 本地编译并安装x264库 12// 下载git clone --depth 1 https://code.videolan.org/videolan/x264.git 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/bin/bash# 配置架构（32 位 或 64 位）ARCH=aarch64 # 32-bit: arm (适用于 armv7-a) | 64-bit: aarch64CPU=armv8-a # 目标 CPU (32-bit: armv7-a | 64-bit: armv8-a)API=21 # 目标 Android API 级别 (armv7 最低 API 16, 推荐 21)ANDROID=android # (32-bit: androideabi | 64-bit: android)CFLAGS=&quot;-mfloat-abi=softfp -march=$CPU&quot;LDFLAGS=&quot;-Wl,--fix-cortex-a8&quot;# Android NDK 路径（请修改为你的路径）export NDK=/Users/luck/Library/Android/sdk/ndk/22.1.7171670export HOST_TAG=darwin-x86_64 # macOS (Linux 用户请改成 linux-x86_64)export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/$HOST_TAGexport SYSROOT=$TOOLCHAIN/sysrootexport PREFIX=$SYSROOT/usr/local# 32位 (armv7) 和 64位 (aarch64) 变量if [ &quot;$ARCH&quot; = &quot;arm&quot; ]; then TARGET=&quot;armv7a-linux-$ANDROID&quot; CROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-$ANDROID-else TARGET=&quot;aarch64-linux-android&quot; CROSS_PREFIX=$TOOLCHAIN/bin/$TARGET-fi# 其他工具变量export CC=$TOOLCHAIN/bin/$TARGET$API-clangexport CXX=$TOOLCHAIN/bin/$TARGET$API-clang++export AR=$TOOLCHAIN/bin/llvm-arexport AS=$TOOLCHAIN/bin/llvm-asexport LD=$TOOLCHAIN/bin/ldexport STRIP=$TOOLCHAIN/bin/llvm-stripexport NM=$TOOLCHAIN/bin/llvm-nmexport RANLIB=$TOOLCHAIN/bin/llvm-ranlib# 编译 x264function build_x264 { ./configure \\ --prefix=$PREFIX \\ --host=$TARGET \\ --cross-prefix=$CROSS_PREFIX \\ --sysroot=$SYSROOT \\ --enable-static \\ --enable-pic \\ --disable-opencl \\ --disable-asm # 可尝试启用 asm: `--enable-asm` make -j$(nproc) make install}build_x264 通过如上命令，下载 x264 库的源码，并进行编译，最后再安装。其中的编译时的配置： –enable-static：启用静态库，使 FFmpeg 可以静态链接 x264。 –enable-pic：用于 Android 和 iOS，防止动态库在 ASLR 下崩溃。 –disable-asm：若编译环境缺少汇编工具 （如nasm），可禁用汇编优化以规避错误‌ 逐条运行如上命令后，最终会输出如下内容，表示成功安装： 12345678910111213install -d /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/bininstall x264 /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/bininstall -d /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/includeinstall -d /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/pkgconfiginstall -m 644 ./x264.h x264_config.h /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/includeinstall -m 644 x264.pc /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/pkgconfiginstall -d /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/libln -f -s libx264.so.164 /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/libx264.soinstall -m 755 libx264.so.164 /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/libinstall -d /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/libinstall -m 644 libx264.a /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ranlib /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/libx264.a 注意： 将 x264 安装到 NDK 里 在编译 FFmpeg 时添加 x264 库 完整的编译脚本发下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/bin/bashmake cleanset -earchbit=64if [ $archbit -eq 64 ];thenecho &quot;build for 64bit&quot;ARCH=aarch64CPU=armv8-aAPI=21PLATFORM=aarch64ANDROID=androidCFLAGS=&quot;-I/usr/local/include&quot;LDFLAGS=&quot;-L/usr/local/lib -lx264&quot;elseecho &quot;build for 32bit&quot;ARCH=armCPU=armv7-aAPI=16PLATFORM=armv7aANDROID=androideabiCFLAGS=&quot;-mfloat-abi=softfp -march=$CPU&quot;LDFLAGS=&quot;-Wl,--fix-cortex-a8&quot;fiexport NDK=/Users/luck/Library/Android/sdk/ndk/22.1.7171670export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64/binexport SYSROOT=$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysrootexport CROSS_PREFIX=$TOOLCHAIN/$ARCH-linux-$ANDROID-export CC=$TOOLCHAIN/$PLATFORM-linux-$ANDROID$API-clangexport CXX=$TOOLCHAIN/$PLATFORM-linux-$ANDROID$API-clang++export PREFIX=./ffmpeg-android/$CPUexport PKG_CONFIG_PATH=$SYSROOT/usr/local/lib/pkgconfig:$PKG_CONFIG_PATHfunction build_android { ./configure \\ --prefix=$PREFIX \\ --cross-prefix=$CROSS_PREFIX \\ --target-os=android \\ --arch=$ARCH \\ --cpu=$CPU \\ --cc=$CC \\ --cxx=$CXX \\ --nm=$TOOLCHAIN/$ARCH-linux-$ANDROID-nm \\ --strip=$TOOLCHAIN/$ARCH-linux-$ANDROID-strip \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-ldexeflags=-pie \\ --enable-runtime-cpudetect \\ --disable-static \\ --enable-shared \\ --disable-ffprobe \\ --disable-ffplay \\ --disable-ffmpeg \\ --disable-debug \\ --disable-doc \\ --enable-avfilter \\ --enable-decoders \\ --enable-libx264 \\ --extra-cflags=&quot;-I$SYSROOT/usr/local/include&quot; \\ --extra-ldflags=&quot;-L$SYSROOT/usr/local/lib -lx264&quot; \\ --enable-mediacodec \\ --enable-decoder=h264_mediacodec \\ --enable-decoder=hevc_mediacodec \\ --enable-decoder=mpeg4_mediacodec \\ --enable-hwaccel=h264_mediacodec \\ --enable-encoder=libx264 \\ --extra-libs=-ldl \\ --enable-gpl \\ --enable-pic \\ --enable-small \\ --disable-asm $ADDITIONAL_CONFIGURE_FLAG make echo $PKG_CONFIG_PATH make install}build_android 如上所示，要在 FFmpeg 的编译命令 configure 后加上如上三条内容，其中： --enable-gpl：x264 是 GPL 许可证，所以 FFmpeg 必须启用 GPL。 --enable-libx264：启用 x264 编码支持。 --enable-pic：防止 ASLR 崩溃 （Android/iOS 需要） #5 ERROR: x264 not found using pkg-config 出现如上错误，通常意味着 pkg-config 无法找到 x264 的 pkg-config 配置文件 （即 x264.pc） 经过对 x264 库编译安装位置的修改，一开始放到 Mac 的 usr/local 里，后来放到 NDK 里，并进行过如下处理但是 FFmpeg 编译时始终最如上错误。暂未解决。 检查 x264 的 .pc 文件路径 ‌确认 .pc 文件存在性‌ 执行以下命令查找 x264.pc 文件路径： 1find / -name &quot;x264.pc&quot; 2&gt;/dev/null 若文件位于非标准路径 （如/mylib/x264/pkgconfig），需手动将路径加入 PKG_CONFIG_PATH‌。 ‌修正 PKG_CONFIG_PATH环境变量‌ 1export PKG_CONFIG_PATH=/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH 使用 vim ~/.bash_profile 命令，打开 bash_profile 文件 然后按 E 打开文件的编辑模式，再按 I 打开插入模式，此时就可以向文件里输入内容了 在文件里添加 export PKG_CONFIG_PATH=/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib/pkgconfig 按 esc 键 退出插入模式，然后输入 :wq 保存并退出文件 执行 source ~/.bash_profile‌ 刷新配置 验证 pkg-config 是否能识别 x264 执行以下命令测试： 1pkg-config --libs --cflags x264 ‌无输出‌：说明 .pc 文件路径未正确配置，但是输出了 .pc 文件路径 在 ffbuild/ 里的 config.log 日志里有日志如下： 1234567891011121314151617...WARNING: /Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-pkg-config not found, library detection may fail..../Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang --sysroot=/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot -D_ISOC11_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Dstrtod=avpriv_strtod -DPIC -I/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include -march=armv8-a -std=c17 -fPIE -fomit-frame-pointer -fPIC -pthread -c -o /var/folders/f5/jntt2zr54g10ls9j2tcn78q80000gn/T//ffconf.w0rPQQNa/test.o /var/folders/f5/jntt2zr54g10ls9j2tcn78q80000gn/T//ffconf.w0rPQQNa/test.c/var/folders/f5/jntt2zr54g10ls9j2tcn78q80000gn/T//ffconf.w0rPQQNa/test.c:3:24: warning: cast to smaller integer type 'int' from 'float (*)(float, float)' [-Wpointer-to-int-cast]int main(void){ return (int) foo; } ^~~~~~~~~1 warning generated./Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang -L/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/lib -lx264 --sysroot=/Users/luck/Library/Android/sdk/ndk/22.1.7171670/toolchains/llvm/prebuilt/darwin-x86_64/sysroot -march=armv8-a -Wl,--as-needed -Wl,-z,noexecstack -pie -fPIE -pie -o /var/folders/f5/jntt2zr54g10ls9j2tcn78q80000gn/T//ffconf.w0rPQQNa/test /var/folders/f5/jntt2zr54g10ls9j2tcn78q80000gn/T//ffconf.w0rPQQNa/test.o -lm -ldlcheck_pkg_config libdrm libdrm xf86drm.h drmGetVersiontest_pkg_config libdrm libdrm xf86drm.h drmGetVersionfalse --exists --print-errors libdrmrequire_pkg_config libx264 x264 stdint.h x264.h x264_encoder_encodecheck_pkg_config libx264 x264 stdint.h x264.h x264_encoder_encodetest_pkg_config libx264 x264 stdint.h x264.h x264_encoder_encodefalse --exists --print-errors x264ERROR: x264 not found using pkg-config 在 NDK 里根本就没有 aarch64-linux-android-pkg-config, 未能解决这个问题 https://stackoverflow.com/questions/12136078/ffmpeg-for-android-toolchains-arm-linux-armeabi-eabi-pkg-config-is-there-any #6 时间戳非单调递增 12342025-03-06 15:58:15.433 4993-5075 cn....screenrecord I Muxed packet for stream 1, size 233, pts 67799482025-03-06 15:58:15.435 4993-5075 cn....screenrecord I Muxed packet for stream 0, size 280, pts 70340262025-03-06 15:58:15.437 4993-5075 cn....screenrecord E Error muxing packet for stream 0, error code: -22, size 6540, pts 70198132025-03-06 15:58:15.886 4993-5094 cn....screenrecord I Muxed packet for stream 1, size 219, pts 7267547 如上日志所示，在序号为 0 的 stream 流传入的数据，前一帧 pts 为 7034026，后一帧却是 7019813。 解决方案 12345678910111213141516// 计算转换后的 pts，并确保它是单调递增的static int64_t lastVideoPts = -1;static int64_t lastAudioPts = -1;int64_t rescaledPts = av_rescale_q(pts, srcTimeBase, dstTimeBase);if (streamIndex == 0) { if (rescaledPts &lt;= lastVideoPts) { rescaledPts = lastVideoPts + 1; // 确保递增 } lastVideoPts = rescaledPts;} else if (streamIndex == 1) { if (rescaledPts &lt;= lastAudioPts) { rescaledPts = lastAudioPts + 1; } lastAudioPts = rescaledPts;}pkt.pts = rescaledPts; 添加如上代码： 记录上一次 pts, 使用静态变量 lastVideoPts 和 lastAudioPts 分别记录视频和音频流上一次写入 muxer 的 pts。 调整不递增的 pts, 如果新计算出的 rescaledPts 小于或等于上一次的值，则将其调整为上一次值加一个单位，保证时间戳严格单调递增。","link":"/2025/03/04/Android%E4%BD%BF%E7%94%A8FFmpeg%E4%B9%8B%E6%97%85/"},{"title":"Gradle版本从2.3升到3.3.2问题集锦","text":"一、Gradle版本升级步骤 二、错误集锦 1. Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated 2. 修改了错误1后再编译报如下错误：All flavors must now belong to a named flavor dimension 3. ERROR: The SourceSet ‘instrumentTest’ is not recognized by the Android Gradle Plugin. Perhaps you misspelled something? 4. ERROR: The Android Gradle plugin supports only Kotlin Gradle plugin version 1.3.0 and higher. 5. compile错误 6. WARNING: API’variantOutput.getPackageApplication()‘isobsolete and has been replaced with’variant.getPackageApplicationProvider()’. #一、Gradle版本升级步骤 1. 在gradle-wrapper.properties文件中修改distributionUrl的版本. 2. 在工程里的build.gradle文件中的dependencies项里修改gradle版本，之后点 Try Again. #二、错误集锦 #1. Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated 错误原因： outputFile变成了可读字段 修改方案： 将variant.outputs.each中的each改成all output.outputFile = new File(outputFile.parent, fileName)改为 outputFileName =fileName 原代码： 1234567891011121314151617applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) { def fileName = &quot;&quot; if (checkQuDao()) { fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; } else { fileName = &quot;QiQi-debug.apk&quot; } // def fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; output.outputFile = new File(outputFile.parent, fileName) } }} 修改后的代码： 1234567891011121314151617applicationVariants.all { variant -&gt; variant.outputs.**all** { output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) { def fileName = &quot;&quot; if (checkQuDao()) { fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; } else { fileName = &quot;QiQi-debug.apk&quot; } // def fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; **outputFileName =fileName** } }} #2. 修改了错误1后再编译报如下错误：All flavors must now belong to a named flavor dimension 错误原因： gradle版本3.0之后添加了flavorDimensions管理 修改方案： 在defaultConfig里面加入flavorDimensions，并在多渠道打包里的每一项里加上dimension。 修改后代码： 1234567defaultConfig { applicationId globalConfiguration.applicationId minSdkVersion globalConfiguration.AndridMinSdkVersion targetSdkVersion globalConfiguration.AndroidTargetSdkVersion multiDexEnabled true flavorDimensions &quot;product&quot;} 123456789101112131415161718productFlavors { xiaomi{ dimension &quot;product&quot; ... } huawei{ dimension &quot;product&quot; ... } oppo{ dimension &quot;product&quot; ... }} 参考文章https://blog.csdn.net/chen_xi_hao/article/details/80526049 #3. ERROR: The SourceSet ‘instrumentTest’ is not recognized by the Android Gradle Plugin. Perhaps you misspelled something? 错误原因： gradle版本3.0之后已废弃instrumentTest 解决方案： 将instrumentTest替换为androidTest 原代码： 1234567891011sourceSets {main { manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets']}instrumentTest.setRoot('tests') 修改后代码： 1234567891011sourceSets { main { manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets'] } androidTest.setRoot('tests') #4. ERROR: The Android Gradle plugin supports only Kotlin Gradle plugin version 1.3.0 and higher. 错误原因： gradle只支持1.3.0及以上的Kotlin Gradle plugin版本 修改方案： 修改kotlin版本，修改工程下的build.gradle文件中的dependencies项里的kotlin版本 #5. compile错误 报了三个错误： 1、WARNING: Configuration ‘compile’ is obsolete and has been replaced with ‘implementation’ and ‘api’. 2、WARNING: Configuration ‘testCompile’ is obsolete and has been replaced with ‘testImplementation’. 3、WARNING: Configuration ‘androidTestCompile’ is obsolete and has been replaced with ‘androidTestImplementation’. 错误原因： compile已过时 解决方案： 使用implementation和api两个字段替换compile implementation和api区别： api 指令 完全等同于compile指令，没区别，你将所有的compile改成api，完全没有错。 implement指令 这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开，这样避免了不同module引用了不同版本的支持包报错的问题。 参考文章https://www.jianshu.com/p/f34c179bc9d0 #6. WARNING: API’variantOutput.getPackageApplication()‘isobsolete and has been replaced with’variant.getPackageApplicationProvider()’. 原代码： 1234567891011121314151617applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) { def fileName = &quot;&quot; if (checkQuDao()) { fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; } else { fileName = &quot;QiQi-debug.apk&quot; } // def fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; outputFileName = fileName } }} 修改后的代码： 1234567891011applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt; if (checkQuDao()) { outputFileName = &quot;QiQi_${variant.versionName}${variant.productFlavors[0].name}.apk&quot; } else { outputFileName = &quot;QiQi-debug.apk&quot; } // def fileName = &quot;QiQi_${defaultConfig.versionName}${variant.productFlavors[0].name}.apk&quot; }}","link":"/2020/05/31/Gradle%E7%89%88%E6%9C%AC%E4%BB%8E2-3%E5%8D%87%E5%88%B03-3-2%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"},{"title":"JNI与FFmpeg基本语法","text":"一、 基础知识 1.1 编码 二、 基本概念与语法 2.1 -&gt; 与 . 2.2 指针作为判断条件 2.3 pts 、 dts 、time_base 三、方法 3.1 GetStringUTFChars() 与 ReleaseStringUTFChars() 3.2 avformat_alloc_output_context2() 3.3 avformat_new_stream() 3.5 AVRational 相关方法 3.5.1 av_q2d() 3.5.2 av_rescale_q() 参考文献 #一、 基础知识 #1.1 编码 方案 结果 说明 FFmpeg 容器 (“mp4”) + MediaCodec (“audio/mp4a-latm”) ✅ 可行 audio/mp4a-latm 是标准 AAC 编码 FFmpeg 容器 (“mp4”) + MediaCodec (“video/avc”) ✅ 可行 H.264 视频流可封装进 MP4 #二、 基本概念与语法 #2.1 -&gt; 与 . C 语言中，「.」 和 「-&gt;」 都是用于访问结构体 （struct） 或联合体 （union） 中成员的操作符。「.」 用于通过结构体实例直接访问其成员、「-&gt;」 用于通过结构体指针访问其指向对象的成员。 在 C 语言中，结构体是一种复合数据类型，它允许将不同或相同类型的数据项组合到一起。每个数据项称为成员 （member），结构体的实例化后，可以通过使用 「.」 操作符直接访问其成员。 例如: 1234567891011121314struct Point { int x; int y;};struct Point p;p.x = 10;p.y = 20;struct Point *ptr = &amp;p;ptr-&gt;x = 30;ptr-&gt;y = 40; 在上述代码中: 创建了一个名为 Point 的结构体，并定义了两个整型成员 x 和 y。 p 是 Point 类型的一个变量，称为实例。通过 「.」 操作符，可以直接访问并设置 p 的成员。 ptr 是一个指向 Point 类型实例 p 的指针。通过使用 「-&gt;」 操作符，可通过 ptr 间接访问并修改 p 的成员 x 和 y。 结论： 可以使用结构体的指针来动态分配内存或者通过函数传递结构体数据。此时 「-&gt;」 操作符被用来通过指针访问结构体实例的成员。 使用 「-&gt;」 操作符前提是有一个指向结构体的指针，这是它与 「.」 操作符的最主要区别。 使用 「.」 和 「-&gt;」 操作符的选择取决于我们手头上拥有的是一个结构体实例还是一个结构体指针。如果我们直接声明了一个结构体类型的变量，我们应该使用 「.」 来访问成员。反之，如果我们有一个指向结构体的指针，我们必须使用 「-&gt;」。 语法的差异也反映在操作符的优先级上：「.」 操作符的优先级高于「-&gt;」。当结合其他操作或表达式时，可能需要使用括号 () 来保证正确的访问顺序。 #2.2 指针作为判断条件 123456789static AVFormatContext *outFormatContext = nullptr;if (outFormatContext) { // 说明 outFormatContext **不是空指针**，已经被分配了内存}if (!outFormatContext) { // 说明 outFormatContext **是空指针**，尚未初始化} outFormatContext 是一个指向 AVFormatContext 的指针。 把 !outFormatContext 当做判断条件等价于 `outFormatContext == nullptr。 nullptr 代表空指针，即指针当前没有指向任何有效的 AVFormatContext 结构体。 把 outFormatContext 当做判断条件等价于 outFormatContext != nullptr 这两种条件都可用于检查 outFormatContext 是否已分配内存 #2.3 pts 、 dts 、time_base 时基 time_base `AVRational` 是 `FFmpeg` 中用于表示有理数 *（分数）* 的数据结构，`FFmpeg` 使用 `AVRational` 来避免浮点数计算的误差，主要用于： 时间基准 (time_base)： 表示 PTS/DTS 的单位 帧率 (frame_rate)：表示视频的 FPS 采样率 (sample_rate) : 表示音频的采样单位 码率 (bitrate)： 表示数据速率 在 FFmpeg 的 libavutil/rational.h 头文件中，AVRational 结构体被定义如下： 1234typedef struct AVRational { int num; // 分子 (numerator) int den; // 分母 (denominator)} AVRational; num （分子）：表示数值的上部分。 den （分母）：表示数值的下部分。 表示的值等于：AVRational = num/den ​ time_base，是时间刻度单位，类型为 AVRational，其物理意义是将 1 秒划分为若干份，每份代表一个时间单位‌。它是用来度量时间的。 如果把 1 秒分为 25 等份，可以理解为一把尺，那么每一格表示的就是 1/25 秒。此时的 time_base={1，25}。 如果把 1 秒分成 90000 份，每一个刻度就是 1/90000 秒，此时的 time_base={1，90000}。 所谓时间基表示的就是每个刻度是多少秒 通过 av_q2d(time_base) 可计算每个刻度的实际秒数。例如： 12AVRational tb = {1, 25}; double sec_per_tick = av_q2d(tb); // 0.04秒/刻度 如上所示，即每个时间刻度是 0.04 秒 时间戳 PTS 与 DTS PTS：Presentation Time Stamp。PTS 主要用于度量解码后的视频帧什么时候被显示出来。 DTS：Decode Time Stamp。DTS 主要是标识读入内存中的 bit 流在什么时候开始送入解码器中进行解码。 也就是 pts 反映帧什么时候开始显示，dts反映数据流什么时候开始解码。 pts 和 dts 的值就是占多少个时间刻度，单位是 time_base 的刻度数。它的单位不是秒，而是 时间刻度。只有 它们再加上 time_base 才能表达出时间具体是多少。 实际显示时刻计算公式： 12display_time = pts * av_q2d(time_base)decode_time = dts * av_q2d(time_base) 时间基转换 不同阶段 （如封装、编解码、原始数据） 的 time_base 可能不同，需通过 av_rescale_q 函数进行转换以避免溢出。例如： 1int64_t new_pts = av_rescale_q(old_pts, old_tb, new_tb); // 将时间戳从old_tb转换到new_tb 这一过程常用于音视频同步或封装格式转换‌ ‌典型转换场景‌： 视频帧时间基：通常为帧率的倒数 （如25fps对应{1,25}） 音频时间基：采样率的倒数 （如44100Hz对应{1,44100}）‌ #三、方法 #3.1 GetStringUTFChars() 与 ReleaseStringUTFChars() 1234567891011121314151617181920212223// 方法GetStringUTFChars(jstring str, jboolean* isCopy)// 实例一const char *outputPath = env-&gt;GetStringUTFChars(outputPath_, nullptr);// 实例二jboolean isCopy;const char *outputPath = env-&gt;GetStringUTFChars(outputPath_, &amp;isCopy);// 释放字符串env-&gt;ReleaseStringUTFChars(outputPath_, outputPath);// 实例二补充if (outputPath != nullptr) { printf(&quot;Output Path: %s\\n&quot;, outputPath); if (isCopy == JNI_TRUE) { // 只有在 JNI 复制了字符串时才释放 env-&gt;ReleaseStringUTFChars(outputPath_, outputPath); }} 参数解析 env：是 JNIEnv* 类型，代表当前 JNI *（Java Native Interface）*环境，提供调用 Java 方法和操作 Java 对象的能力。 outputPath_：是一个 jstring 类型的 Java 字符串，通常是 Java 代码传递给 JNI 的路径或文本。 isCopy：是一个 jboolean* 指针，它用于指示 JNI 是否创建了字符串的副本 （即是否进行了内存分配）。 如实例一中所示，不关心是否创建了副本，isCopy 参数直接传 nullptr，但是由于不知道 JNI 是否复制了字符串, 必须始终调用 ReleaseStringUTFChars() 释放，以防万一。 如实例二中所示，isCopy 参数传递了 jboolean 变量的地址。然后 isCopy 的值会被 GetStringUTFChars() 方法填充，可能是： JNI_TRUE （即 1）：表示 JNI 创建了一个新的字符串副本，需要调用 ReleaseStringUTFChars() 释放。 JNI_FALSE （即 0）：表示 JNI 没有创建新的字符串副本，它直接返回了指向原始字符串数据的指针，不能调用 ReleaseStringUTFChars() 释放。 方法作用 作用：从 Java String 对象中提取 UTF-8 编码的 char* 字符串，并返回指针。 返回值：返回一个 const char*，指向 outputPath_ 的 UTF-8 编码 C 字符串数据。 注意事项 GetStringUTFChars 可能会分配新的内存，因此在使用完后，应调用 ReleaseStringUTFChars() 释放,否则可能会导致内存泄漏。 为什么需要 isCopy？ JNI 可能会以不同方式处理字符串： 如果字符串是 UTF-8 编码的，它可能直接返回 Java 内存中的指针（isCopy = JNI_FALSE）。 如果字符串需要转换，比如 Java 使用 UTF-16 而 JNI 需要 UTF-8，JNI 可能会创建副本 （isCopy = JNI_TRUE）。 不同的 JVM 实现可能有不同策略，某些 JVM 可能会优化，避免不必要的复制。 在调用 env-&gt;GetStringUTFChars(jstring str, jboolean* isCopy) 时，你不需要手动传 JNI_TRUE 或 JNI_FALSE，而是传一个 jboolean 变量的地址（jboolean*），然后 JNI 会在该变量中填充 JNI_TRUE 或 JNI_FALSE，以告知你 JNI 是否创建了新的字符串副本。 #3.2 avformat_alloc_output_context2() 创建并初始化 AVFormatContext ，用于输出某格式的媒体文件，它是 FFmpeg 处理多媒体文件的关键步骤之一。 1234567891011121314// 原始方法int avformat_alloc_output_context2( AVFormatContext **ctx, AVOutputFormat *fmt, const char *format_name, const char *filename);// 实例int ret = avformat_alloc_output_context2(&amp;outFormatContext, NULL, &quot;mp4&quot;, outputPath);if (ret &lt; 0) { printf(&quot;创建输出格式上下文失败: %d\\n&quot;, ret); return -1;} 参数 说明 ctx 输出参数，指向 AVFormatContext* 的指针，函数调用后会为其分配内存并初始化 fmt 指定输出格式的 AVOutputFormat，通常传 NULL 让 FFmpeg 自动选择 format_name 输出文件格式 （如 “mp4”、“flv”、“mov”），如果 fmt 为 NULL，则必须指定 filename 输出文件路径，有助于 FFmpeg 根据扩展名自动推断格式 返回一个 int 值： 成功：ret == 0，outFormatContext 被正确分配。 失败：ret &lt; 0，表示初始化失败，通常是格式不支持或路径错误。 #3.3 avformat_new_stream() 在 AVFormatContext *（输出文件的格式上下文）*中添加一个新流 （视频、音频等）。 1AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c); 成功时返回一个 AVStream* 指针，指向新创建的流；失败时返回 NULL。 参数说明： s：AVFormatContext*，目标格式的上下文 （如 MP4）。 c：AVCodec*，编码器，通常传 nullptr，不直接指定 AVCodec，让 FFmpeg 自动选择合适的编码器。适用于容器格式 （MP4、FLV 等），FFmpeg 会在后续步骤指定编码器。 #3.5 AVRational 相关方法 #3.5.1 av_q2d() 转换 AVRational 为 double 123456789101112// 原始方法double av_q2d(AVRational a);// 实例一 转换AVRational time_base = {1, 1000};double seconds_per_unit = av_q2d(time_base); // 1 / 1000 = 0.001// 实例二 转换再计算总时长double duration = 60000000AVRational time_base = {1, 1000000};double total_sec = duration * av_q2d(time_base); 如实例二所示，最终计算结果总时长为 60 秒‌ #3.5.2 av_rescale_q() av_rescale_q 是 FFmpeg 提供的一个用于 按不同时间基转换时间戳 的函数，常用于 PTS/DTS 转换。 在 FFmpeg (libavutil/mathematics.h) 里，av_rescale_q 的定义如下： 1int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq); 参数说明： 参数 作用 a 需要转换的值（通常是 PTS 或 DTS） bq 原时间基 (AVRational) cq 目标时间基 (AVRational) av_rescale_q 计算的数学公式：new_value=a×cq.numcq.den÷bq.numbq.den\\text{new\\_value} = a \\times \\frac{\\text{cq.num}}{\\text{cq.den}} \\div \\frac{\\text{bq.num}}{\\text{bq.den}}new_value=a×cq.dencq.num​÷bq.denbq.num​ ，简化后为：new_value=a×cq.num×bq.dencq.den×bq.num\\text{new\\_value} = a \\times \\frac{\\text{cq.num} \\times \\text{bq.den}}{\\text{cq.den} \\times \\text{bq.num}}new_value=a×cq.den×bq.numcq.num×bq.den​ 示例 将 PTS 从 1/1000000 秒 （us） 的时间刻度转换为 1/25 秒的时间刻度 12345int64_t pts = 2000000; // 原始 ptsAVRational src_time_base = {1, 1000000}; // 原始时间基 1 微秒AVRational dst_time_base = {1, 25}; // 目标时间基 1/25 秒int64_t new_pts = av_rescale_q(pts, src_time_base, dst_time_base);printf(&quot;转换后的 PTS: %ld\\n&quot;, new_pts); 其中的计算过程为：2 000 000×251 000 000=50\\frac{2\\,000\\,000 \\times 25}{1\\,000\\,000} = 5010000002000000×25​=50 也就是说，PTS 在 1 微秒的时基里，其值为 2000000。经过转换，在 0.04 的时基里，其值为 50 #参考文献 https://zhuanlan.zhihu.com/p/554950638 https://github.com/xufuji456/FFmpegAndroid/blob/master/doc/FFmpeg_compile_shell.md","link":"/2025/03/08/JNI%E4%B8%8EFFmpeg%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"Java编程规范","text":"Java 编码规范 注释规范 代码风格 编码规范 文件命名 类 变量 函数 文件组织规则 常见用法规则 #Java 编码规范 #注释规范 类注释 12345/** * @作者 * @功能 * @时间 */ 方法注释 123456/** * @作者 * @功能 * @参数介绍 * @返回值介绍 */ 成员变量及常量注释 123/** * 变量用途 */ 局部变量注释 1// 功能用途 这里注意有一个空格 缩进同变量起始位置一样 代码块注释 123/** * 代码块的功能和基本介绍起始位置和结束位置 */ 注释排版 保持每个人自己统一就行 #代码风格 下列位置应该使用空格以使代码结构清晰，提高代码可读性： 开始、类的定义、以及if、for、do、while、switch、case语句中的代码都要采用缩进方式； 对齐：程序块的分界符左大括号&quot;{&quot; 和右大括号&quot;}&quot;都另起一行，尾部大括号一行并且位于同一列，同时与引用它们的语句左对齐；对齐只使用TAB键，不使用空格键；不允许把多个短语句写在一行中，即一行只写一条语句；if、for、do、while、case、switch、default等语句自占一行。且都需需要用大括号包裹 换行：一行的长度超过80个字符需要换行 二元操作符前后都需要有空格， ‘.’ 除外； 参数列表中的逗号 ‘,’ 后面； for 循环中的表达式之间，分号 ‘;’ 后面； foreach 循环中冒号 ‘:’ 前后； 方法名 ( 包括声明和调用 ) 和左括号 ‘(’ 之间 不需要 空格； 小括号与内部字符之间 不需要 空格； 没有必要 增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 多行注释中，换行后星号 ‘’ 之前至少放置一个空格，为实现与首行注释的星号 '’ 对齐； 注释星号 ‘*’ 与注释内容 如果处于同一行，两者 之间放置一个空格； 注释的双斜线与注释内容之间有且仅有一个空格； 123456789错误用例// 小括号 与内部字符间不需要空格if ( a == b ) // 没有 必要追求多行 对齐 int a = 3; long b = 4L; StringBuilder sb = new StringBuilder(); 1234567891011121314151617正确用法if (a == b) { ...} for (int i = 0; i &lt; 10; i++) { a += i; } for (String usrName : usrList) { usrAge = usrInfoClass.getUsrAge(usrName); usrInfoClass.showUser(usrName, usrAge); } int a = 3; long b = 4L; StringBuffer sb = new StringBuffer(); #编码规范 #文件命名 资源文件 layout 必须以module名字或缩写作为前缀避免面重复命名 123456789101112activity: module_activity_fragment: module_fragment_dialog: module_dialog_include: module_include_itemview: module_item_Layout: module_layout_ #类 命名需要使用大驼峰规则命名 注意 关键字 类名 和 {} 之间加一个空格 1234public class MyClass {} Bean类 只允许有成员变量和 get set函数 一般也要加上toString()方法 接口类 命名必须以大写字母I开头标识这是个接口类 接口类函数定义不可以使用对方法进行public private等属性修饰 抽象类 需要以Abs开头或者以Base开头 标识这个是个抽象类或者基类需要子类实现才可以用 测试类 命名用Test结尾 枚举类 用enum后缀 成员全部用大写用下换线分割单词 如 SUCCESS_MSG 异常类 Exception结尾 接口实现类 接口实现类用 接口名加Impl结尾 如接口为ICacheSeivice 实现类用CacheSeiviceImpl 其他 类定义用其功能后缀 如Config Dao Service Container Manager Module等 #变量 命名规范 常量全部用大写用下换线分割单词 如 SUCCESS_CODE 成员变量使用小驼峰以m开头如 mTteacherCode 局部变量使用小驼峰如 teacherCode bool 可以用 can has is 不必遵循m开头 或者用able结尾 从意义上能区分是bool值就可以 变量排版 Private Protect Public 等同一类权限范围的函数或变量尽量排布在同一个区域内 123456789101112private String mDate;private String mCode;private List&lt;String&gt; mList;protected String mPrtDate;protected String mPrtcode;protected List&lt;String&gt; mPrtList;public String mPrtDate;public String mPrtcode;public List&lt;String&gt; mPrtList; 变量定义 变量尽量使用有意义的命名拒绝使用魔鬼变量如 list1 list2 data1 data2 尽量不要使用无法理解的字母缩写如果必须用需要添加必要注释 定义数组时，方括号 &quot; [] &quot; 是类型的一部分，所以方括号 &quot; [] &quot; 应放在数据类型后，不要放在变量名后 12错误示范byte rcvBuf [] = new byte[MAX_RECV_BUF_SIZE]; 12正确示范byte [] rcvBuf = new byte[MAX_RECV_BUF_SIZE]; 变量定义一个变量独占一行不允许一行定义多个变量 12错误示范private String data1,data2; 123正确示范private String data1；private String data2; 修饰符使用规则 如果有多个修饰符，修饰符按照如下顺序排列： public protected private abstract static final transient volatile synchronized native strictfp 12错误示范public final static int MAX_USER_CNT = 1024; 12正确示范public static final int MAX_USER_CNT = 1024; #函数 命名及书写规则 采用小驼峰规则命名public void getData() {} 注意多个参数逗号后面要加空格 结尾的入参变量和小括号之间不需要空格小括号面的开始大括号和小括号之间加空格函数结束的大括号需要单独一行 如果是空函数可以缩写成{}不需要换行 123public void getData(String a, String a2) { ...} 函数排版 Private Protect Public 等同一类权限范围的函数或变量尽量排布在同一个区域内 123456789101112131415161718192021222324252627282930313233/** * 共有 */public void fun5(){}public void fun6(){}/** * 保护 */protected void fun3(){}protected void fun4(){}/** * 私有 */private void fun1(){}private void fun2(){} 方法声明 良好的程序设计应该尽可能减小类与类之间耦合，所遵循的经验法则是：尽量限制成员函数的可见性。如果成员函数没必要公有 (public)，就定义为保护 (protected)；没必要保护 (protected)，就定义为私有 (private) 原则就是尽量保证封装性。 方法排版顺序 声明顺序：构造方法、静态公共方法、静态私有方法、公共方法、受保护方法、私有方法 避免参数过多 一般入参不宜超过五个 如果过多可以考虑将函数拆分 或者封装成对象 尽量减少使用参数做逻辑控制 123456789101112131415如下所示将一个函数拆分成两个方法public void buyCourse(long useId, long coureseId, boolean isSVip) {}------------------------------------------------------------public void buyCourse(long useId, long coureseId) {}public void buyCourseForVip(long useId, long coureseId) {} 函数定义需遵守单一功能原则 不要再一个函数里处理过多的逻辑 一个函数只做自己的事就好 如果处理的逻辑过多就要考虑拆分成多个函数 #文件组织规则 注意文件大小尽量控制文件内代码不要过多，保持文件的单一功能 功能独立切与业务无关的通用功能封装成lib_库 功能独立的业务相关功能代码写成module_库 代码文件结构要划分清楚 根据功能或者模块 划分成不同的目录下 入口类尽量暴露在最外侧方便阅读代码时找到入手点 #常见用法规则 异常 捕获异常并不是为了防止程序崩溃 而是要处理它 处理不了的要出log方便定位问题 可能产生多个异常的代码要分别捕获处理避免使用单一catch来统一处理 不可用try catch包裹过多的代码尽量精准捕获定位 准确定位问题可能发生的位置 异常捕获后在catch内添加日志输出并添加方便查验的tag 集合类变量不可以直接使用isEmpty判断要考虑 null的情况 编程习惯 多层判断条件不利于代码可读性 123调整执行顺序体检结束嵌套 多个if嵌套使用是可以考虑建能够提前结束函数的判断条件前置减少if else的嵌套使用 如果涉及到的判断条件以后有增加的可能可以采用`map`注册的方式来优化替代if或者switch过于复杂的问题 map list 数组等 遍历的时候不可以进行添加和删减操作 如果必须做请使用迭代器或者加锁 类对象尽量减少context上下文的持有，需要时可以在类内部的函数上将context作为入参传入减少持有context造成的内存泄漏 如果必须使用可以考虑持有ApplicationContext. 使用Handler 尽量使用静态内部类重载Handler对象 并且用弱引用以减少内存泄漏的风险 处理String 的时候尽量使用 StringBuffer来代替 函数内定义的局部变量应遵循就近原则 禁止在一个地方定义 在很远的地方才使用 影响代码可读性 所有重载的方法必须加@Override注解 不再推荐使用又要兼容旧代码的 变量和方法需要加注解@Deprecated 添加描述注释 注解需要注意每个注解都要独占一行 使用while 或者 doWhile 循环的时候必须 结束循环的条件 严禁使用if (true) while (true)这种实现无限循环 多线程共享变量时要注意考虑线程安全使用线程安全类型或者加锁 耗时操作不可以在主线程中进行操作 代码设计上在耗时操作完成后的回调帮助调用者切回UI线程 方法入参尽量减少 map Object JsonObject String 来代替Json字符串等无法推断的类型字段名如有特殊需求请添加详细的注释并 提供完整json的定义demo Android需要传输过程序列化的类推荐使用Parcelable 需要持久化存储的使用Serializable map遍历使用entrySet代替keySet遍历 减少遍历测试 包装类如果Integer使用equals比较 基础类型如int可以使用 ==","link":"/2023/05/16/Java%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"title":"JetpackCompose学习系列三： 副作用与动画","text":"一、Effect 副作用和一些状态 LaunchedEffect rememberUpdatedState SideEffect DisposableEffect produceState snapshotFlow rememberCoroutineScope 二、Animation – animatable 1. 状态转移型动画 animate*AsState 2. 流程定制型动画 animatable 3. animate*AsState vs Animatable（对比表） 4. AnimationSpace 1. TweenSpec – 补间动画 2. SnapSpec 动画 API 选择 #一、Effect 副作用和一些状态 在 Compose 中，理想的可组合函数应该是“纯函数”：相同输入必然产生相同 UI，无外部可观察影响。然而实际业务中常需要做“UI 之外”的事：网络请求、注册/反注册监听、更新系统栏、埋点、导航等，这些就是“副作用”。 #LaunchedEffect 定义： 在组合中启动一个受生命周期管理的协程。 key 变化会取消旧协程并重启。 当组合退出，协程会自动取消，不需要手动管理。 场景： 页面首次加载/参数变化时重新进行计算； 收集 Flow，Flow 需要在协程内调用，而 LaunchedEffect 内的作用域就是协程。 123456789101112LaunchedEffect(Unit) { // 页面首次进入时，执行一次 viewModel.loadData()}@Composablefun UserScreen(userId: String, repo: UserRepository) { var user by remember { mutableStateOf&lt;User?&gt;(null) } LaunchedEffect(userId) { user = repo.loadUser(userId) // key 变化时自动取消并重启 } /* ... 渲染 user ... */} 配合 rememberUpdatedState，避免为仅回调变化而重启协程： 1234567891011@Composablefun Timer(onTick: (Int) -&gt; Unit) { val latestOnTick by rememberUpdatedState(onTick) LaunchedEffect(Unit) { var seconds = 0 while (true) { delay(1000) latestOnTick(++seconds) // 始终拿到最新回调 } }} #rememberUpdatedState 定义：它会始终保存并暴露最新的值 （state/回调），但是不会因为值变化而触发重新组合。 典型用法：与 LaunchedEffect、DisposableEffect 搭配，避免过度重启或引用过期回调。 12345678910@Composablefun Player(onProgress: (Long) -&gt; Unit) { val latest by rememberUpdatedState(onProgress) LaunchedEffect(Unit) { while (true) { delay(500) latest(SystemClock.elapsedRealtime()) } }} 上面的代码中，使用 rememberUpdatedState，确保协程内部始终调用“最新”的 onProgress，避免陈旧闭包或为回调变化重启协程。 下面是两个错误示例： 错误示例1：不使用 remember 123456789@Composablefun Player(onProgress: (Long) -&gt; Unit) { LaunchedEffect(Unit) { while (true) { delay(500) onProgress(SystemClock.elapsedRealtime()) } }} 上面的错误示例中，LaunchedEffect(Unit) 协程只会执行一次，onProgress 是捕获组合时的旧引用。如果父组件重组传入了新的回调，Player 会进行重组，但是 LaunchedEffect 使用的 Unit 作为 Key 所以不会重启，这也就导致即使 onProgress 变更，取的回调还是旧的。 错误示例2：使用普通 remember 12345678910111213@Composablefun Player(onProgress: (Long) -&gt; Unit) { var callback by remember { mutableStateOf(onProgress) } callback = onProgress // 每次重组更新 LaunchedEffect(Unit) { while (true) { delay(500) callback(SystemClock.elapsedRealtime()) } }} 上面的代码中，mutableStateOf 一旦赋值就触发重组。这里每次重组都会 callback = onProgress，这会导致无意义的重组。但是虽然协程不会重启，但是使用的 callback 每次重组时都会更新到最新的 onProgress。 错误示例3： LaunchedEffect 的 key 使用传入的值 12345678910@Composablefun PlayerB(onProgress: (Long) -&gt; Unit) { LaunchedEffect(onProgress) { // key = onProgress while (true) { delay(500) onProgress(SystemClock.elapsedRealtime()) // 每次重启后捕获最新 onProgress } }} 行为：当父传入新的 onProgress（不同引用）时，旧协程会被取消，新的协程会重启并捕获新的回调。 四种操作的对比 写法 能拿到最新回调？ 是否会触发额外重组？ 协程是否重启？ 直接在 LaunchedEffect(Unit) 内直接调用 onProgress 否（协程捕获启动时的引用） 否（但父改变参数仍会重组Composable本身） 否（key 未变，Effect 不重启，除非组合退出再进） LaunchedEffect(onProgress) 是（重启后捕获新引用） 否（不会因为保存回调本身触发） 是（key 变化时取消并重启） remember { mutableStateOf } 且每次赋值 是 会（赋值会触发 state 改变 -&gt; 重组） 否（Effect key 若为 Unit 则不重启） rememberUpdatedState(onProgress) + LaunchedEffect(Unit) 是（始终取到最新） 否（不会因值更新而触发重组） 否（协程只启动一次） 所以，像这种只取值不需要重组的逻辑使用 rememberUpdatedState —— 它只更新值，不触发重组。 #SideEffect 定义：每次成功重组后在主线程执行的回调，适合把最新的 Compose 状态推送给非 Compose 内容 （例如 ViewModel、日志、外部 SDK）。 场景：更新系统栏、与第三方非声明式控件交互的轻量状态同步。 1234567@Composablefun SystemBars(color: Color) { SideEffect { // 每次重组后把最新颜色同步到系统栏 setSystemBarsColor(color) }} 注意： SideEffect 不适合耗时操作，也不应做会触发再次重组的写入。 SideEffect 每次重组都会执行，而直接在 Compose 函数里写的代码也会每次在重组时执行，它们的不同点在于执行时机： 直接写代码会在每次组合时调用。 SideEffect 是在成功应用组合 （Composition → Layout → Draw） 之后的下一帧执行。换句话说：只有当 UI 确认更新到屏幕上之后，Compose 才会触发 SideEffect 回调。 #DisposableEffect 定义： 在组合中执行一个副作用，并在 退出组合 / key 变化时自动清理。 执行流程为：进入组合 → 执行副作用；key 变化或退出组合 → 调用 onDispose → 若是 key 变化，还会使用新 key 执行副作用 key 变化：先调用旧 onDispose → 再执行新副作用 场景：注册 BroadcastReceiver、Callback、监听器等。 123456789101112@Composablefun BatteryReceiver(context: Context, onChanged: (Int) -&gt; Unit) { DisposableEffect(Unit) { val receiver = object : BroadcastReceiver() { override fun onReceive(c: Context, i: Intent) { onChanged(i.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)) } } context.registerReceiver(receiver, IntentFilter(Intent.ACTION_BATTERY_CHANGED)) onDispose { context.unregisterReceiver(receiver) } }} #produceState 定义： 在组合中开启协程生产一个 State，用于把挂起/回调结果转为 Compose 状态。 进入组合时启动，在其退出组合时取消。 场景：一次性异步获取、轮询，或从 callback 适配到状态。 123456@Composablefun weather(city: String, repo: WeatherRepo): State&lt;Result&lt;Weather&gt;&gt; { return produceState&lt;Result&lt;Weather&gt;&gt;(initialValue = Result.loading(), city) { value = runCatching { repo.fetch(city) } }} 123456789101112131415// androidx.compose.runtime.ProduceStateScope@Composablefun &lt;T&gt; produceState( initialValue: T, key1: Any?, key2: Any?, key3: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt; { val result = remember { mutableStateOf(initialValue) } LaunchedEffect(key1, key2, key3) { ProduceStateScopeImpl(result, coroutineContext).producer() } return result} 上面代码为 produceState 某个重载函数的源码，可以看到，它其实就是 rememeber 、mutableStateOf 和 LaunchedEffect 有组合使用。 #snapshotFlow 定义：把对 Compose 状态的读取转换为冷 Flow；仅当读取到的值变化时发射，并与快照系统对齐。 场景：对输入做防抖、节流，与 Flow 运算符协同。 123456789101112@Composablefun DebouncedSearch(query: String, onSearch: (String) -&gt; Unit) { val latestOnSearch by rememberUpdatedState(onSearch) LaunchedEffect(Unit) { snapshotFlow { query } // 防抖，尾触发，静默一段时间(ms) 后发一次 .debounce(300) // 去重，只与上一次的值进行比较 .distinctUntilChanged() .collect { latestOnSearch(it) } }} 上面的代码：对搜索输入做“防抖+去重”，把 Compose 状态 query 转成 Flow，用户停止输入 300ms 且内容变化时才调用 onSearch，避免频繁请求。 #rememberCoroutineScope 定义：返回一个与当前组合生命周期绑定的 CoroutineScope。 场景：点击事件、手势回调中按需启动协程，而不是依赖重组。 1234567@Composablefun SaveButton(repo: Repo) { val scope = rememberCoroutineScope() Button(onClick = { scope.launch(Dispatchers.IO) { repo.save() } }) { Text(&quot;保存&quot;) }} #二、Animation – animatable #1. 状态转移型动画 animate*AsState animate*AsState 类型的动画有很多，比如 animateDpAsState 、animateColorAsState、animateOffsetAsState、animateFloatAsState 、animateIntAsState 等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 基本尺寸切换：animateDpAsState@Composablefun SizeAnimDemo() { var big by remember { mutableStateOf(false) } val size by animateDpAsState( targetValue = if (big) 120.dp else 60.dp, animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow), label = &quot;size&quot; ) Box( modifier = Modifier .size(size) .background(Color(0xFF4CAF50)) .clickable { big = !big } )}// 颜色切换：animateColorAsState@Composablefun ColorAnimDemo() { var on by remember { mutableStateOf(false) } val bg by animateColorAsState( targetValue = if (on) Color(0xFF3F51B5) else Color(0xFFE91E63), animationSpec = tween(600, easing = FastOutSlowInEasing), label = &quot;bg&quot; ) Box( modifier = Modifier .size(120.dp) .background(bg) .clickable { on = !on } )}// 透明度与旋转：animateFloatAsState@Composablefun AlphaRotateDemo() { var visible by remember { mutableStateOf(true) } val alpha by animateFloatAsState( targetValue = if (visible) 1f else 0f, animationSpec = tween(400), label = &quot;alpha&quot; ) val rotation by animateFloatAsState( targetValue = if (visible) 0f else 180f, animationSpec = spring(stiffness = Spring.StiffnessMedium), label = &quot;rotation&quot; ) Box( modifier = Modifier .size(100.dp) .graphicsLayer { this.alpha = alpha; this.rotationZ = rotation } .background(Color(0xFFFFC107)) .clickable { visible = !visible } )}// 位移动画：animateOffsetAsState@Composablefun OffsetAnimDemo() { var moved by remember { mutableStateOf(false) } val offset by animateOffsetAsState( targetValue = if (moved) Offset(120f, 120f) else Offset.Zero, animationSpec = tween(700), label = &quot;offset&quot; ) Box( modifier = Modifier .size(160.dp) .background(Color(0xFFEEEEEE)) .clickable { moved = !moved } ) { Box( modifier = Modifier .offset { IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) } .size(50.dp) .background(Color.Red, CircleShape) ) }}// 数字平滑过渡：animateIntAsState@Composablefun CountAnimDemo() { var count by remember { mutableStateOf(0) } val displayCount by animateIntAsState( targetValue = count, animationSpec = tween(300), label = &quot;count&quot; ) Row(verticalAlignment = Alignment.CenterVertically) { Button(onClick = { count++ }) { Text(&quot;加&quot;) } Spacer(Modifier.width(12.dp)) Text(text = &quot;$displayCount&quot;, fontSize = 32.sp) }} 上面的一些例子中使用了一些 animate*AsState 类型动画的具体方法，以 animateDpAsState 举例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// androidx.compose.animation.core.AnimateAsStateKt@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, label: String = &quot;DpAnimation&quot;, finishedListener: ((Dp) -&gt; Unit)? = null): State&lt;Dp&gt; { return animateValueAsState( targetValue, Dp.VectorConverter, animationSpec, label = label, finishedListener = finishedListener )}@Composablefun &lt;T, V : AnimationVector&gt; animateValueAsState( targetValue: T, typeConverter: TwoWayConverter&lt;T, V&gt;, animationSpec: AnimationSpec&lt;T&gt; = remember { spring() }, visibilityThreshold: T? = null, label: String = &quot;ValueAnimation&quot;, finishedListener: ((T) -&gt; Unit)? = null): State&lt;T&gt; { val toolingOverride = remember { mutableStateOf&lt;State&lt;T&gt;?&gt;(null) } val animatable = remember { Animatable(targetValue, typeConverter, visibilityThreshold, label) } val listener by rememberUpdatedState(finishedListener) val animSpec: AnimationSpec&lt;T&gt; by rememberUpdatedState( animationSpec.run { if (visibilityThreshold != null &amp;&amp; this is SpringSpec &amp;&amp; this.visibilityThreshold != visibilityThreshold ) { spring(dampingRatio, stiffness, visibilityThreshold) } else { this } } ) val channel = remember { Channel&lt;T&gt;(Channel.CONFLATED) } // .... return toolingOverride.value ?: animatable.asState()} 从上面的源码可以看到，该方法就是将传入的 targetValue 使用 State 进行封装，而 animateValueAsState 里使用了 remember 进行了缓存。也就是说，animate*AsState 类型的动画有如下特性： 不需要使用 mutableStateOf 进行封装，已自行进行 State 的封装 不需要使用 remember 进行缓存，内部已使用 remember 确保不会在重组时重新初始化 返回结果是 State 类型，因此不能被 var 声明 animate*AsState 会在 targetValue 变化时启动过渡，它本身不改变值，必须由“外部状态”驱动 targetValue 的新值 （触发重组）。 targetValue即设置了初始状态下的初始值，也设置了动画过程中的目标值。 只有当新旧 targetValue 不相等时才会启动动画。 结论，animateAsState 适合“值变化即过渡”的声明式场景。 #2. 流程定制型动画 animatable 由上面 animateValueAsState 的源码可以看到，animate*AsState 是对 animatable 的封装，用于提供值变化即过渡场景的动画实现，调用简单。 animatable 传入的值，默认是 float 类型，若想传入其它类型，比如颜色值、Dp 等，需要往里传入一个转换器，用于告诉 animatable 如何将传入的值与 float 互相转换，该转换器实现接口 TwoWayConverter。官方已提供一部分的转换器：Dp.VectorConverter、Color.VectorConverter 等。 1234567891011// androidx.compose.animation.core.TwoWayConverterval Dp.Companion.VectorConverter: TwoWayConverter&lt;Dp, AnimationVector1D&gt; get() = DpToVectorval Size.Companion.VectorConverter: TwoWayConverter&lt;Size, AnimationVector2D&gt; get() = SizeToVector// androidx.compose.animation.ColorVectorConverterKtval Color.Companion.VectorConverter: (colorSpace: ColorSpace) -&gt; TwoWayConverter&lt;Color, AnimationVector4D&gt; get() = ColorToVector 通过上面部分源码可见，转换器转换的是某个类型和 AnimationVector1D、AnimationVector4D 等的转换，其中 AnimationVector 后面的 1D、2D、3D、4D 等是维度的意思，代表几维。其中 Dp 只是一维，Size 是二维的，而颜色是四维的。最高就提供四维。 AnimationVector 里的内部还是使用的 float 存储的值。 animatable 动画其实就是操纵传入的起始值的渐变过程。该过程通过animateTo() 函数实现。该函数是协程函数。 12345678910111213141516@Composablefun ColorAnim() { val scope = rememberCoroutineScope() val color = remember { Animatable(Color(0xFF4CAF50)) } Box( Modifier .size(80.dp) .background(color.value) .clickable { scope.launch { val target = if (color.value == Color(0xFF4CAF50)) Color(0xFF3F51B5) else Color(0xFF4CAF50) color.animateTo(target, animationSpec = tween(600)) } } )} 上面的示例功能为，点击方块时，在 600ms 内执行一次两种颜色之间的补间切换。 animatable 动画另一个设置目标值的方法为 snapTo()，它的调用与 animateTo() 完全一致，只是 snapTo() 是没有动画过度的，直接变为设置的目标值。 #3. animate*AsState vs Animatable（对比表） 特性 animate*AsState Animatable 定位/范式 声明式：值变即过渡 命令式：主动发起/编排动画 触发条件 targetValue 变化自动启动 调用 animateTo/animateDecay/snapTo/stop 返回类型 State&lt;T&gt;（值变更触发重组） Animatable&lt;T, V&gt;，读 anim.value 控制能力 低；不可暂停/恢复/等待 高；可暂停、停止、打断、限界、编排 串行/并行动画 不支持显式编排 协程中自然编排，支持 await 完成 中断行为 新 target 覆盖旧动画继续过渡 stop()/snapTo() 精确控制 与手势/物理 不擅长 强：衰减、弹簧、速度、边界、回弹 初始化 由 targetValue 推导 Animatable(initial) 或 snapTo() 类型支持 Float/Int/Dp/Color/Offset/... 自定义类型配 TwoWayConverter 使用复杂度 低 较高（需协程/时序） 典型场景 颜色/尺寸/透明度等简单过渡 拖拽惯性、回弹、按钮弹跳、序列动画 不适合 需要流程控制/手势物理 仅做极简过渡（代码啰嗦） 常用 API animateFloatAsState 等 animateTo、animateDecay、snapTo、stop、updateBounds 重组特性 每帧更新触发使用处重组 读 anim.value 的 Composable 重组 简要选型 仅需“值变即过渡”→ 使用 animate*AsState 需串行/并行/中断/等待完成/手势物理 → 使用 Animatable #4. AnimationSpace AnimationSpace 定义动画“怎么动”——时间到进度的映射与动力学模型 （时长、节奏曲线、弹性、重复等）。是一个接口。 classDiagram-v2 direction TB AnimationSpec &lt;|-- FiniteAnimationSpec AnimationSpec &lt;|-- InfiniteRepeatableSpec AnimationSpec &lt;|-- StartDelayAnimationSpec AnimationSpec &lt;|-- FloatAnimationSpec FiniteAnimationSpec &lt;|-- SpringSpec FiniteAnimationSpec &lt;|-- DurationBasedAnimationSpec FiniteAnimationSpec &lt;|-- RepeatableSpec DurationBasedAnimationSpec &lt;|-- KeyframesWithSplineSpec DurationBasedAnimationSpec &lt;|-- ArcAnimationSpec DurationBasedAnimationSpec &lt;|-- KeyframesSpec DurationBasedAnimationSpec &lt;|-- SnapSpec DurationBasedAnimationSpec &lt;|-- TweenSpec FloatAnimationSpec &lt;|-- FloatSpringSpec FloatAnimationSpec &lt;|-- FloatTweenSpec #1. TweenSpec – 补间动画 它的作用是定义一段 补间动画 (tween animation) 的时长、延迟和缓动曲线。 123456789101112131415161718192021222324// androidx.compose.animation.core.TweenSpec@Immutableclass TweenSpec&lt;T&gt;( val durationMillis: Int = DefaultDurationMillis, val delay: Int = 0, val easing: Easing = FastOutSlowInEasing) : DurationBasedAnimationSpec&lt;T&gt; { override fun &lt;V : AnimationVector&gt; vectorize(converter: TwoWayConverter&lt;T, V&gt;) = VectorizedTweenSpec&lt;V&gt;(durationMillis, delay, easing) override fun equals(other: Any?): Boolean = if (other is TweenSpec&lt;*&gt;) { other.durationMillis == this.durationMillis &amp;&amp; other.delay == this.delay &amp;&amp; other.easing == this.easing } else { false } override fun hashCode(): Int { return (durationMillis * 31 + easing.hashCode()) * 31 + delay }} 上面是 TweenSpce 的源码，可以看到它有三个入参： durationMillis，动画时长，默认 300 毫秒。 delay，动画启动延时，默认为 0 不延时。 easing，是动画曲线，是规划动画如何进行渐变运动的。 可以通过自定义 Easing 来进行自定义曲线传入的是 0 到 1 的浮点型的动画完成度，返回经过自定义的动画实现完成度。下面列举了一些 easing 的常用类型: 123456789// androidx.compose.animation.core.Easingval FastOutSlowInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1.0f)val LinearOutSlowInEasing: Easing = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1.0f)val FastOutLinearInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 1.0f, 1.0f)val LinearEasing: Easing = Easing { fraction -&gt; fraction } easing 常用类型 描述 适用场景 LinearEasing 匀速动画，速度恒定 进度条、持续匀速滚动 FastOutSlowInEasing 快出慢入，开始快结束慢，符合 Material Design 的默认曲线 交互动效默认曲线、按钮过渡、控件从 A 状态变更为 B 状态 LinearOutSlowInEasing 开始匀速，结束慢 卡片落位、内容收尾减速、控件入场 (从无变有) FastOutLinearInEasing 开始快，结束匀速 弹出进入、强调快速启动、控件出场 (从有变无) CubicBezierEasing 自定义三次贝塞尔曲线 定制品牌动效曲线 EaseIn 缓入，动画从慢到快 启动阶段需加速的元素 EaseOut 缓出，动画从快到慢 结束阶段需减速的元素 EaseInOut 缓入缓出，动画先慢后快再慢 需要自然过渡的位移/淡入淡出 常用 easing 的使用示例： 123456789101112131415161718@Composablefun LinearProgressDemo() { var progress by remember { mutableStateOf(0f) } val animated by animateFloatAsState( targetValue = progress, animationSpec = tween(durationMillis = 600, easing = LinearEasing), label = &quot;progress&quot; ) Column(modifier = Modifier.fillMaxWidth()) { LinearProgressIndicator(progress = animated, modifier = Modifier.fillMaxWidth()) Spacer(Modifier.height(12.dp)) Row { Button(onClick = { progress = 0f }) { Text(&quot;重置&quot;) } Spacer(Modifier.width(12.dp)) Button(onClick = { progress = 1f }) { Text(&quot;满&quot;) } } }} 123456789101112131415161718192021@Composablefun FastOutSlowInStateChangeDemo() { var on by remember { mutableStateOf(false) } val size by animateDpAsState( targetValue = if (on) 120.dp else 60.dp, animationSpec = tween(300, easing = FastOutSlowInEasing), label = &quot;size&quot; ) val color by animateColorAsState( targetValue = if (on) Color(0xFF3F51B5) else Color(0xFFE91E63), animationSpec = tween(300, easing = FastOutSlowInEasing), label = &quot;color&quot; ) Box( modifier = Modifier .size(size) .clip(RoundedCornerShape(16.dp)) .background(color) .clickable { on = !on } )} 12345678910111213141516171819202122232425@Composablefun LinearOutSlowInEnterDemo() { var visible by remember { mutableStateOf(false) } val alpha by animateFloatAsState( targetValue = if (visible) 1f else 0f, animationSpec = tween(400, easing = LinearOutSlowInEasing), label = &quot;alpha&quot; ) val offsetY by animateDpAsState( targetValue = if (visible) 0.dp else 24.dp, animationSpec = tween(400, easing = LinearOutSlowInEasing), label = &quot;offsetY&quot; ) Column { Button(onClick = { visible = !visible }) { Text(if (visible) &quot;隐藏&quot; else &quot;显示&quot;) } Spacer(Modifier.height(12.dp)) Box( modifier = Modifier .offset(y = offsetY) .alpha(alpha) .size(120.dp) .background(Color(0xFF4CAF50)) ) }} 123456789101112131415161718192021222324@Composablefun FastOutLinearInExitDemo() { var visible by remember { mutableStateOf(true) } val alpha by animateFloatAsState( targetValue = if (visible) 1f else 0f, animationSpec = tween(300, easing = FastOutLinearInEasing), label = &quot;alpha&quot; ) val scale by animateFloatAsState( targetValue = if (visible) 1f else 0.8f, animationSpec = tween(300, easing = FastOutLinearInEasing), label = &quot;scale&quot; ) Column { Button(onClick = { visible = !visible }) { Text(if (visible) &quot;出场&quot; else &quot;重置&quot;) } Spacer(Modifier.height(12.dp)) Box( modifier = Modifier .graphicsLayer { this.alpha = alpha; this.scaleX = scale; this.scaleY = scale } .size(120.dp) .background(Color(0xFF03A9F4)) ) }} CubicBezierEasing 12345678910@Immutableclass CubicBezierEasing( private val a: Float, private val b: Float, private val c: Float, private val d: Float) : Easing { // ...} 三阶贝塞尔缓动曲线，用于定制动画完成度与实现完成度之间关系的。三阶贝塞尔曲线由 4 个点进行定位，但是通过上面的源码可以看到，只传入了两个点的坐标。另外两个点固定在了 (0，0)、(1,1)。 定制曲线可以使用网站：https://cubic-bezier.com/ 如上图所示，固定了两个点，可以拖动红蓝两个点进行曲线的定制，横坐标是时间完成度，纵坐标是动画完成度。曲线的斜度就是每一时刻动画的速度，所以越陡峭的位置动画越快 #2. SnapSpec #动画 API 选择 graph TB A[开始] --> B{动画更像艺术作品吗，包含很多视觉元素，比如 SVG 或图片} B -->|是| C{是否是简单的 SVG，比如带微动效的图标} C -->|是| D[AnimatedVectorDrawable] C -->|否| E[动画框架，例如 Lottie] B -->|否| F{是否需要永远重复} F -->|是| G[rememberInfiniteTransition] F -->|否| H{这是布局动画吗} H -->|是| I{是否在不同内容的可组合项之间切换} I -->|是| J{是否使用 navigation compose} J -->|是| K[enterTransition 与 exitTransition] J -->|否| L[AnimatedContent 或 CrossFade 或 Pager] I -->|否| M{是否为出现或消失的过渡} M -->|是| N[AnimatedVisibility，或 animateFloatAsState 配合 Modifier.alpha] M -->|否| O{是否是尺寸变化} O -->|是| P[animateContentSize] O -->|否| Q{其他布局属性需要动画，例如 offset，padding 等} Q -->|是| R{是列表项动画吗} R -->|是| S[animateItemPlacement，支持重排与删除] R -->|否| T[Animatable 配合 animateTo 或 snapTo] Q -->|否| U[AnimationState 或 animate，一次性无状态管理] H -->|否| V{是否需要同时为多个参数做动画} V -->|否| W{动画是否具有一组预定义的目标值} W -->|是| X[animate*AsState，文本使用 TextMotion.Animated] W -->|否| U V -->|是| Y{这些属性是否彼此完全独立} Y -->|是| Z{是否需要同时开始} Z -->|是| AA[updateTransition，配合 AnimatedVisibility，animateFloat，animateInt 等] Z -->|否| AB[多个 Animatable，使用不同的时序调用 animateTo] Y -->|否| AC{是否是手势驱动，并且动画是唯一的真值来源} AC -->|是| T AC -->|否| AA %% 样式定义 classDef start fill:#C8E6C9,stroke:#2E7D32,stroke-width:2px,color:#1B5E20; classDef decision fill:#A5D6A7,stroke:#2E7D32,stroke-width:2px,color:#1B5E20; classDef action fill:#E3F2FD,stroke:#1E88E5,stroke-width:2px,color:#0D47A1; %% 节点分类 class A start; class B,C,F,H,I,J,M,O,Q,R,V,W,Y,Z,AC decision; class D,E,G,K,L,N,P,S,T,U,X,AA,AB action; %% 绿色为“是”分支（默认），红色为“否”分支（按索引） linkStyle default stroke:#66BB6A,stroke-width:2px,color:#000000 %% 否分支索引: 3,4,6,10,11,13,15,18,19,20,21,23,27,28,30 （从0开始计） linkStyle 3 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 4 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 6 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 10 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 11 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 13 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 15 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 18 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 19 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 20 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 21 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 23 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 27 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 28 stroke:#E57373,stroke-width:2px,color:#C62828 linkStyle 30 stroke:#E57373,stroke-width:2px,color:#C62828 动画是基于美术的（即 SVG 或图片）吗？ 是：它是否使用简单的 SVG（即带有微动画的图标）？ 有：AnimatedVectorDrawable。 否：第三方动画框架，例如 Lottie。 否：动画是否需要无限循环播放？ 有：rememberInfiniteTransition。 否：您是否正在为布局添加动画？ 是：您是否在具有不同内容的可组合项之间切换？ 是：您是否在使用 Navigation-Compose？ 可以：使用 composable()，并设置 enterTransition 和 exitTransition。 否：AnimatedContent、Crossfade 或 Pager。 否：您是否要为内容的出现或消失添加动画效果？ 可以：AnimatedVisibility 或 animateFloatAsState 与 Modifier.alpha() 搭配使用。 否：您是否要为大小变化添加动画效果？ 有：Modifier.animateContentSize。 否：您是否正在为其他布局属性（例如偏移或内边距）添加动画效果？ 是：请参阅“这些属性是否完全彼此独立？”。 否：您是否要为列表项添加动画效果？ 有：animateItem()。 否：您是否要为多个属性添加动画效果？ 是：属性是否完全相互独立？ 有：animate*AsState。对于文本，请使用 TextMotion.Animated。 否：它们是否需要同时开始？ 可以：updateTransition，包含 AnimatedVisibility、animateFloat、animateInt 等。 否：Animatable 与 animateTo 搭配使用，使用挂起函数以不同时间调用。 否：动画是否具有预定义的目标值？ 有：animate*AsState。对于文本，请使用 TextMotion.Animated。 否：动画是否由手势驱动，并且是唯一可信来源？ 是：Animatable，带有 animateTo / snapTo。 否：是否为不含状态管理的一次性动画？ 是：AnimationState 或 animate。","link":"/2025/09/03/JetpackCompose%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/"},{"title":"JetpackCompose学习系列二： 状态订阅与自动更新","text":"一、前言 二、自定义 Composable 1. 自定义 Compose 函数建议外层只调用一个 Compose 函数 三、刷新逻辑中的组合 四、MutableState 1. by 与 = 的区别 2. mutableStateOf 1. SnapshotMutableStateImpl 2. SateObject 与 StateRecord 3. get() = next.readable(this).value 解析 4. set() 方法解析 5. 两套订阅系统 6. mutableStateOf 总结 五、 remember 1. 重组作用域 2. remember 3. 带参数的 remember 六、无状态与单向数据流 1. 无状态 Stateless 2. 状态提升 3. 单向数据流 七、List 自动订阅 – mutableStateListOf 八、重组的性能优化 1. 重组的性能风险 2. 性能优化 1. @Stable 注解 2. 类型的公开属性加状态 3. 总结 九、derivedStateOf() 1. derivedStateOf: 将一个或多个状态对象转换为其他状态 2. derivedStateOf 与 remember(key) 区别 3. dervedStateOf 与 remember(key) 综合使用 十、CompositionLocal 1. 简单使用 2. 覆盖使用 3. compositionLocalOf 与 staticCompositionLocalOf 4. 源码 5. 使用场景 示例1：系统提供的 MaterialTheme 示例2 ：组合式日志通道 #一、前言 本文主要讲述Jetpack Compose 的状态订阅与自动更新 Google 官网：https://developer.android.com/develop/ui/compose/documentation?hl=zh-cn #二、自定义 Composable 只有 Composable 函数才可以调用 Composable 函数 Composable 函数名采用大驼峰命名法，首字母都大写 @Composeable 就是相当于标识符，为函数添加注解 @Composeable 即可创建自定义 Compose 组件，这些添加注解的组件函数会在编译阶段被 Compose 的编译器插件进行修改，添加 Composer 类型的参数。实际调用的就是这些被修改后的产物。 这就和协程有些相似，添加了suspend 关键字的方法是协程函数，而在编译阶段编译器会给协程函数添加一个Continuation类型的参数。 Tips：这就是面向切面编程 (AOP) 的实例， 一般使用注解处理器 （Annotation Processor） 或修改字节码进行实现。而 Compose 使用了第三种方式，使用了编译器插件 (Compiler Plugin)，该方式功能更强大，且便于跨平台。 界面的入口 ComponentActivity.setContent() 方法，该方法并没有直接调用 Composable 函数，而是对它进行了传递，经过层层传递，最终invokeComposable() 方法直接调用 Composable 函数，该方法里直接将 Composable 函数进行强制类型转换，并进行调用。源码如下： 123456internal actual fun invokeComposable(composer: Composer, composable: @Composable () -&gt; Unit) { @Suppress(&quot;UNCHECKED_CAST&quot;) val realFn = composable as Function2&lt;Composer, Int, Unit&gt; realFn(composer, 1)} #1. 自定义 Compose 函数建议外层只调用一个 Compose 函数 1234567891011121314151617181920212223@Composablefun MultiComposableDemo1() { // 这里连续调用多个可组合函数是完全合法的，但是不建议 Text(&quot;标题&quot;) Text(&quot;按钮&quot;)}@Composablefun MultiComposableDemo2() { Column { Text(&quot;标题&quot;) Text(&quot;按钮&quot;) }}@Composablefun MultiComposableDemo3() { Row { Text(&quot;标题&quot;) Text(&quot;按钮&quot;) }} Compose 中，@Composable 不&quot;返回 View&quot;，而是 “向父级插槽发射节点”。同一个函数里多次调用可组合函数，会发射多个兄弟节点。 这些兄弟节点如何&quot;测量/摆放&quot;，完全由&quot;外层容器&quot;的布局策略决定 （Row/Column/Box 各不相同）。 如上代码所示，这三个示例都是合法的。但是在示例1中，发射两个兄弟节点，但不声明布局策略。它们将&quot;交给调用处的父容器&quot;去布局： 被放进 Column { MultiComposableDemo1() } → 垂直排布 被放进 Row { MultiComposableDemo1() } → 水平排布 被放进 Box { MultiComposableDemo1() } → 默认重叠在一起 因此&quot;合法但不建议&quot;：组件自身没有确定的布局，表现取决于外部场景，易产生不可预期的重叠/间距问题，也不便封装间距、对齐、可访问性语义等。 当&quot;刻意把布局交给调用方&quot;时 （比如做一个纯内容片段、让它在不同父容器中按父布局策略呈现）。否则，优先在组件内部选定 Row/Column/Box 等，让组件行为可预期。 #三、刷新逻辑中的组合 刷新层层递进分三部分：组合 --&gt; 布局 --&gt; 绘制。 后两层与传统 View 体系里的布局、绘制是一样的。 组合是执行这些 @Compose 函数的过程，这个过程就是拼凑实际界面内容的过程。也就是根据各 @Compose 函数组合出一个个的实际对象，这些实际对象参与后续的布局、绘制。实际对象就是 LayoutNode 等。 #四、MutableState 在 Compose 里进行界面的刷新，通过 MutableState 状态的订阅来进行更新。 1234567@Stableinterface MutableState&lt;T&gt; : State&lt;T&gt; { override var value: T operator fun component1(): T operator fun component2(): (T) -&gt; Unit} 我的理解是 MutableState 是给真实的值套了一层状态的壳子，Compose 通过这层状态的壳子来判断并进行更新，而里面的值才是使用方真正用到的值。 #1. by 与 = 的区别 123456789101112// 示例一@Composablefun MutableStateDemo() { val name = mutableStateOf(&quot;A&quot;) val name2 by mutableStateOf(&quot;B&quot;) Text(text = &quot;名称1：${name.value}, 名称2：${name2}&quot;) // 如果年增修改 name2 ，则需要 var 定义 name2 = &quot;C&quot;} 如上所示： name 的类型为 MutableState 类型，在调用位置需要使用 value 属性获取 String 值，而且因为是 MutableState 类型，只有里面的值需要改变，所以 name 被 val 定义 name2 的类型为 String 类型，在调用位置可直接使用该值，它其实通 by 关键字进行委托右边的值进行读写，也就是说可以通过修改右侧的值，来达到修改它的目的，所以也可以被 val 定义。但是如果需要直接修改 name2 来达到修改值的目的，则需要被 var 定义。 by 委托模式，需要右边的内容实现 getValue() 和 setValue 两个方法，而查看 MutableState 里是没有这个方法，而是通过 MutableState 的扩展函数来进行实现的。源码如下所示： 123456789// 1. androidx.compose.runtime.SnapshotState.kt@Suppress(&quot;NOTHING_TO_INLINE&quot;)inline operator fun &lt;T&gt; State&lt;T&gt;.getValue(thisObj: Any?, property: KProperty&lt;*&gt;): T = value@Suppress(&quot;NOTHING_TO_INLINE&quot;)inline operator fun &lt;T&gt; MutableState&lt;T&gt;.setValue(thisObj: Any?, property: KProperty&lt;*&gt;, value: T) { this.value = value} 所以在使用 by 关键字时，通知还需要引入两个包 import androidx.compose.runtime.setValue 、import androidx.compose.runtime.getValue，来达到 委托的条件。不需要全引，看使用场景。 #2. mutableStateOf #1. SnapshotMutableStateImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 1. androidx.compose.runtime.SnapshotState.kt@StateFactoryMarkerfun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy)// 2. androidx.compose.runtime.ActualAndroid.android.ktinternal actual fun &lt;T&gt; createSnapshotMutableState( value: T, policy: SnapshotMutationPolicy&lt;T&gt;): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy)// 3. androidx.compose.runtime.ParcelableSnapshotMutableState.android.kt@SuppressLint(&quot;BanParcelableUsage&quot;)internal class ParcelableSnapshotMutableState&lt;T&gt;( value: T, policy: SnapshotMutationPolicy&lt;T&gt;) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable { override fun writeToParcel(parcel: Parcel, flags: Int) { ... } override fun describeContents(): Int { return 0 } ...}// 4. androidx.compose.runtime.SnapshotState.ktinternal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl(), SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next ...} 如上源码所示，在经过 4 层查找后，最终，找到了 SnapshotMutableStateImpl，这里实现了 mutableStateOf 里传递的那个 value的 get()和 set 方法。 观察其 set 和 get 方法： 调用 get 方法时，不仅仅返回了结果，还记录了是在哪里调用的 get 方法。 调用 set 方法时，不只是修改 value 的值，还要查找那些调用 get 方法的位置，然后通知这些位置进行刷新。 #2. SateObject 与 StateRecord 123456789101112131415161718192021222324// 5. androidx.compose.runtime.SnapshotState.ktprivate class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue}// 6. androidx.compose.runtime.snapshots.StateRecordabstract class StateRecord { internal var snapshotId: Int = currentSnapshot().id internal var next: StateRecord? = null abstract fun assign(value: StateRecord) abstract fun create(): StateRecord} 继续看 get() = next.readable(this).value，其中的 next 其实是 StateStateRecord 对象，而 StateStateRecord 继续自 StateRecord。 而 SnapshotMutableStateImpl 继承了 StateObjectImpl，而它又实现了 StateObject 接口。能够被订阅的，实际都是 SateObject 的实现类。 12345678910111213// 7. androidx.compose.runtime.snapshots.StateRecordinterface StateObject { val firstStateRecord: StateRecord fun prependStateRecord(value: StateRecord) fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? = null} 回顾一下链路，MutableState 能够被订阅，是因为实现了 StateObject，而 StateObject 没有直接装载目标类型对象，而是将目标类型对象放到了StateRecord 对象里储存。StateRecord 是一个链表，这样做的目的是为了存多个目标类型对象 (多份新旧值)，因为 Compose 支持事务功能。 firstStateRecord 是这个链表里的头节点。 #3. get() = next.readable(this).value 解析 所以，get() = next.readable(this).value 是取出目标类型对象链表的头节点，之后调用 readable() 方法 12345678910111213141516171819202122232425262728// 8. androidx.compose.runtime.snapshots.Snapshot.ktfun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current snapshot.readObserver?.invoke(state) return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError() }}private fun &lt;T : StateRecord&gt; readable(r: T, id: Int, invalid: SnapshotIdSet): T? { // The readable record is the valid record with the highest snapshotId var current: StateRecord? = r var candidate: StateRecord? = null while (current != null) { if (valid(current, id, invalid)) { candidate = if (candidate == null) current else if (candidate.snapshotId &lt; current.snapshotId) current else candidate } current = current.next } if (candidate != null) { @Suppress(&quot;UNCHECKED_CAST&quot;) return candidate as T } return null} readable() 方法，中 snapshot.readObserver?.invoke(state) 用于进行记录 StateObject，也就是MutableState 对象，被这个地方使用了。这个地方也就是指调用了 MutableState 的 get 方法的地方。而这个记录行为相当于订阅行为，MutableState 每次被修改的时候，会遍历 这些记录，将这些记录里的地方标记为失效，失效的地方在下一帧进行重组 （Recompose, 再次进行组合）。 readable() 方法最终调用到三个入参的重载方法，该方法遍历 StateRecord 链表，找到一个 最新的、可用的 StateRecord。并返回这个值。 所以，get() = next.readable(this) 的作用是，拿到头节点，遍历整个表，取出最新的、可用的 StateRecord，并且记录下 StateObject的子类被使用的地方。之后再调用 .value 是取出存在于 StateRecord 里的目标类型对象。 #4. set() 方法解析 12345set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} 123456789101112131415// 9. androidx.compose.runtime.snapshots.Snapshot@PublishedApiinternal fun &lt;T : StateRecord&gt; current(r: T) = Snapshot.current.let { snapshot -&gt; readable(r, snapshot.id, snapshot.invalid) ?: sync { Snapshot.current.let { syncSnapshot -&gt; readable(r, syncSnapshot.id, syncSnapshot.invalid) } } ?: readError() }inline fun &lt;T : StateRecord, R&gt; T.withCurrent(block: (r: T) -&gt; R): R = block(current(this)) next.WithCurrent {} 方法就是执行一下 {} 里的内容，并将 current(this) 的结果传递给 {}。 而 current(this) 方法里最终调用的 readable()三参数的函数，该方法遍历 StateRecord 链表，找到一个 最新的、可用的 StateRecord，并返回这个值。也就是说，将当前最新的、可用的 StateRecord 传递给 {}。该代码块里执行，如下代码： 123if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value }} 这个代码块是比较一下新旧值是否一样，如果值没有变化，就结束；如果值有变化，就进入这个 if 语句内部，执行 next.overwritable(this, it) { this.value = value }。 1234567891011121314151617181920212223242526272829303132333435// 10. androidx.compose.runtime.snapshots.Snapshotinternal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }}internal fun &lt;T : StateRecord&gt; T.overwritableRecord( state: StateObject, snapshot: Snapshot, candidate: T): T { if (snapshot.readOnly) { // If the snapshot is read-only, use the snapshot recordModified to report it. snapshot.recordModified(state) } val id = snapshot.id if (candidate.snapshotId == id) return candidate val newData = sync { newOverwritableRecordLocked(state) } newData.snapshotId = id snapshot.recordModified(state) return newData} 如上所示，overwriteable() 方法调用了一个 overwritableRecord() 方法：如果传进来的 StateRecord 正好对应了传进来的 Snapshot，则直接返回传入的 StateRecord。如果不对应，则生成一个 StateRecord，然后返回这个生成的。 其中，StateRecord 修改前后的值都会被存起来，形成一个链表。链表上的各个节点其实都对应了某个时刻的 Compose 的整个内部状态， Compose 记录每个变量的每个状态，用的是 StateRecord。具体各个链表上的哪些节点共属于同一个状态由 Snapshot 进行记录。Snapshot 记录的是整个状态，可以对应多个 StateRecord，而一个 StateRecord 对应一个 Snapshot。 Tips: 有了快照，在某些变量发生改变时，就不必马上进行应用并显示到界面，而是可以在跑完整个 Compose 流程后，在这个过程中所有改变的变量一起应用，并拿应用后的最终结果，进行布局绘制。 系统有多个 Snapshot 时，它们是有先后顺序的。 同一个 StateObject 的每个 StateRecord，都有它们对应的 Snapshot 的 id。即使 Snapshot 和 StateRecord 的 id 不直接对应，但是只要 StateRecord 对应的 Snapshot 对刚才的那个 Snapshot 是有效的，那即使id 不相等，Snapshot 也可以拿到 StateRecord。 总结， overwritableRecord() 方法，使用直接取、废物利用、直接创建再返回等方式，返回一个 StateRecord。 再返回 overwritable() 方法，拿到了 Snapshot 对应的 StateRecord 然后，执行 block()，这个 block() 就是 set() 方法里的 {this.value = value}，也就是把 set(value) 里的业务类型对象 value 赋值给新拿到的 StateRecord里的value。 之后，再调用 notifyWrite(snapshot, state) 123456// 10. androidx.compose.runtime.snapshots.Snapshot@PublishedApiinternal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeCount += 1 snapshot.writeObserver?.invoke(state)} 如上所示，该方法用于查找该变量在哪里被读了，然后标记这块组合为失效。 回顾一下解析 set() 方法时，有如下代码 12345fun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current snapshot.readObserver?.invoke(state) ...} 这和刚才的 snapshot.writeObserver?.invoke(state) 相对应。 snapshot.readObserver?.invoke(state)，相当于订阅 snapshot.writeObserver?.invoke(state)，相当于通知 这两个流程加起来是一个订阅流程。 #5. 两套订阅系统 compose 先订阅 Snapshot，对读写 StateObject 分别做订阅，并且在读和写的时候进行通知，所以有两个接受者：readObserver、writeObserver。 订阅时间： Snapshot 创建的时候 通知时间： 读和写的时候 compose 还会对每一个 StateObject 的应用做订阅。 订阅时间： 第一套设阅的 readObserver 被调用 (通知) 的时候 通知时间： StateObject 新值被应用的时候 snapshot 是允许有多个的，但是只有一个当前且全局的 snapshot, 当把一个非全局的 snapshot 应用到全局的 snapshot,这个改动才算生效，这个过程就叫应用。 snapshot 主要用于组合过程中，writeObserver 是用 在组合过程中，值被改变，才标记失效 12345678910111213@Composablefun ComposableDemo() { val name = mutableStateOf(&quot;A&quot;) Box (modifier = Modifier.clickable { // 步骤1 name.value = &quot;B&quot; }) { // 步骤2 Text(name.value) // 步骤3 name.value = &quot;C&quot; }} 上面代码在组合过程中，也就是在执行过程中: 在 步骤2 中，读 name 值，所以被记录了，然后又在 步骤3 进行了 name 的写操作。由此会通知读位置失效也就是 步骤 2 、步骤 3 所在的大括号范围。 在步骤 1 中，点击监听中也对 name 值进行改变，并不是在组合过程中，所以不会通知 writeObserver。只有在组合过程中的写操作，才会通知 writeObserver，所以是通过第二套订阅系统进行的更新，也就是通过对 StateObject 的应用做订阅。 #6. mutableStateOf 总结 1234567891011121314151617181920212223// 1. androidx.compose.runtime.SnapshotState.ktinternal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl(), SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next ...} mutableStateOf 返回一个 MutableState 对象，而该对象的实现为 SnapshotMutableStateImpl，而 SnapshotMutableIntStateImpl 又是 StateObject 的实现，能够被订阅的，实际都是 SateObject 的实现类。 StateObject 通知 StateRecord 来记录真实需要的业务类型对象，并通过链表的形式记录该值的一系列变化。 StateObject 的get 方法会把读值的位置记录下来，StateObject 的 set 方法，会把所有读值的地方标记为失效。每个 StateObject 的新值被应用时，也会标记读该值的地方标记为失效。在这两种标记为失效的场景下，都会在下一帧重组刷新。 #五、 remember #1. 重组作用域 123456@Composablefun ComposableDemo() { val name = mutableStateOf(&quot;A&quot;) Text(name.value) } 前面提到过，会在取值时记录取值的地方，并在写值的时候将该地方置为无效，并在下一帧进行重组。 Compose 的编译器插件会把这些可能重新调用的代码块包起来，在包起来的代码块执行完成后，会把这个代码块保存起来，并标记到当前执行的位置，这样，当重新执行的逻辑被执行的时候，那就拿出这个代码块重新执行。注意，只有可能会被重新执行的代码才会被包起来。这种被包起来的在重组时一起执行的代码范围被叫做重组作用域 （recompose scope） 。 而如果在重组作用域里包含了状态变量的初始化，则每次重组都会把状态变量初始化，而不是使用修改之后的值。 #2. remember 12345@Composablefun ComposableDemo() { var name by remember { mutableStateOf(1) } Text(name.toString(), Modifier.clickable {name = name + 1}) } 如上代码所示，第一行使用 remember 包裹了 name 的初始化值，之后第二行 Text 显示这个值并监听 Text 的点击事件，一旦点击就将 name 的值加一。 通过之前的分析可以得到，上面的重组作用域是这两行代码，而第一行是 name 的初始化代码，如果不用 remember 包裹的话，则每次重组都会给 name 赋初值，也就达不到点击按钮原本的效果。 remember 的效果，其实起到缓存作用。是在第一次被调用时，执行 remember 包裹的内容，并保存执行结果，等下次再调用时直接返回保存的结果。所以在重组时即使又调用了初始化操作，但是返回的其实是保存的结果。 使用时机： 对可能进行重组的变量使用。即只有在组合里创建的变量，不想每次重组后都重新初始化，才需要 remember #3. 带参数的 remember 12345678910111213// androidx.compose.runtime@Composableinline fun &lt;T&gt; remember(crossinline calculation: @DisallowComposableCalls () -&gt; T): T = currentComposer.cache(false, calculation)@Composableinline fun &lt;T&gt; remember( key1: Any?, crossinline calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache(currentComposer.changed(key1), calculation)} 从上面源码可以看到 remember 还可以带 key 参数 12345@Composablefun RememberParamsDemo(name: String) { val length = remember(name) { name.length } Text(length.toString()) } 上面代码，传递一个字符串，然后在代码块里，使用 Text 显示这个字符串的长度。只有当 name 的值改变时，才会重新进行 .length 的计算。 注意，key 值慎重 （不要） 使用引用类型，比如 List 等，因为 基本数据类型如 String 的改变方式只有一种，那就是重新赋值。但是引用类型的改变除了赋值，主要是内部元素的改变，这种内部元素的改变，不会导致引用类型的变量指向一个新的对象，也就导致remember 里的 key 进行比较时，一直使用的同一个对象进行比较。类似于进行如下比较 1234val list = mutableListOf(&quot;u1&quot;, &quot;u2&quot;) val oldList = listlist.add(&quot;u3&quot;) val newList = list 上面的示例中 list 、oldList 、newList 三个变量都指向同一个对象，所以，它们即结构化相等，也引用相等 （指向同一对象） 使用 key 的典型场景: 注意：key 变化很频繁会导致频繁重建（例如手势中的偏移），避免把高速变化量做 key。 重算/重建&quot;依赖输入&quot;的结果：当输入变更才需要重新计算，其他时候复用缓存。 1val filtered = remember(query, items) { items.filter { it.contains(query) } } 让&quot;内部状态&quot;随某个标识重置：切换详情页、用户、Tab 时，清空或重建子状态。 1234@Composablefun DetailScreen(userId: String) { var note by remember(userId) { mutableStateOf(&quot;&quot;) } // userId 变就重置} 缓存&quot;与某个 key 绑定&quot;的对象/控制器：例如每个 Tab 一套滚动状态。 1val listState = remember(currentTab) { androidx.compose.foundation.lazy.LazyListState() } 只在 key 变化时初始化一次的值（昂贵初始化、资源句柄等）。 1val colorMap = remember(themeId) { buildColorMap(themeId) } 不使用 key（或更合适替代）的情况 仅仅是&quot;从其他 State 派生&quot;的值，优先用 derivedStateOf（自动跟踪依赖）。 1val text by remember { derivedStateOf { &quot;${firstName.value} ${lastName.value}&quot; } } 想跨配置变更保存值（如旋转），用 rememberSaveable 而不是靠 key。 1var count by rememberSaveable { mutableStateOf(0) } #六、无状态与单向数据流 #1. 无状态 Stateless 所谓状态就是控件属性，比如 TextView，它的 getText() 、setText() 里面操作的 text 就是 TextView 的状态信息。 而，原生 Compose 函数具有无状态的特点，也就是说 Compose 是没有这些内部属性的。比如 Text函数，即使往里设置了文本，但是通过 Text 函数是没办法取出设置的这个文本的。 12345@Composablefun StatelessDemo() { val length = 2 Text(length.toString()) } 如上代码所示， Text 函数是没有状态的，也就是没有内部属性，但是 StatelessDemo 这个函数是有状态的，它有 length 这个内部属性。 #2. 状态提升 如何获取一个没状态的组件的状态？关键点在于 内部 两个字，直接就不在内部去拿，而是直接拿传入这个组件的那个属性值就可以了。 如何获取一个有状态的组件的状态？有状态的组件变为无状态的组件，即把状态移到组件外部去，这样也就可以获取状态了。比如刚才的例子，StatelessDemo 组件虽然有 length 这个状态，但是在这个组件外部是没办法拿到这个状态的。只要把 length 值往外提就可以。 12345678910@Composablefun StatelessDemo(length: Int) { Text(length.toString()) }@Composablefun StatelessDemo2() { val length = 3 StatelessDemo(length)} 如上代码所示，把 StatelessDemo 里的状态 length 往外提，放到了它的父组件 StatelessDemo2 里，如果在父组件的范围里就可以获取到这个状态。但是注意，这此时 length 相当于父组件 StatelessDemo2 的状态，若父组件的父组件要想获取该状态，还需要把状态再往上提升。 这种把状态往外提到父组件的行为就叫做状态提升 （State Hoisting）。 注意，状态尽量不往上提升，否则该状态能被其它组件修改，容易导致不可测错误。 1234fun StatelessDemo3(length: Int) { val name = &quot;A&quot; Text(name + length.toString()) } 看 StatelessDemo3，看 length 它是无状态的，但是看 name 它又是有状态的。所以，说有状态还是无状态，不是指的某个组件，而是看组件的具体属性是有状态还是无状态。同一个组件可能即是有状态的还是无状态的，但是属性一定是确定状态类型的。 #3. 单向数据流 多数据来源会有数据同步性的问题。 比如，一个UI界面即会显示数据库内容，又会显示网络内容，但网络内容优先级更高，也就是说在网络请求的时候要先取数据库内容先显示，等网络数据返回了再去覆盖显示。但是要是网络请求比数据库取数据还快，就导致了旧数据覆盖新数据的问题。 所以，只能 UI 界面只有一个数据源那就是数据库，网络数据在更底层，网络数据返回了去更新数据库，如果串行起来，就不会有数据错误的情况。这就是单一信息源 （Single Source of Truth） Compose 官方建议单一信息源，适用于所有界面中会用到的数据。 1234567@Composablefun TextFieldDemo1() { var name = &quot;&quot; TextField(value= name, onValueChange = { //name = it })} 如上代码所示，name 作为一个外部变量，来充当 TextField 的外部状态， value 参数是文件输入框的显示内容， onValueChange 是内容监听器。 按上面 TextFieldDemo1 所示代码，在输入框里输入内容是不显示的，因为没有在输入文字之后把新值更新给 name。也就是说， 上面的代码只是把文本显示的内容与文本内容来源 name 进行了关联，但是并没有把用户的输入行为与文本内容来源做关联。所以应该做如下修改。 12345@Composablefun TextFieldDemo2() { var name by remember { mutableStateOf(&quot;&quot;)} TextField(value= name, onValueChange = { name = it })} 如上所示，在监听器里去更新文本内容来源 name。又因为 name 在重组作用域里，所以要使用 remember，并且为了要重组还要使用 mutableStateOf。 由上面的代码逻辑可以看到，TextField 的信息来源有两个，一个是外部变量 name，一个是用户的输入事件。 因为用户的输入事件响应是封装到 TextField 里，对用户不可见，为了保证单一信息源，所以不会因为用户输入事件而直接改变外部的文本内容源 name，而是直接对外暴露了 onValueChange 事件，交给用户去处理 TextField处理后的内容是否要显示。由此不会让 TextField 内部作为一个信息源，而是都对外暴露出去，这样才是完全封装，用户不需要再关心内部如何实现。 这种 状态向下传递，事件向上传递修改状态 的模式，叫做单向数据流 （Unidirectional Data Flow） 由 TextField 组件的使用可以得到：具有交互功能的无状态组件，把状态提到外部的同时，也要把交互功能的回调一起提出去。 #七、List 自动订阅 – mutableStateListOf 上文提到过使用 mutableStateOf 包裹数据，可以实现状态订阅和自动更新。基本数据类型都可以，下面实验一下 List 数据是否可行 12345678910111213141516var nums by mutableStateOf(mutableListOf(1,2,3))@Composablefun StateListDemo() { Column { Button( onClick = { // 代码1 nums.add(nums.last() + 1) }) { Text(&quot;Add&quot;) } nums.forEach { Text(&quot;第 $it&quot;) } }} 如上所示，使用 MutableState 包裹 MutableList 类型数据，赋值给 nums，然后添加一个列表，列表顶部有一个 Add 按钮，点击时会给 nums 列表追加一个元素，在按钮之下纵向显示元素内容。 但是点击的结果在界面上是没有显示追加的元素的！ 首先回想一下之前的状态订阅和自动更新功能是因为在 set() 、get 方法添加了钩子，做了一些操作。 然后分析一下取值代码, 在 nums 读取的位置，通过 foreach 函数读取所有的值，当 nums 更新时，该函数所在的重组作用域被标识失效，没有问题，是可以被成功订阅的。 再分析一下赋值代码，在 Add 按钮被点击的时候 nums 进行更新，添加一个新元素。问题出在这里！ 刚才说过，是给 set 添加了钩子，而 set 方法是重新赋值、替换整个对象、改变引用指向。也就是说 Compose 的监听是对赋值行为的监听，而不会监听对象的内部状态。 而 nums.add() 方法只改变了nums的内部内容。所以 set 方法没有被触发。 有两个解决方案： 方案一： 重新生成 list, 并赋值给 nums，按上面示例来说，可以在 代码1 处，执行完 nums 的内容改变后，再添加一条语句 nums = nums.toMutableList()，也就是将 nums 内容生成一个新的 list 再重新赋值给 nums，如果就触发了重新赋值的逻辑，界面也就刷新了。性能的损耗虽然不大，但是很不优雅！ 方案二：mutableStateListOf 该关键字返回的是一个 MutableList 对象，但是该对象内部元素的变化会被 Compose 观测到，而不是对象本身被观测。如此也就可以进行更新。 12345678910111213141516val nums = mutableStateListOf(1, 2, 3)@Composablefun StateListDemo() { Column { Button( onClick = { // 代码1 nums.add(nums.last() + 1) }) { Text(&quot;Add&quot;) } nums.forEach { Text(&quot;第 $it&quot;) } }} 上面的代码就可以在按钮点击时，正确刷新界面了。 注意，mutableStateListOf只监听列表元素的结构性变化，也就是元素的增减和替换，而不监听元素内部的状态改变。 与 mutableStateListOf 类似 mutableStateMapOf 它返回是的一个 MutableMap，也只监听 map 里元素的结构性变化，代码如下： 123456789// 以下操作会引起依赖该 `Map` 的 `Composable` 重组：map[key] = value → 插入或更新（只要 key 对应的 value 被替换掉，就会触发）map.put(key, value) / map.putAll(...)map.remove(key)map.clear() #八、重组的性能优化 #1. 重组的性能风险 回顾一下触发重组的时机： mutableStateOf 发生在变量的值被改变的时候 mutableStateListOf 、mutableStateMapOf 监听的内部元素，内部元素增删、替换时。 触发重组和重组是两个过程： 触发重组是某个变量发生改变之后，compose 把调用变量所在的重组作用域里的内容标记为失效。 重组是指在下一帧里去调用这些失效的 compose 代码。 1234567@Composablefun ComposableDemo() { var count by remember { mutableStateOf(1) } Column { Text(count.toString(), Modifier.clickable {count = count + 1}) }} 如上所示，每次点击都会改变 count 值，而该值的改变，会触发 count 被调用位置的重组作用域内容的重组，从而刷新界面。 假设 count 的重组作用域范围为 Column 范围，如果 Column 里还有其它的 compose 函数，那因为count 而触发的重组，也会导致 Column 里的其它函数被重新调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// androidx.compose.foundation.layout.ColumnKt@Composableinline fun Column( modifier: Modifier = Modifier, verticalArrangement: Arrangement.Vertical = Arrangement.Top, horizontalAlignment: Alignment.Horizontal = Alignment.Start, content: @Composable ColumnScope.() -&gt; Unit) { val measurePolicy = columnMeasurePolicy(verticalArrangement, horizontalAlignment) Layout( content = { ColumnScopeInstance.content() }, measurePolicy = measurePolicy, modifier = modifier )}// androidx.compose.ui.layout.LayoutKt@Suppress(&quot;ComposableLambdaParameterPosition&quot;)@UiComposable@Composableinline fun Layout( content: @Composable @UiComposable () -&gt; Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) { val compositeKeyHash = currentCompositeKeyHash val localMap = currentComposer.currentCompositionLocalMap ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;( factory = ComposeUiNode.Constructor, update = { set(measurePolicy, SetMeasurePolicy) set(localMap, SetResolvedCompositionLocals) @OptIn(ExperimentalComposeUiApi::class) set(compositeKeyHash, SetCompositeKeyHash) }, skippableUpdate = materializerOf(modifier), content = content )}// androidx.compose.runtime.LayoutKt@Composable @ExplicitGroupsComposableinline fun &lt;T, reified E : Applier&lt;*&gt;&gt; ReusableComposeNode( noinline factory: () -&gt; T, update: @DisallowComposableCalls Updater&lt;T&gt;.() -&gt; Unit, noinline skippableUpdate: @Composable SkippableUpdater&lt;T&gt;.() -&gt; Unit, content: @Composable () -&gt; Unit) { if (currentComposer.applier !is E) invalidApplier() currentComposer.startReusableNode() if (currentComposer.inserting) { currentComposer.createNode(factory) } else { currentComposer.useNode() } Updater&lt;T&gt;(currentComposer).update() SkippableUpdater&lt;T&gt;(currentComposer).skippableUpdate() currentComposer.startReplaceableGroup(0x7ab4aae9) content() currentComposer.endReplaceableGroup() currentComposer.endNode()} 看上面的源码，Column 是一个内联函数，也就是说在编译前 Column 函数里的内容也就是 Layout 直接被放到它被调用的位置。 而其中的 Layout 函数也是一个内联函数，也会做同样的操作，也就是 ReusableComposeNode 被放到调用 Column 的位置。 ReusableComposeNode 也是一个内联函数，最终还是 content 在原来的位置， 而 content 就是被传入的 compose 函数。 结论，也就是在编译前 把用户写的 Column 里内部代码直接放到 Column 的位置，进而说明 Column 后面跟的大括号是不存在的。也就是说重组作用域并不一定在大括号的范围内。 1234567891011@Composablefun RecomposeScopeDemo() { var count by remember { mutableStateOf(1) } System.out.println(&quot;Recompose 范围1&quot;) Column { System.out.println(&quot;Recompose 范围2&quot;) Text(count.toString(), Modifier.clickable {count = count + 1}) } System.out.println(&quot;Recompose 范围3&quot;)} 如上代码所示，点击文本会触发重组，而重组会打印那三条日志。 重组范围的不可控制，逻辑上想要重组的范围之外的内容因为重组也被调用，这就导致了性能的风险。大范围的 recompose 就造成了计算资源的浪费，大量计算花在了需求之外上面。 #2. 性能优化 123456789101112131415161718192021222324252627282930@Composablefun RecomposeScopeDemo() { var count by remember { mutableStateOf(1) } // 最外层日志 println(&quot;Recompose 范围1&quot;) Column { // 中间层日志 LogScope2() // 内层日志（和 count 绑定，必然会重组） LogScope3(count) { count++ } }}@Composablefun LogScope2() { println(&quot;Recompose 范围2&quot;) Text(&quot;固定文本，不依赖外部状态&quot;)}@Composablefun LogScope3(count: Int, onClick: () -&gt; Unit) { println(&quot;Recompose 范围3&quot;) Text( count.toString(), Modifier.clickable { onClick() } )} 上面的代码，在第一次组合时，会打印三条日志，但是在点击文本触发重组时，不会打印 Recompose 范围2 这条日志。 这是因为 LogScope3 依赖了 count 这个状态，而 LogScope2 没有依赖。虽然在重组时调用了 LogScope2 这个函数，但是这个函数里面的代码没有被执行。这是因为编译器插件在修改 compose 函数时，不只添加了参数 Composer，还给函数里面的代码添加了逻辑判断，判断函数里面的状态和上一次函数被调用时的是否一致，如果一致就是说显示内容不会改变，就会跳过这个函数的内部代码。 而 LogScope2 里根本就没有状态，所以除了初次组合，之后的重组都不会再执行里面的代码。 如果把 LogScope2 里代码做如下修改： 123456@Composablefun LogScope2() { val name by mutableStateOf(1) println(&quot;Recompose 范围2&quot;) Text(&quot;固定文本，不依赖外部状态 $name&quot;)} 这样，在点击文本时，也会打印该日志。因为 LogScope2 里有可被观测的状态了。 在前面说，当状态发生改变时触发重组，那如何判断状态改变呢？ 12345@StateFactoryMarkerfun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 通过上面源码可见，创建状态对象时默认使用 structuralEqualityPolicy策略，即 Kotlin 的 Structual Equality 结构性相等来判断的，即 kotlin 的 ==。 自定义类型 ==（结构相等）行为 要点/建议 data class 按主构造所有属性逐一比较 自动生成 equals/hashCode/copy，适合值语义 普通类（未重写 equals） 等同 ===（引用相等） 只有同一实例才为true 普通类（已重写 equals） 按你的实现逻辑 必须同时重写 hashCode；用于集合键/元素时尤为重要 123456789101112131415161718192021222324252627282930313233343536373839var data = Data(&quot;A&quot;)@Composablefun RecomposeScopeDemo() { var count by remember { mutableStateOf(1) } // 最外层日志 println(&quot;Recompose 范围1&quot;) Column { // 中间层日志 LogScope2(data) // 内层日志（和 count 绑定，必然会重组） LogScope3(count) { count++ data = Data(&quot;A&quot;) } }}@Composablefun LogScope2(data: Data) { println(&quot;Recompose 范围2&quot;) Text(&quot;data:${data.value}&quot;)}@Composablefun LogScope3(count: Int, onClick: () -&gt; Unit) { println(&quot;Recompose 范围3&quot;) Text( count.toString(), Modifier.clickable { onClick() } )}data class Data(val value: String) 上面的代码还是看 LogScope2 它依赖了外部状态 Data，该状态在文本点击的时候会被重新赋值一个新对象，但是其内部的值 value 在新旧对象中是一样的，符合自定义对象的结构性相等，如此 compose 判断，虽然状态对应的对象改变了，但是两个对象结构性相等，依然跳过 LogScope2 的内部代码。所以点击文本时不会打印 范围2 这条日志。 如果上面的代码大部分不动，只把数据类 Data 里的 value 属性的定义从 val 改为 var，即 data class Data(var value: String),点击文本时，又会打印 范围2 这条日志了。 这是因为当 Data 里的 value 使用 var 定义时，compose 认为 Data 是不可靠的类。 123456789101112131415161718192021222324252627282930313233343536373839404142// 改动1val data1 = Data(&quot;A&quot;)val data2 = Data(&quot;A&quot;)var data = data1@Composablefun RecomposeScopeDemo() { var count by remember { mutableStateOf(1) } // 最外层日志 println(&quot;Recompose 范围1&quot;) Column { // 中间层日志 LogScope2(data) // 内层日志（和 count 绑定，必然会重组） LogScope3(count) { count++ // 改动2 data = data2 } }}// 假设修改 user2.value = &quot;B&quot;@Composablefun LogScope2(data: Data) { println(&quot;Recompose 范围2&quot;) Text(&quot;data:${data.value}&quot;)}@Composablefun LogScope3(count: Int, onClick: () -&gt; Unit) { println(&quot;Recompose 范围3&quot;) Text( count.toString(), Modifier.clickable { onClick() } )}// 改动3data class Data(var value: String) 如上所示，Data 里的 value 使用 var 定义，并声明两个 data 对象 data1、data2，但是对象内容一致。LogScope2 依赖的状态data 赋初值为 data1，然后在文本点击时 data 赋值为 data2。此时点击文本， LogScope2 也会被重新调用，并执行内部逻辑，打印 范围2 日志。 假设，如果认为 LogScope2 依赖的状态没有改变 （纯走结构化相等逻辑），也就不走内部逻辑，不打印 范围2 日志。此时是没有逻辑问题的。 但是如果在其它位置，修改了 data2 的 value 值，因为 data2 不是状态变量，不会触发重组。而 LogScope2 因为某个内部状态变更触发了自身的重组，那它显示的 data 内容是不改变的，因为它一直监听的 data1 对象 （虽然赋值 data2,但是没走内部逻辑，data2 没传入 LogScope2 里）。如此，就造成了逻辑上的错误，明明赋值了 data2，但是一直监听的 data1。 var 就意味着值可以被修改，也就意味着，现在两个对象是一样的，不代表未来也是一样的。因此内部的监测对象需要替换为最新的，否则会造成逻辑错误。 所以为了保证正确性， compose 只要判断出自定义对象里有属性使用了var 定义，即使结构化相等，也认为状态变更了，以此更新内部监测的对象。 这种 即使现在相等，但不能保证未来也一定相等的类型，就是不可靠类型。 val 就代表了不可修改，所以对象被创建出来后，里面的属性就不会再改变，也就是现在相等，未来也相等，这就是可靠的类型。 判断某个类型可靠/不可靠是 compose 自动行为。只要里面有 var 定义就判断为不可靠，有些简单粗暴。 #1. @Stable 注解 @Stable 注解是一个稳定性标记，可以放到某个类型上，通过这个注解告诉 compose 这个类型是可靠的，但是要由程序员保证可靠性。 让程序员保证可靠性有两种方法： 类型的实例在一个地方做了修改，要把结构性相等的实例做同样的修改，相当烦琐。 不再重写类型的equals 方法，默认使用的 Any.equals()，即只有同一个对象才相等。 也就是说上面的数据类最终可以改为如下形式： 1234567891011121314151617181920212223242526272829303132333435363738394041// 改动1var data = Data(&quot;A&quot;)@Composablefun RecomposeScopeDemo() { var count by remember { mutableStateOf(1) } // 最外层日志 println(&quot;Recompose 范围1&quot;) Column { // 中间层日志 LogScope2(data) // 内层日志（和 count 绑定，必然会重组） LogScope3(count) { count++ // 改动2 } }}// 假设修改 user2.value = &quot;B&quot;@Composablefun LogScope2(data: Data) { println(&quot;Recompose 范围2&quot;) Text(&quot;data:${data.value}&quot;)}@Composablefun LogScope3(count: Int, onClick: () -&gt; Unit) { println(&quot;Recompose 范围3&quot;) Text( count.toString(), Modifier.clickable { onClick() } )}// 改动3@Stableclass Data(var value: String) 上面做了三处改动，首先状态 data 不再赋值新对象，一直使用同一对象，其次 Data 类由 @Stable 修饰表示是可靠的，然后去掉了data 关键字，表示 Data 只是一个普通类，没有重写 equals 方法，那就会走 Any.equals() 也就是对象相等逻辑。 由此，文本点击时，不会打印 范围2 日志。而若把 @Stable注解去掉，还是会打印 范围2 日志，因为 Data 不可靠。 @Stable 的内部源码示例： 1234567// androidx.compose.runtime.MutableState@Stableinterface MutableState&lt;T&gt; : State&lt;T&gt; { override var value: T operator fun component1(): T operator fun component2(): (T) -&gt; Unit} compose 将 MutableState 接口定义为可靠的，可靠性由该接口的实现类去实现，比如 SnapshotMutableStateImpl 类每将 value 值改变时，就会通知每个使用 value 值的地方。 #2. 类型的公开属性加状态 可靠性： 现在相等就永远相等 当公开属性改变时，通知到用到这个属性的 Composition，也就是要触发重组，只要符合这条，compose 就认为符合稳定性要求。 公开属性要是自定义类型时，要保证自定义类型是可靠类型 为了保证第二条稳定性要求，类型可以写成如下形式： 123class Data(value: String) { var value by mutableStateOf(value)} 如上所示，类型里的所有公开属性，即使使用了 var 定义，但是这些属性有了状态，那 compose 也判断该类型是可靠的。注意必须所有的 var 的公开属性都要有状态，否则还是不可靠。 程序员推荐使用这种方式来辅助 compose 判断可靠性。 #3. 总结 保证稳定性有如下方式： 规范 合规要点 推荐实现/示例 反例/风险 现在相等就永远相等 equals/hashCode 只依赖不可变字段；避免把可变字段纳入判等，或者使用默认的 equals 方法，不重写 equals 方法，让对象相等性判断即 data class User(val id: Long, val name: String)；判等仅基于 id 等稳定标识 equals 依赖 var name；修改后集合键失效、稳定性被破坏 当公开属性改变时，必须通知到使用它的 Composition（触发重组） 用可观察状态包装：mutableStateOf、mutableStateListOf、StateFlow、LiveData + collectAsState var user by mutableStateOf(User(...))；更新：user = user.copy(name = &quot;Bob&quot;)；列表：mutableStateListOf() 直接改普通 var 或原地 list.add()；UI 不重组或重组不及时 公开属性为自定义类型时需&quot;可靠/稳定&quot; 类型稳定：data class、字段全为稳定类型且为 val；必要时 @Stable/@Immutable；正确 equals/hashCode @Immutable data class Profile(val id: Long, val tags: List&lt;String&gt;)（对外暴露只读 List） 暴露 MutableList、类型内部可变且泄露；未重写 equals/hashCode 简单总结 不要轻易重写equals 方法，也就是慎用 data class 使用 var 修饰的公开属性，要加状态进行包裹 如果使用特殊的方式实现自动通知，compose 无法自动判断是否可靠，要加注解 @Stable #九、derivedStateOf() #1. derivedStateOf: 将一个或多个状态对象转换为其他状态 官网：https://developer.android.com/develop/ui/compose/side-effects?hl=zh-cn#derivedstateof 当可组合项输入的变化频率超过您需要的重组频率时，就应该使用 derivedStateOf 函数。这种情况通常是指，某些内容（例如滚动位置）频繁变化，但可组合项只有在超过某个阈值时才需要对其做出响应。derivedStateOf 会创建一个新的 Compose 状态对象，您可以观察到该对象只会按照您的需要进行更新。 12345678910111213141516171819202122@Composablefun DerivedStateDemo(messages: List&lt;Message&gt;) { Box { val listState = rememberLazyListState() LazyColumn(state = listState) { // ... } // 知识点1 val showButton by remember { // 知识点2 derivedStateOf { listState.firstVisibleItemIndex &gt; 0 } } AnimatedVisibility(visible = showButton) { ScrollToTopButton() } }} 如上所示： 在上面代码段中，每当第一个可见项发生变化时，firstVisibleItemIndex 都会跟着发生变化。当滚动屏幕时，它的值会变为 0、1、2 等。但是，只有当值大于 0 时才需要进行重组。这种更新频率的不匹配意味着，这种情形很适合使用 derivedStateOf。 知识点1 , 使用 by remember{} 缓存 rememeber 大括号内的东西，只有在第一次组合时调用，后续重组时不再执行。 by 通过代理直接取值。 知识点2 , derivedStateOf， 它的参数是一个 Lambda 表达式，该函数用于返回一个 State 类型数据，lambda 的结果就是 State 对象包裹的数据。 lambda 里使用的其它状态改变时, lambda 会自动重新计算，从而使 State 的 value 更新。 #2. derivedStateOf 与 remember(key) 区别 12345678910111213141516171819@Composablefun DerivedVsRememberDemo() { var count by remember { mutableStateOf(0) } // 方式一：derivedStateOf（自动跟踪读取到的 state） val doubledByDerived by remember { derivedStateOf { count * 2 } } // 方式二：remember(key)（显式以 key 作为重算条件） val doubledByRemember = remember(count) { count * 2 } // 方式三：不带状态，直接在重组的时候进行计算 val doubleByNormal = count * 2 Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) { Text(&quot;count = $count&quot;) Text(&quot;derivedStateOf: $doubledByDerived&quot;) Text(&quot;remember(count): $doubledByRemember&quot;) Text(&quot;doubleByNormal: $doubleByNormal&quot;) Button(onClick = { count++ }) { Text(&quot;count +1&quot;) } }} 如上所示，这三种方法都会在 count 变化时得到同样的结果。 方法一，使用 derivedStateOf 方式，直接从状态 count 派生出了 doubleByDerived 状态，在按钮点击时，改变状态 count 值， derivedStateOf 因依赖了 count 状态，所以会重新计算，并刷新状态 doubledByDerived 的值，导致重组，重新调用重组作用域内的所有代码，从而显示了新值 方法二，使用 remember(key) 的方式，判断 count 是否改变，如果 count 改变才会执行 remember 内的 lambda 表达式，返回的是一个无状态的数值类型。但是因为 count 状态值变更了，导致重组作用域内所有代码重新执行，所以页面也刷新了 remember(count) 显示内容。 方法三，直接进行计算，不缓存也不派生对象，每次重组时都重新计算，而 count 状态变更，导致重组作用域所有代码都重新执行，此时 doubleByNormal 会计算出新值来，而下面的显示代码也被执行，从而使用了新值进行显示更新。 123456789101112131415161718192021@Composablefun DerivedVsRememberDemo2() { var count by remember { mutableStateOf(0) } ProcessCount(count) { count++ }}@Composablefun ProcessCount(count: Int, onClick: () -&gt; Unit) { // 方式一：derivedStateOf（自动跟踪读取到的 state） val doubledByDerived by remember { derivedStateOf { count * 2 } } // 方式二：remember(key)（显式以 key 作为重算条件） val doubledByRemember = remember(count) { count * 2 } Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) { Text(&quot;count = $count&quot;) Text(&quot;derivedStateOf: $doubledByDerived&quot;) Text(&quot;remember(count): $doubledByRemember&quot;) Button(onClick = onClick) { Text(&quot;count +1&quot;) } }} 在上面的代码中：点击，方法一不会进行计算，方法二可以正常计算。因为进入 ProcessCount 函数的 count 是没有状态的， derivedStateOf 没有办法去识别，而 remember 直接判断的 key 值本身的改变。 derivedStateOf、remember(key) 与&quot;重组时直接计算&quot;的区别与使用时机 项目 derivedStateOf remember(key) 重组时直接计算（无状态） 定义 从已存在的 State 派生出新 State（自动跟踪依赖） 按 key 缓存/重建值或对象，key 变才重算/重建 在重组时直接用 State 计算出普通值 重算触发 仅当计算体内&quot;读取到的 State&quot;变化，读取 State 的快照状态 仅当提供的 key 变化，只将 key 进行结构化比较 每次其所在 Composable 重组（通常因依赖的 State 变化） 输出 State（可被下游订阅） 普通值或对象（非 State） 普通值 典型用途 过滤/排序/格式化等派生值，缩小重组范围 重置内部状态、按入参重建控制器/昂贵对象 轻量、廉价的即时计算（如简单算术/拼接） 示例 val r by remember { derivedStateOf { items.value.filter { it.ok } } } val ctrl = remember(userId) { Controller(userId) } val doubled = count * 2 优点 依赖精确、按需重算；结果可下游独立订阅 语义清晰、控制重建时机；适合&quot;随 key 重置&quot; 实现最简单、无额外状态与记忆开销 注意事项 计算体内必须读取 State，否则不会更新 key 高频变化会频繁重建；对引用类型的内部元素变更无感（key 不变不重建） 昂贵计算会在每次重组重复；无法被下游单独订阅 不适用 入参不是 State 且只需偶尔重建 仅从 State 派生轻量值（此时优先 derivedStateOf） 需要复用结果/多个下游独立订阅/需要精确控制重算 组合用法 remember(key) { derivedStateOf { compute(state, key) } } 与 derivedStateOf 搭配处理&quot;非 State 入参 + State 依赖&quot; 升级路径：若变慢或需订阅，再改为 remember(key) 或 derivedStateOf #3. dervedStateOf 与 remember(key) 综合使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 综合使用示例@Composablefun InvokeDemo() { // 试验1 val list = remember { mutableListOf(&quot;A&quot;, &quot;B&quot;) } // 试验2 val list2 = remember { mutableStateListOf(&quot;A&quot;, &quot;B&quot;) } // 试验3 var changeSign by remember { mutableStateOf(false) } val list3 = remember(changeSign) { if (changeSign) { mutableStateListOf(&quot;A&quot;, &quot;B&quot;) } else { mutableStateListOf(&quot;C&quot;, &quot;D&quot;) } } Button(onClick = { list.add(&quot;C&quot;) list2.add(&quot;C&quot;) changeSign = !changeSign }) { Text(&quot;change&quot;) } ComprehensiveDemo(list) ComprehensiveDemo(list2) ComprehensiveDemo2(list3) ComprehensiveDemo(list3)}@Composablefun ComprehensiveDemo(highPriorityKeywords: List&lt;String&gt; = listOf(&quot;E&quot;, &quot;F&quot;, &quot;D&quot;)) { val todoTasks = remember { mutableStateListOf&lt;String&gt;(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) } val highPriorityTasks by remember(highPriorityKeywords) { derivedStateOf { todoTasks.filter { highPriorityKeywords.any { keyword -&gt; it.contains(keyword) } } } } Box(Modifier.fillMaxSize()) { LazyColumn { items(items = highPriorityTasks) { /* ... */ } items(items = todoTasks) { /*...*/ } } }}@Composablefun ComprehensiveDemo2(highPriorityKeywords: List&lt;String&gt; = listOf(&quot;E&quot;, &quot;F&quot;, &quot;D&quot;)) { val todoTasks = remember { mutableStateListOf&lt;String&gt;(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) } val highPriorityTasks by remember { derivedStateOf { todoTasks.filter { highPriorityKeywords.any { keyword -&gt; it.contains(keyword) } } } } Box(Modifier.fillMaxSize()) { LazyColumn { items(items = highPriorityTasks) { /* ... */ } items(items = todoTasks) { /*...*/ } } }} 上面代码 ComprehensiveDemo 功能为：维护一个可变的待办列表 todoTasks，并基于关键字highPriorityKeywords 动态派生出高优先级列表 highPriorityTasks，列表变化时界面自动更新。界面用 LazyColumn 先展示高优先级任务，再展示全部任务。 derivedStateOf 的 lambda 里依赖的状态有两个： todoTasks、highPriorityKeywords。todoTasks 是有状态的对象，而 highPriorityKeywords 虽然是 List 类型，没有状态，但是外部可以传递 MutableStateList 类型，因为 List 是 MutabvleStateList 的父类。 所以 highPriorityKeywords 是否有状态，取决于外部调用 DerivedStateDemo2 时，传入的 highPriorityKeywords 是否有状态。为了保证 highPriorityKeywords 改变时一定会触发重算，必需要要传入有状态的列表。 上面三个试验，传入不同的参数，有不同的展示效果，具体见下表： 调用 初始 keywords 点击后 keywords remember 重建 derivedStateOf 重算 highPriorityTasks（前 → 后） ComprehensiveDemo(list) [“A”,“B”]（普通 MutableList） [“A”,“B”,“C”]（原地 add） 否（引用未变） 否（未读到 State） [“A”,“B”] → [“A”,“B”] ComprehensiveDemo(list2) [“A”,“B”]（SnapshotStateList） [“A”,“B”,“C”]（结构变更） 否（引用未变） 是（遍历读到状态列表） [“A”,“B”] → [“A”,“B”,“C”] ComprehensiveDemo2(list3) [“C”,“D”]（由 key 构造的新实例） [“A”,“B”]（切换为另一新实例） 否（无 key，记住了首次实例） 否（捕获旧实例） [“C”,“D”] → [“C”,“D”] ComprehensiveDemo(list3) [“C”,“D”] [“A”,“B”] 是（key 变更） 是（重建并计算） [“C”,“D”] → [“A”,“B”] #十、CompositionLocal CompositionLocal 顾名思义是组合的局部变量，是具有穿透函数的功能的局部变量。是 Jetpack Compose 的“环境/上下文注入”机制：在组合树中自上而下隐式传递数据，避免通过参数层层传递。 #1. 简单使用 1234567891011121314151617181920212223242526272829// 1) 定义data class AppUser(val name: String)val LocalUser = compositionLocalOf&lt;AppUser?&gt; { null }// 2) 提供@Composablefun App(user: AppUser, content: @Composable () -&gt; Unit) { CompositionLocalProvider(LocalUser provides user) { content() } // 代码1 LocalUser.current}// 3) 读取（任意子层级）@Composablefun Greeting() { val user = LocalUser.current Text(text = &quot;Hi, ${user?.name ?: &quot;Guest&quot;}&quot;)}// 4）示例@Composablefun InvokeDemo() { val user = AppUser(&quot;Lee&quot;) App(user) { Greeting() }} 如上所示： 首先，将想要传递的数据使用 compositionLocalOf 函数进行封装，封装为了个 CompositionLocal 类型的数据，并声明成一个顶级属性 (为了全局可用)，属性的名字前缀一般使用 local 方便标识这一类数据。当前示例想要传递 AppUser 数据。 然后，使用中缀函数 provides 来进行定义谁传递什么数据，它的等价写法是 LocalUser.provides(user) 接着，使用 CompositionLocalProvider 实现数据的隐式传递 最后，使用定义的那个顶级属性的 current 属性来获取要传递的数据，当前示例为 LocalUser.current 注意，在代码1 处的调用只是去取封装时的初始值，需要看赋默认值的逻辑是否有报错处理。当前示例只是返回一个 null。 123val LocalUser = compositionLocalOf&lt;AppUser?&gt; { error(&quot;没有提供值&quot;) }// 等价于val LocalUser = compositionLocalOf&lt;AppUser?&gt; { throw IllegalStateException(&quot;没有提供值&quot;) } 如上所示，如果是这样声明，则在作用范围外去调用 current 时，比如代码1处，应用会抛异常。 #2. 覆盖使用 12345678910111213141516171819202122232425262728@Composablefun OverrideDemo() { // 全局提供一个用户 val globalUser = AppUser(&quot;Lee&quot;) App(globalUser) { Column { // 使用全局提供的值 -&gt; &quot;Hi, Lee&quot; Greeting() // 在子树内局部覆写为另一个用户 CompositionLocalProvider(LocalUser provides AppUser(&quot;Tom&quot;)) { // 覆写生效 -&gt; &quot;Hi, Tom&quot; Greeting() // 还可以再次覆写 -&gt; &quot;Hi, Alice&quot; CompositionLocalProvider(LocalUser provides AppUser(&quot;Alice&quot;)) { Greeting() } // 回到上一层覆写 -&gt; 仍然是 &quot;Hi, Tom&quot; Greeting() } // 覆写作用域结束，恢复到全局 -&gt; &quot;Hi, Lee&quot; Greeting() } }} CompositionLocalProvider 是有作用范围的，子树内的 CompositionLocalProvider 会就近覆盖父层提供的值；离开该作用域后恢复上一层的值。 #3. compositionLocalOf 与 staticCompositionLocalOf 维度 compositionLocalOf staticCompositionLocalOf 适用场景考量/备注 读取跟踪 跟踪读取点 不跟踪读取点 影响重组范围 值变更时的重组 仅重组“实际读取它”的 Composable 重组该 Provider 之下的整棵子树 精准 vs 广域 读取开销 略高 较低 读取时是否记录依赖 变更开销 较低 较高 值变更频率高更适合前者 MutationPolicy 支持 SnapshotMutationPolicy 不支持 可用结构等价等策略控制重组 默认值 需提供安全默认值 需提供安全默认值 未提供时也能工作 典型用途 动态环境依赖（当前用户、A/B 开关、动态配置、日志/路由等） 主题 token、布局方向、密度等几乎不变的环境值 值是否“几乎不变” API 示例 val LocalX = compositionLocalOf&lt;T&gt; { default } val LocalX = staticCompositionLocalOf&lt;T&gt; { default } 定义方式 常见示例 自定义 LocalUser、LocalNavController、LocalLogger LocalTextStyle、LocalContentColor、LocalLayoutDirection、LocalDensity Material 多为 static 使用建议 值会变且希望小范围重组时使用 值很少变且全局常量化时使用 不要用它传高频业务状态（用 State/ViewModel） #4. 源码 12345678910111213141516// androidx.compose.runtime.CompositionLocal@Stablesealed class CompositionLocal&lt;T&gt;(defaultFactory: () -&gt; T) { internal open val defaultValueHolder: ValueHolder&lt;T&gt; = LazyValueHolder(defaultFactory) internal abstract fun updatedStateOf( value: ProvidedValue&lt;T&gt;, previous: ValueHolder&lt;T&gt;? ): ValueHolder&lt;T&gt; @OptIn(InternalComposeApi::class) inline val current: T @ReadOnlyComposable @Composable get() = currentComposer.consume(this)} 上面代码为 CompositionLocal 的源码，可以看到调用 current 属性时，get() 方法上有 @Composable 注解，也就是说调用 current 属性时必须要在 @Composable 函数内。 123456789// androidx.compose.runtime.CompositionLocal@Composable@OptIn(InternalComposeApi::class)@NonSkippableComposablefun CompositionLocalProvider(vararg values: ProvidedValue&lt;*&gt;, content: @Composable () -&gt; Unit) { currentComposer.startProviders(values) content() currentComposer.endProviders()} 上面代码为 CompositionLocalProvider 的源码，可以看到可以传入多个值的，而且可以很明显看到提供的值的作用范围就是传入的 @Composable 函数。 #5. 使用场景 主题与样式：颜色、排版、形状等 （Material 的 Local）*。 环境信息：LocalContext、LocalDensity、LocalLayoutDirection。 跨层级依赖：如日志通道、导航控制器、权限/配置等轻量依赖。 #示例1：系统提供的 MaterialTheme 12345678910111213141516171819202122232425262728//androidx.compose.material3.MaterialThemeKt@Composablefun MaterialTheme( colorScheme: ColorScheme = MaterialTheme.colorScheme, shapes: Shapes = MaterialTheme.shapes, typography: Typography = MaterialTheme.typography, content: @Composable () -&gt; Unit) { val rememberedColorScheme = remember { // Explicitly creating a new object here so we don't mutate the initial [colorScheme] // provided, and overwrite the values set in it. colorScheme.copy() }.apply { updateColorSchemeFrom(colorScheme) } val rippleIndication = rememberRipple() val selectionColors = rememberTextSelectionColors(rememberedColorScheme) CompositionLocalProvider( LocalColorScheme provides rememberedColorScheme, LocalIndication provides rippleIndication, LocalRippleTheme provides MaterialRippleTheme, LocalShapes provides shapes, LocalTextSelectionColors provides selectionColors, LocalTypography provides typography, ) { ProvideTextStyle(value = typography.bodyLarge, content = content) }} #示例2 ：组合式日志通道 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 1) 定义 Logger 与默认实现interface Logger { fun d(tag: String, msg: String) fun e(tag: String, msg: String, tr: Throwable? = null)}object NoOpLogger : Logger { override fun d(tag: String, msg: String) {} override fun e(tag: String, msg: String, tr: Throwable?) {}}class AndroidLogger : Logger { override fun d(tag: String, msg: String) = android.util.Log.d(tag, msg) override fun e(tag: String, msg: String, tr: Throwable?) = android.util.Log.e(tag, msg, tr)}// 2) 定义 CompositionLocal（日志一般较少变动，可用 staticCompositionLocalOf）val LocalLogger = staticCompositionLocalOf&lt;Logger&gt; { NoOpLogger }// 3) 在应用根部提供全局 Logger@Composablefun AppRoot(content: @Composable () -&gt; Unit) { val logger = remember { AndroidLogger() } CompositionLocalProvider(LocalLogger provides logger) { content() }}// 4) 任意子层级读取并使用@Composablefun SaveButton() { val logger = LocalLogger.current Button(onClick = { logger.d(&quot;SaveButton&quot;, &quot;clicked&quot;) // ...执行保存逻辑 }) { Text(&quot;保存&quot;) }}// 5) 在子树“局部覆写”为埋点 Logger（不影响外层）class AnalyticsLogger(private val send: (String, String) -&gt; Unit) : Logger { override fun d(tag: String, msg: String) = send(tag, msg) override fun e(tag: String, msg: String, tr: Throwable?) = send(tag, &quot;ERR: $msg&quot;)}@Composablefun AnalyticsScope(content: @Composable () -&gt; Unit) { val analyticsLogger = remember { AnalyticsLogger { tag, msg -&gt; // 发送到你的埋点/日志平台 // analytics.track(tag, msg) } } CompositionLocalProvider(LocalLogger provides analyticsLogger) { content() }}// 用法示例 1：在应用根部全局注入并使用class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AppRoot { Column(Modifier.padding(16.dp)) { Text(&quot;首页&quot;) Spacer(Modifier.height(8.dp)) SaveButton() // 点击时通过 LocalLogger 记录日志 } } } }}// 用法示例 2：在子树内局部覆写为埋点 Logger@Composablefun DetailScreen() { Column(Modifier.padding(16.dp)) { Text(&quot;详情页（局部埋点 Logger）&quot;) Spacer(Modifier.height(8.dp)) AnalyticsScope { // 此区域内的日志会走 AnalyticsLogger SaveButton() } }}// 用法示例 3：预览/测试中替换为自定义 TestLogger@Preview(showBackground = true)@Composablefun Preview_SaveButton() { val testLogger = object : Logger { override fun d(tag: String, msg: String) { println(&quot;D/$tag: $msg&quot;) } override fun e(tag: String, msg: String, tr: Throwable?) { println(&quot;E/$tag: $msg&quot;) } } CompositionLocalProvider(LocalLogger provides testLogger) { SaveButton() }} 上面的示例功能如下： 在 AppRoot 外层统一注入 AndroidLogger，日常直接用。 某些页面/组件内，用 AnalyticsScope 局部覆写，实现“日志通道”切换与叠加策略。 测试/预览时可提供 NoOpLogger 或自定义 TestLogger 收集输出。","link":"/2025/09/03/JetpackCompose%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/"},{"title":"Java成员方法执行顺序","text":"一、三个成员方法： 二、代码实例 三、结论 #一、三个成员方法： 普通初始化块：直接在类里写花括号，初始化块只在创建Java对象时隐式执行,而且在执行构造器之前执行。例子如下： 12345public class XXX { { //普通初始化块的可执行性代码 }} 静态初始化块：就是定义普通初始化块时使用了static修饰符，静态初始化块只在在类初始化阶段执行，而不是在创建对象时才执行，所以只会调用一次。例子如下： 12345public class XXX { static { //静态初始化块的可执行性代码 }} 构造方法：与类名同名的方法，，在创建Java对象时执行。例子如下: 12345public class A { A () { //构造方法的可执行性代码 }} #二、代码实例 1234567891011121314151617public class FatherClass { int value = 11; { value = 12; Log.d(&quot;Extends&quot;,&quot;普通初始化块-Father&quot;); } static { Log.d(&quot;Extends&quot;,&quot;静态初始化块-Father&quot;); } FatherClass () { Log.d(&quot;Extends&quot;,&quot;构造方法-Father&quot;); }} 1234567891011121314public class ChildClass extends FatherClass { { Log.d(&quot;Extends&quot;,&quot;普通初始化块-ChildClass&quot;); } static { Log.d(&quot;Extends&quot;,&quot;静态初始化块-ChildClass&quot;); } ChildClass() { Log.d(&quot;Extends&quot;,&quot;构造方法-ChildClass&quot;); }} 执行： 12ChildClass childClass = new ChildClass();Log.d(&quot;Extends&quot;,&quot;value值：&quot;+childClass.value); 输出结果为： 1234567D/Extends: 静态初始化块-FatherD/Extends: 静态初始化块-ChildClassD/Extends: 普通初始化块-FatherD/Extends: 构造方法-FatherD/Extends: 普通初始化块-ChildClassD/Extends: 构造方法-ChildClassD/Extends: value值：12 #三、结论 单个类执行顺序为：静态初始化块—&gt;普通初始化块—&gt;构造方法。但是静态初始化块只会执行一次。 继承父类后调用子类时执行顺序为：父类静态初始化块—&gt;子类静态初始化块—&gt;父类普通初始化块—&gt;父类构造方法—&gt;子类普通初始化块—&gt;子类构造方法。 关于普通赋值：普通初始化块、声明实例变量指定的默认值都可以是对象的初始化代码，执行顺序与代码中的排列顺序相同。如FatherClass中，先执行int value = 11;再执行了value = 12；所以value结果为12。若是将int value == 11;放于普通初始化块后，如 123456{ value = 12; Log.d(&quot;Extends&quot;,&quot;普通初始化块-Father&quot;);}int value = 11; 则value的值为11。 关于静态变量赋值：与普通赋值一致。 参考：https://www.cnblogs.com/wft1990/p/7998353.html https://blog.csdn.net/qq_34626097/article/details/83352293 https://blog.csdn.net/china_songlei/article/details/79696583","link":"/2020/05/31/Java%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"},{"title":"JetpackCompose学习系列四：与传统 View 系统的交互 和 自定义 View","text":"Compose 与 传统 View 的交互 Compose 里绘制自定义 View #Compose 与 传统 View 的交互 #Compose 里绘制自定义 View","link":"/2025/09/12/JetpackCompose%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/"},{"title":"Kotlin编程规范","text":"Kotlin 编码规范 配置开发环境 应用代码风格指导 使用代码检查 源代码组织 目录 文件名 文件组织 类 接口实现 重载方法 命名规则 包 类 方法 属性 幕后属性 取名的学问 格式化 缩进 空格 冒号 类的声明 修饰符顺序 注解 函数 表达式主体 属性 控制流 方法调用 链式方法调用 Lambda 尾随逗号 注释文档 避免冗余结构 Unit 返回类型 分号 字符串模板 使用语言特性 不可变性 默认值 类型别名 Lambda 的参数 Lambda 的返回值 具名参数 条件语句 if 和 when 可空 Boolean 值 循环 区间的循环 字符串 函数与属性 扩展函数 中缀函数 工厂函数 平台类型 作用域函数 库的编码规范 #Kotlin 编码规范 #配置开发环境 使用 Android Studio 提供的代码风格支持。 #应用代码风格指导 打开 Settings/Preferences | Editor | Code Style | Kotlin 点击 Set from… 选择 Kotlin style guide #使用代码检查 打开 Settings/Preferences | Editor | Inspections | General 勾选 Incorrect formatting inspection #源代码组织 #目录 在纯 Kotlin 项目中，目录结构遵循省略了公共根包的包结构。例如项目中的所有代码都位于 org.example.kotlin 包及其子包中，那么 org.example.kotlin 包的文件应该直接放在源代码根目录下，而 org.example.kotlin.network.socket 中的文件应该放在源代码根目录下的 network/socket 子目录中。 在 Java 和 Kotlin 混编项目中，Kotlin 源文件应与 Java 源文件位于同一根目录下，并遵循相同的目录结构：文件应存储在 package 声明对应的目录中。 #文件名 如果 Kotlin 文件包含单个类或接口，其文件名应与类名相同，并附加扩展名 .kt。 如果文件包含多个类，或仅包含顶级声明，请选择一个描述文件包含内容的名称，并相应地命名文件。 使用首字母大写的驼峰风格（也称为 Pascal 风格），例如 ProcessDeclarations.kt。 文件名应该描述文件中代码的作用。因此，您应该避免在文件名中使用无意义的词，比如叫 Util。 #文件组织 在可以文件大小保持合理（不超过几百行）的前提下，鼓励在同一个 Kotlin 源文件中放置在语义上彼此密切相关的多个声明（类、顶级函数或属性）。 当为一个类定义与该类的所有使用者相关的扩展函数时，将这些函数与该类本身放在同一个文件中。在定义仅对特定使用者有意义的扩展函数时，将它们放在该使用者的代码旁边。避免为了声明某个类的所有扩展而创建代码。 #类 类的内容应按以下顺序进行： 属性声明和初始化代码块 次级构造函数 方法声明 伴随对象 不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。 将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。 #接口实现 在实现一个接口时，实现成员的顺序应该与该接口定义的成员顺序相同（如果需要，还要添加用于实现的额外的私有方法） #重载方法 在类中总是将重载放在一起。 #命名规则 #包 包名称始终是小写的，并且不使用下划线 (org.example.project)。 通常不鼓励使用多词名称，但如果您确实需要使用多个词，可以将它们连接在一起或使用驼峰式 (org.example.myproject, org.example.myProject)。 #类 类和对象的名称以大写字母开头并使用驼峰风格： 12open class DeclarationProcessor { /*……*/ }object EmptyDeclarationProcessor : DeclarationProcessor() { /*……*/ } #方法 函数、属性与局部变量的名称以小写字母开头、使用驼峰风格而不使用下划线： 12fun processDeclarations() { /*...*/ }var declarationCount = 1 例外：用于创建类实例的工厂函数可以与抽象返回类型具有相同的名称： 123interface Foo { /*...*/ }class FooImpl : Foo { /*...*/ }fun Foo(): Foo { return FooImpl() } #属性 常量名称（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）应该使用大写、下划线分隔的名称 (蛇形命名法) 命名: 12const val MAX_COUNT = 8val USER_NAME_FIELD = &quot;UserName&quot; 保存具有行为或可变数据的对象的顶级属性或对象属性的名称应使用驼峰命名法： 1val mutableCollection: MutableSet&lt;String&gt; = HashSet() 持有单例对象引用的属性的名称可以使用与 object 声明相同的命名风格： 1val PersonComparator: Comparator&lt;Person&gt; = /*...*/ 对于枚举常量，可以使用大写、下划线分隔的名称 (蛇形命名法) ，也可使用首字母大写的常规驼峰名称，具体取决于用途。 1enum class Color { RED, GREEN } #幕后属性 如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀： 1234class VM { private val _count = mutableLiveData&lt;Int&gt;() val count: LiveData&lt;Int&gt; get() = _count} #取名的学问 类的名称通常是用来解释类是什么的名词或者名词短语：List、 PersonReader。 方法的名称通常是动词或动词短语，说明该方法做什么：close、 readPersons。 修改对象或者返回一个新对象的名称也应遵循建议。例如 sort 是对一个集合就地排序，而 sorted 是返回一个排序后的集合副本。 名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词 （Manager、Wrapper 等）。 当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（IOStream）； 而如果缩写更长一些，就只大写其首字母（XmlFormatter、 HttpInputStream）。 #格式化 #缩进 使用 4 个空格缩进。不要使用 tab。 对于大括号，将左大括号放在结构开始行的末尾，将右大括号放在与结构开始行水平对齐的单独一行上。 12345if (elements != null) { for (element in elements) { // ... }} #空格 在二元运算符周围放置空格 (a + b)。例外：不要在范围运算符周围放置空格 (0..i)。 不要在一元运算符两边放置空格 (a++)。 在控制流关键字（if、when、for 和 while）和相应的左括号之间放置空格。 不要在主构造函数声明、方法声明或方法调用中的左括号前放置空格。 123class A(val x: Int)fun foo(x: Int) { ... }fun bar() { foo(1) } 不要在 (, [ 之后或 ], ) 之前放置空格。 不要在 . 或 ?. 周围放置空格。 12foo.bar().filter { it &gt; 2 }.joinToString()foo?.bar() 在 // 之后加一个空格。 1// This is a comment 不要在用于指定泛型的尖括号周围放置空格。 1class Map&lt;K, V&gt; { ... } 不要在 :: 周围放置空格。 12Foo::classString::length 不要在可空类型标记 ? 之前放置空格 1var text: String? = null 作为一般规则，避免任何类型的水平对齐。将标识符重命名为具有不同长度的名称不应影响声明或任何用法的格式。 #冒号 在以下情况的 : 前加一个空格： 当它用于分隔类型和父类型时。 委托给父类构造函数或同一类的不同构造函数时 在匿名内部类 object 关键字之后 不要在分隔声明及其类型的 : 前放置空格。 在 : 后面总是放一个空格。 12345678abstract class Foo&lt;out T : Any&gt; : IFoo { abstract fun foo(a: Int): T}class FooImpl : Foo() { constructor(x: String) : this(x) { /*...*/ } val x = object : IFoo { /*...*/ }} #类的声明 主要构造函数参数较少的类可以写在一行中： 1class Person(id: Int, name: String) 具有较长声明的类应进行格式化，使主要构造函数中的每个参数位于单独的行中并缩进。此外，右括号应该换行。父类构造函数调用或实现接口列表应与右括号位于同一行： 12345class Person( id: Int, name: String, surname: String) : Human(id, name) { /*...*/ } 对于实现多个接口的类，要首先调用父类构造函数，然后每个接口应该位于不同的行： 123456class Person( id: Int, name: String, surname: String) : Human(id, name), KotlinMaker { /*...*/ } 对于超长父类型列表的类，在冒号后换行并水平对齐所有超类型名称： 1234567class MyFavouriteVeryLongClassHolder : MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ }} 当类头很长时，为了清楚地分开类头和主体，可以在类头后面放一个空行（如上例所示），或者将左花括号放在单独的一行上： 1234567class MyFavouriteVeryLongClassHolder : MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(), SomeOtherInterface, AndAnotherOne{ fun foo() { /*...*/ }} 对构造函数参数使用常规缩进（4 个空格）。这确保在主构造函数中声明的属性与在类主体中声明的属性具有相同的缩进。 #修饰符顺序 如果声明有多个修饰符，请始终按以下顺序放置它们： 12345678910111213141516public / protected / private / internalexpect / actualfinal / open / abstract / sealed / constexternaloverridelateinittailrecvarargsuspendinnerenum / annotation / fun // 修饰 `fun interface`companioninline / valueinfixoperatordata 除非你在编写库，否则请省略多余的修饰符（例如 public）。 #注解 将所有注解放在修饰符前： 12@Named(&quot;Foo&quot;)private val foo: Foo 将注解放在声明之前的单独行中，并使用相同的缩进： 12@Target(AnnotationTarget.PROPERTY)annotation class JsonExclude 不带参数的注解可以放在同一行： 12@JsonExclude @JvmFieldvar x: String 不带参数的单个注解可以与相应的声明放在同一行： 1@Test fun foo() { /*...*/ } #函数 如果函数签名不适合一行，请使用以下语法： 123456fun longMethodName( argument: ArgumentType = defaultValue, argument2: AnotherArgumentType,): ReturnType { // body} 对函数参数使用常规缩进（4 个空格），格式与构造函数参数一致。 对于主体由单个表达式组成的函数，建议使用表达式主体。 1234fun foo(): Int { // 不好 return 1}fun foo() = 1 // 很好 #表达式主体 如果函数的表达式主体与函数声明不在同一行，请将 = 放在第一行并将表达式主体缩进 4 个空格。 12fun f(x: String, y: String, z: String) = veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z) #属性 对于非常简单的只读属性，请考虑单行格式化： 1val isEmpty: Boolean get() = size == 0 对于更复杂的属性，始终将 get 和 set 关键字放在不同的行中并缩进 4 个空格： 12val foo: String get() { /*...*/ } 对于带有初始化的属性，如果初始化代码很长，则在 = 符号后换行并将初始化缩进 4 个空格： 12private val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCha #控制流 如果 if 或者 when 的条件语句是多行的，请始终使用 () 包围条件语句。条件语句的每个后续行相对语句开始缩进 4 个空格。将条件语句的右括号与左花括号放在单独的一行中，这有助于对齐条件和主体。 12345if (!component.isSyncing &amp;&amp; !hasAnyKotlinRuntimeInScope(module)) { return createKotlinNotConfiguredPanel(module)} 将 else, catch, finally 关键字以及 do-while 循环的 while 关键字放在与前面的大括号相同的行上： 1234567891011if (condition) { // body} else { // else part}try { // body} finally { // cleanup} 在一个 when 语句中，如果一个分支不止一行，请考虑用空行将它与相邻的 case 块分开： 123456789private fun parsePropertyValue(propName: String, token: Token) { when (token) { is Token.ValueToken -&gt; callback.visitValue(propName, token.value) Token.LBRACE -&gt; { // ... } }} 将短分支与条件放在同一行，不带大括号。 1234when (foo) { true -&gt; bar() // 很好 false -&gt; { baz() } // 不好} #方法调用 在长参数列表中，在左括号后换行。将参数缩进 4 个空格。将多个密切相关的参数分组在同一行中。在分隔参数名称和值的 = 周围放置空格。 12345drawSquare( x = 10, y = 10, width = 100, height = 100, fill = true) #链式方法调用 使用链式调用时，将 . 或 ?. 运算符放在一行的起始，并缩进 4 个空格： 1234val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace } 通常应该在链中的第一个调用之前换行，但如果不换行更有意义，也可以省略。 #Lambda 在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。 如果一个调用接受单个 lambda 表达式，应该尽可能使用大括号。 1list.filter { it &gt; 10 } 如果为 lambda 分配标签，请不要在标签和左花括号之间放置空格： 12345fun foo() { ints.forEach lit@{ // ... }} 在多行的 lambda 中声明参数名称时，将名称和箭头放在第一行，然后换行： 123appendCommaSeparated(properties) { prop -&gt; val propertyValue = prop.get(obj) // ...} 如果参数列表太长而无法放在一行中，请将箭头放在单独的一行中： 123456foo { context: Context, environment: Env -&gt; context.configureEnv(environment)} #尾随逗号 尾随逗号是一系列元素的最后一项之后的逗号符号： 12345class Person( val firstName: String, val lastName: String, val age: Int, // 尾随逗号) 使用尾随逗号有几个好处： 版本控制差异更清晰 — 因为所有的焦点都集中在更改的值上。 添加和重新排序元素变得容易 - 如果您操作元素，则无需添加或删除逗号。 简化代码生成。例如，对象初始值代码最后一个元素也可以有一个逗号。 尾随逗号完全是可选的 - 没有它们你的代码仍然可以工作。建议声明时使用尾随逗号，使用方自行决定是否使用。 #注释文档 对于较长的文档注释，请将开头 /** 放在单独的行上，并以 * 开始后续的每一行： 1234/** * 这是一条多行 * 文档注释。 */ 简短的注释可以放在一行中： 1/** 这是一条简短文档注释。 */ 避免使用 @param 和 @return 标签。将参数和返回值的描述直接合并到注释中，并在提及参数的任何地方添加指向参数的链接。仅当不适合流程的冗长描述时才使用@param 和 @return 12345678910111213// 不要:/** * 返回给定值的绝对值。 * @param 需要返回绝对值的数值。 * @return 绝对值。 */fun abs(number: Int): Int { /*...*/ }// 要这样：/** * 返回给定值 [number] 的绝对值 */fun abs(number: Int): Int { /*...*/ } #避免冗余结构 一般来说，如果 Kotlin 中的某个语法结构是可选的并且被 IDE 高亮提示为冗余，那么您应该在代码中省略它。不要为了 “清晰” 而在代码中留下不必要的句法元素。 #Unit 返回类型 如果函数返回 Unit，则应省略返回类型： 12fun foo() { // 这里不需要 &quot;: Unit&quot;} #分号 尽可能省略分号。 #字符串模板 将简单变量插入字符串模板时不要使用大括号。仅对较长的表达式使用大括号。 1println(&quot;$name has ${children.size} children&quot;) #使用语言特性 #不可变性 优先使用不可变数据，而不是可变数据。初始化后不需要修改的局部变量与属性，总是将其声明为 val 而不是 var。 总是使用不可变集合接口（Collection, List, Set, Map）来声明无需改变的集合。使用工厂函数创建集合实例时，尽可能返回不可变集合类型的函数： 1234567891011// 不好：使用可变集合类型作为无需改变的值fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) { ... }// 很好：使用不可变集合类型fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) { ... }// 不好：arrayListOf() 返回 ArrayList&lt;T&gt;，这是一个可变集合类型val allowedValues = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)// 很好：listOf() 返回 List&lt;T&gt;val allowedValues = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) #默认值 优先声明带有默认参数的函数而不是声明重载函数。 123456// 不好fun foo() = foo(&quot;a&quot;)fun foo(a: String) { /*...*/ }​// 很好fun foo(a: String = &quot;a&quot;) { /*...*/ } #类型别名 如果有一个在代码中多次用到的函数类型或者带有类型参数的类型，那么最好为它定义一个类型别名： 12typealias MouseClickHandler = (Any, MouseEvent) -&gt; Unittypealias PersonIndex = Map&lt;String, Person&gt; 不要使用私有类型别名避免名称冲突，请使用 import ... as ...。 #Lambda 的参数 在简短，非嵌套的 lambda 中，建议使用 it 约定而不是显式声明参数。在带参数的嵌套 lambda 中，始终显式声明参数。 #Lambda 的返回值 避免在 lambda 表达式中使用多个返回到标签。请考虑重新组织这样的 lambda 表达式使其只有单一退出点。 如果这无法做到或者不够清晰，请考虑将 lambda 表达式转换为匿名函数。 不要在 lambda 表达式的最后一条语句中使用返回到标签。 #具名参数 当一个方法接受多个相同的原生类型参数或者 Boolean 类型参数时，请使用具名参数语法，除非在上下文中的所有参数的含义都已绝对清楚。 1drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true) #条件语句 优先使用 try, if 和 when 的表达式形式。 12345678910111213141516171819// 不好if (x) return foo()else return bar()when(x) { 0 -&gt; return &quot;zero&quot; 1 -&gt; return &quot;one else -&gt; return &quot;others&quot;}// 很好return if (x) foo() else bar()return when(x) { 0 -&gt; &quot;zero&quot; 1 -&gt; &quot;one&quot; else -&gt; &quot;others&quot;} 以上优于： if (x) return foo() else return bar() when(x) { 0 -&gt; return “zero” else -&gt; return “nonzero” } #if 和 when 对于二元判断优先使用 if 而不是 when。如果有三个或更多选项，请优先使用 when。 12345678// 使用 ifif (x == null) ... else ...// 而不是 whenwhen (x) { null -&gt; // ... else -&gt; // ...} #可空 Boolean 值 如果需要在条件语句中用到可空的 Boolean, 使用 if (value == true) 或 if (value == false) 检查。 #循环 优先使用高阶函数（filter、map 等）而不是循环。例外：forEach（优先使用常规的 for 循环， 除非 forEach 的接收者是可空的或者 forEach 用做长调用链的一部分。） 当在使用多个高阶函数的复杂表达式与循环之间进行选择时，请了解每种情况下所执行操作的开销并且记得考虑性能因素。 #区间的循环 使用 until 函数在一个开区间上循环： 12for (i in 0..n - 1) { /*...*/ } // 不好for (i in 0 until n) { /*...*/ } // 很好 #字符串 优先使用字符串模板而不是字符串拼接。 优先使用多行字符串而不是将 \\n 转义序列嵌入到常规字符串字面值中。 如需在多行字符串中维护缩进，当生成的字符串不需要任何内部缩进时使用 trimIndent，而需要内部缩进时使用 trimMargin： 123456789101112131415161718println(&quot;&quot;&quot; Not trimmed text &quot;&quot;&quot; )println(&quot;&quot;&quot; Trimmed text &quot;&quot;&quot;.trimIndent() )val a = &quot;&quot;&quot;Trimmed to margin text: |if(a &gt; 1) { | return a |}&quot;&quot;&quot;.trimMargin()println(a) #函数与属性 在某些情况下，不带参数的函数可与只读属性互换。 虽然语义相似，但是在某种程度上有一些风格上的约定。 以下情况优先使用属性而不是函数： 不会抛异常 计算开销小（或者在首次运行时缓存） 如果对象状态没有改变，那么多次调用都会返回相同结果 #扩展函数 自由使用扩展函数。每当你有一个主要用于某个对象的函数时，可以考虑使其成为一个以该对象为接收者的扩展函数。为了尽量减少 API 污染，尽可能地限制扩展函数的可见性。根据需要，使用局部扩展函数、成员扩展函数或者具有私有可视性的顶层扩展函数。 #中缀函数 一个函数只有用于两个角色类似的对象时才将其声明为中缀函数。比如：and、to、zip。 不良示例如：add。 如果一个方法会改动其接收者，那么不要声明为中缀形式。 #工厂函数 如果为一个类声明一个工厂函数，那么不要让它与类自身同名。优先使用独特的名称，该名称能表明为何该工厂函数的行为与众不同。只有当确实没有特殊的语义时，才可以使用与该类相同的名称。 12345class Point(val x: Double, val y: Double) { companion object { fun fromPolar(angle: Double, radius: Double) = Point(...) }} 如果一个对象有多个重载的构造函数，它们并非调用不同的超类构造函数，并且不能简化为具有默认参数值的单个构造函数，那么优先用工厂函数取代这些重载的构造函数。 #平台类型 返回平台类型表达式的公有函数/方法必须显式声明其 Kotlin 类型： 1fun apiCall(): String = MyJavaApi.getProperty(&quot;name&quot;) 任何使用平台类型表达式初始化的属性（包级别或类级别）必须显式声明其 Kotlin 类型： 123class Person { val name: String = MyJavaApi.getProperty(&quot;name&quot;)} 使用平台类型表达式初始化的局部值可以有也可以没有类型声明： 1234fun main() { val name = MyJavaApi.getProperty(&quot;name&quot;) println(name)} #作用域函数 Kotlin 提供了一系列用来在给定对象上下文中执行代码块的函数：let、run、with、apply 以及 also。 关于不同情况下选择正确作用域函数的准则，请参考作用域函数。 #库的编码规范 在编写库时，建议遵循一组额外的规则以确保 API 的稳定性： 总是显式指定成员的可见性（以避免将声明意外暴露为公有 API ） 总是显式指定函数返回类型以及属性类型（以避免当实现改变时意外更改返回类型） 为所有公有成员提供 KDoc 注释，不需要任何新文档的覆盖成员除外 （以支持为该库生成文档）","link":"/2023/05/16/Kotlin%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"title":"JetpackCompose学习系列一：基本概念与传统 View 迁移","text":"一、前言 二、什么是 Jetpack Compose 核心理念 关键要素 优势 三、声明式 UI 1. 核心定义 2. 关键特性与优势 四、独立于平台与跨平台 1. KMP 2. Compose Multiplatform 3. 三者的关系 五、Jetpack Compose 的分包结构 1. compile 库 2. runtime 库 3. UI 库 4. animation 5. foundation 6. material/material3 7. 总结 六、一些传统组件的 Compose 平替 1. ImageView 2. TextView 3. FrameLayout 4. LinearLayout 5. RelativeLayout 6. ConstraintLayout 7. ScrollView 8. RecyclerView 9. Button 七、Modifier 经典方法 1. 内外边距 2. size、width、height 3. background 与 clip 4. click 监听 5. Modifier 总结 #一、前言 本文主要讲述Jetpack Compose 的基本概念及分包 Google 官网：https://developer.android.com/develop/ui/compose/documentation?hl=zh-cn #二、什么是 Jetpack Compose Jetpack Compose 是 Android 官方推出的现代声明式 UI 工具包，基于 Kotlin，用函数式与响应式模型来构建界面，不再使用 XML 布局，通过调用带有 @Composable 的函数描述 UI，数据变更时框架自动重组并更新界面。 #核心理念 声明式 UI: “描述是什么”而非“如何绘制”，让 UI 与状态天然同步。 可组合性: 通过小而可复用的 @Composable 函数组合出复杂界面。 状态驱动: 以状态为单一数据源 （如 remember/rememberSaveable），数据变化触发重组。 单向数据流: 降低副作用与耦合，便于测试与维护。 #关键要素 @Composable 函数: UI 的基本构建单元，可相互调用。 setContent(...): 在 Activity/Fragment 中作为 Compose 的入口。 Modifier: 用于布局、交互与装饰的可链式配置。 Material 设计: 原生支持 Material 3 主题与组件，轻松统一风格。 列表与动画: 提供高性能 LazyColumn 等列表与易用动画 API。 #优势 减少样板代码: 无需 XML 与 findViewById，代码更少更直观。 更高复用与可测试性: 小型可组合项易拆分、易复用、易测试。 与传统 View 互操作: 可在现有应用中渐进式采用 Compose。 生产力提升: 预览、热重载等工具链支持更高效的 UI 开发。 #三、声明式 UI #1. 核心定义 用“描述界面在某状态下应该长什么样”的方式构建 UI，将界面视为状态的纯函数：UI = f(state)。当状态变化时，框架自动计算差异并更新界面，而非手动操作控件树。 传统 Android 界面采用命令式更新：通过 findViewById() 手动操作各个 View（如 setText、addChild、setImageBitmap）。这易遗漏同步、产生竞态与异常，且视图越多维护复杂度越高。 声明式模型 （Compose） 以“数据描述界面”：状态变更时由框架“从概念上重生成”界面并自动应用差异，避免手动同步有状态视图树。与命令式的对比，不再通过 setText、addChild 等步骤性命令修改内部状态，改为重建/重组界面描述并由框架调度最小必要更新，减少同步与时序错误。 为控制性能成本，Compose 通过“重组”智能只更新必要部分，因此应将 UI 拆成小而可复用、无副作用的可组合项，配合单向数据流以最小化重组范围并提升可维护性。 #2. 关键特性与优势 状态驱动与单向数据流: 单一可信数据源驱动 UI，数据向下流动、事件向上冒泡。 可组合与可复用: 小而纯的组件组合出复杂界面，易于测试与维护。 差量更新机制: 通过重组/协调 （如 Compose 的重组、React 的协调） 只更新必要部分，兼顾性能。 优势: 降低样板与复杂度，减少状态错位与竞态，更易测试与主题化，提升迭代效率。 代价与实践: 需要合理拆分组件、提升纯度与最小副作用，做好状态提升与作用域管理，以获得更高效的重组/协调。 代表实现: Jetpack Compose、React、SwiftUI 等 #四、独立于平台与跨平台 Jetpack Compose 是独立于 Android 平台的，它里面的上层暴露给开发者使用的（各种类、接口、参数等等）都与 Android 无关，只有最底层真正绘制才与 Android 有关。类似的有 RecyclerView、ConstraintLayout、AppCompat 等库不依赖最新版 Android 。 独立平台的下一步就能很方便的跨平台。 我们思考一下， Jetpack Compose 的预览功能？它并非是在模拟器里实现的，而是直接在 Android Studio 里实现的功能，换句话说是在 Mac 平台 和 Windows 平台上实现了依赖 Android Studio 的 Jetpack Compose 的显示系统。 #1. KMP KMP 官网: https://kotlinlang.org/docs/multiplatform.html Kotlin Multiplatform (KMP) 是 Kotlin 官方提供的跨平台机制。 目标：写的业务逻辑 *（比如网络请求、数据存储、算法）*一次编写，多平台共享。 大概结构： 123456commonMain/ → 公共代码（Kotlin 编写，逻辑共享）androidMain/ → Android 特有实现iosMain/ → iOS 特有实现 这样，业务逻辑在 commonMain 写一次，平台差异化部分在各自 xxxMain 里补充。和 Flutter 很类似 其中，KMP 只负责逻辑共享，UI 还是各写各的 （Android 用 Compose，iOS 用 SwiftUI）。 #2. Compose Multiplatform 官网: https://www.jetbrains.com/compose-multiplatform/ Compose Multiplatform 由 JetBrains 与 Google 合作，把 Jetpack Compose 的技术扩展到 Android、iOS、Desktop、Web。 如此，就可以在 commonMain 里写 UI 代码，一套 UI 同时跑在多个端。 #3. 三者的关系 Jetpack Compose 是 Android 专属的现代 UI 框架。 KMP 是 Kotlin 提供的跨平台逻辑共享机制，不关心 UI。 Compose Multiplatform 是基于 KMP 之上扩展，把 UI 也跨平台复用。 #五、Jetpack Compose 的分包结构 官网：https://developer.android.com/jetpack/androidx/releases/compose?hl=zh-cn Compose 由 androidx 中的 7 个 Maven 组 ID 构成。每个组都包含一套特定用途的功能。 组 说明 compose.animation 在 Jetpack Compose 应用中构建动画，丰富用户体验。 compose.compiler 借助 Kotlin 编译器插件，转换 @Composable functions（可组合函数）并启用优化功能。 compose.foundation 使用现成可用的构建块编写 Jetpack Compose 应用，还可扩展 Foundation 以构建您自己的设计系统元素。 compose.material 使用现成可用的 Material Design 组件构建 Jetpack Compose UI。这是更高层级的 Compose 入口点，旨在提供与 www.material.io 上描述的组件一致的组件。 compose.material3 使用 Material Design 3（新一代 Material Design）组件构建 Jetpack Compose UI。Material 3 中包括了更新后的主题和组件，以及动态配色等 Material You 个性化功能，旨在与新的 Android 12 视觉风格和系统界面相得益彰。 compose.runtime Compose 编程模型和状态管理的基本构建块，以及 Compose 编译器插件的目标核心运行时。 compose.ui 与设备互动所需的 Compose UI 的基本组件，包括布局、绘图和输入。 Material 库 和 Material 3 库，这两个是 Material Design 的不同分支，Material 针对的是的Material 2规范。 可以将 Material 和 Material 3 这两个库视为同一个功能库。 分包是为了将来扩展方便。 #1. compile 库 用于编译 @Compose 函数，需要在 build.gradle 文件里做如下配置才可以启用： 1234567891011android { // ... buildFeatures { compose = true } composeOptions { kotlinCompilerExtensionVersion = &quot;1.5.1&quot; }} #2. runtime 库 包含整个 Compose 最底层的概念模型，比如：数据结构、状态转换机制等。State 就在这个库里。 #3. UI 库 提供 UI 相关最基础的功能，比如：测量、布局、绘制、触摸反馈等。所有的控件函数最终都会调用 Layout() 函数，该函数位于 UI 库。 #4. animation 基于 UI 实现的一系列动画。 #5. foundation 提供相对完整可用的 UI 体系，比如： Row、Image 等组件都在该库 #6. material/material3 实现了 Maerial Design 的一系列组件。 比如 Button 点击有水波纹效果等。 #7. 总结 compiler --&gt; runtime --&gt; UI --&gt; animation --&gt; foundation --&gt; material/material3 如上所示，从左到右，库是层层依赖的关系。 在各库组下还有诸多的库，一般来说，只需要引入与组名相同的包即可，该库就会有绝大部分功能，但是像测试等功能是不在该库内的。 123456789101112131415161718192021222324252627282930313233343536// compose 相关的一些库dependencies { // Compose BOM（替换 &lt;bom-version&gt; 为最新） def composeBom = platform(&quot;androidx.compose:compose-bom:&lt;bom-version&gt;&quot;) implementation composeBom androidTestImplementation composeBom implementation &quot;androidx.compose.ui:ui&quot; implementation &quot;androidx.compose.ui:ui-graphics&quot; implementation &quot;androidx.compose.ui:ui-tooling-preview&quot; implementation &quot;androidx.compose.foundation:foundation&quot; implementation &quot;androidx.compose.animation:animation&quot; implementation &quot;androidx.compose.runtime:runtime&quot; implementation &quot;androidx.compose.runtime:runtime-livedata&quot; implementation &quot;androidx.compose.material3:material3&quot; // 提供 material 的矢量图 implementation &quot;androidx.compose.material:material-icons-extended&quot; implementation &quot;androidx.activity:activity-compose:&lt;version&gt;&quot; implementation &quot;androidx.lifecycle:lifecycle-runtime-compose:&lt;version&gt;&quot; implementation &quot;androidx.lifecycle:lifecycle-viewmodel-compose:&lt;version&gt;&quot; implementation &quot;androidx.navigation:navigation-compose:&lt;version&gt;&quot; implementation &quot;androidx.constraintlayout:constraintlayout-compose:&lt;version&gt;&quot; implementation &quot;androidx.paging:paging-compose:&lt;version&gt;&quot; implementation &quot;io.coil-kt:coil-compose:&lt;version&gt;&quot; implementation &quot;androidx.hilt:hilt-navigation-compose:&lt;version&gt;&quot; implementation &quot;com.google.accompanist:accompanist-systemuicontroller:&lt;version&gt;&quot; debugImplementation &quot;androidx.compose.ui:ui-tooling&quot; // 提供预览功能 debugImplementation &quot;androidx.compose.ui:ui-test-manifest&quot; androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4&quot; } 比如 UI 库，只需要引入 androidx.compose.ui:ui 即可使用大部分功能，但是不包括一些 UI 测试、 UI 预览等功能。 androidx.compose.ui:ui-tooling 提供了预览功能，其中包括 UI 的预览，还有预览界面上的 交互按钮、部署按钮。它依赖 androidx.compose.ui:ui-tooling-preview 库，该库提供 UI 的预览。 `` 三条包引入原则： 写代码的时候，依赖 material(3)就够了；或者跳过 material 依赖 foundation 使用基本的 UI 样式 如果需要预览功能，需要添加 ui-tooling 库 如果需要 Material Design 的大量矢量图标，引入 material-icons-extended 库。material(3) 只有少部分矢量图标。 #六、一些传统组件的 Compose 平替 #1. ImageView 传统的 ImageView 对应 Compose 的 Image。 Image 最终调用的 Android 的 Canvas.drawBitmap()、Canvas.drawColor() 等最直接、省力的 API。 在 Jetpack Compose 里加载图片使用 Image 函数，它在大部分重载函数里有两个必传参数：painter、contentDescription。 contentDescription， 是语义化描述，用于无障碍功能。 painter，用于渲染图片，有如下三种方式可以获取 painter 对象： 加载本地资源 123456Image( painter = painterResource(id = R.drawable.ic_launcher_foreground), contentDescription = &quot;App Icon&quot;, modifier = Modifier.size(80.dp), contentScale = ContentScale.Crop) 使用 painter 加载Bitmap 12345678val imageBItmap = bitmap.asImageBitmap()Image( painter = BitmapPainter(imageBitmap), contentDescription = &quot;BitmapPainter 示例&quot;, modifier = Modifier.size(120.dp), contentScale = ContentScale.Fit ) 网络图片 加载网络图片需要引入三方库，Glide、Coil (Coroutine Image Loader) 都可。官方推荐 Coil，非面向 View 系统。 coil 官网：https://github.com/coil-kt/coil 123456Image( painter = rememberAsyncImagePainter(&quot;https://picsum.photos/300/300&quot;), contentDescription = &quot;网络图片&quot;, modifier = Modifier.fillMaxWidth(), contentScale = ContentScale.Crop) #2. TextView 传统的 TextView 对应 Compose 的 Text。 Text 最终调用的 Android 的 drawText()、drawTextRun() 等 API。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Composablefun TextExamples() { Column( modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp) ) { // 基础用法 Text(text = &quot;你好，Compose Text&quot;) // 自定义样式 Text( text = &quot;加粗/斜体/字号/颜色&quot;, fontSize = 18.sp, fontWeight = FontWeight.SemiBold, fontStyle = FontStyle.Italic, color = Color(0xFF1565C0) ) // 溢出省略号 Text( text = &quot;这是一段很长很长很长的文字，用于演示单行溢出省略号效果……&quot;, maxLines = 1, overflow = TextOverflow.Ellipsis ) // 居中对齐 Text( text = &quot;居中对齐文本&quot;, modifier = Modifier.fillMaxWidth(), textAlign = TextAlign.Center, style = MaterialTheme.typography.titleMedium ) // 行高与字间距 Text( text = &quot;行高与字间距示例\\n第二行内容&quot;, lineHeight = 24.sp, letterSpacing = 0.5.sp ) // 下划线 / 删除线 Text( text = &quot;下划线与删除线&quot;, textDecoration = TextDecoration.Underline + TextDecoration.LineThrough ) // 富文本（不同样式混排） Text( text = buildAnnotatedString { append(&quot;混合样式：&quot;) withStyle(SpanStyle(color = Color(0xFFD32F2F), fontWeight = FontWeight.Bold)) { append(&quot;红色加粗&quot;) } append(&quot; 与 &quot;) withStyle(SpanStyle(color = Color(0xFF388E3C), fontStyle = FontStyle.Italic)) { append(&quot;绿色斜体&quot;) } } ) }} #3. FrameLayout 对应 Box，用于一层层叠加的布局样式。下面是一个标题栏的示例。 123456789101112Box { Image( painter = painterResource(id = R.mipmap.icon_large), contentDescription = &quot;底层图片&quot; ) Text( text = &quot;上层文字&quot;, fontSize = 28.sp, color = color_333333, textAlign = TextAlign.Center )} #4. LinearLayout 对应 Column() 、Row()，线性排列的布局样式。一个是从上到下排列，一个是从左到右排列。底层使用的同一套逻辑，使用同一个布局函数，上层进行了拆分，方便使用。 1234567891011121314151617181920212223242526272829303132333435363738394041// Column: 从上到下的线性排列Column( modifier = Modifier .fillMaxWidth() .background(Color(0xFFF5F5F5)) .padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp), horizontalAlignment = Alignment.CenterHorizontally) { Image( painter = painterResource(id = R.drawable.ic_launcher_foreground), contentDescription = &quot;示例图片&quot;, modifier = Modifier.size(64.dp), contentScale = ContentScale.Crop ) Text(&quot;这是图片下方的文字&quot;)}// Row, 从左到右的线性排列。图片在左，文字在右Text(&quot;Row 示例&quot;, style = MaterialTheme.typography.titleMedium)Row( modifier = Modifier .fillMaxWidth() .background(Color(0xFFF5F5F5)) .padding(12.dp), horizontalArrangement = Arrangement.spacedBy(12.dp), verticalAlignment = Alignment.CenterVertically) { Image( painter = painterResource(id = R.drawable.ic_launcher_foreground), contentDescription = &quot;示例图片&quot;, modifier = Modifier.size(48.dp), contentScale = ContentScale.Crop ) Column(verticalArrangement = Arrangement.spacedBy(4.dp)) { Text(&quot;主标题&quot;) Text(&quot;副标题/描述&quot;, color = Color.Gray, fontSize = 12.sp) }} #5. RelativeLayout 对应的还是 Box，但是可以使用 Modifier 控制位置。比如下面的标题栏的示例 12345678910111213141516171819202122232425262728Box( modifier = modifier .fillMaxWidth() .height(TitleBar_Height)) { // 在 Box 里居中 Text( modifier = Modifier .align(Alignment.Center), text = &quot;标题&quot;, fontWeight = LightBoldWeight, fontSize = 28.sp, color = color_333333, textAlign = TextAlign.Center ) // 在 Box 里上下居中，左右在左边 Image( modifier = Modifier .fillMaxHeight() .padding(horizontal = 24.dp) .align(Alignment.CenterStart) .click { // 点击处理 }, painter = painterResource(id = R.mipmap.icon_back), contentDescription = &quot;返回按钮&quot; )} #6. ConstraintLayout 对应的是 ConstraintLayout，需要引入依赖 androidx.constraintlayout:constraintlayout-compose:1.0.1 官网： https://developer.android.com/develop/ui/compose/layouts/constraintlayout?hl=zh-cn 123456789101112131415161718192021222324252627282930313233343536373839404142434445ConstraintLayout(modifier = Modifier.fillMaxWidth()) { // 1. 先要创建 constaintLayout 认同的引用 val (titleRef, imageRef) = createRefs() // 2. 设置组件水平、垂直链， 非必要 createHorizontalChain(titleRef, imageRef, chainStyle = ChainStyle.Packed) Column( Modifier // 3. 使用引用，作为某个组件的名称，并进行位置上的定位 .constrainAs(titleRef) { start.linkTo(parent.start) end.linkTo(imageRef.start) // 紧贴 Image width = Dimension.fillToConstraints } ) { Text( modifier = Modifier .fillMaxWidth() .align(Alignment.Start), text = &quot;标题&quot;, maxLines = 2, textAlign = TextAlign.Start, overflow = TextOverflow.Ellipsis ) Spacer(modifier = Modifier.height(4.dp)) // 时间 Text( modifier = Modifier.align(Alignment.Start), text = ”时间“, maxLines = 1, overflow = TextOverflow.Ellipsis ) } Image(modifier = Modifier .constrainAs(imageRef) { end.linkTo(parent.end) // 紧贴父容器右边 start.linkTo(titleRef.end) top.linkTo(titleRef.top) bottom.linkTo(titleRef.bottom) } .padding(12.dp), painter = painterResource(id = R.mipmap.icon_arrow), contentDescription = &quot;返回按钮&quot;)} #7. ScrollView 可滑动、滚动的组件。可以在任意布局函数上添加一个 Modifier 的扩展函数 Modifier.verticalScroll()、Modifier.horizontalScroll()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Composablefun SimpleVerticalScroll() { Column( modifier = Modifier .height(180.dp) .fillMaxWidth() .verticalScroll(rememberScrollState()) // 直接内联 state .padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp) ) { repeat(30) { i -&gt; Box( modifier = Modifier .fillMaxWidth() .height(36.dp) .background(if (i % 2 == 0) Color(0xFFF3F6FF) else Color(0xFFF8F9FB)), contentAlignment = Alignment.CenterStart ) { Text(&quot;竖向项 #${i + 1}&quot;, modifier = Modifier.padding(horizontal = 8.dp)) } } }}@Composablefun SimpleHorizontalScroll() { Row( modifier = Modifier .fillMaxWidth() .height(80.dp) .horizontalScroll(rememberScrollState()) // 直接内联 state .padding(12.dp), horizontalArrangement = Arrangement.spacedBy(8.dp), verticalAlignment = Alignment.CenterVertically ) { repeat(20) { i -&gt; Box( modifier = Modifier .width(100.dp) .fillMaxHeight() .background(if (i % 2 == 0) Color(0xFFDFF5E6) else Color(0xFFE8F7FF)), contentAlignment = Alignment.Center ) { Text(&quot;卡片 #${i + 1}&quot;) } } }} #8. RecyclerView 对应 LazyColumn()、LazyRow()、LazyGrid 等。不需要 Adapter 、ViewHolder。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * 垂直方向的惰性列表（仅渲染可见项），适合长列表场景。 * 关键点： * - contentPadding：内容整体内边距 * - verticalArrangement：每个 item 之间的垂直间距 * - items(...)：按数据源逐项渲染；item { ... } 可插入头/尾等单个内容 * - 建议提供 key 提升复用效率（如 id 或唯一字符串） */@Composablefun LazyColumnDemo() { // 模拟数据源（真实项目中可来自 ViewModel） val data = (1..20).map { &quot;列表项 $it&quot; } LazyColumn( modifier = Modifier.fillMaxWidth(), contentPadding = PaddingValues(16.dp), // 列表整体上下左右的内边距 verticalArrangement = Arrangement.spacedBy(8.dp) // 每个 item 之间的垂直间距 ) { // 头部（可选） item { Text( text = &quot;— Header —&quot;, color = Color.Gray, fontSize = 12.sp, modifier = Modifier.padding(bottom = 8.dp) ) } // 使用 items 渲染数据；建议提供 key，避免位置变动导致重组开销 items( items = data, key = { it } // 这里用字符串本身作为 key；真实项目用稳定 id ) { item -&gt; Box( modifier = Modifier .fillMaxWidth() // 宽度占满父级 .height(48.dp) // 固定高度，利于复用与测量 .background(Color(0xFFEFEFEF)), contentAlignment = Alignment.CenterStart ) { Text( text = item, fontSize = 16.sp, modifier = Modifier.padding(horizontal = 12.dp) ) } } // 底部（可选） item { Text( text = &quot;— Footer —&quot;, color = Color.Gray, fontSize = 12.sp, modifier = Modifier.padding(top = 8.dp) ) } }}/** * 水平方向的惰性列表，常用于横向卡片滑动。 * 关键点： * - contentPadding：左右与上下的内边距 * - horizontalArrangement：每个 item 的水平间距 * - 固定 item 尺寸有利于性能与布局稳定 */@Composablefun LazyRowDemo() { val data = (1..20).map { &quot;卡片 $it&quot; } LazyRow( modifier = Modifier.fillMaxWidth(), contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp), horizontalArrangement = Arrangement.spacedBy(12.dp) // item 之间水平间距 ) { items( items = data, key = { it } ) { item -&gt; Box( modifier = Modifier .size(width = 120.dp, height = 72.dp) // 固定卡片大小 .background(Color(0xFFDDEBFF)), contentAlignment = Alignment.Center ) { Text(text = item) } } }}/** * 垂直方向的网格列表（惰性），适合宫格展示。 * 关键点： * - columns： * - GridCells.Fixed(列数)：固定列数 * - GridCells.Adaptive(minSize)：自适应列数（列宽不小于 minSize） * - aspectRatio(1f)：保持方形卡片 * - 为网格提供间距：verticalArrangement / horizontalArrangement */@Composablefun LazyVerticalGridDemo() { val data = (1..20).map { &quot;网格 $it&quot; } LazyVerticalGrid( columns = GridCells.Fixed(2), // 固定 2 列；也可用 GridCells.Adaptive(140.dp) modifier = Modifier .fillMaxWidth() .height(360.dp), // 指定可见高度，方便预览 contentPadding = PaddingValues(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp), // 行间距 horizontalArrangement = Arrangement.spacedBy(12.dp) // 列间距 ) { items( items = data, key = { it } ) { item -&gt; Box( modifier = Modifier .aspectRatio(1f) // 正方形卡片 .background(Color(0xFFFFF0D5)), contentAlignment = Alignment.Center ) { Text(text = item) } } }} #9. Button 对应 Button 函数，但是 Jetpack Compose 里的 Button 只有点击范围，具体的点击的内容，比如说文本，还需要再添加 Text 去填充。 123456789101112131415161718192021222324252627282930313233343536373839404142@Composablefun ButtonExamples() { Column( modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp) ) { // 基础按钮 Button(onClick = { /* TODO */ }) { Text(&quot;Button&quot;) } // 带图标按钮 Button(onClick = { /* TODO */ }) { Icon(Icons.Filled.Favorite, contentDescription = null) Spacer(Modifier.width(8.dp)) Text(&quot;Icon Button&quot;) } // 不同变体 ElevatedButton(onClick = { /* TODO */ }) { Text(&quot;ElevatedButton&quot;) } OutlinedButton(onClick = { /* TODO */ }) { Text(&quot;OutlinedButton&quot;) } TextButton(onClick = { /* TODO */ }) { Text(&quot;TextButton&quot;) } // 禁用 Button(onClick = { /* TODO */ }, enabled = false) { Text(&quot;Disabled&quot;) } // 自定义颜色与圆角、充满宽度 Button( onClick = { /* TODO */ }, modifier = Modifier.fillMaxWidth(), colors = ButtonDefaults.buttonColors( containerColor = Color(0xFF6366F1), contentColor = Color.White ), shape = MaterialTheme.shapes.medium ) { Text(&quot;Submit&quot;) } }} 注意，Button 也是使用了 Material3 设计规范，有自己的点击效果和内间距。 #七、Modifier 经典方法 #1. 内外边距 在 Android 传统 View 里，使用 margin 设置外边距，使用 padding 设置内间距。但是 Jetpack Compose 里有只有 padding。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Composablefun ModifierOrderDemo() { Column( modifier = Modifier .fillMaxWidth() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp) ) { // 一个灰色容器，方便观察内层红色背景与 padding 的关系 Box( modifier = Modifier .fillMaxWidth() .background(Color(0xFFEFEFEF)) .padding(12.dp) ) { // 情况 1：background 再 padding // 含义：红色背景绘制在“padding 之前”的区域上；padding 产生的空白区域不会被红色填充 Box( modifier = Modifier .background(Color.Red) .padding(16.dp) // 这层 padding 在背景“外面”，因此 padding 区域显示为灰色容器色 ) { Text( text = &quot;background -&gt; padding（红色不含四周 padding）&quot;, color = Color.White, modifier = Modifier.align(Alignment.CenterStart) ) } } Box( modifier = Modifier .fillMaxWidth() .background(Color(0xFFEFEFEF)) .padding(12.dp) ) { // 情况 2：padding 再 background // 含义：先腾出 padding 空间，再整体铺红色背景；红色将包含 padding 区域一起显示 Box( modifier = Modifier .padding(16.dp) .background(Color.Red) // 背景在最外层，覆盖到 padding 区域 ) { Text( text = &quot;padding -&gt; background（红色包含四周 padding）&quot;, color = Color.White, modifier = Modifier.align(Alignment.CenterStart) ) } } // 小结： // - background -&gt; padding：背景在内、padding 在外，padding 区域不被背景覆盖 // - padding -&gt; background：padding 在内、背景在外，背景覆盖包含 padding 区域 }} 说明： 可以使用 padding 来达到内间距、外间距的效果，只需调整调用顺序即可。 padding 可以理解为就是此时 View 的内间距，而 background 绘制此时 View 的背景色。 如此 先设置 padding，再设置 background，就是设置的 View 的内间距 先设置 background，再设置 padding，就是设置了 View 的外间距 使用 padding时，一定要注意 size、width 、height 等方法， padding 包含在尺寸里。 #2. size、width、height 使用 size 、width、height 来划定 View 的大小。注意，不添加尺寸方法时，默认值相当于传统 View 系统里的 wrap_content 传统 View（XML/视图） 含义 Compose 对应写法 备注/示例 match_parent（宽） 宽度占满父容器 Modifier.fillMaxWidth() 例：Modifier.fillMaxWidth() match_parent（高） 高度占满父容器 Modifier.fillMaxHeight() 例：Modifier.fillMaxHeight() match_parent（宽高） 宽高都占满父容器 Modifier.fillMaxSize() 例：Modifier.fillMaxSize() wrap_content（默认） 按内容测量大小 不加尺寸修饰符 / wrapContentSize() Compose 默认即“包裹内容” wrap_content（仅宽） 宽按内容，高不变 Modifier.wrapContentWidth() 亦有 wrapContentHeight()、wrapContentSize() 指定定值（dp） 固定尺寸 Modifier.width(XX.dp) / height(XX.dp) / size(XX.dp) 例：Modifier.size(48.dp) 最小/最大尺寸 约束尺寸范围 Modifier.sizeIn(minWidth=..., maxHeight=...) 例：Modifier.sizeIn(minWidth=80.dp) 必须尺寸 强制为指定值 Modifier.requiredWidth(...) / requiredHeight(...) / requiredSize(...) 忽略父约束的进一步缩小 LinearLayout + weight 按权重分配剩余空间 Modifier.weight(1f, fill = true) Row/Column 子项使用；fill=false 仅占内容 ConstraintLayout 的 match_constraint（0dp） 依约束拉伸填充 Compose ConstraintLayout：Dimension.fillToConstraints 需使用 Compose ConstraintLayout DSL 外边距 margin 与父/兄弟间距 父容器 padding 或 Spacer 例：父 padding(16.dp)；或 Spacer(Modifier.width(8.dp)) 内边距 padding 内容与边界内距 Modifier.padding(...) 与 background/clip 顺序相关 #3. background 与 clip background 方法，可以设置背景色，包括纯色和渐变色，还可以设置背景的形状，一般使用圆角矩形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Composablefun BackgroundExamples() { Column( modifier = Modifier .fillMaxWidth() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp) ) { // 1) 纯色背景 Box( modifier = Modifier .fillMaxWidth() .height(64.dp) .background(Color(0xFF2196F3)), contentAlignment = Alignment.Center ) { Text(&quot;纯色背景&quot;) } // 2) 渐变色背景（线性） Box( modifier = Modifier .fillMaxWidth() .height(64.dp) .background( brush = Brush.linearGradient( colors = listOf(Color(0xFF42A5F5), Color(0xFF7E57C2)) ) ), contentAlignment = Alignment.Center ) { Text(&quot;线性渐变背景&quot;) } // 3) 圆角矩形背景（纯色 + 圆角） Box( modifier = Modifier .fillMaxWidth() .height(64.dp) .background( color = Color(0xFF66BB6A), shape = RoundedCornerShape(12.dp) ) .padding(12.dp), // 便于观察圆角 contentAlignment = Alignment.Center ) { Text(&quot;圆角矩形背景&quot;) } }} clip 方法，顾名思义，就是对 View 进行裁剪，它有只有个参数：shape 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Composablefun ClipExamples() { Column( modifier = Modifier .fillMaxWidth() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp) ) { // 1) 圆形裁剪（常用于头像） Row( verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp) ) { Box( modifier = Modifier .size(72.dp) .clip(CircleShape) // 内容被裁成圆形 .background(Color(0xFFE3F2FD)) .border(2.dp, Color(0xFF2196F3), CircleShape), contentAlignment = Alignment.Center ) { Text(&quot;A&quot;) } // 如需图片裁剪为圆形 // 将 R.drawable.sample 替换为你的图片资源 Image( painter = painterResource(id = R.drawable.ic_launcher_foreground), contentDescription = null, contentScale = ContentScale.Crop, modifier = Modifier .size(72.dp) .clip(CircleShape) .border(2.dp, Color.White, CircleShape) ) } // 2) 圆角矩形裁剪（与 background 顺序对比） Row( horizontalArrangement = Arrangement.spacedBy(12.dp) ) { // 2.1 先 clip 再 background：背景和内容都会被裁圆角 Box( modifier = Modifier .size(120.dp, 64.dp) .clip(RoundedCornerShape(12.dp)) .background(Color(0xFF66BB6A)), contentAlignment = Alignment.Center ) { Text(&quot;clip -&gt; bg&quot;, color = Color.White) } // 2.2 仅圆角背景，不裁剪内容（比如内层溢出仍可能方形） Box( modifier = Modifier .size(120.dp, 64.dp) .background(Color(0xFF66BB6A), shape = RoundedCornerShape(12.dp)), contentAlignment = Alignment.Center ) { Text(&quot;bg(shape)&quot;, color = Color.White) } } // 3) 斜切角（CutCornerShape） Box( modifier = Modifier .size(160.dp, 64.dp) .clip(CutCornerShape(topStart = 16.dp, bottomEnd = 16.dp)) .background(Color(0xFFFFA726)), contentAlignment = Alignment.Center ) { Text(&quot;CutCornerShape&quot;, color = Color.White) } // 4) 自定义形状（GenericShape：三角形） val TriangleShape = GenericShape { size, _ -&gt; moveTo(0f, size.height) lineTo(size.width / 2f, 0f) lineTo(size.width, size.height) close() } Box( modifier = Modifier .size(120.dp) .clip(TriangleShape) .background(Color(0xFF7E57C2)), contentAlignment = Alignment.Center ) { Text(&quot;Triangle&quot;, color = Color.White) } }} 说明： 想让“背景与内容都被裁剪”：先 clip(shape) 再 background(...)。 只想要圆角背景但不裁剪内容：用 background(color, shape=...) 即可。 常见形状：CircleShape、RoundedCornerShape、CutCornerShape，复杂形状用 GenericShape。 #4. click 监听 与传统 View 体系的点击监听设置不同，要给 View 对象设置监听器。 @Compose函数是没有返回结果的，也就不存在能够进行设置的句柄。 一般组件的点击，使用 Modifier.clickable{} 方法，Button 组件的点击监听，使用组件自身的函数入参 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// padding 对 click 的影响@Composablefun ClickAreaOrderDemo() { Column( modifier = Modifier .fillMaxWidth() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp) ) { // 场景 A：padding → background → padding → clickable // 结论：命中区 = 内容 + 两层 padding（最大） // 说明：background 仅绘制，不改变命中区大小；clickable 之后不再扩大命中区 Box( modifier = Modifier .padding(30.dp) // 扩大外层尺寸 → 计入命中 .background(Color(0xFFFFEBEE)) // 仅绘制 → 不影响命中大小 .padding(8.dp) // 再次扩大尺寸 → 计入命中 .clickable { /* 点击触发 */ }, contentAlignment = Alignment.CenterStart ) { Text(&quot;A: 命中包含两层 padding&quot;, modifier = Modifier.padding(4.dp)) } // 场景 B：padding → clickable → background → padding // 结论：命中区 = 内容 + 第一层 padding // 说明：clickable 之后的 padding 仅视觉留白，不计入命中；background 仅绘制 Box( modifier = Modifier .padding(30.dp) // 计入命中 .clickable { /* 点击触发 */ } // 命中范围在此确定 .background(Color(0xFFE3F2FD)) // 仅绘制 → 不影响命中大小 .padding(8.dp), // 不计入命中（仅视觉留白） contentAlignment = Alignment.CenterStart ) { Text(&quot;B: 命中仅包含第一层 padding&quot;, modifier = Modifier.padding(4.dp)) } // 场景 C：size → padding → background → padding → clickable // 结论：命中区 = 固定尺寸 + 两层 padding // 说明：两次 padding 都在 clickable 之前，均会扩大命中区；background 仅绘制 Box( modifier = Modifier .size(80.dp) // 基础固定尺寸 → 计入命中 .padding(20.dp) // 扩大尺寸 → 计入命中 .background(Color(0xFFE8F5E9)) // 仅绘制 → 不影响命中大小 .padding(8.dp) // 再扩大尺寸 → 计入命中 .clickable { /* 点击触发 */ }, contentAlignment = Alignment.Center ) { Text(&quot;C: 命中为 80dp + 20dp + 8dp&quot;, modifier = Modifier.padding(4.dp)) } // 场景 D：size → padding → clickable // 结论：命中区 = 固定尺寸 + padding // 说明：clickable 之前的 padding 会扩大命中区 Box( modifier = Modifier .size(80.dp) // 基础固定尺寸 → 计入命中 .padding(20.dp) // 扩大尺寸 → 计入命中 .clickable { /* 点击触发 */ }, contentAlignment = Alignment.Center ) { Text(&quot;D: 命中为 80dp + 20dp&quot;, modifier = Modifier.padding(4.dp)) } // 场景 E：size → clickable → padding // 结论：命中区 = 固定尺寸（不包含 padding） // 说明：clickable 之后的 padding 仅视觉留白，不计入命中 Box( modifier = Modifier .size(80.dp) // 固定命中尺寸 .clickable { /* 点击触发 */ } // 命中范围在此锁定 .padding(20.dp), // 不计入命中（仅视觉留白） contentAlignment = Alignment.Center ) { Text(&quot;E: 命中为 80dp，不含 padding&quot;, modifier = Modifier.padding(4.dp)) } // 场景 F：clickable → padding // 结论：命中区 = 内容本体（不包含 padding） // 说明：padding 位于 clickable 之后，仅产生视觉留白 Box( modifier = Modifier .clickable { /* 点击触发 */ } // 命中范围在此确定 .padding(20.dp), // 不计入命中（仅视觉留白） contentAlignment = Alignment.Center ) { Text(&quot;F: 命中为内容本体，不含 padding&quot;, modifier = Modifier.padding(4.dp)) } // 场景 G：padding → clickable // 结论：命中区 = 内容 + padding // 说明：clickable 之前的 padding 会扩大命中区 Box( modifier = Modifier .padding(20.dp) // 扩大尺寸 → 计入命中 .clickable { /* 点击触发 */ }, contentAlignment = Alignment.Center ) { Text(&quot;G: 命中包含 padding&quot;, modifier = Modifier.padding(4.dp)) } }} 说明： clickable 函数应用了 Material3 的设计风格，点击会有水波纹效果。 clickable 与 padding / background / size 关系表 写法（同一条 Modifier 链） 命中区是否扩大 命中包含哪些 视觉表现 / 备注 padding → clickable ✅ 是 内容 + padding 常用来增大触点区域（推荐做法，比如小图标） clickable → padding ❌ 否 仅内容（不含 padding） padding 只会把内容往里缩，看起来像有空隙但点不到空隙 padding → background → padding → clickable ✅ 是 包含两层 padding background 只影响绘制，不改变大小，命中区仍然按外层 padding 扩大 padding → clickable → background → padding ✅ 是 仅第一层 padding clickable 锁定了命中区，之后的 padding 只是视觉留白 size / width / height / fillMax* → clickable ✅ 是 按指定尺寸（固定/拉伸后） 点击范围被“定死”为指定尺寸，即使内容更小 clickable → size / width / height / fillMax* ❌ 否 仍是原始内容大小 外层视觉变大但不可点，容易出现“背景比触点大”的错觉 父容器上的 padding（子项 clickable） ❌ 否 不包含父容器的 padding 父容器的 padding 相当于 外边距，对子项的点击无效 offset → clickable ❌ 否 仅内容，位置平移 点击范围随 offset 移动 clickable → offset ❌ 否 仅内容，位置平移 一样，offset 不会改变大小，只改变命中区位置 关系总结 padding 在前 → 点击范围扩大（常用来放大触点）。 padding 在后 → 只影响内容布局（不会扩大命中范围）。 size 在前 → 点击范围按指定大小。 size 在后 → 只是视觉效果，点击不变。 background 永远不影响命中区，它只是画出来。 #5. Modifier 总结 Modifier 可以被传递给几乎任何一个 @Compose函数里。 Modifier 的 调用顺序是敏感的，相同方法，不同调用顺序会导致不同的结果。 Modifier 对同一个函数多次调用，会依次执行。 Modifier 的方法都是 对调用方法时的组件 进行方法的应用。 所有 Modifier 的调用的方法，其实都是返回 Modifier 类型的 Modifier 的扩展函数。 通用的设置使用 Modifier，专项的设置用函数参数。比如，文本的颜色、字号大小等 Text 专属设置，可以直接通过 Text函数的入参进行设置，而背景色，间距等通用的，则需要 Modifier。","link":"/2025/08/23/JetpackCompose%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/"},{"title":"MediaPlayer 详解","text":"前言 一、支持媒体格式 1. 音频支持 2. 视频支持 3. 图片支持 4. 网络协议 二、常用方法 三、 状态转换 四、使用注意事项 1. 使用流媒体时准备方法使用prepareAsync() 2. 回收资源 3. setOnCompletionListener的使用 五、播放进度展示 SeekBar与MediaPlayer所需要方法 进度条展示步骤 1. 创建SeekBar 2. 添加进度条的改变监听器 3. 设置seekBar最大值 4. 更新进度条 #前言 MediaPlayer 是 Android 系统自带的播放器，支持播放各种常见媒体类型，包含了 Audio 和 Video 的播放功能，可以播放存储在应用资源（原始资源）内的媒体文件、文件系统中的独立文件或者通过网络连接获得的数据流中的音频或视频。 #一、支持媒体格式 下表介绍了 Android 平台中内置的媒体格式支持。括号中注明了不能保证在所有 Android 平台版本上均可用的编解码器，例如：（Android 3.0 及更高版本）。请注意，任何给定的移动设备均可能支持该表中未列出的其他格式或文件类型。 参考：https://developer.android.com/guide/topics/media/media-formats #1. 音频支持 格式/编解码器 编码器 解码器 详细信息 支持的文件类型/容器格式 AAC LC • • 支持单声道/立体声/5.0/5.1 内容，标准采样率为 8-48 kHz。 • 3GPP (.3gp) • MPEG-4（.mp4、.m4a） • ADTS 原始 AAC（.aac、在 Android 3.1 及更高版本中解码、在 Android 4.0 及更高版本中编码、不支持 ADIF） • MPEG-TS（.ts、不可查找、Android 3.0 及更高版本） HE-AACv1 (AAC+) •（Android 4.1 及更高版本） • HE-AACv2（增强型 AAC+） &nbsp; • 支持立体声/5.0/5.1 内容，标准采样率为 8-48 kHz。 AAC ELD（增强型低延迟 AAC） •（Android 4.1 及更高版本） •（Android 4.1 及更高版本） 支持单声道/立体声内容，标准采样率为 16-48 kHz AMR-NB • • 4.75-12.2 kbps，采样率为 8 kHz 3GPP (.3gp) AMR-WB • • 有 9 个比特率（介于 6.60-23.85 kbit/s 之间）可供选择，采样率为 16 kHz 3GPP (.3gp) FLAC •（Android 4.1 及更高版本） •（Android 3.1 及更高版本） 单声道 / 立体声（非多声道）。采样率最高可达 48 kHz（但对于输出为 44.1 kHz 的设备，则建议最高不超过 44.1 kHz，因为 48-44.1 kHz 的降采样器不包含低通滤波器）。建议使用 16 位；对于 24 位，不会应用任何抖动。 仅支持 FLAC (.flac) GSM &nbsp; • Android 支持在电话设备上进行 GSM 解码 GSM (.gsm) MIDI &nbsp; • MIDI 类型 0 和 1。DLS 版本 1 和 2。XMF 和 Mobile XMF。支持铃声格式 RTTTL/RTX、OTA 和 iMelody • 类型 0 和 1（.mid、.xmf、.mxmf） • RTTTL/RTX（.rtttl、.rtx） • OTA (.ota) • iMelody (.imy) MP3 &nbsp; • 单声道 / 立体声 8-320 Kbps 恒定 (CBR) 或可变比特率 (VBR) MP3 (.mp3) Opus •（Android 5.0 及更高版本） Matroska (.mkv) PCM/WAVE •（Android 4.1 及更高版本） • 8 位和 16 位线性 PCM（比特率最高可达到硬件上限）。以 8000、16000 和 44100 Hz 录制原始 PCM 所需的采样率。 WAVE (.wav) Vorbis &nbsp; • &nbsp; • Ogg (.ogg) • Matroska（.mkv、Android 4.0 及更高版本） #2. 视频支持 格式/编解码器 编码器 解码器 详细信息 支持的文件类型/容器格式 H.263 • • 对 H.263 的支持在 Android 7.0 及更高版本中并非必需 • 3GPP (.3gp) • MPEG-4 (.mp4) H.264 AVCBaseline&nbsp;Profile&nbsp;(BP) •（Android 3.0 及更高版本） • • 3GPP (.3gp) • MPEG-4 (.mp4) • MPEG-TS（.ts、仅限 AAC 音频、不可查找、Android 3.0 及更高版本） H.264 AVCMain&nbsp;Profile&nbsp;(MP) •（Android 6.0 及更高版本） • 解码器为必需项，编码器为推荐项。 H.265 HEVC •（Android 5.0 及更高版本） 适用于移动设备的 Main Profile Level 3 和适用于 Android TV 的 Main Profile Level 4.1 • MPEG-4 (.mp4) MPEG-4 SP &nbsp; • &nbsp; 3GPP (.3gp) VP8 •（Android 4.3 及更高版本） •（Android 2.3.3 及更高版本） 只能在 Android 4.0 及更高版本中流式传输 • WebM (.webm) • Matroska（.mkv、Android 4.0 及更高版本） VP9 •（Android 4.4 及更高版本） • WebM (.webm) • Matroska（.mkv、Android 4.0 及更高版本） #3. 图片支持 格式 / 编解码器 编码器 解码器 详细信息 支持的文件类型 / 容器格式 BMP • BMP (.bmp) GIF • GIF (.gif) JPEG • • 基准式 + 渐进式 JPEG (.jpg) PNG • • PNG (.png) WebP •（Android 4.0 及更高版本）无损、透明度、Android 4.2.1 及更高版本） •Android 4.0 及更高版本）无损、透明度、Android 4.2.1 及更高版本） WebP (.webp) HEIF •（Android 8.0 及更高版本） HEIF（.heic；.heif） #4. 网络协议 音频和视频播放支持以下网络协议： RTSP（RTP、SDP） HTTP/HTTPS 渐进式流式传输 HTTP/HTTPS 实时流式传输草案协议： 仅限 MPEG-2 TS 媒体文件 协议版本 3（Android 4.0 及更高版本） 协议版本 2 (Android 3.x) 在 Android 3.0 之前的版本中不支持 注意：Android 3.1 之前的版本不支持 HTTPS。 #二、常用方法 参考：https://developer.android.com/reference/android/media/MediaPlayer 返回结果 方法名 说明 static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder) 指定从Uri对应的资源文件中来装载文件，同时指定了SurfaceHolder对象并返回MediaPlyaer对象，不需要再调用准备方法。 static MediaPlayer create(Context context, int resid) 指定从资源ID对应的资源文件中来装载文件，并返回新创建的MediaPlyaer对象，不需要再调用准备方法。 static MediaPlayer create(Context context, Uri uri) 指定从Uri对应的资源文件中来装载文件，并返回新创建的MediaPlayer对象，不需要再调用准备方法。 int getCurrentPosition() 获取当前播放的位置，单位毫秒 int getDuration() 获取音频的时长，单位毫秒 int getVideoHeight() 获取视频的高度。 int getVideoWidth() 获取视频的宽度。 boolean isLooping() 判断MediaPlayer是否正在循环播放。 boolean isPlaying() 判断MediaPlayer是否正在播放。 void pause() 暂停播放。 void prepare() 准备播放（装载文件），调用此方法会使MediaPlayer进入Prepared状态。 void prepareAsync() 异步准备播放,需要与setOnPreparedListener联合使用 void release() 释放媒体资源。 void reset() 重置MediaPlayer进入IDLE状态。 void seekTo(int msec) 定位到指定的时间位置。 void setAudioStreamType(int streamtype) 设置音频流的类型。 void setDataSource(String path) 指定装载path路径所代表的文件。 void setDataSource(Context context, Uri uri, Map&lt;String, String headers) 指定装载uri所代表的文件。 void setDataSource(Context context, Uri uri) 指定装载uri所代表的文件。 void setDataSource(FileDescriptor fd, long offset, long length) 指定装载fd所代表的文件中从offset开始长度为length的文件内容。 void setDataSource(FileDescriptor fd) 指定装载fd所代表的文件。 void setDisplay(SurfaceHolder sh) 设置显示方式。 void setLooping(boolean looping) 设置是否循环播放。 void setNextMediaPlayer(MediaPlayer next) 设置当前流媒体播放完毕,下一个播放的MediaPlayer。 void setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener) 注册一个回调函数,在网络视频流缓冲变化时调用。 void setOnCompletionListener(MediaPlayer.OnCompletionListener listener) 为MediaPlayer的播放完成事件绑定事件监听器。 void setOnErrorListener(MediaPlayer.OnErrorListener listener) 为MediaPlayer的播放错误事件绑定事件监听器。 void setOnPreparedListener(MediaPlayer.OnPreparedListener listener) 当MediaPlayer已经准备完成时触发该监听器。 void setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener) 当MediaPlayer里一个定位操作完成时触发该监听器。 void setOnVideoSizeChangedListener(MediaPlayer.OnVideoSizeChangedListener listener) 注册一个用于监听视频大小改变的监听器。 void setScreenOnWhilePlaying(boolean screenOn) 设置是否使用SurfaceHolder来显示。 void setSurface(Surface surface) 设置Surface。 void setVideoScalingMode(int mode) 设置视频缩放的模式。 void setVolume(float leftVolume, float rightVolume) 设置播放器的音量。 void setWakeMode(Context context, int mode) 为MediaPlayer设置低级电源管理行为。 void start() 开始或恢复播放。 void stop() 停止播放。 #三、 状态转换 上面这张状态转换图清晰的列举了主要的方法的调用时序，每种方法只能在一些特定的状态下使用，如果MediaPlayer的状态不正确则会引发IllegalStateException异常。 Idle状态： 当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象就会处于idle状态。在处于Idle状态时，调用getCurrentPosition(), getDuration(), getVideoHeight(),getVideoWidth(),setAudioStreamType(int), setLooping(boolean), setVolume(float, float), pause(), start(), stop(), seekTo(int), prepare()或者 prepareAsync()方法都会出现相应错误。因为没有装裁资源嘛。 使用new()和调用reset()置成Idle状态有一个重要差别：当一个MediaPlayer对象刚被构建的时候，内部的播放引擎和对象的状态都没有改变，在这个时候调用以上的那些方法，框架将无法回调客户端程序注册的OnErrorListener.onError()方法，所以不会进入Error状态；但若这个MediaPlayer对象调用了reset()方法之后，再调用以上的那些方法，内部的播放引擎就会回调客户端程序注册的OnErrorListener.onError()方法，这时MediaPlayer会进入Error状态。 提示： 使用new操作符创建的MediaPlayer对象处于Idle状态，而那些通过重载的create()方法创建的MediaPlayer对象却不是处于Idle状态。如果成功调用了重载的create()方法，则MediaPlayer已经是prepared状态；若调用重载的create()方法失败，则MediaPlayer返回null。 End状态： 通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关资源。如果MediaPlayer进入了End状态，则不会再进入任何其他状态。 Initialized状态： MediaPlayer调用setDataSource()方法成功就进入Initialized状态，表示此时要播放的文件已经设置好了。 提示： 若当此MediaPlayer 不在Idle 的状态下，调用了setDataSource()方法，会抛出IllegalStateException异常。 Prepared状态： 载入资源成功之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的。其中，prepareAsync()方法需要与setOnPreparedListener配合使用。只有进入Prepared状态，才可以调用start()方法进行文件播放。 提示： 当MediaPlayer对象处于Prepared状态的时候，可以调整音频/视频的属性，如音量，播放时是否一直亮屏，循环播放等。 Preparing状态： 这个状态主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。 Started状态： 在 prepared状态下，就可以调用start()方法，这样MediaPlayer就处于Started状态，这表明MediaPlayer正在播放文件过程中。可以使用isPlaying()测试MediaPlayer是否处于了Started状态。如果播放完毕，而又设置了循环播放，则MediaPlayer仍然会处于Started状态。 Paused状态： Started状态下MediaPlayer调用pause()方法可以暂停MediaPlayer，从而进入Paused状态，MediaPlayer暂停后再次调用start()则可以继续MediaPlayer的播放，转到Started状态，暂停状态时可以调用seekTo()方法，且不会改变状态。 Stop状态： Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()或 prepare()回到先前的Prepared状态重新开始才可以。 PlaybackCompleted状态： 文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。 Error状态： 在一般情况下，由于种种原因一些播放控制操作可能会失败，如不支持的音频/视频格式，缺少隔行扫描的音频/视频，分辨率太高，流超时等原因，等等会触发会触发OnErrorListener.onError()事件，此时MediaPlayer会进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。 可以通过setOnErrorListener()设置监听器来监听MediaPlayer是否进入Error状态。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。 #四、使用注意事项 #1. 使用流媒体时准备方法使用prepareAsync() 使用start()播放流媒体之前，需要装载流媒体资源。这种情况应该使用prepareAsync()用异步的方式装载流媒体资源。因为流媒体资源的装载是会消耗系统资源的，在一些硬件不理想的设备上，如果使用prepare()同步的方式装载资源，可能会造成UI界面的卡顿，非常影响用户体验的。使用异步方式时，为了避免还没有装载完成就调用start()而报错的问题，需要绑定MediaPlayer.setOnPreparedListener()事件，它将在异步装载完成之后回调。异步装载还有一个好处就是避免装载超时引发ANR（Application Not Responding）错误。 1234567891011MediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setDataSource(UriPath);// 通过异步的方式装载媒体资源mediaPlayer.prepareAsync();mediaPlayer.setOnPreparedListener(new OnPreparedListener() { @Override public void onPrepared(MediaPlayer mp) { // 装载完毕回调 mediaPlayer.start(); }}); #2. 回收资源 使用完MediaPlayer需要回收资源。在使用完MediaPlayer，不要等待系统自动回收，最好是主动回收资源。 12345if (mediaPlayer != null) { mediaPlayer.stop(); mediaPlayer.release(); mediaPlayer = null;} #3. setOnCompletionListener的使用 setOnCompletionListener监听器在MediaPlayer播放完成后触发。但是，在使用prepareAsync()方法准备资源时出错也会调用该方法，可根据播放器总时长是否为0来判断是成功还是失败，即getDuration() == 0。 #五、播放进度展示 SeekBar可以用来显示播放进度，用户也可以利用SeekBar的滑块来控制音乐的播放。 #SeekBar与MediaPlayer所需要方法 SeekBar: setProgress（int value）：设置滑块中心的位置。 setMax(int value)：设置进度条的最大长度,可以设置为播放器的总时长，这样seeKTo时不需要再转换。 setOnSeekBarChangeListener(OnSeekBarChangeListener l)：设置SeekBar的进度改变监听器。 MediaPlayer: getDuration()：获得音乐长度,单位毫秒。 getCurrentPosition()：获得现在播放的位置，单位毫秒。 seekTo(int msec)：调用seekTo()方法可以调整播放的位置。 #进度条展示步骤 #1. 创建SeekBar 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:minWidth=&quot;29dp&quot; android:textColor=&quot;#FF999999&quot; android:textSize=&quot;11sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:text=&quot;06:52&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;--:--&quot; android:textColor=&quot;#FF999999&quot; android:textSize=&quot;11sp&quot; android:minWidth=&quot;29dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:text=&quot;06:52&quot; /&gt; &lt;SeekBar android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:max=&quot;0&quot; android:maxHeight=&quot;2dp&quot; android:paddingStart=&quot;9dp&quot; android:paddingEnd=&quot;9dp&quot; android:progressDrawable=&quot;@drawable/seekbar_style_audio_work_detail&quot; android:splitTrack=&quot;false&quot; android:thumb=&quot;@mipmap/ico_audio_work_seek_dot&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toRightOf=&quot;@id/audio_tv_current_duration&quot; app:layout_constraintRight_toLeftOf=&quot;@id/audio_tv_total_duration&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 注意： 若滑块与进度条之间有间隔，则需要添加属性android:splitTrack=&quot;false&quot;。 若要设置SeekBar左右间距则必须使用android:paddingStart和android:paddingEnd。 #2. 添加进度条的改变监听器 12345678910111213141516mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { } @Override public void onStartTrackingTouch(SeekBar seekBar) { stopAudioProgressSync(); } @Override public void onStopTrackingTouch(SeekBar seekBar) { MediaPlayer.seekTo(seekBar.getProgress()); }}); 说明： onProgressChanged (SeekBar seekBar, int progress, boolean fromUser) * 进度已经被修改。客户端可以使用fromUser参数区分用户触发的改变还是编程触发的改变 * progress 当前的进度值。此值的取值范围为0到max之间。Max为用户通过setMax(int)设置的值，默认为100 * fromUser 如果是用户触发的改变则返回True onStartTrackingTouch (SeekBar seekBar) * 通知用户已经开始一个触摸拖动手势。客户端可能需要使用这个来禁用seekbar的滑动功能，或是禁止进度条更新。 onStopTrackingTouch (SeekBar seekBar) * 通知用户触摸手势已经结束。户端可能需要使用这个来启用seekbar的滑动功能，或是再次开启进度条更新。 #3. 设置seekBar最大值 1mSeekBar.setMax(mediaPlayer.getDuration());//设置SeekBar的长度 注意: getDuration()方法要在prepare()方法成功之后，否则会出现Attempt to call getDuration without a valid mediaplayer异常 #4. 更新进度条 12345678910111213141516171819202122232425262728293031323334private DisposableObserver&lt;Long&gt; mAudioProgressSyncObserver;/** * 关闭音频进度更新计时器 */public void stopAudioProgressSync() { if (mAudioProgressSyncObserver != null) mAudioProgressSyncObserver.dispose();}/** * 打开音频进度更新计时器 */public void startAudioProgressSync() { stopAudioProgressSync(); mAudioProgressSyncObserver = Observable.interval(0, 500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribeWith(new DisposableObserver&lt;Long&gt;() { @Override public void onNext(Long count) { //如果当前是播放状态，则更新进度条及当前播放时间 } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } });}","link":"/2020/05/22/MediaPlayer%E8%AF%A6%E8%A7%A3/"},{"title":"MotionLayout 初体验一","text":"前言 使用 1. 添加依赖 2. 创建MotionLayout布局 3、属性说明： 1. 插值属性 2. 自定义属性 3. 其它MotionLayout属性 #前言 MotionLayout是一种布局类型，为ConstraintLayout子类，可以帮助管理应用程序中的运动和组件动画。 MotionLayout是为了弥合布局过渡和复杂运动处理之间的差距。可以根据功能将其视为具有TransitionManager和CoordinatorLayout混合特征的属性动画框架。 除了描述布局切换之间的过渡外（例如TransitionManager），MotionLayout还可以为任何属性设置动画（不仅是布局属性）。而且还支持可定位的过渡，这意味着可以根据某些条件（例如触摸输入）立即过渡到任何点，它支持触摸处理和关键帧。 注意： MotionLayout 将仅为其直接子级提供功能，不支持再深层嵌套的布局层次结构或 activity 转换。 MotionLayout是完全声明式的，即可以用XML完全描述一个复杂的过渡-不需要代码。 Android API 要大于等于14，即android4.0。 #使用 #1. 添加依赖 将ConstraintLayout2.0依赖项添加到应用程序的build.gradle文件中。 如果使用的是AndroidX，请添加以下依赖项： 123dependencies { implementation 'androidx.constraintlayout:constraintlayout:2.0.0-beta6'} 如果不使用 AndroidX，请添加以下支持库依赖项： 123dependencies { implementation 'com.android.support.constraint:constraint-layout:2.0.0-beta6'} 以下示例均为AndroidX版本 MotionLayout示意图如下： #2. 创建MotionLayout布局 MotionLayout是ConstraintLayout的子类，所以你可以将任何现有的ConstraintLayout换成MotionLayout,如下： 1234&lt;!-- before: ConstraintLayout --&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout .../&gt;&lt;!-- after: MotionLayout --&gt;&lt;androidx.constraintlayout.motion.widget.MotionLayout .../&gt; MotionLayout完整布局： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.motion.widget.MotionLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/motionLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layoutDescription=&quot;@xml/scene_01&quot; tools:showPaths=&quot;true&quot;&gt; &lt;View android:id=&quot;@+id/button&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:background=&quot;@color/colorAccent&quot; android:text=&quot;Button&quot; /&gt;&lt;/androidx.constraintlayout.motion.widget.MotionLayout&gt; 其中，app:layoutDescription属性引用一个MotionScene。MotionScene是XML资源文件，其中包含相应布局的所有运动描述。为了使布局信息与动作描述分开，每个动作都MotionLayout引用一个单独的MotionScene。请注意，MotionScene中的定义优先于布局文件中的任何类似定义。 完整MotionScene示例如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;MotionScene xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:motion=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;Transition motion:constraintSetStart=&quot;@+id/start&quot; motion:constraintSetEnd=&quot;@+id/end&quot; motion:duration=&quot;1000&quot;&gt; &lt;OnSwipe motion:touchAnchorId=&quot;@+id/button&quot; motion:touchAnchorSide=&quot;right&quot; motion:dragDirection=&quot;dragRight&quot; /&gt; &lt;/Transition&gt; &lt;ConstraintSet android:id=&quot;@+id/start&quot;&gt; &lt;Constraint android:id=&quot;@+id/button&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:layout_marginStart=&quot;8dp&quot; motion:layout_constraintBottom_toBottomOf=&quot;parent&quot; motion:layout_constraintStart_toStartOf=&quot;parent&quot; motion:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet android:id=&quot;@+id/end&quot;&gt; &lt;Constraint android:id=&quot;@+id/button&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:layout_marginEnd=&quot;8dp&quot; motion:layout_constraintBottom_toBottomOf=&quot;parent&quot; motion:layout_constraintEnd_toEndOf=&quot;parent&quot; motion:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/ConstraintSet&gt;&lt;/MotionScene&gt; #3、属性说明： &lt;Transition&gt; 包含了动作的基本定义。 motion:constraintSetStart和motion:constraintSetEnd对动作的端点引用。这些端点是在&lt;ConstraintSet&gt;中定义。 motion:duration 指定运动完成所需的毫秒数。 &lt;OnSwipe&gt; 可以让用户以触摸控制动作。 motion:touchAnchorId 指定可以滑动和拖动的视图。 motion:touchAnchorSide 表示我们正在从右侧拖动视图。 motion:dragDirection指拖动的进度方向。例如，这 motion:dragDirection=&quot;dragRight&quot;意味着随着向右拖动，进度会增加。 &lt;ConstraintSet&gt;可以在其中定义描述运动的各种约束。在以上示例中，ConstraintSet为动作的每个端点定义一个约束。这些端点垂直居中（通过 app:layout_constraintTop_toTopOf=&quot;parent&quot;和 app:layout_constraintBottom_toBottomOf=&quot;parent&quot;）。在水平方向上，端点在屏幕的最左侧和右侧。 有关MotionScene支持的各种元素的详细信息，请参见 MotionLayout示例。 #1. 插值属性 在MotionScene文件中，ConstraintSet元素可以包含在过渡期间内插的其他属性。除了位置和界限外，还通过以下方式插入以下属性MotionLayout： alpha visibility elevation rotation, rotationX, rotationY translationX, translationY, translationZ scaleX, scaleY #2. 自定义属性 在标签&lt;Constraint&gt;中，可以使用&lt;CustomAttribute&gt;标签为与位置或View属性相关的属性指定过渡。 123456&lt;Constraint android:id=&quot;@+id/button&quot; ...&gt; &lt;CustomAttribute motion:attributeName=&quot;backgroundColor&quot; motion:customColorValue=&quot;#D81B60&quot;/&gt;&lt;/Constraint&gt; 一个&lt;CustomAttribute&gt;标签包含它自己的两个属性： motion:attributeName，是必需的，并且必须有getter和setter方法匹配。 例如，backgroundColor由于我们的视图具有基础getBackgroundColor()和setBackgroundColor()方法，因此受支持。 另一个必须提供的属性基于值类型。从以下受支持的类型中进行选择： motion:customColorValue 用于颜色 motion:customIntegerValue 对于整数 motion:customFloatValue 用于浮点数 motion:customStringValue 对于字符串 motion:customDimension 尺寸，大小 motion:customBoolean 对于布尔 注意: 指定自定义属性时，必须在开始和结束元素中都定义端点值。 以上面例子为基础，将视图更改颜色作为其运动的一部分。给每个ConstrainSet标签添加一个CustomAttribute标签，如下： 1234567891011121314151617181920212223242526272829&lt;ConstraintSet android:id=&quot;@+id/start&quot;&gt; &lt;Constraint android:id=&quot;@+id/button&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:layout_marginStart=&quot;8dp&quot; motion:layout_constraintBottom_toBottomOf=&quot;parent&quot; motion:layout_constraintStart_toStartOf=&quot;parent&quot; motion:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;CustomAttribute motion:attributeName=&quot;backgroundColor&quot; motion:customColorValue=&quot;#D81B60&quot; /&gt; &lt;/Constraint&gt;&lt;/ConstraintSet&gt;&lt;ConstraintSet android:id=&quot;@+id/end&quot;&gt; &lt;Constraint android:id=&quot;@+id/button&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:layout_marginEnd=&quot;8dp&quot; motion:layout_constraintBottom_toBottomOf=&quot;parent&quot; motion:layout_constraintEnd_toEndOf=&quot;parent&quot; motion:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;CustomAttribute motion:attributeName=&quot;backgroundColor&quot; motion:customColorValue=&quot;#9999FF&quot; /&gt; &lt;/Constraint&gt;&lt;/ConstraintSet&gt; #3. 其它MotionLayout属性 除了上面示例中的MotionLayout属性外，还可以设置其他属性： app:applyMotionScene=&quot;boolean&quot;是否应用MotionScene。此属性的默认值为true。 app:showPaths=&quot;boolean&quot;是否在动作运行时显示运动路径。此属性的默认值为false。 app:progress=&quot;float&quot;可以明确指定过渡进度。可以使用从0（转换开始）到1 （转换结束）的任何浮点值。 app:currentState=&quot;reference&quot;可以指定特定的ConstraintSet。 app:motionDebug可以显示有关动作的其他调试信息。值可为“ SHOW_PROGRESS”，“ SHOW_PATH”或“ SHOW_ALL”。 参考： https://developer.android.com/reference/androidx/constraintlayout/motion/widget/MotionLayout https://developer.android.com/training/constraint-layout/motionlayout#androidx 使用MotionLayout对Android Apps进行动画处理（codelab）","link":"/2020/06/01/MotionLayout%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B8%80/"},{"title":"android.support迁移到androidX","text":"一、前言 二、替换成androidx后遇到的问题 1. 对findViewById的引用不明确 2. v4jar包keyeventcompat不存在 3. ERROR: [TAG] Failed to resolve variable ‘${junit.version}’ 4. Error:error: resource previously defined here. #一、前言 Google 2018 IO 大会推出了 Android新的扩展库 AndroidX，用于替换原来的 Android扩展库，将原来的android.替换成androidx.；只有包名和Maven工件名受到影响，原来的类名，方法名和字段名不会更改。官方早就推荐将support库迁移到androidx，因为后续support库不会再做更新。 迁移时只需要3.2版本及以上的android studio，在菜单refactor中点击migrate to androidx即可，该向导会提示需要做的更新。其中包括gradle版本至少3.2以上，compileSdkVersion 版本28以上。 1. 常用依赖库对比 Old build artifact AndroidX build artifact com.android.support:appcompat-v7:28.0.2 androidx.appcompat:appcompat:1.0.0 com.android.support:design:28.0.2 com.google.android.material:material:1.0.0 com.android.support:support-v4:28.0.2 androidx.legacy:legacy-support-v4:1.0.0 com.android.support:recyclerview-v7:28.0.2 androidx.recyclerview:recyclerview:1.0.0 com.android.support.constraint:constraint-layout:1.1.2 androidx.constraintlayout:constraintlayout:1.1.2 2. 常用支持库类对比 Support Library class AndroidX class android.support.v4.app.Fragment androidx.fragment.app.Fragment android.support.v4.app.FragmentActivity androidx.fragment.app.FragmentActivity android.support.v7.app.AppCompatActivity androidx.appcompat.app.AppCompatActivity android.support.v7.app.ActionBar androidx.appcompat.app.ActionBar android.support.v7.widget.RecyclerView androidx.recyclerview.widget.RecyclerView 了解androidX可以看这一篇:androidX了解一下 更多androidX详细内容看:官方文档 关于gradle低版本升级可以看这篇文章:https://blog.csdn.net/u013183608/article/details/89428563 #二、替换成androidx后遇到的问题 #1. 对findViewById的引用不明确 描述： Activity 中的方法 findViewById(int) 和 AppCompatActivity 中的方法 findViewById(int) 都匹配其中, T是类型变量:T扩展已在方法 findViewById(int)中声明的View 解决方法： compileSdkVersion不一致，应该进行统一 #2. v4jar包keyeventcompat不存在 描述： 错误: 找不到符号 符号: 类 KeyEventCompat 位置: 程序包 androidx.core.view 原因： KeyEventCompat类被取消了hasNoModifiers方法，而该方法已经被KeyEvent实现了 原代码： 12345if (KeyEventCompat.hasNoModifiers(event)) { handled = arrowScroll(FOCUS_FORWARD);} else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) { handled = arrowScroll(FOCUS_BACKWARD);} 修改后代码: 12345if (event.hasNoModifiers()) { handled = arrowScroll(FOCUS_FORWARD);} else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) { handled = arrowScroll(FOCUS_BACKWARD);} #3. ERROR: [TAG] Failed to resolve variable ‘${junit.version}’ 解决方法： file-&gt;Invalidate Caches / restart #4. Error:error: resource previously defined here. 原因： 自定义View时自定义属性使用了系统的属性名称 解决方案： 重命名自已定义的属性，以避免与系统的属性名称重复1234&lt;declare-styleable name=&quot;TestTextView&quot;&gt; &lt;attr name=&quot;text_color&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;text_size&quot; format=&quot;float&quot; /&gt;&lt;/declare-styleable&gt; 不对textColor进行重命名，直接引用系统的textColor，然后在xml里面使用 时，就不能使用自定义的命名空间了（例如：app:），得用使用原生的引用（android:）1234&lt;declare-styleable name=&quot;TestTextView&quot;&gt; &lt;attr name=&quot;textColor&quot;/&gt; &lt;attr name=&quot;textSize&quot;/&gt;&lt;/declare-styleable&gt;","link":"/2020/05/31/android-support%E8%BF%81%E7%A7%BB%E5%88%B0androidX/"},{"title":"fitSystemWindow沉浸状态栏与键盘冲突问题","text":"前言 问题分析 解决方案 #前言 在将状态栏改为沉浸时遇到了如下一个问题：fitsSystemWindows设置为true后，界面就无法全屏，因为顶部有一个状态栏高度的padding；不设置fitsSystemWindows，adjustResize模式无法用于沉浸全屏界面，导至输入框无法跟随键盘。 沉浸状态栏使用的工具：ImmersionBar #问题分析 fitSystemWindow 如果多个View设置了fitsSystemWindows=”true”,只有最外层view起作用，从最外层设置了fitsSystemWindows的view开始计算padding，如果在布局中不是最外层控件设置fitsSystemWindows=”true”, 那么设置的那个控件高度会多出一个状态栏高度。若有多个view设置了，因第一个view已经消耗掉insect，其他view设置了也会被系统忽略。 详细内容见全屏、沉浸式、fitSystemWindow使用及原理分析：全方位控制“沉浸式”的实现 键盘挡住输入框问题 方法一、在AndroidManifest.xml对应的Activity里添加windowSoftInputMode属性 adjustResize：调整activity主窗口的尺寸来为屏幕上的软键盘腾出空间 adjustPan：自动平移窗口的内容，使当前焦点永远不被键盘遮盖，让用户始终都能看到其输入的内容。只有关闭软键盘 才能看到因平移被遮盖的内容。 方法二、在布局最外层使用ScrollView 详细内容见android全屏／沉浸式状态栏下，各种键盘挡住输入框解决办法 #解决方案 去除fitSystemWindow，然后使用adjustResize以保证输入框跟随软键盘，所以现在只要解决一个问题：adjustResize在全屏时失效。 最后通过监听addOnGlobalLayoutListener在输入法弹出时改变rootView或DecorView的高度，使view高度=屏幕高度-输入法高度。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import android.app.Activity;import android.graphics.Rect;import android.os.Build;import android.view.View;import android.view.ViewGroup;import android.view.ViewTreeObserver;public class FullScreenInputWorkaround { // For more information, see https://code.google.com/p/android/issues/detail?id=5497 // To use this class, simply invoke assistActivity() on an Activity that already has its content view set. private static final String TAG = &quot;AndroidBug5497Workaround&quot;; public static FullScreenInputWorkaround assistActivity(Activity activity, View contentView, InputShowListener inputShowListener) { return new FullScreenInputWorkaround(activity, contentView, inputShowListener); } private Activity activity; private View mChildOfContent; private int usableHeightPrevious; private ViewGroup.LayoutParams layoutParams; private ViewTreeObserver.OnGlobalLayoutListener listener; private FullScreenInputWorkaround(Activity activity, View contentView, InputShowListener inputShowListener) { this.activity = activity; this.inputShowListener = inputShowListener; mChildOfContent = contentView; mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(listener = new ViewTreeObserver.OnGlobalLayoutListener() { public void onGlobalLayout() { possiblyResizeChildOfContent(); } }); layoutParams = mChildOfContent.getLayoutParams(); } private void possiblyResizeChildOfContent() { int usableHeightNow = computeUsableHeight(); if (usableHeightNow != usableHeightPrevious) { int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight(); int heightDifference = usableHeightSansKeyboard - usableHeightNow; if (heightDifference &gt; (usableHeightSansKeyboard / 4)) { // keyboard probably just became visible layoutParams.height = usableHeightSansKeyboard - heightDifference; if (inputShowListener != null) { inputShowListener.inputShow(true); } } else { // keyboard probably just became hidden layoutParams.height = usableHeightSansKeyboard; if (inputShowListener != null) { inputShowListener.inputShow(false); } } mChildOfContent.requestLayout(); usableHeightPrevious = usableHeightNow; } } private int computeUsableHeight() { Rect frame = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame); int statusBarHeight = frame.top; Rect r = new Rect(); mChildOfContent.getWindowVisibleDisplayFrame(r); //这个判断是为了解决19之后的版本在弹出软键盘时，键盘和推上去的布局（adjustResize）之间有黑色区域的问题 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { return (r.bottom - r.top) + statusBarHeight; } return (r.bottom - r.top); } public void finish() { if(mChildOfContent != null &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) { mChildOfContent.getViewTreeObserver().removeOnGlobalLayoutListener(listener); } } private InputShowListener inputShowListener; public interface InputShowListener { void inputShow(boolean show); }} 详细内容见Android全屏状态下弹出输入法adjustResize无效的修复方案及踩坑指南","link":"/2020/05/31/fitSystemWindow%E6%B2%89%E6%B5%B8%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8E%E9%94%AE%E7%9B%98%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"},{"title":"Recyclerview加载图片错位","text":"前言 问题产生原因 解决方案 一、设置占位图 1、直接在链式请求中加.placeholder()： 2、添加监听，在回调方法中设置： 二、设置TAG 三、在onViewRecycled方法中重置item的ImageView并取消网络请求 流程：在onBindViewHolder中发起加载请求，然后在view被回收时取消网络请求 #前言 使用recyclerView时遇到了图片错位的问题，这个问题网上已经讨论的很成熟，谨以此文章做个总结。 #问题产生原因 根本原因： 因为有ViewHolder的重用机制，每一个item在移出屏幕后都会被重新使用以节省资源，避免滑动卡顿。 场景A: 第一次进入页面，RecyclerView载入，不做任何触摸操作 Adapter经过onCreateViewHolder()创建当前显示给用户的N个ViewHolder对象，并且在onBind时启动了N条线程加载图片 N张图片全部加载完毕，并且显示到对应的ImageView上 控制屏幕向下滑动，前K个item离开屏幕可视区域，后K个item进入屏幕可视区域 前K个item被回收，重用到后K个item。后K个item显示的图片是前K个item的图片 开启了K条线程，加载后K张图片。等待几秒，后K个item显示的图片突然变成了正确的图片 经过细化分析可以看出：如果当前网络速度很快，第6个步骤的加载速度在1秒甚至0.5秒内，就会造成人眼看到的图片闪烁问题，后K个item的图片闪了一下变成了正确的图片。 场景B: 第一次进入页面，RecyclerView载入，不做任何触摸操作 Adapter经过onCreateViewHolder()创建当前显示给用户的N个ViewHolder对象，并且在onBind时启动了N条线程加载图片 结果N张图片全部加载完毕，并且显示到对应的ImageView上，但还有1张未加载完(假设是第一张图片未加载完) 控制屏幕向下滑动动，前K个item离开屏幕可视区域，后K个item进入屏幕可视区域 前K个item被回收，重用到后K个item。场景A的问题不再说，后K张图片加载完毕(看上去一切正常) 等待几秒，第一张图片终于加载完成，后K个item中的某一个突然从正确的图片(当前positon应 该显示的图片)变成不正确的图片(第一个item的图片) 以上过程是场景B，问题出在加载第一张图片的线程T，持有了item1的ImageView对象引用，而这张图片加载速度非常慢，直到item1已经被重用到后面item后，过了一段时间，线程T才把图片一加载出来，并设置到item1的ImageView上，然而线程T并不知道item1已经不存在且已复用成其他item，于是，图片发生错乱了。 场景C: 第一次进入页面，RecyclerView载入，不做任何触摸操作 Adapter经过onCreateViewHolder()创建当前显示给用户的N个ViewHolder对象，并且在onBind时启动了N条线程加载图片 忽略图片加载情况，直接向下滚动，再向上滚动，再向下滚动，来回操作 由于离开了屏幕的item是随机被回收并重用的，所以向下滚动时我们假设item1、item3被回收重用到item9、item10，item2、item4被回收重用到item11、item12 向上滚动时，item9、item12被回收重用到item1、item2，item10、item11被回收重用到item3、item4 多次上下滚动后，停下，最后发现某一个item的图片在不停变化，最后还不一定是正确的图片 以上过程是场景C，问题出现在ViewHolder的回收重用顺序是随机的，回收时会从离开屏幕范围的item中随机回收，并分配给新的item，来回操作数次，就会造成有多条加载不同图片的线程，持有同一个item的ImageView对象，造成最后在同一个item上图片变来变去，错乱更加严重。 #解决方案 #一、设置占位图 Glide有两种方法设置占位图 #1、直接在链式请求中加.placeholder()： 1234Glide.with(this) .load(picUrl) .placeholder(R.drawable.ic_loading) .into(holder.ivThumb) #2、添加监听，在回调方法中设置： 123456789101112131415Glide.with(mContext) .load(picUrl) .error(R.drawable.ic_loading) .into(new SimpleTarget&lt;GlideDrawable&gt;() { @Override public void onResourceReady(GlideDrawable glideDrawable, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) { holder.ivThumb.setImageDrawable(glideDrawable); } @Override public void onStart() { super.onStart(); holder.ivThumb.setImageResource(R.drawable.ic_loading); } }); #二、设置TAG 使用setTag（）方式。但是，Glide图片加载也是使用这个方法，所以需要使用setTag（key，value）方式进行设置，这种方式是不错的一种解决方式，注意取值的时候应该是getTag（key）这个方法，当异步请求回来的时候对比下tag是否一样，再判断是否显示图片,我使用的是position设置tag. 时间及事件梳理 开始-&gt;当前item1给ImageView打tag -&gt;当前item1发起网络请求 -&gt;异步处理网络请求 -&gt;当前item1滑出屏幕 -&gt;划出屏幕的item重用并滑进屏幕命名为item2 -&gt;item2重新给ImageView打上tag -&gt;item1的图片下载完成，因为重用的原因，图片将要加载给item2 -&gt;用原先传入的item1设置的tag和新覆盖的tag比较，发现不相同 -&gt;不给当前item2设置图片，避免了图片错位 代码 123456789101112131415161718192021@Overridepublic void onBindViewHolder(final VideoViewHolder holder, final int position) { holder.thumbView.setTag(R.id.tag_dynamic_list_thumb, position); Glide.with(mContext) .load(picUrl) .error(R.drawable.video_thumb_loading) .into(new SimpleTarget&lt;GlideDrawable&gt;() { @Override public void onResourceReady(GlideDrawable glideDrawable, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation { if (position != (Integer) holder.thumbView.getTag(R.id.tag_dynamic_list_thumb)) return; holder.thumbView.setImageDrawable(glideDrawable); } @Override public void onStart() { super.onStart(); holder.thumbView.setImageResource(R.drawable.ic_loading); } });} #三、在onViewRecycled方法中重置item的ImageView并取消网络请求 #流程：在onBindViewHolder中发起加载请求，然后在view被回收时取消网络请求 代码 123456789101112131415161718192021@Overridepublic void onBindViewHolder(VideoViewHolder holder, int position) { String istrurl = mImgList.get(position).getImageUrl(); if (null == holder || null == istrurl || istrurl.equals(&quot;&quot;)) { return; } Glide.with(mContext) .load(picUrl) .placeholder(R.drawable.ic_loading) .into(holder.thumbView);}@Overridepublic void onViewRecycled(VideoViewHolder holder) { if (holder != null) { Glide.clear(holder.thumbView); holder.thumbView.setImageResource(R.drawable.ic_loading); } super.onViewRecycled(holder);} 参考文章： https://blog.csdn.net/lililijunwhy/article/details/79869491 https://blog.csdn.net/qq_33808060/article/details/59116624 https://blog.csdn.net/life90/article/details/78884618","link":"/2020/05/31/Recyclerview%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E9%94%99%E4%BD%8D/"},{"title":"Kotlin学习系列一：内置类型","text":"一、前言 二、基本类型 1. Kotlin 与 java 基本类型对比 2. 变量声明 3. 类型推导 4. 无符号类型 5. 输出语句 6. 字符串比较 7. Raw String 三、数组 1. 数组创建 2. 数组长度 3. 数组读写 4. 数组遍历 1. java 中的 foreach 循环遍历 5. 数组的包含关系 四、区间 1. 区间创建 1. 闭区间 2. 半闭半开区间 3. 区间的步长 2. 区间的迭代与包含 3. 区间示例 五、集合 1. 集合的创建 1. 方法一：Kotlin特有方式 2. 方法二：使用Java中的实现类 2. 集合实现类复用与类型别名 3. 集合框架的操作 1. List列表 2. Map 4. Pair键值对 1. 创建 2. 获取对应元素 3. 解构 4. Triple 1. 创建 2. 获取对应元素 3. 解构 六、函数基本概念 1. 函数定义 2. 函数与方法关系 3. 函数类型 4. 函数的引用 5. 变长参数 6. 多返回值 7. 默认参数 8. 具名参数 七、示例 八、附录 #一、前言 本文主要讲述Kotlin 内置类型即本身已被Kotlin集成的类型 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin英文官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： Kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶--挂起函数 kotlin学习系列十一：协程应用 #二、基本类型 类型 大小 (bits) 最小值 最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-231) 2,147,483,647 (231 - 1) Long 64 -9,223,372,036,854,775,808 (-263) 9,223,372,036,854,775,807 (263 - 1) Float 32 —— —— Double 64 —— —— Boolean —— —— —— #1. Kotlin 与 java 基本类型对比 名称 Kotlin Java 字节 Byte byte/Byte 整型 Int &amp; Long int/Integer &amp; long/Long 浮点型 Float &amp; Double float/Float &amp; double/Double 字符 Char char/Character 字符串 String String #2. 变量声明 格式： 修饰符 变量名 [: 类型】 = 初始值 修饰符： val：声明只读变量，对应 java 里加了final修饰符的变量，只有get方法，没有set方法。 var：声明可读写变量。 Kotlin里的val a:Int = 2等同于Kotlin里的val a = 2等同于Java里的final int a = 2 #3. 类型推导 声明变量时可不加类型，Kotlin会根据初始化的值去自动匹配变量对应类型。 整型默认为Int，浮点型默认为Double。 变量声明为Long或Float时，要在初始值后加上L或F表示，其中L在一些字体中易与i混淆，所以不能用小写的l声明长整型变量。例如： 1234val a = 32//Int类型val b = 23.2//Double类型val c = 32L//Long类型val d = 23.2F//Float类型 数值类型转换时，必须要调用对应类型的转换函数，否则报错。例如 1234val e = 10val f:Long = e.toLong()val g:Int = f.toInt() #4. 无符号类型 名称 有符号类型 无符号类型 字节 Byte UByte 短整型 Short UShort 整型 Int UInt 长整型 Long ULong 字符串 String String 无符号类型的数值范围：有符号类型去掉负数部分，正数部分再乘以 2，即无符号类型变量不能赋值负数 #5. 输出语句 除支持java中用加号拼接字符串名，还支持在字符串内直接引用表达式的方式 格式： println(“内容 ${表达式}”) 例： 12val j = &quot;321&quot;println(&quot;Value of j is $j , j.length is ${j.length}&quot;) println等同于java中的System.out.println #6. 字符串比较 ==：比较字符串的内容，等同于Java里的equals语句 ===：比较字符串的引用，等同于Java里的== 123val a = &quot;32&quot;val b = &quot;32&quot;a == b 返回true, a === b 返回true #7. Raw String 123val 变量名 = &quot;&quot;&quot; 内容&quot;&quot;&quot;[.trimIndent()] trimIndent函数作用：删除多余公共缩进 1234567val n = &quot;&quot;&quot; &lt;html&gt; &lt;body&gt; &lt;H1&gt;Hello World&lt;/H1&gt; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;.trimIndent() 打印结果为： 12345&lt;html&gt; &lt;body&gt; &lt;H1&gt;Hello World&lt;/H1&gt; &lt;/body&gt;&lt;/html&gt; 如果不加函数trimIndent()，则打印结果为： &lt;html&gt; &lt;body&gt; &lt;H1&gt;Hello World&lt;/H1&gt; &lt;/body&gt; &lt;/html&gt; #三、数组 名称 Kotlin Java 整型 IntArray int[] 整型装箱 Array Integer[] 字符 CharArray char[] 字符装箱 Array Character[] 字符串 Array String[] #1. 数组创建 Java创建方式：int[] c = new int[]{1,2,3,4,5} Kotlin创建方式： 1. val c0 = intArrayOf(1,2,3,4,5) 2. val c1 = IntArray(5){it + 1} 说明：其中 5 表示数组长度，it 表示数组下标。 3. val c3 = arrayOf(&quot;Hello&quot;, &quot;World&quot;) #2. 数组长度 格式：数组名.size 其中数组的函数contentToString()，返回指定数组内容的字符串表示形式。 例： 123val c2 = IntArray(5){it}println(c2.size)println(c2.contentToString()) 打印结果为： 125[0, 0, 0, 0, 0] #3. 数组读写 与Java一致 例： 1234val d = arrayOf(&quot;hello&quot;, &quot;world&quot;)d[0] = &quot;kotlin&quot;println(&quot;${d[0]}, ${d[1]}&quot;)println(d.contentToString()) 打印结果为： 12kotlin, world[kotlin, world] #4. 数组遍历 #1. java 中的 foreach 循环遍历 1234float[] e = new float[] {1,3,5,7};for(float elem : e) { System.out.println(elem);} kotlin 中如下方式： 1234567val e = floatArrayOf(1F,3F,5f,7F);for(elem in e) { println(elem)}e.forEach { elem -&gt; println(elem)} #5. 数组的包含关系 判断某元素是否在数组中 格式：元素 [!]in 数组名 说明：判断元素在或不在数组内，返回布尔值 例： 123val e = floatArrayOf(1F,3F,5f,7F);println(2f in e)println(2f !in e) 打印结果： 12falsetrue #四、区间 #1. 区间创建 #1. 闭区间 格式：小值 … 大值 说明：该区间包含起止值，只能创建升序区间 例： 123val intRange = 1 .. 10 //[1, 10]val charRange = 'a' .. 'z' //['a', 'z']val longRange = 1L .. 100L //[1L, 100L] 格式：大值 downTo 小值 说明：该区间为倒序区间，包含起止值。 例： 1234val intRangeReverse = 10 downTo 1 //[10, 1]val charRangeReverse = 'z' downTo 'a' //['z', 'a']val longRangeReverse = 100L downTo 1L //[100L, 1L]println(intRangeReverse.joinToString()) 打印： 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 #2. 半闭半开区间 格式：小值 until 大值 说明：该区间包含起始值，只能创建升序区间 例： 123val intRangeExclusive = 1 until 10 //[1, 10)val charRangeExclusive = 'a' until 'z' //['a', 'z')val longRangeExclusive = 1L until 100L //[1L, 100L) #3. 区间的步长 在创建区间的格式再加上step 数值 例： 12345val intRange = 1 .. 10 step 2//[1, 3, 5, 7, 9]val charRange = 'a' .. 'z' step 2//['a', 'c', 'e', ... , 'y']val intRangeReverse = 10 downTo 1 step 2//[10, 8, 6, 4, 2]val charRangeReverse = 'z' downTo 'a' step 2//['z', 'x', 'v', ... , 'b'] 整型、字符型、长整型区间是离散，就是一个个的数值，而 Float 类型和 Double 类型区间是连续的，包含区间内的所有数值，所以 Float 类型和 Double 类型不能使用步长 #2. 区间的迭代与包含 只有离散型区间才可以迭代，格式与数组一致 所有区间都可以判断包含关系，格式与数组一致 123456789val intRange = 1 .. 10 step 2val floatRange = 1f .. 2ffor(elem in intRange) { println(elem)}intRange.forEach { elem -&gt; println(elem)}println(1.3235f in floatRange) #3. 区间示例 可以使用区间来实现java中fori循环 1234567val array = intArrayOf(1, 3, 5, 7)for(i in 0 until array.size) { println(array[i])}for (i in array.indices) { println(&quot;i:$i, value: ${array[i]}&quot;)} 其中，数组的属性 indices，表示一个 [0, array.size] 的整型区间 打印结果为： 123456781357i:0, value: 1i:1, value: 3i:2, value: 5i:3, value: 7 #五、集合 增加了“不可变”集合框架接口 复用Java API的所有实现类型 运算符级别的支持，简化集合框架的访问 名称 Kotlin Java 不可变List List&lt;T> List&lt;T> 可变List MutableList&lt;T> 不可变Map Map&lt;K,V> Map&lt;K,V> 可变Map MutableMap&lt;K,V> 不可变Set Set&lt;T> Set&lt;T> 可变Set MutableSet&lt;T> #1. 集合的创建 #1. 方法一：Kotlin特有方式 格式：val 变量名:List类型 = 对应集合类型的Of方法 例： 12345val initList:List&lt;Int&gt; = listOf(1,2,3);val initList:MutableList&lt;Int&gt; = mutableListOf(1,2,3);val map:Map&lt;String, Any&gt; = mapOf(&quot;name&quot; to &quot;张三&quot;, &quot;age&quot; to 32)val map:Map&lt;String, String&gt; = mapOf(&quot;Name&quot; to &quot;张三&quot;, &quot;age&quot; to &quot;32&quot;) 其中： 语句A值 to B值为pair类型，可以简单理解为Java中的K-V键值对 Any等同于Java中的Object类型 #2. 方法二：使用Java中的实现类 格式：val strList = 集合实现类 例： 1val strList = ArrayList&lt;String&gt;() 该方法与Java声明集合的只差一个new字段，但是引用的包名不一致。 Java中的ArrayList包名为java.util.ArrayList Kotlin中的ArrayList包名为kotlin.collections.ArrayList 虽然包名不一致，但引用的是同一个东西。 #2. 集合实现类复用与类型别名 kotlin.collections源码如下： 12345678package kotlin.collections@SinceKotlin(&quot;1.1&quot;) public actual typealias RandomAccess = java.util.RandomAccess@SinceKotlin(&quot;1.1&quot;) public actual typealias ArrayList&lt;E&gt; = java.util.ArrayList&lt;E&gt;@SinceKotlin(&quot;1.1&quot;) public actual typealias LinkedHashMap&lt;K, V&gt; = java.util.LinkedHashMap&lt;K, V&gt;@SinceKotlin(&quot;1.1&quot;) public actual typealias HashMap&lt;K, V&gt; = java.util.HashMap&lt;K, V&gt;@SinceKotlin(&quot;1.1&quot;) public actual typealias LinkedHashSet&lt;E&gt; = java.util.LinkedHashSet&lt;E&gt;@SinceKotlin(&quot;1.1&quot;) public actual typealias HashSet&lt;E&gt; = java.util.HashSet&lt;E&gt; 通过类型别名调用kotlin包内的ArrayList等类型时等同于使用Java中的ArrayList等类型 使用类型别名是为了方便开发者跨平台开发。 #3. 集合框架的操作 #1. List列表 +=等价于add -=等价于remove stringList.add(&quot;aa&quot;)等同于stringList += &quot;aa&quot; stringList.remove(&quot;aa&quot;)等同于stringList -= &quot;aa&quot; 1234567val listStr = ArrayList&lt;String&gt;()listStr += &quot;Hello&quot;println(listStr)listStr[0] = &quot;World&quot;println(listStr)val listZero = listStr[0]println(listZero) 打印结果为 123[Hello][World]World #2. Map 访问Map时也可以用方括号的方式，[]内的值实际上就是key 123val map = HashMap&lt;String, Any&gt;()map[&quot;Hello&quot;] = 10println(map[&quot;Hello&quot;]) 打印结果为： 110 #4. Pair键值对 #1. 创建 123456val pair = &quot;Hello&quot; to &quot;Kotlin&quot;val pair2 = Pair(&quot;Hello&quot;, &quot;Kotlin&quot;)println(pair)println(pair2) 打印结果为： 12(Hello, Kotlin)(Hello, Kotlin) #2. 获取对应元素 12345val first = pair.firstval second = pair.secondprintln(first)println(second) 打印结果为： 12HelloKotlin #3. 解构 将Pair拆解成两个变量 1234val (x, y) = pairprintln(x)println(y) 打印结果为： 12HelloKotlin #4. Triple #1. 创建 12val triple = Triple(&quot;Hello&quot;, 3, 4.0)println(triple) 打印结果为： 1(Hello, 3, 4.0) #2. 获取对应元素 1234567val first = triple.firstval second = triple.secondval third = triple.thirdprintln(first)println(second)println(third) 打印结果为： 123Hello34.0 #3. 解构 将Triple拆解成三个变量 12345val (x, y, z) = tripleprintln(x)println(y)println(z) 打印结果为： 123Hello34.0 #六、函数基本概念 #1. 函数定义 格式： 123fun 函数名(函数参数列表)[:函数返回值] { 函数代码块} 例： 123fun main(args: Array&lt;String&gt;): Unit { println(args.contentToString())} 其中，Unit等价于Java的void,函数返回值为Unit时可不加，即上面例可写为： 123fun main(args: Array&lt;String&gt;) { println(args.contentToString())} #2. 函数与方法关系 方法可以认为是函数的一种特殊类型 从形式上，有receiver的函数即为方法 简单来说Abc.get中的Abc就是receiver 例： 1234567891011fun main(args: Array&lt;String&gt;) { val foo:Foo = Foo() val result = foo.bar(&quot;Hello,&quot;, &quot;World&quot;) println(result)}class Foo { fun bar(p0:String, p1:String): String { return p0+p1 }} 其中，Foo类中有函数bar，其功能为拼接传入的两个字符串并返回。 使用foo.bar来调用bar函数，其中foo即为receiver，bar函数也可称之为方法 Kotlin中可以不定义类直接定义函数，这种没有receiver的函数为顶级函数 #3. 函数类型 函数的类型具有与函数签名相对应的特殊表示法，即它们的参数和返回值 所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型 函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定 函数类型表达 函数 类型 fun foo() {} () -> Unit fun foo(p0:Int):String{ ... } (Int) -> String class Foo { fun bar(p0:String, p1:String):Any { ... } } Foo.(String,String) -> Any 等价于 (Foo,String,String) -> Any 等价于 Function3&lt;Foo, String, Long, Any> 如果receiver当做函数参数类型列表里第一项，则表明该函数为方法 参考：https://www.kotlincn.net/docs/reference/lambdas.html #4. 函数的引用 ::是创建一个成员引用或者一个类引用的操作符 函数的引用类似C语言中的函数指针，可用于函数传递 函数 lamba表达 fun foo() {} ::foo fun foo(p0:Int):String{ ... } ::foo class Foo { fun bar(p0:String, p1:String):Any { ... } } Foo::bar 声明函数类型的变量 函数 声明函数变量 fun foo() {} val f:() -> Unit = ::foo fun foo(p0:Int):String{ ... } val g:(Int) -> String = ::foo class Foo { fun bar(p0:String, p1:String):Any { ... } } val h:(Foo, String, Long) -> Any = Foo::bar 可省略函数类型，让编译器去推断 函数 声明函数变量 fun foo() {} val f = ::foo fun foo(p0:Int):String{ ... } val g = ::foo class Foo { fun bar(p0:String, p1:String):Any { ... } } val h = Foo::bar 方法的函数引用 12345class Foo { fun bar(p0:String, p1:Long) :Any{ ... }}val foo = Foo()val m:(String, Long) -&gt; Any = foo.bar 其中bar函数使用的Foo类的实例化对象foo作为receiver，这种方式称为绑定receiver的函数引用 #5. 变长参数 格式：vararg 参数名：参数类型 与java中的void multiParams(String... args)类似 在调用函数之前参数个数是不确定的，只有在调用的时候才能确定参数的类型和数量。 则参数是某个类型的数组 例： 123fun multiParams(vararg ints: Int) { println(ints.contentToString)} 调用： 1multiParams(1,2,3,4) #6. 多返回值 借助Pair和Triple类型完成多返回值的操作 例： 12345678fun multiReturnValues() : Triple&lt;Int, Long, Double&gt; { return Triple(1, 3L, 5.0)}val (a,b,c) = multiReturnValues()println(a)println(b)println(c) 通过解构将Pair和Triple中的值赋给不同变量 #7. 默认参数 定义： 12345fun defaultParameter(x:Int, y:String, z: Long = 0L) { println(&quot;x:$x, y:$y, z: $z&quot;)} 调用： 1defaultParameter(2, &quot;5&quot;) 注意：默认值应该是从参数列表最后一项往前赋值，调用时传递地参数 按照定义时的参数列表顺序传递参数值 #8. 具名参数 定义： 123fun defaultParameter(x:Int = 5, y:String, z: Long = 0L) { println(&quot;x:$x, y:$y, z: $z&quot;)} 调用： 1defaultParameter(y = &quot;5&quot;) 调用时可使用形参名字来显式接收参数，这样避免了给首尾参数加默认值，调用时无法只传中间参数值的问题 #七、示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950fun main() { val calculator = Calculator() calculator.cal(&quot;3&quot;,&quot;*&quot;,&quot;5&quot;)}class Calculator { fun cal(vararg args:String) { if (args.size &lt; 3) { return showHelp() } val operators = mapOf( &quot;+&quot; to ::plus, &quot;-&quot; to ::minus, &quot;*&quot; to ::times, &quot;/&quot; to ::div, ) val opFun = operators[args[1]]?: return showHelp() try { println(&quot;Input:${args.joinToString(&quot; &quot;)}&quot;) println(&quot;Output:&quot; + opFun(args[0].toInt(), args[2].toInt())) } catch (e: Exception) { println(&quot;Invalid Input&quot;) showHelp() } } fun plus(arg0:Int, arg1: Int):Int{ return arg0 + arg1 } fun minus(arg0:Int, arg1: Int):Int{ return arg0 - arg1 } fun times(arg0:Int, arg1: Int):Int{ return arg0 * arg1 } fun div(arg0:Int, arg1: Int):Int{ return arg0 / arg1 } fun showHelp() { val helpStr = &quot;&quot;&quot; Simple Calculator: Input: 2 * 3 Output: 6 &quot;&quot;&quot;.trimIndent() println(helpStr) }} 实现简单的四则运算功能 #八、附录 参考文章： https://www.kotlincn.net/docs/reference/basic-types.html https://www.kotlincn.net/docs/reference/functions.html","link":"/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/"},{"title":"kotlin学习系列九：协程一","text":"一、前言 二、协程基本概念 1. 什么是协程Coroutine 2. 协程调试 1. 协程 VM 参数 2. 断点调试协程 三、launch 启动协程 1. luanch启动协程示例 2. 设置线程休眠原因 3. launch源码简单分析 四、 runBlocking 启动协程 1. 启动示例 2. 源码简单分析及对比 五、挂起函数–Kotlin协程的核心 1. 挂起函数优势 2. 深入理解 suspend 3. 协程与挂起函数 六、参考文章 #一、前言 本文主要讲述Kotlin 协程基本概念、协程调试、launch、runBlocking、挂起函数 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列十：协程二 kotlin学习系列十一：协程三 #二、协程基本概念 协程源码库：https://github.com/hltj/kotlinx.coroutines-cn #1. 什么是协程Coroutine 协程 通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程 （甚至不同机器） 上调度执行，而代码则保持如同顺序执行一样简单 协程 就像 非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程 协程 很重要的一点就是当它挂起的时候，不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束 协程是可以由程序自行控制 挂起、恢复 的程序 协程可以用来实现多任务的协作执行 协程可以用来解决异步任务控制流的灵活转移 协程可以让异步代码同步化 协程可以降低异步程序的设计复杂度 #2. 协程调试 想要学好 Kotlin 协程，掌握它的调试技巧很重要。一般来说，我们可以通过两种方法来进行调试：设置 VM 参数、断点调试。 #1. 协程 VM 参数 只需要将 VM 参数设置成 -Dkotlinx.coroutines.debug，当我们在 log 当中打印“Thread.currentThread().name”的时候，如果当前代码是运行在协程当中的，则打印信息就会携带协程的相关信息 设置方法如下图所示，先打开Run/Debug Configuration窗口 然后在该窗口中的VM框中添加-Dkotlinx.coroutines.debug即可。 添加成功后，示例代码如下： 123456789101112131415161718// 不必关心代码逻辑，关心输出结果即可fun main() { GlobalScope.launch(Dispatchers.IO) { println(&quot;Coroutine started:${Thread.currentThread().name}&quot;) delay(1000L) println(&quot;Hello World!&quot;) } println(&quot;After launch:${Thread.currentThread().name}&quot;) Thread.sleep(2000L)}/*输出结果：After launch:mainCoroutine started:DefaultDispatcher-worker-1 @coroutine#1*/ 当代码处于协程当中的时候，“Thread.currentThread().name”是会带上协程相关的信息的，这里的“@coroutine#1”就代表了 launch 创建的协程。 #2. 断点调试协程 除了设置 VM 参数之外，还可以直接使用 IDE 的调试功能，直接以打断点的形式来调试协程。具体来说，主要以下几个注意事项： 第一步，将 Android Studio 升级到最新版本，目前我使用的版本是 Android Studio Dolphin | 2021.3.1 Patch 1 版本。 第二步，确保 IDE 自带的 Kotlin 编译器插件版本号大于 1.4 ，目前我使用的是 1.7.20 。 第三步，为协程代码打断点，并且右击断点处，勾选 suspend、All，这代表了断点将会对协程生效。 第四步，直接进行调试，当程序停留到断点处以后，就需要确保协程调试窗口已经被开启了，如下图所示，选择对应选项打开协程调试窗口 最后是协程调试窗口： 在这个专属的协程调试窗口当中，可以看到很多有用的协程信息，包括： 当前协程的名字，这里是“coroutine#1”； 当前协程运行在哪个线程之上，这里是“DefaultDispatcher-worker-1”； 当前协程的运行状态，这里是“RUNNING”； 当前协程的“创建调用栈”。 通过调试，我们可以真真切切地看到，我们用 launch 创建了一个协程，“coroutine#1”，这个协程是运行在“DefaultDispatcher-worker-1”这个线程之上的 #三、launch 启动协程 可以把协程想象成了更加轻量的线程。线程的启动方式我们都知道，也就是 new Thread()、或者是 thread{}。那么，如何才能启动一个真正的协程呢？ #1. luanch启动协程示例 1234567891011121314151617181920212223/* delay 函数的定义 注意这个关键字 ↓ */public suspend fun delay(timeMillis: Long) { ... }// 仅用于研究，生产环境不建议使用GlobalScopefun main() { // ① GlobalScope.launch { // ② delay(1000L) println(&quot;Hello World!&quot;) } // ③ Thread.sleep(2000L)}/*输出结果；Hello World!*/ 说明： 注释① ，GlobalScope.launch{}，它是一个高阶函数，它的作用就是启动一个协程。GlobalScope 是 Kotlin 官方为我们提供的“协程作用域”，这涉及到协程的“结构化并发”理念。 注释② ，delay()，它的作用就是字面上的意思，“延迟”。以上代码中，我们是延迟了 1 秒。从 delay() 的函数签名这里可以发现，它的定义跟普通的函数不太一样，它多了一个“suspend”关键字，这代表了它是一个挂起函数。而这也就意味着，delay 将会拥有“挂起和恢复”的能力。delay() 是非阻塞，既然它拥有“挂起和恢复”的能力，那么它肯定能实现非阻塞 注释③ ，它的作用是让当前线程休眠 2 秒钟。很多协程的初学者都会很好奇，为什么上面的代码当中需要一个 Thread.sleep(2000L) 呢？它的作用是什么？ #2. 设置线程休眠原因 123456789101112fun main() { GlobalScope.launch { delay(1000L) println(&quot;Hello World!&quot;) }}/*输出结果；无*/ 说明： 如上代码所示，删掉线程休眠的代码以后，协程代码就无法正常工作了。为了弄清楚这个问题，可以做一个类比，暂时先将协程代码改成如下线程代码： 1234567891011121314fun main() { // 守护线程 // ↓ thread(isDaemon = true) { Thread.sleep(1000L) println(&quot;Hello World!&quot;) }}/*输出结果；无*/ 可以看到，将代码改为线程以后，程序仍然没有输出任何结果。而这里，创建的 Thread 其实是一个“守护线程”。守护线程，就意味着当主线程结束的时候，它也会跟着被销毁。所以前面用 GlobalScope 创建的协程之所以不会正常运行，也是因为类似的原因。为了让问题能够更明确地暴露出来，为之前的代码增加一些日志： 123456789101112131415fun main() { GlobalScope.launch { println(&quot;Coroutine started!&quot;) delay(1000L) println(&quot;Hello World!&quot;) } println(&quot;Process end!&quot;)}/*输出结果；Process end!*/ 根据输出结果，我们可以推测出：通过 launch 创建的协程还没来得及开始执行，整个程序就已经结束了 。相应的，也就能推测出，之前案例中 Thread.sleep(2000) 的作用就是为了不让主线程退出 。 #3. launch源码简单分析 协程代码特殊的一个行为模式，那就是：它的代码不是按照顺序执行的 。为了让这一点更加明显，我们再增加一些日志： 1234567891011121314151617181920fun main() { GlobalScope.launch { // 1 println(&quot;Coroutine started!&quot;) // 2 delay(1000L) // 3 println(&quot;Hello World!&quot;) // 4 } println(&quot;After launch!&quot;) // 5 Thread.sleep(2000L) // 6 println(&quot;Process end!&quot;) // 7}/*输出结果：After launch!Coroutine started!Hello World!Process end!*/ 根据这个程序运行结果，以上的协程代码运行顺序是 1、5、6、2、3、4、7。也就是说，launch 并不会阻塞线程的执行，甚至，我们可以认为 launch() 当中 Lambda 一定就是在函数调用之后才执行的。 通过 launch 启动一个协程以后，并没有让协程为我们返回一个执行结果，这其实就是典型的 Fire-and-forget(即发即弃，只发送消息,不关心消息是否发送成功) 的应用场景。打个比方，launch 一个协程任务，就像猎人射箭一样。 launch 和射箭，有几个共同点： 箭一旦射出去了，目标就无法再被改变；协程一旦被 launch，那么它当中执行的任务也不会被中途改变。 箭如果命中了猎物，猎物也不会自动送到我们手上来；launch 的协程任务一旦完成了，即使有了结果，也没办法直接返回给调用方。 那么，launch 为什么无法将结果返回给调用方呢？ launch 函数的源代码给出了答案，这个函数的返回值是一个 Job，它其实代表的是协程的句柄 (Handle，句柄是对资源的抽象引用），它并不能为返回协程的执行结果。 123456public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job { ... } 说明： CoroutineScope.launch()，代表了 launch 其实是一个扩展函数，而它的“扩展接收者类型”是 CoroutineScope。这就意味着，launch() 会等价于 CoroutineScope 的成员方法。而要调用 launch() 来启动协程，就必须要先拿到 CoroutineScope 的对象。前面的案例，使用的 GlobalScope，其实就是 Kotlin 官方提供的一个 CoroutineScope 对象，方便开发者直接启动协程。 是第一个参数：CoroutineContext，它代表了协程的上下文，它的默认值是 EmptyCoroutineContext，如果不传这个参数，默认就会使用 EmptyCoroutineContext。一般来说，也可以传入 Kotlin 官方提供的 Dispatchers，来指定协程运行的线程池。协程上下文，是协程当中非常关键的元素。 是第二个参数：CoroutineStart，它代表了协程的启动模式。如果不传这个参数，它会默认使用 CoroutineStart.DEFAULT。CoroutineStart 其实是一个枚举类，一共有：DEFAULT、LAZY、ATOMIC、UNDISPATCHED。最常使用的就是 DEFAULT、LAZY，它们分别代表：立即执行、懒加载执行。 最后一个参数，是一个函数类型的 block，它的类型是“suspend CoroutineScope.() -&gt; Unit”，这个类型看起来有点复杂，先以“(Int) -&gt; Double”这个函数类型开始： 123456fun func1(num: Int): Double { return num.toDouble()}val f1: (Int) -&gt; Double = ::func1 上面的代码很好理解，“(Int) -&gt; Double”代表了参数类型是 Int，返回值类型是 Double 的函数，::func1 这里，使用了函数引用的语法。接下来，再来看看“CoroutineScope.(Int) -&gt; Double”意味着什么： 123456fun CoroutineScope.func2(num: Int): Double { return num.toDouble()}val f2: CoroutineScope.(Int) -&gt; Double = CoroutineScope::func2 很明显，在函数类型前面增加了一个接收者类型后，它的含义就变成了：这个函数应该是 CoroutineScope 类的成员方法或是扩展方法，并且，它的参数类型必须是 Int，返回值类型必须是 Double。那么，“suspend (Int) -&gt; Double”这个类型代表了什么呢？来看个例子： 1234567suspend fun func3(num: Int): Double { delay(100L) return num.toDouble()}val f3: suspend (Int) -&gt; Double = ::func3 有了前面的基础，很容易就能理解，“suspend (Int) -&gt; Double”，其实就代表了一个“挂起函数”，同时它的参数类型是 Int，返回值类型是 Double。 到这里，还可以进一步推理，请看下面的代码： 1234567suspend fun CoroutineScope.func4(num: Int): Double { delay(100L) return num.toDouble()}val f4: suspend CoroutineScope.(Int) -&gt; Double = CoroutineScope::func4 这时候，对于“suspend CoroutineScope.(Int) -&gt; Double”这个函数类型，它首先应该是一个“挂起函数”，同时，它还应该是 CoroutineScope 类的成员方法或是扩展方法，并且，它的参数类型必须是 Int，返回值类型必须是 Double。 那么现在，回头再看 launch() 函数的第三个参数“suspend CoroutineScope.() -&gt; Unit”，其实就能轻松分析出它的类型。 #四、 runBlocking 启动协程 #1. 启动示例 async，是在很多其他编程语言都存在的一种协程模式，比如 C#。在 Kotlin 当中，可以使用 async{} 创建协程，并且还能通过它返回的句柄拿到协程的执行结果。看个简单的例子： 12345678910111213141516171819202122fun main() = runBlocking { println(&quot;In runBlocking:${Thread.currentThread().name}&quot;) val deferred: Deferred&lt;String&gt; = async { println(&quot;In async:${Thread.currentThread().name}&quot;) delay(1000L) // 模拟耗时操作 return@async &quot;Task completed!&quot; } println(&quot;After async:${Thread.currentThread().name}&quot;) val result = deferred.await() println(&quot;Result is: $result&quot;)}/*输出结果：In runBlocking:main @coroutine#1After async:main @coroutine#1 // 注意，它比“In async”先输出In async:main @coroutine#2Result is: Task completed!*/ 注意： 上面的代码中，我们直接使用 runBlocking 来实现了 main 函数。 由于 runBlocking 的最后一个参数的类型是“suspend CoroutineScope.() -&gt; T”，因此在 Lambda 当中已经有了 CoroutineScope，所以我们可以直接在 runBlocking 当中，用 async 启动一个协程。 从程序的输出结果可以看到： 存在两个协程，runBlocking 启动的叫做“coroutine#1”；async 启动的叫做“coroutine#2”。 async 启动协程以后，它也不会阻塞当前程序的执行流程，因为：“After async”在“In async”的前面就已经输出了。 async{}的返回值是一个 Deferred 对象，通过调用它的 await() 方法，就可以拿到协程的执行结果。对比前面 launch 举的“射箭”的例子，这里的 async，就更加像是“钓鱼”： 在钓鱼的时候，我们手里的鱼竿，就有点像是 async 当中的 Deferred 对象。只要手里有这根鱼竿，一旦有鱼儿上钩了，我们就可以直接拿到结果。 #2. 源码简单分析及对比 123456789101112public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit // 不同点1): Job {} // 不同点2public fun &lt;T&gt; CoroutineScope.async( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; T // 不同点1): Deferred&lt;T&gt; {} // 不同点2 说明： 从上面的代码中，可以发现 launch 和 async 的两个不同点： 一个是 block 的函数类型，前者的返回值类型是 Unit，后者则是泛型 T； 另外一个不同点在返回值上，前者返回值类型是 Job，后者返回值类型是 Deferred。而 async 可以返回协程执行结果的原因也在于此 这里，借用朱涛老师的动图，来演示程序整体的执行流程： #五、挂起函数–Kotlin协程的核心 Kotlin 协程最大的优势，就在于它的挂起函数。虽然很多编程语言都有协程的特性，但目前为止，只有 Kotlin 独树一帜，引入了“挂起函数”的概念。另外尽管有些语言的协程底层，也存在“挂起恢复”的概念，但是将这一概念直接暴露给开发者，直接用于修饰一个函数的，Kotlin 算是做了一种创新。 #1. 挂起函数优势 1234567891011// 代码段1getUserInfo(new CallBack() { @Override public void onSuccess(String response) { if (response != null) { System.out.println(response); } }}); 如上是一段简单的Java代码，在这段代码中，发起了一个异步请求，从服务端查询用户的信息，通过 CallBack 返回 response。这样的代码看起来没什么问题，平时我们写代码的时候也经常写类似的代码。不过实际的商业项目不可能这么简单，有的时候，可能需要连续执行几个异步任务，比如说，查询用户信息 --&gt; 查找该用户的好友列表 --&gt; 拿到好友列表后，查找该好友的动态。这样一来，代码就难免会往下面这个方向发展： 123456789101112131415161718192021222324252627// 代码段2getUserInfo(new CallBack() { @Override public void onSuccess(String user) { if (user != null) { System.out.println(user); getFriendList(user, new CallBack() { @Override public void onSuccess(String friendList) { if (friendList != null) { System.out.println(friendList); getFeedList(friendList, new CallBack() { @Override public void onSuccess(String feed) { if (feed != null) { System.out.println(feed); } } }); } } }); } }}); 如上的代码模式就是 回调地狱。给它取这个名字是有原因的，以上代码存在诸多缺陷：可读性差、扩展性差、维护性差，极易出错！想象一下，如果让你基于以上代码再扩展出“超时取消”“出错重试”“进度展示”等相关功能，你会不会觉得头疼？所以这时候，就该轮到 Kotlin 协程出场了。用协程的挂起函数，来重构上面的代码： 123456// 代码段3val user = getUserInfo()val friendList = getFriendList(user)val feedList = getFeedList(friendList) 以极简代码实现上述回调地狱，这就是 Kotlin 协程的魅力：以同步的方式完成异步任务。注意，以上代码之所以能写成类似同步的方式，关键还是在于 getUserInfo()、getFriendList()、getFeedList() 这三个请求函数的定义。 12345678910111213141516171819202122232425262728293031// 代码段4// delay(1000L)用于模拟网络请求//挂起函数// ↓suspend fun getUserInfo(): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;BoyCoder&quot;}//挂起函数// ↓suspend fun getFriendList(user: String): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;Tom, Jack&quot;}//挂起函数// ↓suspend fun getFeedList(list: String): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;{FeedList..}&quot;} 说明： 从以上代码中，可以看到，所谓的挂起函数，其实就是比普通的函数多了一个 suspend 关键字。如果去掉这个 suspend 关键字，所有的函数都会变成普通函数。 代码中的 withContext(Dispatchers.IO)，作用是控制协程执行的线程池 实际上，挂起函数最神奇的地方，就在于它的挂起和恢复功能。从字面上看，suspend 这个词就是“挂起”的意思，而它既然能被挂起，自然就还可以被恢复。它们两个一般是成对出现的。 如上图所示，描述了挂起函数整体的执行流程。 说明： 在 IntelliJ 当中，挂起函数会有一个特殊的箭头标记，这样就便于我们分辨出当前调用的函数是否是普通函数。调用挂起函数的位置，叫做是挂起点 表面上看起来是同步的代码，实际上也涉及到了线程切换，一行代码，切换了两个线程。 比如“val user = getUserInfo()”，其中“=”左边的代码运行在主线程，而“=”右边的代码运行在 IO 线程。 每一次从主线程到 IO 线程，都是一次协程挂起。 每一次从 IO 线程到主线程，都是一次协程恢复。 挂起和恢复，这是挂起函数特有的能力，普通函数是不具备的。 挂起，只是将程序执行流程转移到了其他线程，主线程不会被阻塞。以上代码运行在 Android 系统， App 仍然可以响应用户的操作，主线程并不繁忙。 #2. 深入理解 suspend Kotlin 协程做到一行代码切换两个线程，实现方式都藏在了挂起函数的 suspend 关键字里。 suspend，是 Kotlin 当中的一个关键字，它主要的作用是用于定义“挂起函数”。同样的一个函数，加上 suspend 修饰以后，它的函数类型就会发生改变。 12345678910111213141516171819// 代码段5fun func1(num: Int): Double { return num.toDouble()}/*func1与func3唯一的区别 ↓ */suspend fun func3(num: Int): Double { delay(100L) return num.toDouble()}val f1: (Int) -&gt; Double = ::func1val f2: suspend (Int) -&gt; Double = ::func3val f3: (Int) -&gt; Double = ::func3 // 报错val f4: suspend (Int) -&gt; Double = ::func1 // 报错 由以上代码可知，同样是 Int 作为参数，Double 作为返回值，有没有 suspend 修饰，它们两者的函数类型是不一样的。“suspend (Int) -&gt; Double”与“(Int) -&gt; Double”并不能互相赋值。因此，Kotlin 的函数类型，除了跟参数、返回值、接收者相关，还跟 suspend 相关。 小tips： Compose中的 @Composable 跟 suspend 一样，也可以改变一个函数的类型 那么，suspend 修饰的函数，到底会变成什么类型？将挂起函数与前面“回调地狱的代码”放在一起对比 其实，挂起函数的本质，就是 Callback。 虽然写出来的挂起函数并没有任何 Callback 的逻辑，但是，当 Kotlin 编译器检测到 suspend 关键字修饰的函数以后，就会自动将挂起函数转换成带有 CallBack 的函数。 将上面的挂起函数反编译成 Java代码如下： 123456789// 代码段6// Continuation 等价于 CallBack// ↓ public static final Object getUserInfo(Continuation $completion) { ... return &quot;BoyCoder&quot;;} 从反编译的结果来看，挂起函数确实变成了一个带有 CallBack 的函数，只是这个 CallBack 换了个名字，叫做 Continuation。Continuation 在 Kotlin 中的定义： 1234567891011121314// 代码段7public interface Continuation&lt;in T&gt; {// ...// 相当于 CallBack的onSuccess 结果 // ↓ ↓ public fun resumeWith(result: Result&lt;T&gt;)}interface CallBack { void onSuccess(String response);} 根据以上定义，Continuation 本质上也就是一个带有泛型参数的 CallBack。这个“从挂起函数转换成 CallBack 函数”的过程，被叫做是 CPS 转换*（Continuation-Passing-Style Transformation）*。Kotlin 官方要将 CallBack 命名为 Continuation 的原因：Continuation 道出了它的实现原理。 以下动画用来演示一下挂起函数在 CPS 转换过程中，函数签名的变化： 在上面 CPS 转换的过程中，函数的类型发生了变化：“suspend ()-&gt;String” 变成了 “(Continuation)-&gt; Any?”。 而这就意味着，如果在 Java 中访问一个 Kotlin 挂起函数 getUserInfo()，会看到 Java 里的 getUserInfo() 的类型是“(Continuation)-&gt; Object” （即接收 Continuation 为参数，返回值是 Object）。 那么 Continuation 到底是什么？ 只需要把握住 Continuation 的词源 Continue 即可。Continue 是“继续”的意思，Continuation 则是“接下来要做的事情”。放到程序中，Continuation 就代表了，“程序继续运行下去需要执行的代码”，“接下来要执行的代码”，或者是“剩下的代码”。 就以上面的代码为例，当程序运行 getUserInfo() 这个挂起函数的时候，它的“Continuation”则是下图红框的代码： 这样理解了 Continuation 以后，CPS 也就容易理解了，它其实就是将程序接下来要执行的代码进行传递的一种模式。 而 CPS 转换，就是将原本的同步挂起函数转换成 CallBack 异步代码的过程。这个转换是编译器在背后做的，程序员对此并无感知。 根据这个动图，可以看到当程序执行到 getUserInfo() 的时候，剩下的未执行代码都被一起打包了起来，以 Continuation 的形式，传递给了 getUserInfo() 的 Callback 回调当中。当然，这种方式其实只是大致模拟了挂起函数的 CPS 转换过程，实际细节要远比这个复杂。 以上就是 Kotlin 挂起函数的核心原理，它的挂起和恢复，其实也是通过 CPS 转换来实现的。 再来看看之前的协程思维模型： 所以，协程之所以是非阻塞，是因为它支持“挂起和恢复”； 而挂起和恢复的能力，主要是源自于“挂起函数”； 而挂起函数是由 CPS 实现的，其中的 Continuation，本质上就是 Callback。 #3. 协程与挂起函数 协程和挂起函数虽然都是支持挂起和恢复的，但它们不是一种东西。 12345678910111213// 代码段8fun main() { getUserInfo() // 报错}suspend fun getUserInfo(): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;BoyCoder&quot;} 在上面的代码中，直接在 main 函数当中调用了 getUserInfo() 这个挂起函数，这时候， IDE 会报错：挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用。这个意思也很好理解，对于这样的要求，很容易就能写出下面的代码： 123456789101112// 代码段9// 在协程中调用getUserInfo()fun main() = runBlocking { val user = getUserInfo()}// 在另一个挂起函数中调用getUserInfo()suspend fun anotherSuspendFunc() { val user = getUserInfo()} 而 runBlocking 的函数签名： 12345678// 代码段10public actual fun &lt;T&gt; runBlocking( context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T {} 它的第二个参数 block 的类型“suspend CoroutineScope.() -&gt; T”，如此 block 也是一个挂起函数的类型！所以说，虽然“协程和挂起函数”都可以调用“挂起函数”，但是协程的 Lambda，也是挂起函数。所以，它们本质上都是因为“挂起函数可以调用挂起函数”。也就是说，站在目前的阶段来看，可以认为：挂起和恢复，是协程的一种底层能力；而挂起函数，是这种底层能力的一种表现形式，通过暴露出来的 suspend 关键字，开发者可以在上层，非常方便地使用这种底层能力。 #六、参考文章 Kotlin 编程第一课","link":"/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/"},{"title":"kotlin学习系列七：反射","text":"一、前言 二、反射的基本概念 1. 反射概念 2. 反射的依赖 1. 添加反射库依赖 3. 反射常见用途 4. 反射常用的数据结构 1. kotlin常用反射数据结构 2. kotlin与java的反射数据结构对比 5. Kotlin中使用反射 1. 在Kotlin中使用Java反射和Kotlin反射优缺点 2. 使用Kotlin反射 3. KClass 4. KCallable 5. KParameter 6. KType 7. KClass与KType区别 8. 类型擦除 9. 总结 三、 示例 – 获取泛型实参 1. 获取Function返回值的类型实参 1. 通过Kotlin反射获取 2. 通过Java反射获取 2. 在抽象父类里获取该父类泛型的实参 四、 示例 – 为数据类实现DeepCopy 1. 数据类自带的copy方法只是浅拷贝 2. 为数据类添加深拷贝方法 五、 示例 – Model映射 1. 通过Map转为任意类型 2. 通过任意类型映射为任意类型 六、 示例 – 可释放对象引用的不可空类型 七、 插件化加载类 1. ClassLoader 1. ClassLoader的双亲委派机制 2. 插件化加载类实现 1. 创建plugin接口 2. 创建两个继承plugin接口的类 3. 将实现类所在Module打包成jar 4. 为两个实现接口的类添加配置文件 5. 递归监听文件夹 6. 创建自定义类加载器 八、参考文章 #一、前言 本文主要讲述Kotlin 反射 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶 kotlin学习系列十一：协程应用 #二、反射的基本概念 #1. 反射概念 反射是允许程序在运行时访问程序结构的一类特性 程序结构包括：类、接口、方法、属性等语法特性 总的来看，Kotlin 反射具备这三个特质： 感知 程序的状态，包含程序的运行状态，还有源代码结构； 修改程序的状态； 根据程序的状态，调整自身的决策行为。 #2. 反射的依赖 说明： Java中有反射的概念，Java的JDK中包含了Java的反射API 对于Kotlin来说，Kotlin自己做了一套反射的API,是一个独立的库 #1. 添加反射库依赖 在 Kotlin 当中，反射库并没有直接集成到标准库当中。这是为了方便一些对程序安装包敏感的应用，可以根据实际需求来选择是否要用 Kotlin 反射。 123456dependencies { implementation(kotlin(“stdlib-jdk8”, KotlinCompilerVersion.VERSION)) implementation(”org.jetbrains.kotlin:kotlin-reflect”)} 说明： 使用Kotlin的反射，需要单独引入依赖库kotlin-reflect stdlib是Kotlin的标准库 #3. 反射常见用途 列出类型的所有属性 (java-&gt;filed，kotlin-&gt;property)、方法 (java-&gt;method，kotlin-&gt;funtion)、内部类等等 调用给定名称及签名的方法或访问指定名称的属性 通过签名信息获取泛型实参的具体类型 访问运行时注解及其信息完成注入或者配置操作 #4. 反射常用的数据结构 #1. kotlin常用反射数据结构 数据结构 概念及使用说明 KType 描述未擦除的类型或泛型参数等，例如：Map&lt;String,Int&gt;;可通过typeOf或者以下类型获取对应的父类、属性、函数参数等 KClass 描述对象的实际类型，不包含泛型参数，例如：Map; 可通过对象、类型名直接获得 KProperty 描述属性，可通过属性引用、属性所在类的KClass获取 KFunction 描述函数，可通过函数引用、函数所在类的KClass获取 说明： KType描述的是类型，与写出来的类型是一致的，而KClass描述的是真实的类型，编译完成后的泛型擦除掉的类型。 属性包括backing-field、getter、setter，KProperty有对应属性可以获取到getter、setter #2. kotlin与java的反射数据结构对比 说明： KType基本对应Java中的Type，使用场景也类似 KClass对应Java中的Class KProperty与Java中的Field作用类似，但是KProperty功能更强大 KFunction与Java中的Method作用类似。Java中没有函数的概念，只有方法的概念。而Function既可以当顶级函数使用，也可以当作方法使用 #5. Kotlin中使用反射 #1. 在Kotlin中使用Java反射和Kotlin反射优缺点 Kotlin中也可以使用Java反射 Java反射 优点：无需引入额外依赖，首次使用速度相对较快 缺点：无法访问Kotlin语法特性，需对Kotlin生成的字节码足够了解 Kotlin反射 优点：支持访问Kotlin几乎所有特性，API设计更友好 缺点：引用Kotlin反射库(2.5MB，编译后400KB)，首次调用慢 Kotlin反射首次调用慢的原因：Kotlin反射信息是写到注解@Metadata中，而这些信息序列化为二进制，首次调用会获取注解，并将信息反序列化。 #2. 使用Kotlin反射 123456//javapublic static void main(String[] args) throws NoSuchFieldException { Class&lt;String&gt; cls = String.class; Class&lt;? extends Object&gt; clsOfObj = String.class; Field field = cls.getDeclaredField(&quot;value&quot;);} 123456789101112//kotlin@ExperimentalStdlibApifun main() { var cls: KClass&lt;String&gt; = String::class val mapCls = Map::class println(mapCls) val property = cls.declaredMemberProperties.firstOrNull() val mapType = typeOf&lt;Map&lt;String, Int&gt;&gt;() cls.members.forEach { println(it.name) }} 说明： 如上所示，先获取String类的KClass，然后通过方法declaredMemberProperties获取声明在String类中的属性 使用::class获取某个类的KClass Java的Class与Kotin的KClass相互转化: Java的Class转换为KClass：在Class类后加.kotlin Kotlin的KClass转换为Class：在KClass类后加.java #3. KClass 12345678910public actual interface KClass&lt;T : Any&gt; : KDeclarationContainer, KAnnotatedElement, KClassifier { public actual val simpleName: String? public actual val qualifiedName: String? override val members: Collection&lt;KCallable&lt;*&gt;&gt; // 省略部分代码} 这个 KClass 其实就代表了一个 Kotlin 类，通过 对象 ::class，我们就可以拿到这个对象的KClass simpleName，类的名称，对于匿名内部类，则为 null； qualifiedName，完整的类名； members，所有成员属性和方法，类型是Collection&lt;Kcallable&lt;*&gt;&gt;； constructors，类的所有构造函数，类型是Collection&lt;KFunction&lt;T&gt;&gt;； nestedClasses，类的所有嵌套类，类型是Collection&lt;KClass&lt;*&gt;&gt;； visibility，类的可见性，类型是KVisibility?，分别是这几种情况，PUBLIC、PROTECTED、INTERNAL、PRIVATE； is开头的函数：判断是否为某个类型： isAbstract，是不是抽象类 isCompanion，是不是伴生对象 isFinal，是不是 final； isOpen，是不是 open； isSealed，是不是密封的； isData，是不是数据类； isInner，是不是内部类； isFun，是不是函数式接口； isValue，是不是 Value Class nestedClasses()：获取内部类 objectInstance()：获取object实例，如果调用的KClass是单例类，可通过该方法直接获取单例类的实例 supertypes()：获取父类的KType列表。 declaredMemberProperties只能获取声明在某个类中的属性，拿不到该类的扩展属性。 12var cls: KClass&lt;String&gt; = String::classcls.declaredMemberProperties 说明： 代码cls.declaredMemberProperties的返回类型为Collection&lt;KProperty1&lt;String, *&gt;&gt; KProperty与KFunction后数字释义： 如果没有receiver，则是KProperty0与KFunction0 如果有一个receiver，则是KProperty1与KFunction1 如果有两个receiver，则是KProperty2与KFunction2 declaredMemberExtensionProperties只能获取 声明在某个类中的扩展属性，获取的扩展属性不是该类的扩展属性 12345class A { fun String.printStar() { }} 说明： 如上代码所示，在类A中为类String定义了一个扩展函数printStar()，则代码A::class.declaredMemberExtensionFunctions可以获取到扩展函数printStar()，但是String.class.declaredMemberExtensionFunctions获取不到。函数printStar()就有两个receiver：A，String #4. KCallable KCallable 代表了 Kotlin 当中的所有可调用的元素，比如函数、属性、甚至是构造函数。下面是 KCallable 的重要成员： name，名称，这个很好理解，属性和函数都有名称； parameters，所有的参数，类型是List&lt;KParameter&gt;，指的是调用这个元素所需的所有参数； returnType，返回值类型，类型是 KType； typeParameters，所有的类型参数 (比如泛型)，类型是List&lt;KTypeParameter&gt;； call()，KCallable 对应的调用方法 visibility，可见性； isSuspend，是不是挂起函数 #5. KParameter KParameter，代表了KCallable当中的参数，它的重要成员如下： index，参数的位置，下标从 0 开始； name，参数的名称，源码当中参数的名称； type，参数的类型，类型是 KType； kind，参数的种类，对应三种情况：INSTANCE 是对象实例、EXTENSION_RECEIVER 是扩展接受者、VALUE 是实际的参数值。 #6. KType KType，代表了 Kotlin 当中的类型，它重要的成员如下： classifier，类型对应的 Kotlin 类，即 KClass，例子： classifier == String::class 来判断是不是 String 类型的； arguments，类型的类型参数，看起来好像有点绕，其实它就是这个类型的泛型参数； isMarkedNullable，是否在源代码中标记为可空类型，即这个类型的后面有没有“?”修饰。 #7. KClass与KType区别 12345678fun main() { val mapCls = Map::class println(mapCls) val mapType = typeOf&lt;Map&lt;out String, Int&gt;&gt;() mapType.arguments.forEach { println(it) }} 打印结果： 123class kotlin.collections.Mapout kotlin.Stringkotlin.Int 说明： Map::class获取的KClass打印出来就只是该类型的class mapType.arguments返回值类型是List&lt;KTypeProjection&gt;，打印每个KTypeProjection KTypeProjection的构造器中有两个参数Kvariance(使用处的型变声明)、KType(泛型实参类型) 在获取KType时，为Map的第一个泛型String添加了逆变声明out，所以在打印类型时会先打印出参数的型变类型，之后再打印出类型，如果没有定义型变则只显示类型 #8. 类型擦除 12345class Person(val name: String, val age: String)interface Api { fun getUsers(): List&lt;Person&gt;} 上述代码的关键二进制代码如下： 1234567891011121314public abstract interface cn/ltt/projectcollection/kotlin/kotlinreflection/Api { // access flags 0x401 // signature ()Ljava/util/List&lt;Lcn/ltt/projectcollection/kotlin/kotlinreflection/Person;&gt;; // declaration: java.util.List&lt;cn.ltt.projectcollection.kotlin.kotlinreflection.Person&gt; getUsers() public abstract getUsers()Ljava/util/List; @Lorg/jetbrains/annotations/NotNull;() // invisible LOCALVARIABLE this Lcn/ltt/projectcollection/kotlin/kotlinreflection/Api; L0 L1 0 @Lkotlin/Metadata;(mv={1, 4, 2}, bv={1, 0, 3}, k=1, d1={&quot;\\u0000\\u0014\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0000\\n\\u0000\\n\\u0002\\u0010 \\n\\u0002\\u0018\\u0002\\n\\u0000\\u0008f\\u0018\\u00002\\u00020\\u0001J\\u000e\\u0010\\u0002\\u001a\\u0008\\u0012\\u0004\\u0012\\u00020\\u00040\\u0003H&amp;\\u00a8\\u0006\\u0005&quot;}, d2={&quot;Lcn/ltt/projectcollection/kotlin/kotlinreflection/Api;&quot;, &quot;&quot;, &quot;getUsers&quot;, &quot;&quot;, &quot;Lcn/ltt/projectcollection/kotlin/kotlinreflection/Person;&quot;, &quot;app_debug&quot;}) // compiled from: KotlinReflectionLab.kt} 说明： 可以看到在类Api中的getUsers()函数返回结果是Person类型的集合，而编译后该方法返回值是List,将Person擦除了。 可以通过signature拿到这个类型Person。 混淆时，proguard会将signature混淆，所以要keep住signature才可以拿到泛型实参。 Proguard配置：-keepattributes Signature #9. 总结 反射，其实就是 Kotlin 为我们开发者提供的一个工具，通过这个工具，我们可以让程序在运行的时候“自我反省”。这里的“自我反省”一共有三种情况，其实跟我们的现实生活类似。 第一种情况，程序在运行的时候，可以通过反射来查看自身的状态。 第二种情况，程序在运行的时候，可以修改自身的状态。 第三种情况，程序在运行的时候，可以根据自身的状态调整自身的行为。 #三、 示例 – 获取泛型实参 #1. 获取Function返回值的类型实参 #1. 通过Kotlin反射获取 1234567891011121314class Person(val name:String, val age: String)interface Api { fun getUsers(): List&lt;Person&gt;}fun main() { //方法一 Api::class.declaredMemberFunctions.first { it.name == &quot;getUsers&quot; } .returnType.arguments.forEach { println(it) } //方法二 Api::getUsers.returnType.arguments.forEach { println(it) }} 打印结果： 12cn.ltt.projectcollection.kotlin.kotlinreflection.Personcn.ltt.projectcollection.kotlin.kotlinreflection.Person 说明： 方法一：通过declaredMemberFunctions方法获取Api类中的KFunction集合，然后通过函数名称过滤得到getUsers()函数的KFunction，之后调用returnType函数返回KFunction中的KType，然后通过KType拿到泛型的实参Person 方法二：直接拿到getUsers()的函数引用KFunction1&lt;Api, List&lt;Person&gt;&gt;，之后调用returnType函数返回KFunction中的KType，然后通过KType拿到泛型的实参Person first函数作用是返回第一个满足条件的对象 #2. 通过Java反射获取 123456789class Person(val name:String, val age: String)interface Api { fun getUsers(): List&lt;Person&gt;}fun main() { (Api::class.java.getDeclaredMethod(&quot;getUsers&quot;) .genericReturnType as ParameterizedType).actualTypeArguments.forEach { println(it) }} 打印结果： 1class cn.ltt.projectcollection.kotlin.kotlinreflection.Person 说明： 先拿到Java中的class文件，再通过方法getDeclaredMethod()得到函数getUsers()的Method，再调用方法genericReturnType返回getUsers()的Type，之后将Type强转为ParameterizedType,再调用方法actualTypeArguments得到返回参数的列表，然后得到泛型的实参Person ParameterizedType是Type的子接口，代表泛型参数 优化强转代码： 12345678fun main() { Api::class.java.getDeclaredMethod(&quot;getUsers&quot;) .genericReturnType.safeAs&lt;ParameterizedType&gt;()?.actualTypeArguments?.forEach { println(it) }}fun&lt;T&gt; Any.safeAs(): T? { return this as? T} 说明： 对任何类型声明了一个安全强转方法safeAs()，如果转换失败返回null 如上代码所示，使用安全强转方法safeAs()就可以在强转时不再添加括号，增强可读性 #2. 在抽象父类里获取该父类泛型的实参 12345678910111213141516171819202122abstract class SuperType&lt;T&gt; { val typeParameter by lazy { this::class.supertypes.first().arguments.first().type!! } val typeParameterJava by lazy { this.javaClass.genericSuperclass.safeAs&lt;ParameterizedType&gt;()!!.actualTypeArguments.first() }}class SubType : SuperType&lt;String&gt;()fun&lt;T&gt; Any.safeAs(): T? { return this as? T}fun main() { val subType = SubType() subType.typeParameter.let(::println) subType.typeParameterJava.let(::println)} 打印结果： 12kotlin.Stringclass java.lang.String 说明： 方法一使用Kotlin反射：父类里的this一定是子类的实例，所以this::class获取的是子类SubType的KClass，之后调用supertypes获取继承的父类的集合，再调用first()方法获取在声明子类时第一个继承的父类的KType，之后再调用arguments获取父类的泛型参数列表，调用first()取第一个泛型参数KTypeProjection，最后取他的type属性值 方法二使用Java反射：调用this.javaClass获取java的class实例，之后调用genericSuperclass获取带有泛型实参的Type!，之后调用safeAs()方法将Type!类型转为ParameterizedType类型，再调用方法actualTypeArguments得到参数的列表，再调用first()取第一个参数 打印结果一个是Kotlin的String，一个是Java的String。Kotlin的String的编译完成后会编译为Java的String,所以在Java的反射中所有的Kotlin类型都是Java类型 #四、 示例 – 为数据类实现DeepCopy 定义两个数据类Person、Group，Group是Person的一个参数 123data class Person(val name:String = &quot;Lee&quot;, val age:Int = 18, val group: Group)data class Group(val id:Int, val name:String, val location:String) #1. 数据类自带的copy方法只是浅拷贝 1234567fun main() { val person = Person(group = Group(1,&quot;student&quot;,&quot;beijing&quot;)) val copiedPerson = person.copy() println(person === copiedPerson) println(person.name === copiedPerson.name) println(person.group === copiedPerson.group)} 打印结果： 123falsetruetrue Person类反编译class文件后部分代码如下： 1234567891011121314151617181920212223242526public final class Person { ... @NotNull public final Person copy(@NotNull String name, int age, @NotNull Group group) { Intrinsics.checkNotNullParameter(name, &quot;name&quot;); Intrinsics.checkNotNullParameter(group, &quot;group&quot;); return new Person(name, age, group); } // $FF: synthetic method public static Person copy$default(Person var0, String var1, int var2, Group var3, int var4, Object var5) { if ((var4 &amp; 1) != 0) { var1 = var0.name; } if ((var4 &amp; 2) != 0) { var2 = var0.age; } if ((var4 &amp; 4) != 0) { var3 = var0.group; } return var0.copy(var1, var2, var3); }} 说明： Kotlin中==等价于Java中的equals()方法，而===是比较内存地址 由反编译后的代码可知，调用Person默认的copy方法时会调用copy$default()，之后调用Person的copy()函数，传入三个参数，这三个参数，就是Person自身的三个值，所以虽然创建了一个新的Person类，但是Person类里的数据类Group的还是一样的 #2. 为数据类添加深拷贝方法 1234567891011121314151617181920212223242526fun &lt;T : Any&gt; T.deepCopy(): T { if(!this::class.isData){ return this } return this::class.primaryConstructor!!.let { primaryConstructor -&gt; primaryConstructor.parameters.map { parameter -&gt; val value = (this::class as KClass&lt;T&gt;).memberProperties.first { it.name == parameter.name } .get(this) if((parameter.type.classifier as? KClass&lt;*&gt;)?.isData == true){ parameter to value?.deepCopy() } else { parameter to value } }.toMap() .let(primaryConstructor::callBy) }}fun main() { val deepCopiedPerson = person.deepCopy() println(person === deepCopiedPerson) println(person.name === deepCopiedPerson.name) println(person.group === deepCopiedPerson.group) println(deepCopiedPerson)} 打印结果： 1234falsetruefalsePerson(name=Lee, age=18, group=Group(id=1, name=student, location=beijing)) 数据类扩展函数deepCopy()说明： 只为数据类添加深拷贝的方法，所在通过语句this::class.isData判断调用该方法的类是不是数据类 数据类一定有主构造器，可以通过this::class.primaryConstructor获取数据类主构造器 将primaryConstructor作为参数传入let函数中，再通过parameters获取主构造器中的参数列表 再调用map函数，将主构造器中的每个参数做一些操作，函数返回的是键值对列表 this::class.memberProperties语句得到某个类的成员属性列表，之后取第一个过滤条件成功的成员属性，过滤条件为该成员属性名字与之前取的参数列表中的参数名称一致 this::class中的返回结果类型是KClass&lt;out T&gt;，其中泛型是协变的，而调用KProperty的get()函数时要将泛型传入，此时泛型要是逆变的，而数据类没有继承关系，所以将this::class强转为KClass&lt;T&gt;，之后就可以通过get()函数将receiver传入，得到该属性的值了 此时需要判断属性的值若是基本类型，则直接赋值，若是数据类则深拷贝 parameter.type.classifier获取parameter的KClass，再判断KClass如果是数据类则需要进行深拷贝，若是其它的类型则直接赋值 通过map函数获取了parameter和其对应值的列表后，再调用toMap()函数，将列表转为集合 将集合作为参数传入let方法中，最后调用构造器的callBy方法创建该类的实例，callBy方法入参即为parameter和其对应值的集合，所以可以使用::代替lambda表达式 若代码块仅包含以 it 作为参数的单个函数，则可以使用方法引用 :: 代替 lambda 表达式 深拷贝思路： 先判断如果是数据类再进行深拷贝 深拷贝就是构造对象，所以先获取数据类的主构造器 再去获取主构造器的参数，数据类的主构造器的参数同时也是数据类的属性 根据参数的名字拿到属性名字再拿到属性的值 再判断属性值的类型：若为基本类型，直接取值；若是数据类，则进行深拷贝 (这里使用了递归的思路) 之后调用主构造器的调用方法，并将主构造器的参数和参数值传入。 最后获得了一个新的数据类 打印结果说明： 通过反射创建新的Person实例，所以两个实例不会相等 基本数据类型有一个常量共享池，所以基本数据类型的参数相等 对数据类Person进行深拷贝时，也对它的参数数据类Group进行了深拷贝，而深拷贝使用反射创建新的实例，所以两个Group实例不相等 打印出深拷贝的Person实例，与一开始创建的Person实例里的基本数据都是一致的 #五、 示例 – Model映射 在工程中可能会有数据类之间转换的需要，本章讲述如何通过反射进行类之间快速的转换 123456789data class Human(val name: String, val avatarUrl: String)data class Person( var id: Int, var name: String, var avatarUrl: String, var smallUrl: String, var detailUrl: String) 如上定义两个数据类Human、Person #1. 通过Map转为任意类型 12345678910111213141516171819202122232425fun main() { val personMap = mapOf( &quot;id&quot; to 0, &quot;login&quot; to &quot;Lee&quot;, &quot;avatarUrl&quot; to &quot;https://api.github.com/users/Lee&quot;, &quot;detailUrl&quot; to &quot;https://api.github.com/users/Lee&quot; ) val personFromMap: Person = personMap.mapAs() println(personFromMap)}inline fun &lt;reified To : Any&gt; Map&lt;String, Any?&gt;.mapAs(): To { return To::class.primaryConstructor!!.let { it.parameters.map { parameter -&gt; parameter to (this[parameter.name] ?: if(parameter.type.isMarkedNullable) null else throw IllegalArgumentException(&quot;${parameter.name} is required but missing.&quot;)) }.toMap() .let(it::callBy) }} 打印结果： 1Person(id=0, name=Lee, avatarUrl=https://avatars2.githubusercontent.com/u/30511713?v=4, smallUrl=https://api.github.com/users/Lee, detailUrl=https://puppet16.github.io/) 说明： 获取要转换成的目标To的KClass实例，之后再获取该类的主构造器 通过parameters方法获取主构造器的参数列表 再通过map函数对参数列表里每个参数进行如下操作 构造参数及参数值的键值对，若参数值为null，则判断若参数类型可以为空，则返回空，否则直接抛异常 之后通过toMap()函数，将参数及参数值的键值对列表转为集合 最后调用主构造器的callBy()函数，将之前的参数及参数值键值对集合传入其中 如此便将map集合转换为了一个任意类型 注意： map的key值需要与转换目标的参数名称一致，且转换目标的参数要定义在主构造器中 #2. 通过任意类型映射为任意类型 12345678910111213141516171819fun main() { val person = Person( 0, &quot;Lee&quot;, &quot;https://avatars2.githubusercontent.com/u/30511713?v=4&quot;, &quot;https://api.github.com/users/Lee&quot;, &quot;https://puppet16.github.io/&quot; ) val human: Person = person.mapAs() println(human)}inline fun &lt;reified From : Any, reified To : Any&gt; From.mapAs(): To { return From::class.memberProperties.map { it.name to it.get(this) } .toMap().mapAs()} 打印结果： 1Person(id=0, name=Lee, avatarUrl=https://api.github.com/users/Lee, smallUrl=https://api.github.com/users/Lee, detailUrl=https://api.github.com/users/Lee) 说明： 获取被转换的类From的成员属性列表，之后将列表转换为集合，集合键为属性名称，值为属性值，最后再调用上一节所讲的Map的转换函数mapAs() 注意： 两个任意类型中的参数名称要一致，且参数要定义在主构造器中 #六、 示例 – 可释放对象引用的不可空类型 创建一个引用，该引用持有一个占用较大内存资源的类型对象，在最后不需要该引用时，我们需要将其释放，也就是将引用置为null，Kotlin中只有声明为可空类型才能置为null，但是可空类型属性使用比较繁琐，可以通过属性代理将定义不可空类型引用释放 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ReleasableNotNull&lt;T: Any&gt;: ReadWriteProperty&lt;Any, T&gt; { private var value: T? = null override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T { return value ?: throw IllegalStateException(&quot;Not initialized or released already.&quot;) } override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: T) { this.value = value } fun isInitialized() = value != null fun release() { value = null }}inline val KProperty0&lt;*&gt;.isInitialized: Boolean get() { isAccessible = true return (this.getDelegate() as? ReleasableNotNull&lt;*&gt;)?.isInitialized() ?: throw IllegalAccessException(&quot;Delegate is not an instance of ReleasableNotNull or is null.&quot;) }fun KProperty0&lt;*&gt;.release() { isAccessible = true (this.getDelegate() as? ReleasableNotNull&lt;*&gt;)?.release() ?: throw IllegalAccessException(&quot;Delegate is not an instance of ReleasableNotNull or is null.&quot;)}class Bitmap(val width: Int, val height: Int)class Activity { private var bitmap by ReleasableNotNull&lt;Bitmap&gt;() fun onCreate(){ println(this::bitmap.isInitialized) bitmap = Bitmap(1920, 1080) println(::bitmap.isInitialized) } fun onDestroy(){ println(::bitmap.isInitialized) ::bitmap.release() println(::bitmap.isInitialized) }}fun main() { val activity = Activity() activity.onCreate() activity.onDestroy()} 打印结果： 1234falsetruetruefalse 说明： 定义了一个自定义属性代理类ReleasableNotNull，该类接收一个泛型，这个泛型就是可以被释放的引用类型 自定义属性代理类只需要实现getValue()和setValue方法即可，不一定非要实现ReadWirtProperty接口 在ReleasableNotNull类中创建了属性value，类型为可空的泛型T 在ReleasableNotNull类中的getValue()方法，如果value为空的话要抛出异常，因为传进来的类型不可能为空，为空的情况也是没有初始化或是手动调用release()方法，将该属性释放了，此时也不能再使用该类获取类型了 isInitialized()方法是判断ReleasableNotNull类是否初始化 release()方法是将传进来的类型释放 因为isInitialized()和release()方法是定义在属性代理类ReleasableNotNull内的方法，而该类的属性value才是最终要调用这两个方法的receiver，所以要为属性添加两个扩展方法 根据lateInit中对属性添加扩展方法的样式为自定义属性代理类ReleasableNotNull里的属性添加代理 KProperty0&lt;*&gt;.isInitialized是为所有无receiver的属性添加扩展属性isInitialized，获取该属性值时应该返回自定义属性代理类ReleasableNotNull里的isInitialized方法结果，所以通过getDelegate()方法先获取该属性的代理对象，然后再强转为ReleasableNotNull,若强转失败则抛出异常IllegalAccessException；若强转成功则直接调用isInitialized()方法 KProperty0&lt;*&gt;.release()与KProperty0&lt;*&gt;.isInitialized内部处理基本一致，只是KProperty0&lt;*&gt;.release()是为KProperty0&lt;*&gt;添加了一个扩展函数，KProperty0&lt;*&gt;.isInitialized为KProperty0&lt;*&gt;添加了一个扩展属性 使用getDelegate()前必须加上isAccessible = true语句给予访问权限，否则会报错:kotlin.reflect.full.IllegalPropertyDelegateAccessException: Cannot obtain the delegate of a non-accessible property 使用如上代码时必须要添加kotlin的反射库 #七、 插件化加载类 插件加载运行，并实现插件文件监听及热部署即自动监听jar包的修改，若进行了修改则重新进行加载运行里面的类 #1. ClassLoader 说明： 启动类加载器 (BootstrapClassLoader)： 启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，负责加载存放在 JDK\\jre\\lib (JDK代表JDK的安装目录，下同) 下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库 （如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。 总结： 启动类加载器加载java运行过程中的核心类库JRE\\lib\\rt.jar, sunrsasign.jar, charsets.jar, jce.jar, jsse.jar, plugin.jar以及存放在JRE\\classes里的类，也就是JDK提供的类等。常见的比如：Object、Stirng、List… 扩展类加载器 (ExtClassLoader)： 该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\\jre\\lib\\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库 （如javax.开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器 (AppClassLoader)： 该类加载器由 sun.misc.Launcher$AppClassLoader来实现，会加载 java 环境变量 CLASSPATH 所指定的路径下的类库。而 CLASSPATH 所指定的路径可以通过 System.getProperty(&quot;java.class.path&quot;) 获取；该变量也可以覆盖，可以使用参数 -cp，例如：java -cp 路径（可以指定要执行的 class 目录）；开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中 默认的类加载器。 总结： 应用程序类加载器加载CLASSPATH变量指定路径下的类，即指你自已在项目工程中编写的类 自定义类加载器 (CustomClassLoader)： 该 ClassLoader 是指我们自定义的 ClassLoader，大部分情况下使用 AppClassLoader 就足够了。 #1. ClassLoader的双亲委派机制 ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用 （不是继承的关系，是一个包含的关系），虚拟机内置的类加载器 (Bootstrap ClassLoader) 本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。 当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是 由上至下依次检查的。 加载步骤： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成 如果BootStrapClassLoader加载失败 (例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载。 如果AppClassLoader也加载失败，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。 总结： 自底向上检查类是否已经加载，自顶向下尝试加载类 双亲委派机制作用： 防止重复加载同一个 .class。通过委托去向上面问一问是否加载过了，加载过了就不用再加载一遍 保证核心 .class 不能被篡改。假如我们自定义了一个java.lang.Integer类，当使用它时，因为双亲委派，会先使用BootStrapClassLoader来进行加载，这样加载的便是jdk的Integer类，而不是自定义的这个，避免因为加载自定义核心类而造成JVM运行错误。 JVM如何判断两个class是否相同： JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class #2. 插件化加载类实现 为方便的实现类的加载和卸载必须要自定义ClassLoader。必须保证类和它的ClassLoader都没有被使用的情况下才可以卸载类 实现思路： 有一个名为Host的项目，它依赖了一个公共库Common，这个库中定义了一堆的接口，为Host访问插件里的类做入口。如此所有插件的入口类都是Common中定义的接口的实现。如此Host反射取到插件里的入口实现类并将其强转为Common里的接口后就可以访问插件内容了 #1. 创建plugin接口 在一个名为plugin_common的单独的Module中创建插件的入口接口 12345678910interface Plugin { companion object { const val CONFIG = &quot;plugin.config&quot; const val KEY = &quot;plugin.impl&quot; } fun start() fun stop()} 说明： 如上在名为plugin_common的单独的Module中创建一个接口Plugin，其中有两个方法start()、stop()，还 该接口的伴生对象中创建了两个常量CONFIG、KEY，CONFIG是实现Plugin接口的类的配置文件名；KEY是配置文件中的键值名称 #2. 创建两个继承plugin接口的类 在名为plugin_1的单独的Module中创建Plugin接口的实现类PluginImpl1，在名为plugin_2的单独的Module中创建Plugin接口的实现类PluginImpl2 1234567891011121314class PluginImpl1: Plugin{ override fun start() { println(&quot;Plugin1: Start&quot;) newMethod() } fun newMethod(){ println(&quot;newMethod called!!&quot;) } override fun stop() { println(&quot;Plugin1: Stop&quot;) }} 123456789class PluginImpl2: Plugin{ override fun start() { println(&quot;Plugin2: Start&quot;) } override fun stop() { println(&quot;Plugin2: Stop&quot;) }} 说明： 如上是两个接口Plugin的实现类PluginImpl1、PluginImpl2，在各自的实现方法中打印一些信息，只是在PluginImpl1中的start()方法多调用了一个方法newMethod()，该方法也是打印信息 #3. 将实现类所在Module打包成jar plugin_1、plugin_2的build.gradle文件内容如下： 12345678910111213141516171819202122232425262728plugins { id 'java' id 'org.jetbrains.kotlin.jvm'}group 'cn.ltt.kotlin.plugin'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { mavenCentral()}dependencies { implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot; implementation project(&quot;:plugin_common&quot;) testCompile(group: 'junit', name: 'junit', version: '4.12')}compileKotlin { kotlinOptions.jvmTarget = &quot;1.8&quot;}compileTestKotlin { kotlinOptions.jvmTarget = &quot;1.8&quot;} 说明： 点击Gradle窗口中plugin_1\\Tasks\\build\\assemble条目，生成jar包 jar包位置：plugin_1\\build\\libs\\plugin_1-1.0-SNAPSHOT.jar #4. 为两个实现接口的类添加配置文件 因为实现Plugiin接口的类的名字没有要求，如果想使用反射拿到该类还需要知道类的名字，所以添加一个配置文件，该文件中写出该类的名字 12//plugin_1plugin.impl=cn.ltt.kotlin.plugin1.PluginImpl1 12//plugin_2plugin.impl=cn.ltt.kotlin.plugin1.PluginImpl2 说明： 该配置文件在各自Module下的resources文件夹内，名为plugin.config #5. 递归监听文件夹 为了实现热加载插件需要实时监听文件是否有改动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//FileWatcher.kttypealias FileEventListener = (file: File) -&gt; Unitprivate val EMPTY: FileEventListener = {}@RequiresApi(Build.VERSION_CODES.O)class FileWatcher(private val watchFile: File, private val recursively: Boolean = true, private val onCreated: FileEventListener = EMPTY, private val onModified: FileEventListener = EMPTY, private val onDeleted: FileEventListener = EMPTY) { private val folderPath by lazy { Paths.get(watchFile.canonicalPath).let { if (Files.isRegularFile(it)) it.parent else it } ?: throw IllegalArgumentException(&quot;Illegal path: $watchFile&quot;) } @Volatile private var isWatching = false private fun File.isWatched() = watchFile.isDirectory || this.name == watchFile.name private fun Path.register(watchService: WatchService, recursively: Boolean, vararg events: Kind&lt;Path&gt;) { when (recursively &amp;&amp; watchFile.isDirectory) { true -&gt; // register all subfolders Files.walkFileTree(this, object : SimpleFileVisitor&lt;Path&gt;() { override fun preVisitDirectory(dir: Path, attrs: BasicFileAttributes): FileVisitResult { dir.register(watchService, *events) return FileVisitResult.CONTINUE } }) false -&gt; register(watchService, *events) } } @Synchronized fun start() { if(!isWatching){ isWatching = true } thread { // We obtain the file system of the Path val fileSystem = folderPath.fileSystem // We create the new WatchService using the try-with-resources block(in kotlin we use `use` block) fileSystem.newWatchService().use { service -&gt; // We watch for modification events folderPath.register(service, recursively, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY ) // Start the infinite polling loop while (isWatching) { // Wait for the next event val watchKey = service.take() watchKey.pollEvents().forEach { watchEvent -&gt; // Get the type of the event Paths.get(folderPath.toString(), (watchEvent.context() as Path).toString()).toFile() .takeIf { it.isWatched() } ?.let( when (watchEvent.kind()) { StandardWatchEventKinds.ENTRY_CREATE -&gt; { println(&quot;onCreated&quot;) onCreated } StandardWatchEventKinds.ENTRY_DELETE -&gt; { println(&quot;onDeleted&quot;) onDeleted } else -&gt;{ println(&quot;onModified&quot;) onModified // modified. } } ) } if (!watchKey.reset()) { // Exit if no longer valid break } } } } } @Synchronized fun stop(){ isWatching = false }} 说明： 如上代码功能为递归的监听某个文件夹和文件的修改 类FileWatcher有三个事件：onCreated创建、onModified修改、onDeleted删除 这三个事件的类型是FileEventListener，可以看到这只是一个别名，事件只是一个接口File类型参数，不返回结果的函数 #6. 创建自定义类加载器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class PluginClassLoader(private val classPath: String) : URLClassLoader(arrayOf(File(classPath).toURI().toURL())) { init { println(&quot;Classloader init @${hashCode()}&quot;) } protected fun finalize() { println(&quot;Classloader will be gc @${hashCode()}&quot;) }}@RequiresApi(Build.VERSION_CODES.O)class PluginLoader(private val classPath: String) { private val watcher = FileWatcher( File(classPath), onCreated = ::onFileChanged, onModified = ::onFileChanged, onDeleted = ::onFileChanged ) private var classLoader: PluginClassLoader? = null private var plugin: Plugin? = null fun load() { reload() watcher.start() } private fun onFileChanged(file: File) { println(&quot;$file changed, reloading...&quot;) reload() } @Synchronized private fun reload() { plugin?.stop() this.plugin = null this.classLoader?.close() this.classLoader = null val classLoader = PluginClassLoader(classPath) val properties = classLoader.getResourceAsStream(Plugin.CONFIG)?.use { Properties().also { properties -&gt; properties.load(it) } } ?: run { classLoader.close() return println(&quot;Cannot find config file for $classPath&quot;) } plugin = properties.getProperty(Plugin.KEY)?.let { val pluginImplClass = classLoader.loadClass(it) as? Class&lt;Plugin&gt; ?: run { classLoader.close() return println(&quot;Plugin Impl from $classPath: $it should be derived from Plugin.&quot;) } pluginImplClass.kotlin.primaryConstructor?.call() ?: run { classLoader.close() return println(&quot;Illegal! Plugin has no primaryConstructor!&quot;) } } plugin?.start() this.classLoader = classLoader System.gc() }}@RequiresApi(Build.VERSION_CODES.O)fun main() { arrayOf( &quot;plugin_1/build/libs/plugin_1-1.0-SNAPSHOT.jar&quot;, &quot;plugin_2/build/libs/plugin_2-1.0-SNAPSHOT.jar&quot; ).map { PluginLoader(it).apply { load() } }} 说明： 创建一个插件jar包的加载器PluginClassLoader，该类继承自URLClassLoader,URLClassLoader入参为URL类型的数组列表URLClassLoader可以加载jar文件 PluginClassLoader传入一个jar文件的String类型地址，之后将这个地址转为URL再将其创建为一个数组传入URLClassLoader中，如此就加载了jar文件 创建插件加载器PluginLoader，每个插件对应一个PluginLoader对象。该类需要传入插件所在的地址名为classPath 在PluginLoader中创建FileWahter对象watcher，传入插件所在地址、三个对应事件，因为这三个事件都是入参为File不需要返回结果的函数 定义函数onFileChanged()，入参为File类型，不需要返回结果，则可将该函数放到创建对象FileWathcer语句中，在文件的创建、修改、删除事件都使用函数onFileChanged监听 如果文件有更改的话，应该重新加载文件，所以onFileChanged()函数中要重新加载文件 定义函数reload()，在该函数中真正实现加载插件的逻辑 定义函数load()，该函数用于开始执行文件的监听和插件的加载，是整个加载插件功能的入口 加载插件需要PluginClassLoader类，及加载的插件，所以要定义变量classLoader，类型为可空的PluginClassLoader；定义变量plugin，类型为可空的Plugin 重新加载时要先将之前的插件关闭，调用plugin的stop方法 每个plugin对应一个PluginClassLoader，所以在reload方法中去重新创建PluginClassLoader的实例 加载插件前要先获取该插件的配置定义属性名为properties，使用语句classLoader.getResourceAsStream(Plugin.CONFIG)获取配置文件的InputStream 再创建一个 Properties对象，通过它的load()方法，加载配置文件的输入流 再通过 elves操作符，判断如果没有拿到Plugin.CONFIG的配置文件，则关闭当前ClassLoader，打印异常信息：不能获取配置文件 通过语句properties.getProperty(Plugin.KEY)获取配置文件中插件的入口类名 通过语句 classLoader.loadClass(it) as? Class&lt;Plugin&gt;加载该类，并将该类强转为Plugin类型将其赋值给属性pluginImplClass，如果转换失败则关闭当前ClassLoader，打印异常信息：该类并未实现接口plugin 通过语句pluginImplClass.kotlin.primaryConstructor?.call()创建类实例： classLoader.loadClass语句获取的类是Java中的类，所以要先将pluginImplClass转为kotlin的类，再调用该类的主构造器的创建方法创建该类。注意：此时默认实现接口Plugin的类都有主构造器。如果创建失败则关闭当前ClassLoader，打印异常信息：该类没有主构造器 如此，拿到了plugin类实例，此时可以调用实例的start()方法 之后重新为classloader对象赋值为之前加载plugin类所用的ClassLoader 因为创建了大量的局部的变量，在最后的时候调用System.gc()，通知系统及时回收 对于函数来说添加注解@Synchronized来加锁，如此保证函数在多线程下也可以正常使用 main()方法中操作： 创建了一个包含两个插件jar包地址的String类型的数组 通过map函数将数组每个元素都做了如下的操作 创建PluginLoader类的实例，传入参数即为插件jar包地址，之后再调用该实例的apply方法，如此PluginLoader实例即为apply方法中的receiver，在apply方法中调用PluginLoader类的实例的load方法开始加载插件 验证是否为实时监听热更新方法：修改插件里类的某个方法，之后再重新打包 #八、参考文章 深入分析Java ClassLoader原理 这篇文章绝对让你深刻理解java类的加载以及ClassLoader源码分析","link":"/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/"},{"title":"Kotlin学习系列三：表达式","text":"一、前言 二、常量和变量 1. 变量 2. 常量 1. 常量值创建 2. 常量引用 编译期和运行时常量 三、分支表达式 1. if ... else 2. when ... 1. when语句中的条件可以下放到分支上 2. when条件中可以声明变量 3. try ... catch 四、 运算符与中缀表达式 1. 运算符 1. 一些Kotlin预置运算符重载 2. 自定义运算符重载 2. 中缀表达式 1. 定义 2. 自定义 五、Lambda表达式 1. 匿名函数 1. 匿名函数定义 2. 匿名函数传递 3. 匿名函数类型 2. Lambda表达式定义 1. 表达式的完整语法形式 2. 表达式的函数类型 3. 表达式参数类型推断 4. 表达式类型推断 5. 表达式的参数省略形式 六、示例 1. 为Person 实现equals和hashCode方法 2. 为String添加四则运算 七、附录 #一、前言 本文主要讲述Kotlin 表达式 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶--挂起函数 kotlin学习系列十一：协程应用 #二、常量和变量 #1. 变量 修饰符： var：声明可读写变量。 val：声明只读变量，对应 java 里加了final修饰符的变量，若作为属性使用，可以创建get方法，但没有set方法。 例： 12345678910class X { val b : Int get() { return (Math.random() * 100).toInt() } fun test () { var ac = 2 ac = 3 }} #2. 常量 #1. 常量值创建 修饰符： const 说明： 只能定义在全局范围 只能修饰基本类型，如Int、Float等 必须立即用字面量初始化 例： 1const val b = 3 对标java中的静态常量 1static final int b = 3; #2. 常量引用 对应自定义对象， 12val person = Person(18, &quot;Lee&quot;)person.age = 20 创建的自定义对象时是在堆上的，对象里属性可以改变，但引用没变 #编译期和运行时常量 编译期常量：编译时即可确定常量值，并用值替换调用处 例： 1const val b = 3 运行时常量：运行时才能确定值，调用处通过引用获取值 例： 123456val c:Intif (a == 3) { c = 5} else { c = 6} #三、分支表达式 #1. if ... else kotlin中if ... else是表达式，并非语句。 1c = a == 3 ? 5 : 6 1c = if (a == 3) 5 else 6 #2. when ... kotlin中的when表达式功能等价于java中的switch case语句 12345678910switch(a) { case 0: c = 5; break; case 1: c = 100; break; default: c = 20;} 1234567891011when(a) { 0 -&gt; c = 5 1 -&gt; c = 100 else -&gt; c = 200}var c = when(a) { 0 -&gt; 5 1 -&gt; 100 else -&gt; 200 } #1. when语句中的条件可以下放到分支上 123456789101112var x: Any ...when { x is String -&gt; c = x.length x == 1 -&gt; c = 100 else -&gt; c = 20}var c = when { x is String -&gt; x.length x == 1 -&gt; 100 else -&gt; 20 } #2. when条件中可以声明变量 注意： 在1.3版本之后可用 1234c = when (val input = readLine()) { null -&gt; 0 else -&gt; input.length } #3. try ... catch kotlin中的try ... catch表达式功能等价于java中的try ... catch语句 其中，try和catch可以看做是不同分支。 123456c = try { a / b } catch (e : Exception) { e.printStackTrace() 0 } #四、 运算符与中缀表达式 #1. 运算符 运算符重载 运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。 Java不支持运算符重载 kotlin支持运算符重载，但运算符范围仅限官方指定的符号。官网:运算符重载 二目算术运算符 表达式 实际调用 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b)、 a.mod(b) （已弃用） a…b a.rangeTo(b) #1. 一些Kotlin预置运算符重载 ==与equals kotlin中运算符==相当于调用函数equals，都是比较表达式的值 1234var d = &quot;Hello&quot;var e = &quot;World&quot;d.equals(e)d == e +与plus kotlin中运算符+相当于调用函数plus 1232 + 32.plus(3) in与contains kotlin中运算符in相当于调用函数contains 123val list = listOf&lt;Int&gt;(1,2,3,4)println(2 in list)println(list.contains(2)) []与get与set kotlin中运算符[]在某些条件下相当于调用函数get或函数set 12345678910val map = mutableMapOf( &quot;Hello&quot; to 2, &quot;World&quot; to 3 ) val value = map[&quot;Hello&quot;] val value1 = map.get(&quot;Hello&quot;) map[&quot;Hello&quot;] = 4 map.set(&quot;World&quot;, 4) 若运算符[]在等号左侧，则等价于方法**get** 若运算符[]在等号右侧，则等价于方法**set** &gt;与compareTo 函数compareTo 作用： 与指定值进行比较。 如果此值等于指定的其他值，则返回零； 如果小于指定的其他值，则返回负数； 如果大于指定的其他值，则返回正数 122 &gt; 32.compareTo(3) &gt; 0 ()与invoke kotlin中运算符()相当于调用函数invoke 123456val func = fun():Int { println(&quot;Hello&quot;) return 1 }func()func.invoke() #2. 自定义运算符重载 自定义运算符时需要使用关键字 operator，作用：将一个函数标记为重载一个操作符，也就是操作符重载。 1234567891011121314151617181920212223242526272829303132333435363738394041//复数的类class Complex(var real: Double, var image: Double) { override fun toString(): String { return &quot;$real + ${image}i&quot; } operator fun plus(other: Complex): Complex { return Complex(this.real + other.real, this.image + other.image) } operator fun plus(other: Double) :Complex { return Complex(this.real + other, this.image) }}//扩展函数operator fun Complex.plus(other:Int): Complex { return Complex(this.real + other, this.image)}//扩展函数operator fun Complex.minus(real: Double): Complex { return Complex(this.real - real, this.image)}//扩展函数operator fun Complex.get(index: Int):Double { return when(index) { 0 -&gt; this.real 1 -&gt; this.image else -&gt; throw IndexOutOfBoundsException() }}fun main() { val a = Complex(3.0, 4.0) val b = Complex(2.0, 2.0) println(a + 20) println(a + b) println(a + 3) println(a - 3.0) println(a[0]) println(a[1]) println(a[2])} 打印结果为: 1234567891023.0 + 4.0i5.0 + 6.0i6.0 + 4.0i0.0 + 4.0i3.04.0Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException at cn.ltt.projectcollection.kotlin.KotlinLabKt.get(KotlinLab.kt:137) at cn.ltt.projectcollection.kotlin.KotlinLabKt.main(KotlinLab.kt:150) at cn.ltt.projectcollection.kotlin.KotlinLabKt.main(KotlinLab.kt) #2. 中缀表达式 #1. 定义 例如： 2 to 3 等价于2.to(3) 所以to不是运算符 函数to的实现如下： 1public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 其中关键字 infix 表示该函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求： 它们必须是成员函数或扩展函数； 它们必须只有一个参数； 其参数不得接受可变数量的参数且不能有默认值 #2. 自定义 12345678infix fun String.rotate(count:Int): String { val index = count % length return this.substring(index) + this.substring(0, index)}fun main() { println(&quot;HelloWorld&quot; rotate 5)} 如上，定义了一个字符串的可使用中缀表示法的扩展函数rotate，作用是将字符串在某个位置左右翻转 #五、Lambda表达式 Kotlin 函数都是头等的，这意味着它们可以存储在变量与数据结构中、作为参数传递给其他高阶函数以及从其他高阶函数返回。可以像操作任何其他非函数值一样操作函数。 Java中的Lambda是SAM(Single abstract method)类型的语法糖，它需要一个接收类型，该接收类型只能是只有一个方法的接口，而Kotlin中的Lambda是匿名函数的语法糖。 1234567891011121314151617181920//java 8Function1 f1 = (p) -&gt; { System.out.println(p); return &quot;Hello&quot;;};Function2 f2 = (p0, p1) -&gt; { System.out.println(p0 + p1); return &quot;World&quot;;};String result = f1.invoke(2);f2.apply(1, 2);interface Function1 { String invoke(int p);}interface Function2 { String apply(int p0, long p1);} #1. 匿名函数 #1. 匿名函数定义 普通的函数一般使用关键字fun后加函数名来创建，而匿名函数是将函数名省略 12345678fun func() { println(&quot;Hello&quot;)}//匿名函数fun() { println(&quot;Hello&quot;)} #2. 匿名函数传递 可以将匿名函数赋值给变量 123val func = fun(){ println(&quot;Hello&quot;)} 如上，func是一个变量名，并非函数名 #3. 匿名函数类型 匿名函数只是少了函数名，类型与普通函数一致 123val func : () -&gt; Unit = fun() { println(&quot;Hello&quot;)} 若变量类型为函数类型，则该变量可以通过他的invoke函数调用或直接在变量后面加上操作符() 123//函数类型变量调用func.invoke()func() #2. Lambda表达式定义 lambda 表达式与匿名函数是 “函数字面值” ，即未声明的函数，但应立即做为表达式传递。 #1. 表达式的完整语法形式 123val 函数名[：函数类型] = { 形参名[:形参类型] -&gt; lambda表达式} 说明： 函数类型包括形参类型和返回值类型 lambda 表达式总是括在花括号中 完整语法形参声明放在花括号内，并有可选的类型标注， 函数体跟在一个 -&gt; 符号之后。 如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个） 表达式会视为返回值。 例： 123val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y } 如上： 声明了一个函数sum，(Int,Int) -&gt; Int是函数sum的类型，表示函数sum有两个Int形参和一个返回Int类型的返回值。 有两个Int类型的形参x、y，函数体只有一行x + y。 其中操作符+是函数plus的重载，而函数plus返回结果为Int，所以函数sum返回值类型是Int #2. 表达式的函数类型 lambda表达式的类型还可以使用FunctionN 123val sum: Function2&lt;Int, Int, Int&gt; = {x: Int, y: Int -&gt; x + y} 其中，Function2前两个Int表示两个Int类型的形参，最后一个Int表示Int类型的返回值。 #3. 表达式参数类型推断 若表达式参数类型可从表达式类型推断出来，可不加类型 1234567val sum: Function2&lt;Int, Int, Int&gt; = {x, y -&gt; x + y}val sum2:(Int,Int) -&gt;Int ={x, y -&gt; x + y} 其中，参数x和y的类型可由表达式类型推断为Int，所以可不加类型 #4. 表达式类型推断 若表达式的类型可从声明中推断出来，可不加表达式类型 123val sum ={x: Int, y: Int -&gt; x + y} #5. 表达式的参数省略形式 若没有参数，则可省略() -&gt;，而Java中必须要有() -&gt; 1234//java 8Runnable lambda = ()-&gt; { System.out.println(&quot;Hello&quot;);} 123val lambda = { println(&quot;Hello&quot;)} 若参数只有一个，则可将参数及() -&gt;都省略，参数名可默认为关键字 it 123val f2:Function1&lt;Int, Unit&gt; = { println(it)} #六、示例 #1. 为Person 实现equals和hashCode方法 123456789101112131415161718class Person (var name: String, var age: Int) { override fun equals(other: Any?): Boolean { val other = (other as? Person)?:return false return other.age == age &amp;&amp; other.name == name } override fun hashCode(): Int { return 11 + 2 * age + 10 * name.hashCode() }}fun main() { val persons = HashSet&lt;Person&gt;() (0..5).forEach { persons += Person(&quot;Lee&quot;, 20) } println(persons.size)} HashSet数据结构对象中不能存储相同的数据，存储数据时是无序的。 操作符+=是函数plusAssign的重载，其作用为将某元素添加到mutable collection(可变集合) 如果不覆写类Person的equals方法和hashcode方法，则结果打印为6，即认为每个Person(&quot;Lee&quot;, 20)都是不同对象 若覆写了Persona的equals方法和hashcode方法，则结果打印为1，即认为每个Person(&quot;Lee&quot;, 20)是同一个对象 123456789101112131415161718192021222324class Person (var name: String, var age: Int) { override fun equals(other: Any?): Boolean { val other = (other as? Person)?:return false return other.age == age &amp;&amp; other.name == name } override fun hashCode(): Int { return 11 + 2 * age + 10 * name.hashCode() }}fun main() { val persons = HashSet&lt;Person&gt;() val person = Person(&quot;Lee&quot;, 18) persons += person println(persons.size) person.age = 20 persons -= person println(persons.size) persons.forEach { println(&quot;Person{name:${it.name}, age:${it.age}}&quot;) }} 打印结果： 12311Person{name:Lee, age:20} 如上自定义类Person，并覆写了equals方法和hashcode方法，但是这两个方法中均使用了Person类中的成员变量。 此时更改了已放入HashSet的对象属性后，根据打印结果可见，不能将该对象从HashSet对象中删除。 结论： HashMap的key和HashSet的对象本身的equals和hashcode方法一定不要在对象存续期间发生变化 若覆写的equals和hashcode方法使用了对象的成员变量，则要保证成员变量不可更改，即声明为val 若要修改声明为val的成员变量值，则只能重新创建对象 #2. 为String添加四则运算 实现效果: 声明一个String类型变量value，其中除法规则是返回除数在字符串中出现的次数 运算 结果 value + “!” HelloWorld! value - “World” Hello value * 2 HelloWorldHelloWorld value / 3 0 value / “l” 3 123456789101112131415161718192021222324operator fun String.minus(right: Any?): String { return this.replaceFirst(right.toString(), &quot;&quot;)}operator fun String.times(right: Int): String { return (1..right).joinToString(&quot;&quot;) { this }}operator fun String.div(right: Any?): Int { val right = right.toString() return this.windowed(right.length, 1) { it == right }//[false, false, true, true, false ... false, true, false] .count { it }}fun main() { val value = &quot;HelloWorld&quot; println(value - &quot;World&quot;) println(value * 2) println(&quot;*&quot; * 20) println(value / 3) println(value / &quot;l&quot;)} 打印结果为： 12345HelloHelloWorldHelloWorld********************03 形参right表示运算符右侧的运算数 joinToString函数是将可迭代元素拼接成一个字符串，默认以逗号分隔 windowed(size: Int, step: Int = 1)函数返回给定[size]窗口的快照列表 ，并沿着给定的[step]沿着此char序列滑动，其中每个快照默认都是一个字符串。 count{} 函数返回符合某个条件的元素的个数 #七、附录 参考文章： https://www.kotlincn.net/docs/reference/operator-overloading.html https://www.kotlincn.net/docs/reference/lambdas.html","link":"/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/"},{"title":"Kotlin学习系列二：类与接口初解","text":"一、前言 二、类与接口 1. 类定义 1. Kotlin中构造方法使用关键字constructor 2.\b创建构造方法时类内变量分情况判断是否需要初始化值 3. 构造方法分为主构造器与副构造器 2. 类的实例化 3. 接口的定义 4. 接口的实现 5. 抽象类的定义 6. 类的继承 7. 属性Property 1. 属性定义 2. 实现在接口中定义的属性 3. 属性的引用 三、 扩展 1. 扩展方法定义 2. 扩展方法的类型 3. 扩展属性 4. 扩展的能力边界 1. 扩展可以做什么 2. 扩展不可以做什么 5. 使用场景 1. 关注点分离 2. 提高可读性与开发效率 3. 总结 四、空类型安全 1. 空类型异常原因 2. 可空变量属性调用 1. 非空断言运算符!! 2. 安全调用操作符?. 3. elvis运算符?: 3. 空类型的继承关系 4. 平台类型 五、智能类型转换 1. 强制类型转换 2. 类型的安全转换 3. 智能类型转换延伸的几点建议 六、示例–使用Retrofit访问网络请求 七、附录 #一、前言 本文主要讲述Kotlin 类型进阶 本文是对Bennyhuo老师讲解的Kotlin系列视频及朱涛老师讲解的Kotlin编程第一课的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶 kotlin学习系列十一：协程应用 #二、类与接口 #1. 类定义 Kotlin中类的概念与Java中类的概念一致 注意： Kotlin中不加作用域修饰符时默认public Kotlin中类内无内容时可省略{} 类内的变量必须初始化值，否则会报错Variable must be initialized 例： 1234//java中的类定义public class SimpleClass {} 12//kotlin中的类定义class SimpleClass #1. Kotlin中构造方法使用关键字constructor Java中构造方法名称必须与类名一致，且不添加方法返回值，而Kotlin中没有这种限制 例： 1234567//java中构造方法创建public class SimpleClass { public int x; public SimpleClass(int x) { this.x = x; }} 12345678910111213141516//kotlin中构造方法创建class SimpleClass { var x : Int constructor(x:Int) { this.x = x } fun getValue() : Int { return x }}fun main() { val simple = SimpleClass(5) println(simple.getValue())} #2.\b创建构造方法时类内变量分情况判断是否需要初始化值 当类中只有一个带入参的构造方法时，类内声明入参变量时可不初始化值，但是若有无参构造方法则声明变量时一定要初始化值 1234567891011121314151617//kotlin中构造方法创建class SimpleClass { var x : Int = 6 constructor() {} constructor(x:Int) { this.x = x } fun getValue() : Int { return x }}fun main() { val simple = SimpleClass(5) println(simple.getValue())} 如上，当类SimpleClass中有两个构造方法，其中一个是无参构造方法，则变量x需要初始化值 #3. 构造方法分为主构造器与副构造器 如java一般，将构造方法定义在类内，则为副构造器secondary constructor 将构造方法定义在类的定义上，则为主构造器primary constructor 当为主构造器时，可将关键字constructor省略 例： 1234567891011121314151617//副构造器class SimpleClass { var x : Int; constructor(x:Int) { this.x = x; }}//主构造器class SimpleClass constructor(x:Int) { var x : Int = x}//省略关键字的主构造器class SimpleClass (x:Int) { var x : Int = x} 注意： 主构造器要求类内的其它构造器都要调用它 例： 12345678class SimpleClass constructor(x:Int) { var x : Int = x constructor():this(2) {}}class SimpleClass constructor(x:Int = 3) { var x : Int = x} 声明一个主构造器之后又声明了一个无参副构造器，在无参副构造器执行前使用this先执行主构造器，或者在主构造器里为入参赋默认值也可不声明无参副构造器，而调用时不需要传参 如果在主构造器内入参前加上var或val则表示声明一个属性，类内不需要再声明该属性 例： 123class SimpleClass constructor(var x:Int) {} #2. 类的实例化 Kotlin中的实例化不需要new 例： 1234567class SimpleClass constructor(var x:Int) {}fun main() { val simple = SimpleClass(3)} #3. 接口的定义 Kotlin中接口定义使用关键字 interface 例： 123interface SimpleInf { fun simpleMethod()} #4. 接口的实现 Java中接口的实现使用关键字implements，而Kotlin中使用英文冒号: Java中重写使用注解@Override，而Kotlin中使用关键字override，Java中重写可加可不加注解，但Kotlin中一定要加override关键字 例： 1234567//java接口的实现public class SimpleClass implements SimpleInf { @Override public void simpleMethod() { }} 123456//kotlin接口的实现，属性实现方式1class SimpleClass(var x: Int) : SimpleInf { override fun simpleMethod() { }} #5. 抽象类的定义 Kotlin中抽象类定义使用关键字abstract Java中类和方法默认可以被覆写，而Kotlin中默认不可覆写，需要添加关键字open来标识可覆写的类和方法 例： 123456//java抽象类的定义public abstract class AbsClass { public abstract void absMethod(); protected void overridable(){} public final void nonOverridable(){}} 12345678910111213141516//kotlin抽象类的定义及实现abstract class AbsClass { abstract fun absMethod() open fun overridable(){} fun nonOverridable(){}}class AbsClassImpl : AbsClass() { override fun absMethod() { TODO(&quot;Not yet implemented&quot;) } override fun overridable() { super.overridable() }} #6. 类的继承 Java中接口的实现使用关键字extends，而Kotlin中使用英文冒号:，且类需要加一对小括号 Kotlin中使用open标识了某方法可覆写，则类的继承不会改变这种特性，除非在该方法再加上关键字final 例： 1234567//javapublic class SimpleClass extends AbsClass implements SimpleInf { @Override public void simpleMethod() { }} 123456789101112131415161718192021//kotlinopen class SimpleClass(var x:Int) :AbsClass(), SimpleInf { override fun absMethod() { } override fun simpleMethod() { } override fun overridable() { super.overridable() }}open class SimpleClass2 : SimpleClass(3) { final override fun overridable() { super.overridable() }}class SimpleClass3 : SimpleClass2() { //不可再覆写overridable方法} 如上，SimpleClass2继承了SimpleClass，SimpleClass3继承了SimpleClass2。 因SimpleClass类中overridable()方法未做其它关键字修饰，则SimpleClass2可以覆写overridable()方法。 而SimpleClass2类中overridable()方法被关键字final修饰，表示不可再改变，则SimpleClass3不可以覆写overridable()方法。 #7. 属性Property Java中定义属性称之为field，Kotlin中声明的变量称之为property #1. 属性定义 若使用var在类中声明则包含三部分：backing field、get方法、set方法；若使用val声明因不可更改特性，则不包含set方法。 例： 123456789101112131415161718//javapublic class Person { private int age;//field private String name;//field public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 12345678910111213141516171819202122232425262728293031//kotlinclass Person(age:Int, name:String) { val age = age//property var name = name//property}//上述Person类还可写成如下形式，以方便在属性中的get、set方法中做其它操作class Person(age:Int, name:String) { val age = age get() { return field } var name = name get() { return field } set(value) { field = value }}fun main(vararg args:String) { val simpleClass = SimpleClass(3) println(simpleClass.simpleProperty) val person : Person = Person(3, &quot;李四&quot;) println(&quot;Person:age=${person.age},name=${person.name}&quot;) person.name = &quot;王五&quot; //不能为age赋值，因为age被val声明 person.age = 10} Java中接口定义属性，则该属性直接是public且final不可修改，而Kotlin在接口中定义属性不可赋值且需要在实现类里实现，因为在接口中没有backing field 例： 1234interface SimpleInf { val simpleProperty:Int//property fun simpleMethod()} #2. 实现在接口中定义的属性 若Kotlin接口中声明了属性，则在实现类中使用必须实现它，例： 123456789101112131415//kotlin接口的实现，属性实现方式1class SimpleClass(var x: Int) : SimpleInf { override val simpleProperty: Int get() { return 3 } override fun simpleMethod() { }}//属性实现方式二，直接写在主构造器中，初始值在类创建时传入class SimpleClass(override val simpleProperty: Int) : SimpleInf { override fun absMethod() { }} #3. 属性的引用 属性的引用和函数的引用是一样的都是使用双冒号::，例： 1234567891011fun main() { val person : Person = Person(3, &quot;李四&quot;) println(&quot;Person:age=${person.age},name=${person.name}&quot;) val ageRef = Person::age val nameRef = Person::name nameRef.set(person, &quot;王五&quot;) val ageRef2 = person::age val nameRef2 = person::name nameRef2.set(&quot;王五&quot;)} 其中，变量ageRef和ageRef2类型为KProperty0&lt;Int&gt;，变量ageRef2和nameRef2类型为KMutableProperty0&lt;String&gt; #三、 扩展 Kotlin能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。例如，可以为一个不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为扩展函数。此外，也有扩展属性， 允许你为一个已经存在的类添加新的属性。 #1. 扩展方法定义 与类外函数定义差不多，只是在函数名前加一个receiver，表示定义的函数是这个receiver类的方法。例： 1234567891011fun main(vararg args:String) { val list = mutableListOf&lt;Int&gt;(1,2,3,4,5) println(list) list.swap(0,4)//交换下标0，4位置的元素 println(list)}fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) { val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp} 如上，为MutableList&lt;Int&gt;类添加了一个扩展方法，该方法名为swap，作用为交换两个位置的元素。this关键字在扩展函数内部对应到receiver对象（传过来的在点符号前的对象）。 扩展不能真正的修改他们所扩展的类 通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。 扩展其实是生成一个静态方法，其参数是它声明时点前的receiver, 如上为MutableList&lt;Int&gt;类添加了一个方法名为swap扩展方法反编译为： 12345678public final class KotlinLabKt { public static final void swap(@NotNull List&lt;Number&gt; $this$swap, int index1, int index2) { Intrinsics.checkNotNullParameter($this$swap, &quot;$this$swap&quot;); int tmp = ((Number)$this$swap.get(index1)).intValue(); $this$swap.set(index1, $this$swap.get(index2)); $this$swap.set(index2, Integer.valueOf(tmp)); }} 扩展是静态的 扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。 如果类本身和其子类都进行了同一个函数的扩展，这函数是不会有重写关系的，在使用的时候，只会根据需要使用该方法的对象的实际类型来决定是调用了哪个，就是相当于调用静态方法。而不是动态分派。 例： 123456789101112open class Shapeclass Rectangle: Shape()fun Shape.getName() = &quot;Shape&quot;fun Rectangle.getName() = &quot;Rectangle&quot;fun printClassName(s: Shape) { println(s.getName())} printClassName(Rectangle()) 打印结果是Shape因为s的类型是Shape 成员函数与扩展函数 如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。但是，扩展函数可以重载同样名字但不同签名成员函数 扩展的receiver可以为空 注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象(即Any)变量上调用， 即使其值为null，并且可以在函数体内检测this == null，这能让你在没有检测null的时候调用Kotlin中的toString()。例： 123456fun Any?.toString2(): String { if (this == null) return &quot;null&quot; // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()} #2. 扩展方法的类型 123456789//定义一个String类的扩展方法fun String.times(count:Int):String { return count.toString()}fun main() { val str1 = (String::times)(&quot;str&quot;, 3) val str2 = (&quot;*&quot;::times)(3)} 其中str1使用的是未绑定receiver的函数引用，其类型为(String, Int) -&gt;String，str2使用的是绑定receiver的函数引用，其类型为(Int) -&gt;String #3. 扩展属性 与函数类似，Kotlin 支持扩展属性，例： 12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 由于扩展没有实际的将成员插入类中，因此对扩展属性来说backing field(即存储空间)是无效的，不能存值。所以扩展属性不能有初值。他们的行为只能由显式提供的 getters/setters 定义。但是扩展属性可通过this来获取类中的成员变量。例： 123456789101112class PoorGuy{ var pocket: Double = 0.0}var PoorGuy.monkeyLeft : Double get() { return this.pocket } set(value) { pocket = value } backing field无效的还有在接口中定义的属性。接口中只能定义行为，不能持有状态 123456789interface Guy { var moneyLeft: Double get() { return 0.0 } set(value) { }} 而在接口中的属性可以写get和set方法，是因为接口方法的默认实现 #4. 扩展的能力边界 扩展虽然看起来很神奇，但也并不是无所不能的 #1. 扩展可以做什么 当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。在Kotlin中几乎所有的类都可以被扩展，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的java类。唯有匿名内部类，因为他本身不存在名称，我们无法指定receiver，所以不能被扩展。 可以说，Kotlin的扩展应用范围还是非常广的。它最主要的用途，就是 用来取代Java当中的各种工具类，比如 StringUtils、DateUtils等等。 所有Java工具类能做的事情，Kotlin扩展函数都可以做，并且可以做得更好。扩展函数优势在于，开发工具可以在编写代码的时候智能提示。 #2. 扩展不可以做什么 Kotlin 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。 Kotlin 扩展不是真正的类成员，因此它无法被继承它的子类重写。 扩展属性无法存储状态。扩展属性本身没有状态，也无法存储状态。因为它都是静态方法。 扩展的 访问 作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。 如果扩展是顶层的扩展，那么扩展的访问域仅限于该 Kotlin 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。 如果扩展是被定义在某个类当中的，那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。 #5. 使用场景 #1. 关注点分离 Kotlin 标准库当中的 String.kt源代码 如下所示： 12345678910111213141516171819202122232425package kotlinpublic class String : Comparable&lt;String&gt;, CharSequence { companion object {} @kotlin.internal.IntrinsicConstEvaluation public operator fun plus(other: Any?): String @kotlin.internal.IntrinsicConstEvaluation public override val length: Int @kotlin.internal.IntrinsicConstEvaluation public override fun get(index: Int): Char public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence @kotlin.internal.IntrinsicConstEvaluation public override fun compareTo(other: String): Int @kotlin.internal.IntrinsicConstEvaluation public override fun equals(other: Any?): Boolean @kotlin.internal.IntrinsicConstEvaluation public override fun toString(): String} 可以看到Kotlin 里面的 String 类竟然只有这些代码。那么，String 类的那些字符操作的方法到哪里去了？比如，String.substring()、String.toLowerCase() 它们定义在什么地方？实际上，String 相关的操作方法全都放到了Strings.kt当中去了。而这些字符操作方法全部都是以扩展函数的方式定义的，Strings.kt部分源码如下： 12345678910// Strings.kt 部分代码package kotlin.text@Deprecated(&quot;Use uppercase() instead.&quot;, ReplaceWith(&quot;uppercase()&quot;))@DeprecatedSinceKotlin(warningSince = &quot;1.5&quot;)public expect fun String.toUpperCase(): String@kotlin.internal.InlineOnlypublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString() 这就是 Kotlin 扩展的第一个典型使用场景：关注点分离 。所谓 关注点分离 ，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以上面的 String 类为例，String.kt这个类，只关注 String 的核心逻辑；而Strings.kt则只关注 String 的操作符逻辑。 #2. 提高可读性与开发效率 12345678910111213141516171819202122232425262728inline fun &lt;reified T : ViewGroup.LayoutParams&gt; View.updateLayoutParams(block: T.() -&gt; Unit) { val params = layoutParams as T block(params) layoutParams = params}fun View.updateMargin(left: Int? = null, top: Int? = null, right: Int? = null, bottom: Int? = null) { (layoutParams as? ViewGroup.MarginLayoutParams)?.let { param -&gt; updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; { left?.let { marginStart = left } right?.let { marginEnd = right } top?.let { topMargin = top } bottom?.let { bottomMargin = bottom } } }} 上面的代码定义了两个扩展函数，updateLayoutParams()、updateMargin()，后者的方法体当中用到了前者。通过 updateMargin() 这个扩展函数，可以大大简化 Android 当中的 margin 更新。 1view.updateMargin(top = 100, bottom = 100) 而如果不借助扩展函数，我们将不得不写一堆的模板代码： 1234567val params = view.layoutParamsif (params is ViewGroup.MarginLayoutParams) { params.marginTop = 100 params.marginBottom = 100 view.layoutParams = params} 可以看到，借助扩展函数，我们不仅提升了代码的可读性，还提升了编码效率，而这种效率可以说是成倍的提升：借助扩展函数，我们只需要写一行代码，IntelliJ 还会智能提示，帮我们补全代码；不借助扩展函数的话，我们需要写 5 行代码，这样的代码模式不仅枯燥繁琐，IntelliJ 也无法智能提示，也更容易出错。 #3. 总结 Kotlin 扩展主要有两个核心使用场景： 主动使用扩展，通过它来优化软件架构。 对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的String.kt与Strings.kt。 被动使用扩展，提升可读性与开发效率。 当我们无法修改外部的 SDK 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如 view.updateMargin()。 #四、空类型安全 #1. 空类型异常原因 Kotlin 的类型系统旨在消除来自代码空引用的危险的，Kotlin 中唯一可能引起空类型异常原因可能是： 显式调用throw NullPointerException() 使用了下文描述的 !! 操作符； 有些数据在初始化时不一致，例如当： 传递一个在构造函数中出现的未初始化的 this 并用于其他地方（“泄漏 this”）； 超类的构造函数调用一个开放成员，该成员在派生中类的实现使用了未初始化的状态； Java 互操作： 企图访问平台类型的 null 引用的成员； 用于具有错误可空性的 Java 互操作的泛型类型，例如一段 Java 代码可能会向 Kotlin 的 MutableList&lt;String&gt; 中加入 null，这意味着应该使用 MutableList&lt;String?&gt; 来处理它； 由外部 Java 代码引发的其他问题。 声明变量时，在不支持空类型的类型后面加一个 ?，表示该变量可为空，例： 1var nullable: String? = &quot;Hello&quot; 调用可空变量的属性时会报编译错误。 #2. 可空变量属性调用 #1. 非空断言运算符!! 作用： 将任何值转换为非空类型，若该值为空则抛出异常。 注意： 使用时一定要确定可空变量一定不为空。 使用方法： 在调用时变量后跟 !! 将变量强转为不可空类型，例： 1val length = nullable!!.length 若nullable为空，则会报错NullPointerException，否则返回nullable.length的值，变量length不会为空 #2. 安全调用操作符?. 作用： 如果变量非空，就返回调用的变量属性，否则返回null 注意： 可能返回null 使用方法： 在调用时变量后跟 ？ 表示可空变量的属性变量也可能为空。例： 安全调用也可以出现在赋值的左侧。这样，如果调用链中的任何一个接收者为空都会跳过赋值，而右侧的表达式根本不会求值 1val length = nullable?.length //表示length变量也是可空的 若nullable为空，则返回null，否则返回nullable.length的值，变量length可能会空 #3. elvis运算符?: 作用： 若运算符左侧非空，就返回运算符左侧表达式，否则返回运算符右侧非空值 注意： 当且仅当左侧为空时，才会对右侧表达式求值。 1val length nullable?.length ?:0 如果nullable.length为空，则返回0，所以变量length不会为空。 #3. 空类型的继承关系 空类型可接收对应非空类型变量 1234567891011var x: String = &quot;hello&quot;var y: String? = &quot;world&quot;x = y // Type mismatchy = x // OKvar a: Int = 0var b: Number = 10.1a = b // Type mismatchb = a // OK #4. 平台类型 客观存在，不能主观定义，指kotlin外其它语言平台的类型，在kotlin中的表现为其它语言平台类型后面加!，例： 123456//javapublic class Person { public String getTitle() { return null; }} 在kotlin中调用 12val person = Person()val title = person.title 其中变量title就是Java平台中的String类型，该类型表示形式为String!，但不可自定义。 kotlin不能推断出平台类型是否为空，即调用平台类型的属性时最好使用安全调用操作符?. 12val titleLength = title.length // 直接报空指针错误val titleLength = title?.length // #五、智能类型转换 #1. 强制类型转换 Kotlin中如果之前已经判断过某变量是某类型，则不需要再强转为该类型，Kotlin可以自动转换为该类型，而可以直接使用。 1234567891011//java 定义一个接口和一个实现该接口的类public interface Kotliner{}public class Person implements Kotliner { public final String name; public final int age; public Person(String name, int age) { this.name = name; this.age = age; }} java的类型转换 1234Kotliner kotliner = new Person(&quot;Lee&quot;, 20);if (kotliner instanceof Person) { System.out.println(((Person)kotliner).name);} 其中已使用操作符instanceof判断变量kotliner为Person类型，但是在调用name属性时仍需要强制转换为Person kotlin的类型转换 12345val kotliner: Kotiner = Person(&quot;Lee&quot;, 20)if (kotliner is Person) { println((kotliner as Person).name) println(kotliner.name)} 操作符is 类似于Java中的instanceof，用于判断某变量是否属于某个类型 操作符as 将某变量强制转换为某类型 kotlin智能类型转换自动将变量kotliner转换为了Person类型，所以上述两个输出语句等价 类型自动转换作用范围：在if语句之内是转换后的类型，在if语句之外还是之前类型 不支持智能转换的情况 定义的顶级property,在多个方法里都可以调用，虽然在某个方法中调用时判断了该变量是某个值，但是其它线程可能对它做修改，所以不支持智能转换。 123456var tag : String? = nullfun main() { if (tag != null) { println(tag.length) }} 上述代码会在tag.length报错Smart cast to 'String' is impossible, because 'tag' is a mutable property that could have been changed by this time，即无法将类型强制转换为“字符串”，因为“tag”是可变属性，而此时可能已更改 #2. 类型的安全转换 强制转换时要考虑空情况 12val kotliner: Kotiner = Person(&quot;Lee&quot;, 20)println((kotliner as? Person)?.name) 上述代码，在将变量kotliner通过操作符as强制转换为Person时添加了操作符?，表示如果强制转换失败的话返回null，又因变量kotliner强转后的结果可能为null，则调用name属性之前也要加操作符?以判断非空时再调用name属性 #3. 智能类型转换延伸的几点建议 尽可能使用val来声明不可变引用，让程序含义更加清晰确定 尽可能减少函数对外部变量的访问，也为函数式编程提供基础 必要时创建局部变量指向外部变量，避免因它变化引起程序错误 #六、示例–使用Retrofit访问网络请求 1234567891011121314151617181920212223242526272829303132333435interface GitHubApi { @GET(&quot;/repos/{owner}/{repo}&quot;) fun getRespository(@Path(&quot;owner&quot;) owner: String, @Path(&quot;repo&quot;) repo:String): Call&lt;Respository&gt;}fun main() { val gitHubApi = Retrofit.Builder().baseUrl(&quot;https://api.github.com&quot;) .addConverterFactory(GsonConverterFactory.create()) .build() .create(GitHubApi::class.java) val response = gitHubApi.getRespository(&quot;JetBrains&quot;, &quot;Kotlin&quot;).execute() val repository = response.body() if (repository == null) { println(&quot;Error! ${response.code()} - ${response.message()}&quot;) } else { println(repository.name) println(repository.full_name) println(repository.owner.login) File(&quot;Kotlin.html&quot;).writeText(&quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;${repository.owner.login} - ${repository.name}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;a href='${repository.html_url}'&gt;${repository.owner.login} - ${repository.name}&lt;/a&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;.trimIndent()) }} 获取kotlin项目在GitHub中的一些数据，并将其生成一个网页文件。其中的Respository数据类可使用Android Studio的插件NewDataClassAction生成。 #七、附录 参考文章： https://www.kotlincn.net/docs/reference/null-safety.html https://www.kotlincn.net/docs/reference/properties.html https://www.kotlincn.net/docs/reference/extensions.html","link":"/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/"},{"title":"kotlin学习系列六：泛型","text":"一、前言 二、泛型的基本概念 1. 基本声明 1. 函数声明泛型 2. 类声明泛型 3. 使用 4. Nothing 三、泛型约束 1. 添加泛型约束 2. 添加多个约束 3. 多个泛型参数 四、泛型型变 1. 不变 2. 协变 1. 实现协变 2. 协变点 3. 协变-List的源码分析 3. 逆变 1. 实现逆变 2. 逆变点 3. 逆变-Comparable的源码分析 4. UnsafeVariance注解 5. 型变总结 五、 星投影 1. 星投影定义 1. 协变点示例 2. 逆变点示例 2. 适用范围 六、协变、逆变、不变的规则思考 七、泛型实现原理及内联特化 1. 泛型实现原理 1. 泛型擦除 2. 泛型实现对比 2. 内联特化 1. 内联特化概念 2. 内联特化实际应用 八、 示例 1. 模拟 Self Type 1. Builder模式中的类型继承问题 2. Scala的Self Type 3. 使用泛型模拟Self Type 2. 基于泛型实现Model实例的注入 1. 使用注入的地方 2. 通过代理方式实现注入 1. 实现方式一 实现方式二 九、参考文章 #一、前言 本文主要讲述Kotlin 泛型 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶 kotlin学习系列十一：协程应用 #二、泛型的基本概念 泛型是一种类型层面的抽象 泛型通过泛型参数实现构造更加通用的类型的能力 泛型可以让符合继承关系的类型批量实现某些能力 #1. 基本声明 使用泛型前要先用尖括号声明泛型 #1. 函数声明泛型 1234567package kotlin.comparisons@SinceKotlin(&quot;1.1&quot;)public actual fun &lt;T : Comparable&lt;T&gt;&gt; maxOf(a: T, b: T): T { return if (a &gt;= b) a else b} 说明： 函数声明泛型，泛型的声明要放到函数名之前 如上代码是比较大小的源码，比较两个泛型对象大小，返回较大的对象 上述代码声明了一个泛型T该泛型代表的类型要实现Comparable接口，以确保可以比较大小 #2. 类声明泛型 12345678sealed class List&lt;T&gt; { object Nil: List&lt;Nothing&gt;() { //... } data class Cons&lt;E&gt; (val head: E, val tail:List&lt;E&gt;): List&lt;E&gt;() { //... }} 说明： 在类上声明泛型时，泛型声明位于类名后 Nothing类是所有类型的子类 数据类Cons的泛型声明，是声明了一个泛型形参，而它实现List类时将这个形参作为一个实参传递给了密封类List #3. 使用 声明泛型时只是声明了泛型形参，而调用时传递进去一个具体类型的实参 123val max = maxOf(&quot;Hello&quot;, &quot;World&quot;)println(max)//val list = List.Cons&lt;Double&gt;(1.0, List.Nil) #4. Nothing 12package kotlinpublic class Nothing private constructor() 说明： Kotlin 里所有东西都有类型，而且有明显的层级关系如上图所示 Kotlin类型层次结构的最底层就是类型 Nothing ，最顶层是类型Any?，即Nothing类是所有类型的子类，Any?类是所有类型的父类 Nothing类型的表达式计算结果是永远不会返回的 （跟Java 中的 void 相同） Nothing的构造方法私有的，所以是没有实例的。可以使用Nothing来表示“一个不存在的值” Nothing?可以只包含一个值：null 参考文章1 参考文章2 参考文章3 图中线条颜色无实际意义，只为了方便查看 #三、泛型约束 #1. 添加泛型约束 在声明泛型时通过继承父类或实现接口的方式为泛型添加约束 123456package kotlin.comparisons@SinceKotlin(&quot;1.1&quot;)public actual fun &lt;T : Comparable&lt;T&gt;&gt; maxOf(a: T, b: T): T { return if (a &gt;= b) a else b} 12345//javapublic static &lt;T extends Comparable&lt;T&gt;&gt; T maxOf(T a, T b) { if (a.compareTo(b) &gt; 0) return a; return b;} 说明： 如上代码所示，方法maxOf()比较两个泛型类型的大小 : Comparable&lt;T&gt;强制要求传入的泛型参数，必须是 Comparable 或者是它的子类。这叫做泛型的上界。 Java中也是通过继承父类或实现接口的方式为泛型添加约束 #2. 添加多个约束 实现目标：比较两个类大小，并调用较大类的invoke()方法 1234//kotlinfun &lt;T&gt; callMax(a: T, b: T) where T : Comparable&lt;T&gt;, T : () -&gt; Unit { if (a &gt; b) a() else b()} 说明： 通过where语句为泛型添加多个约束 如上代码所示，泛型T必须实现接口Comparable能比较大小，而且是一个返回值是Unit的函数支持invoke()方法 12345//javapublic static &lt;T extends Comparable&lt;T&gt; &amp; Supplier&lt;R&gt;, R extends Number&gt; R callMax(T a, T b) { if (a.compareTo(b) &gt; 0) return a.get(); return b.get();} 说明： 如上所示，在声明泛型T时为它添加了约束, 它必须是Comparable和Supplier的，并且返回结果必须是数值型的 #3. 多个泛型参数 123fun &lt;T,R&gt; callMax(a:T, b:T) where T: Comparable&lt;T&gt;, T:()-&gt;R, R: Number { if (a &gt; b) a() else b()} 说明： 如上代码所示，声明了两个泛型：T代表要比较的类，R代表比较类的返回值是R 要比较的类型T必须实现接口Comparable，而且是一个返回值是数值类型的R的函数 #四、泛型型变 任何时候期望A类型的值时，可以使用B类型的值,则B就是A的 子类型 超类型是子类型的反义词。如果B是A的子类型，那么反过来A就是B的 超类型 首先，型变是什么呢？简单来说，它就是为了解决 泛型的不变性问题。事实上，型变讨论的是：在已知 经 Cat 是 Animal 的子类的情况下，MutableList&lt;Cat&gt; 与 MutableList&lt;Animal&gt; 之间是什么关系。 在正常情况下，编译器会认为它们两者是没有任何关系的。换句话，也就是说，泛型是不变的。Kotlin 编译器会这样处理的原因也很简单，这里我们可以先来假设一下：如果编译器不阻止我们用MutableList&lt;Cat&gt; 替代 MutableList&lt;Animal&gt;，当程序需要 Animal 的集合时，如果我们传入的是 Cat 的集合，我们就可以往 Cat集合 里添加其他类型的动物，比如 Dog。然而，Dog 是无法存入 Cat 的集合的。 那如果反过来，当需要子类集合传入父类集合的时候，我们在函数体内部存储的行为是不会受到影响的，存储 Cat、Animal 类型都没问题。可是，一旦我们想从集合当中取出 Cat 对象的时候，会发现取出来的是 Animal 对象，这时候又错了。 这就造成了类型不一致的可能性，无法确保类型安全，违背了泛型引入的初衷 —— 确保类型安全。 所以，在默认情况下，编译器会认为 MutableList&lt;Cat&gt; 与 MutableList&lt;Animal&gt; 之间不存在任何继承关系，它们也无法互相替代，这样就不会出现前面提到的两种问题。这就是 泛型的不变性。 而Java提供了 有限制的通配符 来确保类型安全，允许泛型类构建相应的子类型化关系，提高代码的通用性(灵活性)。与之对应的，便是Kotlin的型变。Kotlin中存在协变和逆变两种概念 泛型型变有三类：不变、协变、逆变 #1. 不变 泛型形参没有继承关系，泛型实参也没有继承关系 1234567891011sealed class List&lt;T&gt; { object Nil:List&lt;Nothing&gt;() //... data class Cons&lt;E&gt; (val head: E, val tail:List&lt;E&gt;): List&lt;E&gt;() { //... }}fun main() { val list = List.Cons(1.0, List.Nil)} 说明： 声明的泛型T之前 没有任何修饰词 ，表示泛型型变不变，即泛型没有任何继承关系 List&lt;Nothing&gt;不是List&lt;T&gt;的子类，List.Nil也不是List&lt;T&gt;的子类 List.Nil不能满足List&lt;T&gt;，所以list的赋值语句会报错 不变型就是没有子类型化关系，所以它会有一个局限性就是如果以它作为函数形参类型，外部传入只能是和它相同的类型，因为它根本就不存在子类型化关系说法，那也就是没有任何类型值能够替换它，除了它自己本身的类型 例如MutableList&lt;String&gt;和MutableList&lt;String?&gt;是完全两种不一样的类型，尽管String是String?子类型，但是基础泛型MutableList&lt;E&gt;是不变型的，所以MutableList&lt;String&gt;和MutableList&lt;String?&gt;根本没关系。 1234interface MutableList&lt;E&gt;{//没有in和out修饰 fun add(element: E)//E可以作为函数形参类型处于逆变点，输入消费E fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;//E又可以作为函数返回值类型处于协变点，生产输出E} #2. 协变 #1. 实现协变 泛型形参的继承关系与泛型实参的继承关系一致 123456789101112131415161718192021open class Book{}class EduBook: Book() {}class BookStore&lt;T&gt; { fun getBook(): T { TODO() }}fun buyBook(store: BookStore&lt;Book&gt;) { store.getBook()}fun main() { //声明了一家教育类书店 val edu = BookStore&lt;EduBook&gt;() //需要普通类型书店，传入了教育类书店，编译器报错 buyBook(edu)} 说明： 如上声明了几个类：Book、Book的子类EduBook以及书店类 BookStore 在书店类BookStore的泛型参数处，可以传入不同的书的类型，就代表不同类型的书店 之后又定义了买书方法buyBook()方法，该方法传入一个书店然后购买该书店的图书 最后在main()方法中声明了一家教育类型书店edu，然后将该书店作为参数传入buyBook()方法，结果编译器报错：Type mismatch. Required: BookStore&lt;Book&gt; Found: BookStore&lt;EduBook&gt;，因为buyBook()需要BookStore&lt;Book&gt;，而传入了BookStore&lt;EduBook&gt;，类型不匹配 所有书店都应该可以购买图书，由于编译器认死理，我们必须额外提供一些信息给编译器，让它知道我们是在特殊场景使用泛型。具体的做法有两种。 第一种做法，修改泛型参数的使用处，也就是 使用处型变。具体的做法就是修改 buyBook() 函数的声明，在 Book 的前面增加一个 out 关键字： 123fun buyBook(store: BookStore&lt;out Book&gt;) { store.getBook()} 第二种做法，是修改 BookStore 的源代码，也就是声明处型变。具体做法就是，在它泛型形参 T 的前面增加一个关键字 out： 12345class BookStore&lt;out T&gt; { fun getBook(): T { TODO() }} 说明： 在做完以上任意一种修改以后，代码就可以通过编译了。这也就意味着，在这种情况下，我们可以使用BookStore&lt;EduBook&gt;替代BookStore&lt;Book&gt;，也就意味着BookStore&lt;EduBook&gt;可以看作是BookStore&lt;Book&gt;的子类。 由上图可知，图书与书店它们之间的父子关系一致了。这种现象，我们称之为 “泛型的协变” 。也可以说两个具有相同的基础类型的泛型协变类型，如果类型实参具有子类型化关系，那么这个泛型类型具有一致方向的子类型化关系。上面两种修改的方式，就分别叫做 使用处协变 和 声明处协变 。kotlin中泛型的协变out对应Java中的? extend 操作 #2. 协变点 Kotlin 中规定一个泛型协变类，在泛型形参前面加上out修饰后，那么修饰这个泛型形参在函数内部使用范围将受到限制只能作为函数的返回值或者修饰只读权限的属性。 协变点： 在一个类里的函数的返回值为我们定义的泛型参数，则该函数返回的泛型参数为协变点 1234interface Producer&lt;out T&gt; {//在泛型类型形参前面指定out修饰符 val something: T//T作为只读属性的类型，这里T的位置也是out协变点 fun produce(): T//T作为函数的返回值输出给外部,这里T的位置就是out协变点} 以上协变点都是标准的T类型，实际上以下这种方式其实也是协变点,请注意体会协变点含义: 12345interface Producer&lt;out T&gt; { val something: List&lt;T&gt;//即使T不是单个的类型，但是它作为一个泛型类型修饰只读属性，所以它所处位置还是out协变点 fun produce(): List&lt;Map&lt;String,T&gt;&gt;//即使T不是单个的类型，但是它作为泛型类型的类型实参修饰返回值，所以它所处位置还是out协变点} 协变点基本特征: 如果一个泛型类声明成协变的，用out修饰的那个类型形参，在函数内部出现的位置只能在只读属性的类型或者函数的返回值类型。相对于外部而言协变是生产泛型参数的角色，生产者向外输出out #3. 协变-List的源码分析 123456789101112131415161718//通过泛型类定义可以看出使用out修饰符 修饰泛型类型形参Epublic interface List&lt;out E&gt; : Collection&lt;E&gt; { override val size: Int override fun isEmpty(): Boolean override fun contains(element: @UnsafeVariance E): Boolean//咦! 咦! 咦! 和说的不一样啊，为什么还能出现在这个位置，还出来了个@UnsafeVariance 这个是什么鬼？ 告诉你，稳住，先不要急，请听我在后面慢慢说来，先暂时保留神秘感 override fun iterator(): Iterator&lt;E&gt;//这里明显能看出来E处于out协变点位置，而且还是泛型类型Iterator&lt;E&gt;出现的，正好验证我们上述所说的协变的变种类型(E为类型实参的泛型类型) override fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean public operator fun get(index: Int): E//函数返回值的类型E，这里明显能看出来E处于out协变点位置，正好验证我们上述所说的协变的标准类型(E直接为返回值的类型) public fun indexOf(element: @UnsafeVariance E): Int public fun lastIndexOf(element: @UnsafeVariance E): Int public fun listIterator(): ListIterator&lt;E&gt;//(E为类型实参的泛型类型),为out协变点 public fun listIterator(index: Int): ListIterator&lt;E&gt;//(E为类型实参的泛型类型),为out协变点 public fun subList(fromIndex: Int, toIndex: Int): List&lt;E&gt;//(E为类型实参的泛型类型),为out协变点} #3. 逆变 #1. 实现逆变 泛型形参的继承关系与泛型实参的继承关系相反 123456789101112open class TV { open fun turnOn() {}}class HuaWeiTV: TV() { override fun turnOn() {}}class Controller&lt;T&gt; { fun turnOn(tv: T) {}} 说明： 声明了两个类：父类电视类TV，子类华为电视类HuaWeiTV，它们两者是继承关系。由于它们是父子的关系，当函数的参数需要 TV 这个父类的时候，我们是可以传入子类HuaWeiTV作为参数的。 声明了遥控器类Controller，它有一个turnOn()方法用于打开电视 12345678// 需要一个华为电视的遥控器// ↓fun buy(controller: Controller&lt;HuaWeiTV&gt;) { val huaWeiTV = HuaWeiTV() // 打开华为电视 controller.turnOn(huaWeiTV)} 在上面的代码中，我们的buy()函数需要一个“华为电视的遥控器”，在函数的内部，我们需要打开华为电视。那么，当我们需要打开一台华为电视机的时候，我们是否可以用一个“万能的遥控器”呢？当然可以！所以，我们可以写出下面这样的代码： 12345678fun main() {// 实参// ↓ val controller = Controller&lt;TV&gt;() // 传入万能遥控器，报错 buy(controller)} 在这段代码中，由于我们传入的泛型实参是 TV，它是所有电视机的父类。因此，Controller 内部将会处理所有电视机型号的开机、关机。这时候，它就相当于一个万能遥控器，万能遥控器当然也可以打开华为电视。从道理上来讲，我们的推理是没有错的，不过 Kotlin 编译器会报错，报错的内容是说“类型不匹配”，需要的是华为遥控器Controller&lt;HuaWeiTV&gt;，你却买了个万能遥控器Controller&lt;TV&gt;。 所以，为了让我们的代码通过编译，我们需要主动告诉编译器一些额外的信息，具体的做法有两种。 第一种做法，是修改泛型参数的使用处代码，它叫做使用处型变。具体做法就是修改 buy 函数的声明，在 HuaWeiTV 的前面增加一个 in 关键字： 12345678// 需要一个华为电视的遥控器// ↓fun buy(controller: Controller&lt;in HuaWeiTV&gt;) { val huaWeiTV = HuaWeiTV() // 打开华为电视 controller.turnOn(huaWeiTV)} 第二种做法，是修改 Controller 的源代码，这叫声明处型变。具体做法就是，在泛型形参 T 的前面增加一个关键字 in： 123456// 变化在这里// ↓class Controller&lt;in T&gt; { fun turnOn(tv: T)} 我们使用以上任意一种方式修改后，代码就能够通过 Kotlin 编译了。这样修改之后，我们就可以使用Controller&lt;TV&gt;来替代Controller&lt;HuaWeiTV&gt;，也就是说，Controller&lt;TV&gt;是Controller&lt;HuaWeiTV&gt;的子类。 在这个场景下，遥控器与电视机之间的父子关系颠倒了。“华为电视”是“电视”的子类，但是，“万能遥控”成了“华为遥控”的子类。这种父子关系颠倒的现象，我们就叫做 “泛型的逆变”。也可以说两个具有相同的基础类型的泛型逆变类型，如果类型实参具有子类型化关系，那么这个泛型类型具有相反方向的子类型化关系。上面这两种修改方式，就分别叫做使用处逆变和声明处逆变。 #2. 逆变点 Kotlin中规定一个泛型协变类，在泛型形参前面加上out修饰后，那么修饰这个泛型形参在函数内部使用范围将受到限制只能作为函数的返回值或者修饰只读权限的属性。 逆变点： 在一个类里的函数的入参为我们定义的泛型参数，则该函数形参的泛型参数为逆变点 1234interface Consumer&lt;in T&gt;{//在泛型类型形参前面指定in修饰符 var something: T //T作为可变属性的类型，这里T的位置也是in逆变点 fun consume(value: T)//T作为函数形参类型，这里T的位置也就是in逆变点} 和协变类似，逆变也存在那种泛型类型处于逆变点的位置，这些我们都可以把当做逆变点: 1234interface Consumer&lt;in T&gt;{ var something: B&lt;T&gt;//这里虽然是泛型类型但是T所在位置依然是修饰可变属性类型，所以仍处于逆变点 fun consume(value: A&lt;T&gt;)//这里虽然是泛型类型但是T所在位置依然是函数形参类型，所以仍处于逆变点} 逆变点基本特征: 如果一个泛型类声明成逆变的，用in修饰泛型类的类型形参，在函数内部出现的位置只能是作为可变属性的类型或者函数的形参类型。相对于外部而言逆变是消费泛型参数的角色，消费者请求外部输入in #3. 逆变-Comparable的源码分析 在Kotlin中其实最简单的泛型逆变的例子就是Comparable&lt;in T&gt; 12345678public interface Comparable&lt;in T&gt; {//泛型逆变使用in关键字修饰 /** * Compares this object with the specified object for order. Returns zero if this object is equal * to the specified [other] object, a negative number if it's less than [other], or a positive number * if it's greater than [other]. */ public operator fun compareTo(other: T): Int//因为是逆变的，所以T在函数内部出现的位置作为compareTo函数的形参类型，可以看出它是属于消费泛型参数的} #4. UnsafeVariance注解 型变点与泛型参数定义不一致时可以使用注解UnsafeVariance来使编译器停止警告。 即：只要函数内部能保证不会对泛型参数存在写操作的行为，可以使用UnSafeVariance注解使编译器停止警告，就可以将其放在in位置。out关键字修饰的泛型参数也是同理。 示例： 123456789101112package kotlin.collectionsexpect class ArrayList&lt;E&gt; : MutableList&lt;E&gt;, RandomAccess { override val size: Int override fun isEmpty(): Boolean override fun contains(element: @UnsafeVariance E): Boolean override fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean override operator fun get(index: Int): E override fun indexOf(element: @UnsafeVariance E): Int override fun lastIndexOf(element: @UnsafeVariance E): Int ...} 如上所示Kotlin的ArrayList中contains等函数，就是应用UnSafeVariance注解使泛型参数存在于in位置，其内部没有写操作。 #5. 型变总结 协变 逆变 不变 结构 Producer Consumer Java实现 Producer&lt;? extends T&gt; Consumer&lt;? super T&gt; 子类型化关系 保留子类型化关系 逆转子类型化关系 位置 out位置 in位置 角色 生产者 消费者 表现 只读 只写，读取受限 使用泛型时，选择型变类型： 首先需要考虑泛型形参的位置：只读操作(协变或不变)、只写读操作(逆变或不变)、又读又写操作（不变）。 例如：Array中存在又读又写的操作，如果为其指定协变或逆变，都会造成类型不安全： 1234class Array&lt;T&gt;(val size: Int) { fun get(index: Int): T { …… } fun set(index: Int, value: T) { …… }} 最后判断是否需要子类型化关系，子类型化关系主要用于提高API的灵活度。 如果需要子类型化关系，则只读操作(协变或不变)选择协变，否则不变;只写读操作(逆变或不变),选择逆变，否则不变。 #五、 星投影 #1. 星投影定义 所谓的星投影，其实就是用 “星号” 作为泛型的实参。那么，什么情况下，我们需要用星号作为泛型实参呢？答案其实也很简单，当我们不关心实参到底是什么的时候。举个例子，我们现在需要开发一个“找饭店”的功能，借助泛型，我们可以写出这样的代码： 1fun &lt;T&gt; findRestaurant(): Restaurant&lt;T&gt; {} 不过，如果我们并不关心找到的饭店到底是什么类型，不管它是肯德基还是麦当劳的话，那么，我们就完全可以把“星号”作为泛型的实参，比如这样： 12345678910111213class Restaurant&lt;out T&gt; { fun orderFood(): T {}}// 把星号作为泛型实参// ↓fun findRestaurant(): Restaurant&lt;*&gt; {}fun main() { val restaurant = findRestaurant() // 注意这里 val food: Any? = restaurant.orderFood() // 返回值可能是：任意类型} 在上面的代码当中，我们没有传递任何具体的类型给 Restaurant，而是使用了“星号”作为 Restaurant 的泛型实参，因此，我们就无法知道饭店到底是什么类型。相应的，当我们调用 restaurant.orderFood() 的时候，就无法确定它返回的值到底是什么类型。这时候，变量 food 的实际类型可能是任意的，比如 String、Int、Food、KFC，甚至可能是 null，因此，在这里我们只能将其看作是“Any?”类型。那么，对于上面的这种 food 可能是任意类型的情况，我们有没有办法让 food 的类型更加精确一些呢？当然是有的。如果我们为 Restaurant 的泛型类型加上边界的话，food 的类型就可以更精确一些。 123456789101112131415// 区别在这里// ↓class Restaurant&lt;out T: Food&gt; { fun orderFood(): T {}}fun findRestaurant(): Restaurant&lt;*&gt; {}fun main() { val restaurant = findRestaurant() // 注意这里 // ↓ val food: Food = restaurant.orderFood() // 返回值是：Food或其子类} 从这个例子我们能看到，当我们为 Restaurant 泛型类型增加了上界 Food 以后，即使我们使用了“星投影”，也仍然可以通过调用 restaurant.orderFood()，来拿到 Food 类型的变量。在这里，food 的实际类型肯定是 Food 或者是 Food 的子类，因此我们可以将其看作是 Food 类型。泛型虽然很抽象，但它存在的目的，仍然是为了解决我们生活的实际问题。所以，当我们将泛型应用到实际的生活场景时，它就显得不是那么抽象了。 *所替换的类型在： 协变点返回泛型参数上限类型 逆变点接收泛型参数下限类型 #1. 协变点示例 12345678910fun main() { val queryMap: QueryMap&lt;*, *&gt; = QueryMap&lt;String, Int&gt;() queryMap.getKey() queryMap.getValue()}class QueryMap&lt;out K: CharSequence, out V : Any&gt; { fun getKey(): K = TODO() fun getValue(): V = TODO()} 说明： 声明了一个类QueryMap，接收两个泛型：协变泛型K，约束上界为CharSequence; 协变泛型V, 约束上界为Any 声明变量queryMap时类型为QueeryMap，但是传入的两个泛型为星号。 变量queryMap的getKey()方法返回值的类型就是泛型K的上界，即CharSequence 变量queryMap的getValue()方法返回值的类型就是泛型V的上界，即Any #2. 逆变点示例 12345678fun main() { val f: Function&lt;*,*&gt; = Function&lt;Number, Any&gt;() f.invoke()}class Function&lt;in P1, in P2&gt; { fun invoke(p1: P1, p2: P2) = Unit} 说明： 声明了一个类Function，接收两个泛型：逆变泛型P1、逆变泛型P2 声明变量f时类型为Function，但是传入的两个泛型为星号 调用变量f的invoke()方法，时传入的两个参数的类型取泛型的下限 定义泛型时没办法添加下限约束，所以是Nothing 因为Nothing没有实例，所以变量f的invoke()方法无法调用 #2. 适用范围 *不能直接或间接应用在属性或函数上，即不能将*作为一个类型传递给泛型 12QueryMap&lt;Sting,*&gt;()maxOf&lt;*&gt;(1,3) 说明： 如上两种*的使用方式都是 不正确的，不能将*作为一个类型传递给泛型 第一条语句将*间接作用到属性上 第二条语句将*直接作用到函数上 *适用于作为类型描述的场景 123val queryMap:QueryMap&lt;*, *&gt;if(f is Function&lt;*, *&gt;){}HashMap&lt;String, List&lt;*&gt;&gt;() 说明： 类型实例化时或真正使用时可以使用* 第一条语句：定义一个queryMap变量时，该变量类型是QueryMap类，QueryMap类传入的两个泛型使用* 描述，之后会根据QueryMap类里定义泛型时是协变还是逆变，来取上限还是下限 第二条语句：使用操作符is来判断变量是什么类型时，is后的类型可以使用*，因其也是类型描述 第三条语句：是一个HashMap的类型构造，本来是不允许使用*，但是HashMap有两个泛型参数K、V, 这两个泛型参数传的都是具体的类型：K对应String,V对应List&lt;*&gt;，其中List可以传递一个泛型参数，这个泛型参数可以使用*。因为List&lt;*&gt;在这个位置作为参数实际上是一个描述。 总结：直接的类型构造是不能用*，但参数里还有泛型，则该参数里的泛型可以使用* #六、协变、逆变、不变的规则思考 在学完型变以后，也许你会有点迷惑：到底什么时候用逆变，什么时候用协变？如果你看过 Kotlin 的官方文档，你会看到一句这样的话： Consumer in, Producer out ! 直译的话，大概意思就是： 消费者 in，生产者 out。不过，这个对我们中国人的说话语境而言，不是那么好理解。让我们继续根据前面的场景，来做个说明。 1234567891011121314151617// 逆变// ↓class Controller&lt;in T&gt; {// ①// ↓ fun turnOn(tv: T)}// 协变// ↓class Restaurant&lt;out T&gt; {// ②// ↓ fun orderFood(): T { /*..*/ }} 在这段代码中，分别是我们前面提到的逆变、协变的例子。把它们两个放到一起后，你应该就能很容易地发现它们两个的差别了。需要特别留意的地方，我都在注释当中标记出来了，让我来解释给你听：对于逆变的情况，我们模拟的是买遥控器的场景。请注意注释①的地方，我们的泛型 T，它最终会以函数的参数的形式，被传入函数的里面，这往往是一种写入行为，这时候，我们使用关键字 in。对于协变的情况，我们模拟的是点外卖的场景。请注意注释②的地方，我们的泛型 T，它最终会以返回值的形式，被传出函数的外面，这往往是一种读取行为，这时候，我们使用关键字 out。所以，如果要以更加通俗的语言来解释逆变与协变的使用场景的话，我们可以将其总结为：传入 in，传出 out。或者，我们也可以说：泛型作为参数的时候，用 in，泛型作为返回值的时候，用 out。我们再来看一下 Kotlin 源码当中型变的应用。首先，是逆变的应用。 12345678// 逆变// ↓public interface Comparable&lt;in T&gt; {// 泛型作为参数// ↓ public operator fun compareTo(other: T): Int} 在以上代码中，由于泛型是作为了 compareTo 方法的参数传入的，因此，对于 Comparable 的泛型 T，我们应该使用 in 来修饰，这就是逆变的实际应用。我们再来看看协变在 Kotlin 源码当中的应用。 12345678910// 协变// ↓public interface Iterator&lt;out T&gt; {// 泛型作为返回值// ↓ public operator fun next(): T public operator fun hasNext(): Boolean} 从上面的代码里我们可以看到，由于泛型是作为 next 方法的返回值的，因此，对于 Iterator 的泛型 T，我们应该使用 out 来修饰，这就是协变的应用。 12345678910sealed class Result&lt;out R&gt; {// 协变 ①// ↓ ↓ data class Success&lt;out T&gt;(val data: T, val message: String = &quot;&quot;) : Result&lt;T&gt;() data class Error(val exception: Exception) : Result&lt;Nothing&gt;() data class Loading(val time: Long = System.currentTimeMillis()) : Result&lt;Nothing&gt;()} 如上代码定义了密封类，我们对 Success 这个数据类的泛型参数使用了 out 来修饰，这就代表了协变。看到这里，如果你足够细心，就会觉得奇怪：这里为什么可以使用协变呢？前面我们不是说过：“泛型作为参数，用 in；泛型作为返回值，用 out”吗？这里并没有任何函数参数或者返回值啊？其实，这里就又体现出了我们对 Kotlin 底层理解的重要性了。请注意我在上面标记的注释①，val 在 Kotlin 当中，代表不可变的变量，当它修饰类成员属性的时候，代表它只有 getter，没有 setter。当我们看到这样的代码时，我们要能自动脑补出 Success 反编译后的 Java 结构： 1234567891011public static final class Success extends Result { private final Object data; // Success 这个类当中，是会有getter方法的 public final Object getData() { return this.data; } // 省略其他代码} 所以，我们可以用 out 修饰 Success 泛型的原因，是因为 data 的 getter 方法，它本质上是一个返回 T 类型的方法。这时候，如果我们将注释①处的 val 改为 var，那么代码就会立马报错。 12345678910sealed class Result&lt;out R&gt; {// 改为var后，编译器就会立马报错// ↓ data class Success&lt;out T&gt;(var data: T, val message: String = &quot;&quot;) : Result&lt;T&gt;() data class Error(val exception: Exception) : Result&lt;Nothing&gt;() data class Loading(val time: Long = System.currentTimeMillis()) : Result&lt;Nothing&gt;()} 到这里，有了前面的铺垫，我想你应该很快就能反应过来，编译器报错的原因是由于 var 修饰的成员属性，Kotlin 编译器会在背后生成对应 getter 和 setter，这个时候泛型参数既是“参数”也是“返回值”。所以，如果此时我们还用 out 修饰泛型 T，编译器就会报错了。也就是说，如果泛型的 T，既是函数的参数类型，又是函数的返回值类型，那么，我们就无法直接使用 in 或者 out 来修饰泛型 T。不过，函数传入参数的时候，并不一定就意味着写入，这时候，即使泛型 T 是作为参数类型，我们也仍然要想一些办法来用 out 修饰泛型。让我们拿一段官方源码来举例说明一下： 1234567891011121314// 协变 // ↓ public interface List&lt;out E&gt; : Collection&lt;E&gt; {// 泛型作为返回值// ↓ public operator fun get(index: Int): E// 泛型作为参数// ↓ override fun contains(element: @UnsafeVariance E): Boolean// 泛型作为参数// ↓ public fun indexOf(element: @UnsafeVariance E): Int} Kotlin 官方源码当中的 List，也就是这里的泛型 E，它既作为了返回值类型，又作为了参数类型。在正常情况下，如果我们用 out 修饰 E，那编译器是会报错的。但我们其实很清楚，对于 contains、indexOf 这样的方法，它们虽然以 E 作为参数类型，但本质上并没有产生写入的行为。所以，我们用 out 修饰 E 并不会带来实际的问题。所以这个时候，我们就可以通过 @UnsafeVariance 这样的注解，来让编译器忽略这个型变冲突的问题。 123456789101112131415161718// 逆变 协变// ↓ ↓abstract class BaseSingleton&lt;in P, out T&gt; {// ① @Volatile// ↓ private var instance: T? = null // 参数 返回值 // ↓ ↓ protected abstract val creator: (P)-&gt; T // 参数 返回值 // ↓ ↓ fun getInstance(param: P): T = instance ?: synchronized(this) { instance ?: creator(param).also { instance = it } }} 在这个单例模板的例子当中，P 一直作为参数，而 T 则是作为返回值。因此我们用 in 来修饰 P，这就是逆变；对应的我们用 out 修饰 T，这就是协变。不过，如果你足够细心的话，会发现注释①处还有一个 instance 是用泛型 T 修饰的。而它是 var 定义的成员变量，这就意味着，它既有 getter，又有 setter。那它为什么可以用协变的泛型 T 呢？其实，这是因为它是 private 的，如果你把 private 关键字删掉的话，上面的代码就会报错了。 #七、泛型实现原理及内联特化 #1. 泛型实现原理 #1. 泛型擦除 123fun &lt;T : Comparable&lt;T&gt;&gt; maxOf(a: T, b: T): T { return if (a &gt; b) a else b} 编译后代码： 123public static final Comparable maxOf(@NotNull Comparable a, @NotNull Comparable b) { return a.compareTo(b) &gt; 0 ? a : b;} 说明： 如下代码所示，写了一个函数maxOf()比较两个约束为Comparable的泛型形参的大小 编译后泛型T直接取的它的上限Comparable，此为类型擦除 #2. 泛型实现对比 伪泛型： 编译时擦除类型，运行时无实际类型生成。如Java、Kotlin 真泛型： 编译时生成真实类型，运行时也存在该类。如C#、C++ 说明： 在C#语言中，基本类型可以直接作为泛型参数，而在Java中不可以，只能使用基本类型的装箱类型 IR 是intermediate representation（中间表示) 的缩写 Java字节码中会将泛型类型擦除List&lt;String&gt; 、List&lt;Double&gt;只会有一个List。而在C#.Net的字节码中会真正生成List&lt;string、List&lt;double&gt;两个类 运行时，Java中内存也只会加载一个List，而在C#中内存会加载两个 类型擦除会使内存占用减少，但是类型问题在运行时处理进行类型强转，增加了开销 泛型类型无法当做真实类型 123456fun&lt;T&gt; genericMethod(t: T) { val t = T()//报错 val ts = Array&lt;T&gt;(3){TODO()}//报错 val jclass = T::class.java//报错 val list = ArrayList&lt;T&gt;()} 说明： 定义一个函数genericMethod()，传入一个泛型参数 第一行代码会 报错： 因为无法确定泛型T是否有一个默认无参构造器 第二行代码会 报错： Array虽然写成了泛型的形式，但并不是泛型，编译后也不会将泛型擦除，因为它有固定的类型Unit，所以泛型T无法作为数组的元素类型 第三行代码 报错： 因为泛型无法作为一个真正在类型，编译时会将泛型擦除，所以无法获取泛型T的class文件 第四行代码 正确： 因为ArrayList中的泛型会在编译时被擦除，所以传啥都可以 而在C#中，以上语句都是正确的 #2. 内联特化 #1. 内联特化概念 Kotlin独有，Java没有。 如果一个函数是内联函数，则会将内联函数内容替换到调用内联函数的位置，一旦替换过去，则内联函数的泛型也就能确定类型 12345678910inline fun&lt;reified T&gt; genericMethod(t: T) { val t = T()//报错 val ts = Array&lt;T&gt;(3){TODO()} val jclass = T::class.java val list = ArrayList&lt;T&gt;()}fun main() { genericMethod(&quot;str&quot;)} 说明： 如上代码，声明了一个内联函数genericMethod()。且该函数接收的泛型T前加 关键字reified修饰，表示该泛型可被具体化 (reified) 因内联类具体化的特性，调用genericMethod()时会将该函数体放到调用位置，此时该函数的泛型T也能确定类型，即T此时特化成一个具体类型。 调用genericMethod()时, 传入一个String，则内联函数的泛型T特化为了String类型 第一条语句错误：虽然T特化为了String类型，但还是无法确定该类型是否有一个默认无参构造器。但是C#可以添加构造器的约束 第二条语句正确：因T特化为了String类型，所以是创建了一个String类型的数组 第三条语句正确：因T特化为了String类型，所以获取了String类型的class类 #2. 内联特化实际应用 12345package com.google.gson;public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT){ ...} 说明： 如上所示代码为Gson框架中的一个反序列化的一个方法 fromJson()方法接收一个泛型T参数，并返回一个该类型的结果，同时还接收了该泛型T类型的class 反序列化操作步骤：构造对象 --&gt; 填充数据 --&gt; 返回对象 而构造对象一般通过反射构造，这就必须知道该对象的class 12345678910fun main() { val gson = Gson() val garen : Person = gson.fromJson(&quot;&quot;&quot;{&quot;name&quot;:&quot;盖伦&quot;, &quot;age&quot;:20}&quot;&quot;&quot;) val ashe = gson.fromJson&lt;Person&gt;(&quot;&quot;&quot;{&quot;name&quot;:&quot;艾希&quot;, &quot;age&quot;:18}&quot;&quot;&quot;)}data class Person(val name:String, val age:Int)inline fun &lt;reified T&gt; Gson.fromJson(json:String): T = fromJson(json, T::class.java) 说明： 如上代码所示，创建一个Gson类的扩展函数，该函数为内联函数，且只需要传入一个反序列化的字符串，不需要返回值类型的class 该函数直接内联到调用处，所以泛型T也就特化为一个具体的类型，也就可以获取该泛型的class main()函数中声明了变量garen及其类型为Person，并调用扩展的内联函数fromJson()为其赋值，虽然没有为fromJson()中传入泛型的具体类型，但通过 类型推导的形式，将泛型参数的类型推导出来，进而将泛型T特化 main()函数中声明了变量ashe，并调用扩展的内联函数fromJson()为其赋值，为fromJson()中传入泛型的具体类型Person，直接将泛型T特化 #八、 示例 #1. 模拟 Self Type #1. Builder模式中的类型继承问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typealias OnConfirm = () -&gt; Unittypealias OnCancel = () -&gt; Unitprivate val EmptyFunction = {}open class Dialog(val title: String, val content: String)class ConfirmDialog(title: String, content: String, val onConfirm: OnConfirm, val onCancel: OnCancel) : Dialog(title, content)open class DialogBuilder { protected var title = &quot;&quot; protected var content = &quot;&quot; fun title(title: String): DialogBuilder { this.title = title return this } fun content(content: String): DialogBuilder { this.content = content return this } open fun build() = Dialog(this.title, this.content)}class ConfirmDialogBuilder : DialogBuilder() { private var onConfirm: OnConfirm = EmptyFunction private var onCancel: OnCancel = EmptyFunction fun onConfirm(onConfirm: OnConfirm): ConfirmDialogBuilder { this.onConfirm = onConfirm return this } fun onCancel(onCancel: OnCancel): ConfirmDialogBuilder { this.onCancel = onCancel return this } override fun build() = ConfirmDialog(title, content, onConfirm, onCancel)}fun main() { val confirmDialog = ConfirmDialogBuilder() .title(&quot;提交弹窗&quot;) .onCancel { //这行开始报错 println(&quot;点击取消&quot;) } .content(&quot;确定提交吗？&quot;) .onConfirm { println(&quot;点击确定&quot;) } .build() confirmDialog.onConfirm()} 说明： 声明了一个弹窗基类Dialog，该类提供了标题title和内容content两个属性 声明了一个继承弹窗基类的子类提交弹窗类ConfirmDialog，该类除了基类的两个属性外又添加了两个属性：确定点击事件onConfirm()、取消点击事件onCancel 声明了一个Builder模式的基类DialogBuilder，用以构造Dialog，基类中的方法返回基类类型 声明了一个继承基类DialogBuilder的子类ConfirmDialogBuilder，用以构造ConfirmDialog 问题： 子类 Builder 中的函数返回的类型是基类 Builder 的类型，所以使用子类Builder创建出来的子类对象ConfirmDialog无法使用其独有的函数，即在main()方法中在onCancel处的代码会错：Unresolved reference: onCancel #2. Scala的Self Type Scala语言的Self Type可以解决Builder类继承后类型错误问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071object Main { type OnConfirm = () =&gt; Unit type OnCancel = () =&gt; Unit final val EmptyFunction = () =&gt; {} class Dialog(val title: String, val content: String) class ConfirmDialog( title: String, content: String, val onConfirm: OnConfirm, val onCancel: OnCancel ) extends Dialog(title, content) class DialogBuilder { self =&gt; protected var title: String = &quot;&quot; protected var content: String = &quot;&quot; def title(title: String): self.type = { this.title = title return this } def content(content: String): self.type = { this.content = content return this } def build() = new Dialog(this.title, this.content) } class ConfirmDialogBuilder extends DialogBuilder() { private var onConfirm: OnConfirm = EmptyFunction private var onCancel: OnCancel = EmptyFunction def onConfirm(onConfirm: =&gt; Unit): ConfirmDialogBuilder = { this.onConfirm = () =&gt; { onConfirm } return this } def onCancel(onCancel: =&gt; Unit): ConfirmDialogBuilder = { this.onCancel = () =&gt; { onCancel } return this } override def build() = new ConfirmDialog(title, content, onConfirm, onCancel) } def main(args: Array[String]): Unit = { new ConfirmDialogBuilder() .title(&quot;Hello&quot;) .onCancel { println(&quot;onCancel&quot;) } .content(&quot;World&quot;) .onConfirm { println(&quot;onConfirm&quot;) } .build() .onConfirm() }} 说明： 如上为Scala语言代码，其中def相当于kotlin的fun，该函数返回类型为 self.type。其中 self在类后添加了声明，表示该类在使用过程中真实的类型，如果是子类的话，就是子类类型。 在Kotlin中可以使用泛型来实现Self Type #3. 使用泛型模拟Self Type 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364typealias OnConfirm = () -&gt; Unittypealias OnCancel = () -&gt; Unitprivate val EmptyFunction = {}open class Dialog(val title: String, val content: String)class ConfirmDialog(title: String, content: String, val onConfirm: OnConfirm, val onCancel: OnCancel) : Dialog(title, content)interface SelfType&lt;Self&gt; { val self: Self get() = this as Self}open class DialogBuilder&lt;Self : DialogBuilder&lt;Self&gt;&gt; : SelfType&lt;Self&gt; { protected var title = &quot;&quot; protected var content = &quot;&quot; fun title(title: String): Self { this.title = title return self } fun content(content: String): Self { this.content = content return self } open fun build() = Dialog(this.title, this.content)}class ConfirmDialogBuilder : DialogBuilder&lt;ConfirmDialogBuilder&gt;() { private var onConfirm: OnConfirm = EmptyFunction private var onCancel: OnCancel = EmptyFunction fun onConfirm(onConfirm: OnConfirm): ConfirmDialogBuilder { this.onConfirm = onConfirm return this } fun onCancel(onCancel: OnCancel): ConfirmDialogBuilder { this.onCancel = onCancel return this } override fun build() = ConfirmDialog(title, content, onConfirm, onCancel)}fun main() { val confirmDialog = ConfirmDialogBuilder() .title(&quot;提交弹窗&quot;) .onCancel { println(&quot;点击取消&quot;) } .content(&quot;确定提交吗？&quot;) .onConfirm { println(&quot;点击确定&quot;) } .build() confirmDialog.onConfirm()} 打印结果： 1点击确定 说明： 定义了一个接口SelfType，接收一个泛型Self，该接口内定义了一个成员self，类型就是传入的泛型类型，设置该成员的getter方法中将该成员强转为Self 基类DialogBuilder实现接口SelfType，接口传入的泛型在声明时添加了约束：该泛型上界为DialogBuilder类，该类中的函数返回类型改为泛型Self 子类ConfirmDialogBuilder，继承基类DialogBuilder时传入的泛型实参使用子类ConfirmDialogBuilder，如此使用子类ConfirmDialogBuilder中函数返回的就是ConfirmDialogBuilder，则子类创建出来的子类ConfirmDialog 就可以使用子类ConfirmDialog独有的函数 #2. 基于泛型实现Model实例的注入 #1. 使用注入的地方 ViewModel在MVVM中持有View中的数据结构，同时要跟Model进行通信，所以ViewModel持有Model。 但是当有多个Model时，最好通过一个三方的类去管理Model实例，并转发给ViewModel。 其Model的获取通常使用注入方法来实现。 注入方法有： 添加注解。注解处理器在编译时将Model注入； 反射。通过读取注解在运行时实现注入； 代理。通过代理类实现Model注入； #2. 通过代理方式实现注入 #1. 实现方式一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152abstract class AbsModel { init { Models.run { register() } }}class DatabaseModel: AbsModel() { fun query(sql: String): Int = 0}class NetworkModel: AbsModel() { fun get(url:String) = &quot;&quot;&quot;{&quot;code&quot;:0}&quot;&quot;&quot;}object Models { private val modelMap = ConcurrentHashMap&lt;Class&lt;out AbsModel&gt;, AbsModel&gt;() fun &lt;T: AbsModel&gt; KClass&lt;T&gt;.get(): T { return modelMap[this.java] as T } fun AbsModel.register() { modelMap[this.javaClass] = this }}inline fun &lt;reified T: AbsModel&gt; modelOf(): ModelDelegate&lt;T&gt; { return ModelDelegate(T::class)}class ModelDelegate&lt;T: AbsModel&gt;(val kClass:KClass&lt;T&gt;): ReadOnlyProperty&lt;Any, T&gt; { override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T { return Models.run { kClass.get() } }}class MainViewModel{ val databaseModel by modelOf&lt;DatabaseModel&gt;() val networkModel by modelOf&lt;NetworkModel&gt;()}fun initModels() { DatabaseModel() NetworkModel()}fun main() { initModels() val mainViewModel = MainViewModel() mainViewModel.databaseModel.query(&quot;select * from usertable&quot;).let(::println) mainViewModel.networkModel.get(&quot;https://puppet16.github.io/&quot;).let(::println)} 说明： 定义了抽象类AbsModel,其为所有Model的父类，子类创建时一定会调用父类的构造器，所以父类的init块一定会执行，init块中调用了单例Modules的register()方法 定义了单例Models类： 该类中定义了一个抽象类AbsModel的扩展方法register()，该方法是将AbsModel的子类实例放到modeMap中，Key是子类的javaClass即java中的class类。如此只要是继承了AbsModel的子类都会将实例存入modeMap中； 该类中还定义了一个Kotlin的class的扩展方法get()，该方法是获取子类的实例，返回值一定是继承AbsModel的子类 注意：定义的以上两扩展方法作用域只是在单例Models中 定义了基于抽象类AbsModel的子类DatabaseModel、NetworkModel 定义了代理类ModelDelegate，主构造器中定义一个属性kClass，类型为KClass&lt;T&gt;，其中泛型T添加了约束上界为AbsModel。实现接口ReadOnlyProperty的方法getValue()，通过kClass的get()方法取得子类实例 定义了非必须的函数modelOf()，该方法接收一个泛型T，添加了约束上界为AbsModel，返回结果是一个ModelDelegate类的实例 定义类MainViewModel，该类中有两个属性：databaseModel、networkModel，这两个属性通过代理的方式赋值 定义类initModels，该类初始化了子类DatabaseModel、NetworkModel 最后在main()方法中先初始化两个AbsModel子类，再创建属性mainViewModel,之后通过属性mainViewModel获取不同的AbsModel子类实例，调用实例的方法 #实现方式二 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566abstract class AbsModel { init { Models.run { register() } }}class DatabaseModel: AbsModel() { fun query(sql: String): Int = 0}class NetworkModel: AbsModel() { fun get(url:String) = &quot;&quot;&quot;{&quot;code&quot;:0}&quot;&quot;&quot;}class PageModel: AbsModel() { init { Models.run { register(&quot;PageModel2&quot;) } } fun enter() { println(&quot;enter Next Page&quot;) }}object Models { private val modelMap = ConcurrentHashMap&lt;String, AbsModel&gt;() fun &lt;T: AbsModel&gt; String.get(): T { return modelMap[this] as T } fun AbsModel.register(name: String = this.javaClass.simpleName) { modelMap[name] = this println(modelMap.values.joinToString()) }}object ModelDelegate{ operator fun &lt;T: AbsModel&gt; getValue(thisRef: Any, property: KProperty&lt;*&gt;): T { return Models.run { property.name.capitalize().get() } }}class MainViewModel{ val databaseModel: DatabaseModel by ModelDelegate val networkModel: NetworkModel by ModelDelegate val pageModel: PageModel by ModelDelegate val pageModel2: PageModel by ModelDelegate}fun initModels() { DatabaseModel() NetworkModel() PageModel()}fun main() { initModels() val mainViewModel = MainViewModel() mainViewModel.databaseModel.query(&quot;select * from mysql.user&quot;).let(::println) mainViewModel.networkModel.get(&quot;https://www.imooc.com&quot;).let(::println) mainViewModel.pageModel.enter() mainViewModel.pageModel2.enter()} 说明： 方式二是方式一的优化，即将泛型参数省略。 单例Models的register()方法有一个String类型的入参，默认值为子类的简单类名，该入参作为modelMap的Key值。子类DatabaseModel的简单类名为DatabaseModel。单例Models的get()方法就成为了String的扩展方法 类ModelDelegate也不需要泛型区别Model，对于不同属性没有了区别，所以定义为了单例。其中获取子类实例的方法getValue()中使用了被代理的属性的名字获取子类实例，所以 定义的属性名字要与子类名字相同。 capitalize()方法是返回一个字符串，该字符串首字母大写。所以获取属性名字后再使用该函数才可保证与子类名字相同。 在类MainViewModel中声明属性时，直接使用ModelDelegate代理属性赋值会报错：无法确定ModelDelegate类中getValue()方法中的泛型T。要解决这个问题只需要在定义属性时添加上AbsModel的子类型即可推导出泛型T类型。 因为Models的register()方法可以传入String类型的入参，则子类可以自己定义在modelMap中的Key值。 子类PageModel虽然在父类构造器中以PageModel为Key值添加进了一次modelMap中，但在自己的构造器中又以PageModel2为Key值再一次的添加入modelMap中。即在modelMap中Key值为PageModel和PageModel2对应的Value值都是同一个PageModel子类实例 如此可以定义属性pageModel和pageModel2通过代理获取同一个PageModel子类实例 #九、参考文章 Kotlin 中的 Nothing 和 Unit Java和Kotlin中泛型的协变、逆变和不变 Kotlin知识归纳（十二） —— 泛型 https://www.kotlincn.net/docs/reference/generics.html Scala之自身类型(Self Type) 教你如何攻克Kotlin中泛型型变的难点(下篇)","link":"/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/"},{"title":"kotlin 学习系列八：注解","text":"一、前言 二、注解的基本概念 1. 注解定义 2. 限定标注对象@Target 3. 指定作用时机 4. 添加参数 5. 注解使用 6. 明确注解的标注对象 三、内置注解 1. 元注解 1 @Target 2. @Retention 2. 标准库通用注解 1. @Metadata 2. @UnsafeVariance 3. @Suppress 3. 与Java虚拟机交互的注解 1. @JvmField 2. @JvmName 3. @JvmMultifileClass 4. @JvmOverloads 5. @JvmStatic 6. @Synchronized 7. @Volatile 8. @Throws 四、 示例 – 仿 Retrofit反射读取注解请求网络 1. 创建一些需要的注解 2. 创建解析单例RetroApi 3. 测试反射读取注解请求网络功能 五、示例 – 注解加持反射版Model映射 1. 创建支持单个属性别名的注解FildName 2. 创建支持数据类的注解MappingStrategy 六、 示例 – 注解处理器版 Model 映射 1. 简述java编译过程 2. 开源库KotlinPoet 3. 注解处理器AbstractProcessor 1. 自定义注解处理器 2. 声明自定义注解处理器 4. 注解解析器Element 5. 实现注解处理器版 Model 映射 1. 创建注解 2. 创建注解处理器 1. 添加依赖包 2. 创建处理器 3. 添加处理器声明 3. 测试注解处理器 1. build.gradle.kts配置 2. 创建测试文件 七、Kotlin编译器插件 1. 编译器插件工作机制 2. AllOpen插件 1. AllOpen插件介绍 2. AllOpen插件源码 3. NoArg插件 1. NoArg插件介绍 2. NoArg插件源码 1. NoArg-Gradle关键源码 2. NoArg-Intellij关键源码 4. 其它实用插件 5. 总结 八、 参考文章 #一、前言 本文主要讲述Kotlin 注解 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶 kotlin学习系列十一：协程应用 #二、注解的基本概念 注解 实际上就是一种代码标签，它作用的对象是代码。实际上，注解几乎无处不在，比如说，经常能在Kotlin标准库当中看见“@Deprecated&quot; 这样的注解，它代表了被标注的代码“已废弃”。在 Java 中，最常见的是 “@Override&quot; 这个注解，它代表了重写。 注解 可以给特定的注解代码标注一些额外的信息。然而这些信息可以选择不同保留时期，比如源码期、编译期、运行期。然后在不同时期，可以通过某种方式获取标签的信息来处理实际的代码逻辑，这种方式常常就是我们所说的 反射。 总结如下： 注解是对程序的附加信息说明，也就是程序代码的一种补充 注解可以对类、函数、函数参数、属性等做标注 注解的信息可用于源码级、编译期、运行时 #1. 注解定义 Kotlin 的源代码中，提供了很多内置的注解，比如@Deprecated、@JvmStatic、@JvmOverloads等等。除了Kotlin默认就有的注解以外，我们也可以定义自己的注解。 定义注解类使用关键字 annotation 1annotation class State 123public @interface State {} 说明： java中注解通过@interface关键字进行定义，它和接口声明类似，只不过在前面多加@ kotlin中注解和一般类的声明很类似，只是在class前面加上了annotation修饰符 12345678@Target(CLASS, FUNCTION, PROPERTY, ANNOTATION_CLASS, CONSTRUCTOR, PROPERTY_SETTER, PROPERTY_GETTER, TYPEALIAS)@MustBeDocumentedpublic annotation class Deprecated( val message: String, val replaceWith: ReplaceWith = ReplaceWith(&quot;&quot;), val level: DeprecationLevel = DeprecationLevel.WARNING) 从上面的代码里，我们可以看到，@Deprecated 这个注解的定义上面，还有其他的注解 @Target、@MustBeDocumented。这样的注解，我们叫做元注解，即它本身是注解的同时，还可以用来修饰其他注解。 Kotlin 常见的元注解有四个： @Target，这个注解是指定了被修饰的注解都可以用在什么地方，也就是目标； @Retention，这个注解是指定了被修饰的注解是不是编译后可见、是不是运行时可见，也就是保留位置； @Repeatable，这个注解是允许我们在同一个地方，多次使用相同的被修饰的注解，使用场景比较少； @MustBeDocumented，指定被修饰的注解应该包含在生成的 API 文档中显示，这个注解一般用于 SDK 当中。 这里，需要注意的是 Target 和 Retention 的取值 #2. 限定标注对象@Target 定义注解类时，限定定义的注解的标注对象使用 注解@Target 12345678@Target(CLASS, FUNCTION, PROPERTY, ANNOTATION_CLASS, CONSTRUCTOR, PROPERTY_SETTER, PROPERTY_GETTER, TYPEALIAS)@MustBeDocumentedpublic annotation class Deprecated( val message: String, val replaceWith: ReplaceWith = ReplaceWith(&quot;&quot;), val level: DeprecationLevel = DeprecationLevel.WARNING) 说明： Target常用的范围有： CLASS：用于类、接口、单例 CONSTRUCTOR：用于主构造器或副构造器 PROPERTY：用于属性 FUNCTION：用于函数，不包括构造器 注意Target和AnnotationTarget都是包kotlin.annotation下的类 #3. 指定作用时机 定义注解类时，指定作用时机使用 注解@Retention 123@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.CLASS)annotation class State 说明： 如上所示，定义的注解State，只能标注在类、接口、单例上，同时指定在运行时再去解释注解 时机范围： SOURCE：代表这个注解在编译器处理完之后就被抛弃，这意味着它的信息仅存在于编译器处理期间，不会存到.class文件中 BINARY：对应Java中的CLASS，代表编译器将注解存储于类对应的.class文件中，但是在运行时不能通过反射读取，在Java中这是Annotation的默认行为 RUNTIME：代表编译器将注解存储于.class文件中，并且 可由反射获取，由于Kotlin的语言特性，它是Kotlin中的默认策略 #4. 添加参数 可以为注解类添加参数，与一般类添加主构造器参数一致 123@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.CLASS)annotation class State(val status:String) 说明： 注解类的参数类型有限制只能是如下类型：基本类型、KClass、枚举、其他注解 这些类型都是在编译期能确定值的类型 在前几节展示的注解 @Deprecated 类当中包含了包含了如下成员： message 代表了废弃的提示信息； replaceWith 代表了应该用什么来替代废弃的部分； level 代表警告的程度，分别是 WARNING、ERROR、HIDDEN。 #5. 注解使用 直接在对应的限定对象上添加注解即可 12@State(&quot;ready&quot;)class Start #6. 明确注解的标注对象 12@get:JvmName(&quot;getStudentName&quot;)var name:String = &quot;Lee&quot; 说明： 如上定义了一个属性name，而注解@get:JvmName(&quot;getStudentName&quot;)作用是将name的getter方法名字指定为getStudentName 变更名字的操作还可以指定为receiver、get、file等 #三、内置注解 #1. 元注解 元注解 是为其他注解进行说明的注解，当自定义一个新的注解类型时，其中可以使用元注解。元注解位于kotlin.annotation.*包下 #1 @Target @Target 用来 指定一个新注解的使用目标。 @Target 注解有一个 allowedTargets 属性，该属性用来设置注解的使用目标，allowedTargets 是 kotlin.annotation.AnnotationTarget 枚举类型。 AnnotationTarget描述 Kotlin 代码中可以被注解的元素类型，它有 15 个枚举常量。如下： 12345678910111213141516171819202122232425262728293031323334//源码public enum class AnnotationTarget { // 类、接口、object、注解类 CLASS, // 注解类 ANNOTATION_CLASS, // 泛型参数 TYPE_PARAMETER, // 属性 PROPERTY, // 字段、幕后字段 FIELD, // 局部变量 LOCAL_VARIABLE, // 函数参数 VALUE_PARAMETER, // 构造器 CONSTRUCTOR, // 函数 FUNCTION, // 属性的getter PROPERTY_GETTER, // 属性的setter PROPERTY_SETTER, // 类型 TYPE, // 表达式 EXPRESSION, // 文件 FILE, // 类型别名 TYPEALIAS} 常量 使用目标 CLASS 类、接口、对象声明和注解类声明 ANNOTATION_CLASS 其他注解类型声明 TYPE_PARAMERTER 用于泛型中类型参数声明 PROPERTY 属性声明 FIELD 字段声明，包括属性的支持字段 LOCAL_VARIABLE 局部变量声明 VALUE_PARAMETER 用于函数或构造函数参数值声明 CONSTRUCTOR 用于构造函数声明 FUNCTION 用于函数声明，不包括构造函数 PROPERTY_GETTER 只用于属性的 getter 访问器声明 PROPERTY_SETTER 只用于属性的 setter 访问器声明 TYPE 类型使用 EXPRESSION 任何表达式 FILE 文件 TYPEALIAS 类型别名 #2. @Retention @Retention 用来指定一个新注解的有效范围。 @Retention 注解有一个 value 属性，该属性用来设置保留期，value 是 kotlin.annotation.AnnotationRetention 枚举类型。 AnnotationRetention 描述注解保留期，它有 3 个常量，如下： 123456789//源码public enum class AnnotationRetention { // 注解只存在于源代码，编译后不可见 SOURCE, // 注解编译后可见，运行时不可见 BINARY, // 编译后可见，运行时可见 RUNTIME} 常量 保留期 SOURCE 只适用于源代码文件中，此范围最小 BINARY 编译器把注解信息记录在编译之后的二进制文件中，对于反射是不可见的，此范围居中 RUNTIME 编译器把注解信息记录在编译之后的二进制文件中，对于反射是可见的，此范围最大，这是默认保留期 #2. 标准库通用注解 标准库通用注解 位于kotlin.* #1. @Metadata Java 反射对于 Kotlin 的很多特性都无法访问和识别，而Kotlin 的反射可以访问和识别，就是因为注解@Metadata @Metadata会由Kotlin的编译器添加到由编译器生成的class文件中，它可以被编译器和反射读取。 Kotlin 反射过程中，注解的内容解析之后会实例化一个叫做 KotlinClassHeader 的类。下表为注解中的属性与类中成员对应关系： 官网源码：https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-metadata/ Metadata KotlinClassHeader 说明 k kind 注解标注目标类型，例如类、文件等等 mv metadataVersion 该元数据的版本 bv bytecodeVersion 字节码版本 d1 data 自定义元数据 d2 strings 自定义元数据补充字段 xs extraString 附加字段 xi extraInt 1.1 加入的附加标记，标记类文件的来源类型 说明： d1： 存储了自定义格式的元数据，官方声称针对不同的类型格式不定，甚至可以为空，研究发现目前采用 Protobuf 进行序列化存储。这些数据会被 Kotlin 反射读取，是反射的一个非常重要的数据来源。其中包含不限于 类型、函数、属性等的可见性、类型是否可空、函数是否为 suspend等等信息。 d2： 存储明文字符串字面量，主要存储 Jvm 签名等信息。之所以这样设计，主要是为了将这些字符串在运行时直接加载到虚拟机内存的常量池中予以复用，减少内存开销。 #2. @UnsafeVariance 该注解用于泛型破除型变限制 源码如下： 1234@Target(TYPE)@Retention(SOURCE)@MustBeDocumentedpublic annotation class UnsafeVariance #3. @Suppress 在 Java 中，使用注解 @SuppressWarnings(&quot;xxx&quot;) 消除一些编译时的警告 在 Kotlin 中，使用内置的 @Suppress(&quot;xxx&quot;) 消除一些编译时的警告 使用时，将警告类型作为参数传入注解入参 示例如下： 1234val map: Map&lt;Any,Any&gt; = emptyMap()@Suppress(&quot;UNCHECKED_CAST&quot;)map as Map&lt;String, Any&gt; 说明： 如果不添加注解，则会有警告提示：Unchecked cast: Map&lt;Any, Any&gt; to Map&lt;String, Any&gt;，加上注解后警告消失 注解的源码如下： 1234@Target(CLASS, ANNOTATION_CLASS, PROPERTY, FIELD, LOCAL_VARIABLE, VALUE_PARAMETER, CONSTRUCTOR, FUNCTION, PROPERTY_GETTER, PROPERTY_SETTER, TYPE, EXPRESSION, FILE, TYPEALIAS)@Retention(SOURCE)public annotation class Suppress(vararg val names: String) #3. 与Java虚拟机交互的注解 用于与Java虚拟机交互的注解，位于kotlin.jvm.* 官网源码：https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/ 参考文章：正确使用Kotlin注解，兼容Java代码 #1. @JvmField 使Kotlin编译器不再对该字段生成getter/setter，且其作用域为public 1class Person(var name:String, var age:Int) 反编译上述代码class文件后代码如下： 12345678910111213141516171819202122232425262728public final class Person { @NotNull private String name; private int age; @NotNull public final String getName() { return this.name; } public final void setName(@NotNull String var1) { Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;); this.name = var1; } public final int getAge() { return this.age; } public final void setAge(int var1) { this.age = var1; } public Person(@NotNull String name, int age) { this.name = name; this.age = age; }} 为属性添加注解@JvmField如下： 1class Person(@JvmField var name:String, var age:Int) 反编译上述代码class文件后代码如下： 12345678910111213141516171819public final class Person { @JvmField @NotNull public String name; private int age; public final int getAge() { return this.age; } public final void setAge(int var1) { this.age = var1; } public Person(@NotNull String name, int age) { this.name = name; this.age = age; }} 说明： 可以看到添加注解JvmField后，name属性没有了getter/setter，但是作用域从private变为了public #2. @JvmName 告诉使Kotlin编译器生成的Java类或者方法的名称 注意：该注解只能用于函数、属性的 getter/setter、文件 12345678910111213141516package cn.ltt.projectcollection.kotlin.annotationlabvar kotlinField: Int = 2 set(value) { field = value } get() { return field }fun kotlinFunction() {}fun main() { kotlinFunction()} 反编译上述代码class文件后代码如下： 1234567891011121314151617181920212223242526// KotlinAnnotationLabKt.javapackage cn.ltt.projectcollection.kotlin.annotationlab;public final class KotlinAnnotationLabKt { private static int kotlinField = 2; public static final int getKotlinField() { return kotlinField; } public static final void setKotlinField(int value) { kotlinField = value; } public static final void kotlinFunction() { } public static final void main() { kotlinFunction(); } // $FF: synthetic method public static void main(String[] var0) { main(); }} 为文件、函数、属性的getter/setter添加注解@JvmName如下： 12345678910111213141516171819202122232425//修改生成文件名@file:JvmName(&quot;JavaClassLab&quot;)package cn.ltt.projectcollection.kotlin.annotationlabvar kotlinField: Int = 2 //修改属性的set方法名 @JvmName(&quot;setJavaField&quot;) set(value) { field = value } //修改属性的get方法名 @JvmName(&quot;getJavaField&quot;) get() { return field }//修改普通的方法名@JvmName(&quot;JavaFunction&quot;)fun kotlinFunction() {}fun main() { kotlinFunction()} 反编译上述代码class文件后代码如下： 123456789101112131415161718192021222324252627282930313233343536// JavaClassLab.javapackage cn.ltt.projectcollection.kotlin.annotationlab;import kotlin.jvm.JvmName;@JvmName( name = &quot;JavaClassLab&quot;)public final class JavaClassLab { private static int kotlinField = 2; @JvmName( name = &quot;getJavaField&quot; ) public static final int getJavaField() { return kotlinField; } @JvmName( name = &quot;setJavaField&quot; ) public static final void setJavaField(int value) { kotlinField = value; } @JvmName( name = &quot;JavaFunction&quot; ) public static final void JavaFunction() { } public static final void main() { JavaFunction(); }} 说明： 注解@JvmName只能用于函数、属性的 getter/setter、文件 Kotlin可以正常使用添加了注解@JvmName的对象，但是编译器会自动替换成@JvmName声明的名字 Java直接使用@JvmName修改后的名字，由此可以用来应对各种类名修改以后的兼容性问题 #3. @JvmMultifileClass Kotlin编译器会将多个文件生成一个类，该文件具有在此文件中 声明的顶级函数和属性 作为其中的一部分，JvmName注解提供了相应的多文件的名称 1234567891011//MultiClassA.kt@file:JvmName(&quot;Utils&quot;)@file:JvmMultifileClasspackage cn.ltt.projectcollection.kotlin.annotationlab.multiclasstestfun getDeviceId() : String = &quot;deviceId&quot;lateinit var id: Stringconst val DEVICE_ID_DEFAULT = &quot;123&quot; 反编译上述代码class文件后代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142// Utils__MultiClassAKt.javapackage cn.ltt.projectcollection.kotlin.annotationlab.multiclasstest;final class Utils__MultiClassAKt { public static String id; @NotNull public static final String getDeviceId() { return &quot;deviceId&quot;; } @NotNull public static final String getId() { String var10000 = id; return var10000; } public static final void setId(@NotNull String var0) { id = var0; }}// Utils.javapackage cn.ltt.projectcollection.kotlin.annotationlab.multiclasstest;public final class Utils { @NotNull public static final String DEVICE_ID_DEFAULT = &quot;123&quot;; @NotNull public static final String getId() { return Utils__MultiClassAKt.getId(); } public static final void setId(@NotNull String var0) { Utils__MultiClassAKt.setId(var0); } @NotNull public static final String getDeviceId() { return Utils__MultiClassAKt.getDeviceId(); }} 12345678910//MultiClassB.kt@file:JvmName(&quot;Utils&quot;)@file:JvmMultifileClasspackage cn.ltt.projectcollection.kotlin.annotationlab.multiclasstestfun getDeviceWidth() : Int = widthvar width: Int = 333const val DEVICE_WIDTH_DEFAULT = 233 反编译上述代码class文件后代码如下： 12345678910111213141516171819202122232425262728293031323334353637// Utils__MultiClassBKt.javapackage cn.ltt.projectcollection.kotlin.annotationlab.multiclasstest;final class Utils__MultiClassBKt { private static int width = 333; public static final int getDeviceWidth() { return width; } public static final int getWidth() { return width; } public static final void setWidth(int var0) { width = var0; }}// Utils.javapackage cn.ltt.projectcollection.kotlin.annotationlab.multiclasstest;public final class Utils { public static final int DEVICE_WIDTH_DEFAULT = 233; public static final int getWidth() { return Utils__MultiClassBKt.getWidth(); } public static final void setWidth(int var0) { Utils__MultiClassBKt.setWidth(var0); } public static final int getDeviceWidth() { return Utils__MultiClassBKt.getDeviceWidth(); }} Java调用上述两个文件的属性、函数如下所示： 12345678910public class MultiClassTest { public static void main(String[] args) { Utils.getDeviceId(); Utils.getDeviceWidth(); Utils.setId(&quot;111&quot;); Utils.getId(); Utils.getWidth(); System.out.println(Utils.DEVICE_ID_DEFAULT); }} 说明： 通过反编译的代码可以看出，添加了@JvmMultifileClass注解，在生成自己的类文件同时还会生成一个由@JvmName提供名字的公共类，然后，两个添加了@JvmMultifileClass注解的Kotlin文件中的顶级函数、属性的都可以在公共类中调用。 即将两个添加了@JvmMultifileClass注解的文件MultiClassA.kt、MultiClassB.kt 合并到了公共类Utils中，注解可以消除我们去手动创建一个公共类，向公共类中添加方法更加灵活和方便 #4. @JvmOverloads Kotlin编译器为添加该注解的函数生成替换默认参数值的重载 1234fun defaultParamFun(x:Int = 5, y:String, z: Long = 0L) { println(&quot;x:$x, y:$y, z: $z&quot;)} 反编译上述代码class文件后代码如下： 12345678910111213141516171819public static final void defaultParamFun(int x, @NotNull String y, long z) { Intrinsics.checkNotNullParameter(y, &quot;y&quot;); String var4 = &quot;x:&quot; + x + &quot;, y:&quot; + y + &quot;, z: &quot; + z; boolean var5 = false; System.out.println(var4); }// $FF: synthetic methodpublic static void defaultParamFun$default(int var0, String var1, long var2, int var4, Object var5) { if ((var4 &amp; 1) != 0) { var0 = 5; } if ((var4 &amp; 4) != 0) { var2 = 0L; } defaultParamFun(var0, var1, var2);} 为函数添加注解@JvmOveerloads如下： 1234@JvmOverloadsfun defaultParamFun(x:Int = 5, y:String, z: Long = 0L) { println(&quot;x:$x, y:$y, z: $z&quot;)} 反编译上述代码class文件后代码如下： 123456789101112131415161718192021222324252627282930@JvmOverloadspublic static final void defaultParamFun(int x, @NotNull String y, long z) { Intrinsics.checkNotNullParameter(y, &quot;y&quot;); String var4 = &quot;x:&quot; + x + &quot;, y:&quot; + y + &quot;, z: &quot; + z; boolean var5 = false; System.out.println(var4);}// $FF: synthetic methodpublic static void defaultParamFun$default(int var0, String var1, long var2, int var4, Object var5) { if ((var4 &amp; 1) != 0) { var0 = 5; } if ((var4 &amp; 4) != 0) { var2 = 0L; } defaultParamFun(var0, var1, var2);}@JvmOverloadspublic static final void defaultParamFun(int x, @NotNull String y) { defaultParamFun$default(x, y, 0L, 4, (Object)null);}@JvmOverloadspublic static final void defaultParamFun(@NotNull String y) { defaultParamFun$default(0, y, 0L, 5, (Object)null);} 说明： 可以看到添加了注解 @JvmOverloads的函数会重载多个名字相同，参数不同的函数 该注解应该使用在带默认参数的函数上，由此可以让Java享受到Koltin的 默认参数的特性 重载的规则是顺序重载，只有有默认值的参数会参与重载 #5. @JvmStatic 对 函数使用该注解，kotlin编译器将生成另一个静态方法 对 属性使用该注解，kotlin编译器将生成其他的setter和getter方法 作用： 消除Java调用Kotlin的companion object对象时不能直接调用其静态方法和属性的问题 注意：此注解只能在companion object中使用 1234567class ClassA { companion object { var nameDefault: String = &quot;Lee&quot; fun getName(): String = &quot;name:$nameDefault&quot; }} 反编译上述代码class文件后代码如下： 12345678910111213141516171819202122232425262728293031public final class ClassA { @NotNull private static String nameDefault = &quot;Lee&quot;; @NotNull public static final ClassA.Companion Companion = new ClassA.Companion((DefaultConstructorMarker)null); public static final class Companion { @NotNull public final String getNameDefault() { return ClassA.nameDefault; } public final void setNameDefault(@NotNull String var1) { Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;); ClassA.nameDefault = var1; } @NotNull public final String getName() { return &quot;name:&quot; + ((ClassA.Companion)this).getNameDefault(); } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }} 123456//未添加注解java调用companion object中的属性函数public static void main(String[] args) { ClassA.Companion.getName(); ClassA.Companion.getNameDefault(); ClassA.Companion.setNameDefault(&quot;Lee2&quot;);} 说明： 由反编译的代码可以看出，在companion object中定义的函数和属性生成的Java方法也只是在Companion类中。即如果需要调用companion object中定义的函数和属性必须借助Companion 为属性和函数添加注解@JvmStatic如下： 12345678class ClassA { companion object { @JvmStatic var nameDefault: String = &quot;Lee&quot; @JvmStatic fun getName(): String = &quot;name:$nameDefault&quot; }} 反编译上述代码class文件后代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public final class ClassA { @NotNull private static String nameDefault = &quot;Lee&quot;; @NotNull public static final ClassA.Companion Companion = new ClassA.Companion((DefaultConstructorMarker)null); @NotNull public static final String getNameDefault() { ClassA.Companion var10000 = Companion; return nameDefault; } public static final void setNameDefault(@NotNull String var0) { ClassA.Companion var10000 = Companion; nameDefault = var0; } @JvmStatic @NotNull public static final String getName() { return Companion.getName(); } public static final class Companion { /** @deprecated */ // $FF: synthetic method @JvmStatic public static void getNameDefault$annotations() { } @NotNull public final String getNameDefault() { return ClassA.nameDefault; } public final void setNameDefault(@NotNull String var1) { Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;); ClassA.nameDefault = var1; } @JvmStatic @NotNull public final String getName() { return &quot;name:&quot; + ((ClassA.Companion)this).getNameDefault(); } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }} 1234567public static void main(String[] args) { //添加注解后java调用companion object中的属性函数 ClassA.getName(); ClassA.getNameDefault(); ClassA.setNameDefault(&quot;Lee2&quot;);} 说明： 可以看到添加了注解 @JvmStatic后的属性和函数都会在伴生对象所在的类中生成各自对应的静态方法，虽然Companion这个静态内部类还在，但是Java现在就不需要再借助Companion类而可以直接调用对应的静态方法和属性 #6. @Synchronized Kotlin语言不支持synchronized关键字，使用该注解生成同步方法 1234@Synchronizedfun start() {} 反编译上述代码class文件后代码如下： 12public final synchronized void start() {} 说明： 注解@Synchronized只能添加在 函数、属性的getter/setter方法 设置了该注解的函数编译器生成java方法时会自动添加一个synchronized关键字 #7. @Volatile 该注解对应Java端的关键字volatile，功能与其一致 12@Volatilelateinit var name: String 反编译上述代码class文件后代码如下： 1public volatile String name; 说明： 注解@Volatile只用于属性 设置了该注解的属性编译器生成java变量时会自动添加一个volatile关键字 #8. @Throws Checked exception: 继承自 Exception 类。代码需要处理 API 抛出的 checked exception，要么用 catch 语句，要么直接用 throws 语句抛出去。可以理解为 编译时异常，不处理编译不能通过。 由于Kotlin语言不支持CE(Checked Exception)，为了兼容这种写法，Kotlin语言增加了@Throws注解，该注解的接收一个可变参数，参数类型是多个异常的KClass实例。Kotlin编译器通过读取注解参数，在生成的字节码中自动添加CE声明 1234@Throws(IllegalAccessException::class)fun hello(){} 反编译上述代码class文件后代码如下： 12public static final void hello() throws IllegalAccessException {} 说明： 注解只能用于 函数、属性的getter/setter、构造器上 #四、 示例 – 仿 Retrofit反射读取注解请求网络 #1. 创建一些需要的注解 123456789101112131415161718192021222324252627282930313233343536data class User( var login: String, var location: String, var avatar_url: String, var bio: String)@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.CLASS)annotation class Api(val url: String)@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class Get(val url: String = &quot;&quot;)@Api(&quot;https://api.github.com&quot;)interface GitHubApi { @Api(&quot;users&quot;) interface Users { @Get(&quot;{name}&quot;) fun get(name: String): User @Get(&quot;{name}/followers&quot;) fun followers(name: String): List&lt;User&gt; } @Api(&quot;repos&quot;) interface Repos { @Get(&quot;{owner}/{repo}/forks&quot;) fun forks(owner: String, repo: String) }} 说明： 定义一个数据类User，用于接收从接口https://api.github.com/users/puppet16返回的数据，分别有登录名 (login)、所在地 (location) 、头像 (avatar_url)、个性签名 (bio) https://api.github.com/users/用户名接口可以获取Github网站上某用户的一些公开信息 定义了两个作用于接口上的注解Api、Path: Api注解：有一个参数用于保存网络地址的host Path注解：有一个参数用于保存网络地址的path路径，参数默认为空串 定义了一个作用于函数上的注解Get,有一个参数用于保存网络地址的 定义一个接口GitHubApi，在该接口定义上添加注解@Api，参数传入 https://api.github.com，在该接口内又定义了接口接口Users，添加注解@Api，传入的是该类的host值：users，该类又定义了两个函数： 函数get()，用于获取用户的信息 函数followers()，用于获取助关注用户的用户列表 #2. 创建解析单例RetroApi 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455object RetroApi { const val PATH_PATTERN = &quot;&quot;&quot;(\\{(\\w+)\\})&quot;&quot;&quot; val okHttp = OkHttpClient() val gson = Gson() val enclosing = { cls: Class&lt;*&gt; -&gt; var currentCls: Class&lt;*&gt;? = cls sequence { while(currentCls != null){ currentCls = currentCls?.also { yield(it) }?.enclosingClass } } } inline fun &lt;reified T&gt; create(): T { val functionMap = T::class.functions.map{ it.name to it }.toMap() val interfaces = enclosing(T::class.java).takeWhile { it.isInterface }.toList() val apiPath = interfaces.foldRight(StringBuilder()) { clazz, acc -&gt; acc.append(clazz.getAnnotation(Api::class.java) ?.url?.takeIf { it.isNotEmpty() } ?:clazz.name).append(&quot;/&quot;) }.toString() return Proxy.newProxyInstance(RetroApi.javaClass.classLoader, arrayOf(T::class.java)) { proxy, method, args -&gt; functionMap[method.name]?.takeIf { it.isAbstract }?.let { function -&gt; val parameterMap = function.valueParameters.map { it.name to args[it.index - 1] }.toMap() //{name} val endPoint = function.findAnnotation&lt;Get&gt;()!!.url.takeIf { it.isNotEmpty() }?: function.name val compiledEndPoint = Regex(PATH_PATTERN).findAll(endPoint).map { matchResult -&gt; matchResult.groups[1]!!.range to parameterMap[matchResult.groups[2]!!.value] }.fold(endPoint) { acc, pair -&gt; acc.replaceRange(pair.first, pair.second.toString()) } val url = apiPath + compiledEndPoint println(url) okHttp.newCall(Request.Builder().url(url).get().build()).execute().body?.charStream()?.use { gson.fromJson(JsonReader(it), method.genericReturnType) } } } as T }} 说明： 定义一个正则表达式PATH_PATTERN，用于匹配带大括号的大括号内做任意文本的字符串，其中分为了两组，一组是带大括号的内容文本，第二组是大括号内的文本。 定义一个OkHttpClient的实例，名为okHttp 定义一个Gson的实例，名为gson 定义了一个名为enclosing的lambda表达式，它接收一个Class&lt;*&gt;类型的参数cls，定义一个属性，用于保存当前的Class&lt;*&gt;,之后在函数中定义一个懒序列，在序列中做如下操作： 创建一个循环，循环条件是当前class不为空 enclosingClass()方法可以获取对应类的直接外部类class对象 序列的next方法就可以拿到yield()方法传递出的内容 通过yield()方法将当前类currentCls放置到队列中 通过currentCls?.enclosingClass获取当前class的直接外部类，并将其赋值给当前类currentCls 总结：enclosing表达式的功能就是返回了一个序列，该序列中有某类的一层层的所有外部类 create()方法通过动态代理形式去创建一个泛型类型T对象，该函数使用了内联特化。 定义了一个Map类型的属性functionMap，存储泛型T所有函数的名字和函数的键值对 定义了一个List类型的属性interfaces，存储泛型T所有的接口类型的外部类及他自身。通过enclosing()函数将泛型 T的java的class传递进去，返回一个包含泛型T所有外部类的队列，先从泛型T本身类型取逐层往外层的类取，直到外层的类不是接口为止，然后将符合的数据转为list，所以该list中外部类元素的顺序是 从内往外的 定义了一个String类型的属性apiPath，用于存储泛型T所包含的网络路径。通过定义的intetfaces属性取得所有外部类class对象列表，然后通过foldRight()方法从后向前遍历元素 (因为interfaces列表中类顺序是从内向外，而地址是从外往里的)。foldRight()函数有两个参数：一个是初始值，这里定义的初始值是一个StringBuilder对象，一个是以列表中元素和初始值为参数的函数，在该函数中通过 clazz.getAnnotation(Api::class.java)反射得出该类的Api注解对象，之后获取该注解中的url属性的值，若 url是空的，则取该类的类名，之后将取到的取到的地址段通过append方法拼接成一个字符串 通过java反射包中的Proxy.newProxyInstance()创建一个代理类，其中 第一个参数传递的是RetroApi类的classloader， 第二个参数传递的是数组类型的接口列表，即传递以泛型T为元素的数组 第三个参数是InvocationHandler类型，也就是一个函数，该函数是一个接口且只有一个方法，所以可以使用lambda表达式，将其从参数列表中往外提 InvocationHandler接口中的invoke方法有三个参数： 第一个参数是 Object类型的proxy，第二个参数是 Method类型的method，第三个参数是 Object[]类型的args: 在该方法中通过属性functionMap可以得到以method.name为Key值的对应的泛型T中的函数，通过takeIf判断必须该函数必须是抽象的，这样的才需要实现。 之后通过let函数，将之前的取得的抽象的函数作为名为function的参数创建一个匿名函数。 在该匿名函数中，先通过调用函数的valueParameters()方法，获取该函数的形参列表，之后生成形参名称为key，对应形参值为value的键值对组成的map,其名为parameterMap 接着通过findAnnotation方法获取该函数某注解实例，在此获取Get注解的实例，取出该注解中url属性的值，若该值为空，则取该函数名，将结果保存到属性endPoint中 之后通过函数Regex匹配正则表达式，再调用findAll获取所有满足正则的内容，之后调用map函数，对每个满足正则文本matchResult进行操作，matchResult.groups有三个元素，第一个元素是匹配的整个字符串；第二个元素是匹配的第一组结果，第三个元素是匹配的第二组结果。此时第一个元素就是属性endPoint存储的字符串，第二个元素就是带大括号的文本，第三个元素就是大括号内的文本，再通过属性parameterMap取得以第三个元素为key值的形参值，将matchResult中的第二个元素的文本的下标范围range作为key，再将形参值作为value，以此构造成键值对组成map 通过fold()函数将上一步骤得到的map每个元素进行操作，初始值设置为endPoint,该步骤功能为将endPoint中对应大括号包裹的文本替换为大括号内文本作为形参名对应的形参值 如此得到了将大括号及大括号中广西替换为形参值的字符串，其名为compiledEndPoint 定义属性url,用于存储完整的网络地址。也就是将apiPath和compiledEndPoint拼接到一起 调用 okHttp的newCall方法，进行网络请求。先通过Request.Builder()创建一个带url的request，之后调用execute()同步方法发起网络请求，之后获取返回体的charStream，通过use函数对流进行操作，结束时会自动关闭：通过gson的fromJson()方法将返回的内容反序列化，fromJson()方法第一个参数为JsonReader对象，构建对象时将charStream作为参数传入构造方法中；第二个参数为泛型的实参，可通过method.genericReturnType获取 #3. 测试反射读取注解请求网络功能 12345fun main() { val usersApi = RetroApi.create&lt;GitHubApi.Users&gt;() println(usersApi.get(&quot;puppet16&quot;)) println(usersApi.followers(&quot;puppet16&quot;).map { it.login })} 打印结果如下： 1234https://api.github.com/users/puppet16User(login=puppet16, location=Beijing, avatar_url=https://avatars.githubusercontent.com/u/14159272?v=4, bio=A day is a miniature of eternity. )https://api.github.com/users/puppet16/followers[xLily, lianxiaolei, Fakekid] 说明： 通过单例RetroApi的create方法，创建了一个GitHubApi.Users的实例userApi 先获取了用户名为puppet16的GitHub账号信息 又获取了用户名为puppet16的GitHub账号的关注列表 #五、示例 – 注解加持反射版Model映射 在kotlin学习系列七：反射中的 示例 – Model映射章节中，讲到可以通过map映射为任意类型数据类，但是当前实现有缺陷： map中的 key值必须与数据类的属性名字一致 1234567891011inline fun &lt;reified To : Any&gt; Map&lt;String, Any?&gt;.mapAs(): To { return To::class.primaryConstructor!!.let { it.parameters.map { parameter -&gt; parameter to (this[parameter.name] ?: if(parameter.type.isMarkedNullable) null else throw IllegalArgumentException(&quot;${parameter.name} is required but missing.&quot;)) }.toMap() .let(it::callBy) }} 说明： map中的key值与数据类中的构造方法中的属性名称对应，若map中没有构造方法中参数的值，则判断这个参数是否可以为null，若可以则返回空，否则直接抛异常 判断map中有没有构造方法中参数的值的依据是：将构造方法中的参数名当作了key值去map中取value，如此就必须保证map中存储的key必须与数据类中的构造方法中的属性名称相同 #1. 创建支持单个属性别名的注解FildName 12345678910111213141516171819202122232425262728293031323334353637383940@Target(AnnotationTarget.VALUE_PARAMETER)annotation class FieldName(val name: String)inline fun &lt;reified To : Any&gt; Map&lt;String, Any?&gt;.mapAs(): To { return To::class.primaryConstructor!!.let { it.parameters.map { parameter -&gt; parameter to (this[parameter.name] ?: (parameter.annotations.filterIsInstance&lt;FieldName&gt;().firstOrNull()?.name?.let(this::get)) ?: if (parameter.type.isMarkedNullable) null else throw IllegalArgumentException(&quot;${parameter.name} is required but missing.&quot;)) }.toMap() .let(it::callBy) }}data class Human(val name: String, @FieldName(&quot;avatar_url&quot;) val avatarUrl: String, @FieldName(&quot;detail_url&quot;) val detailUrl: String)data class Person( var id: Int, var name: String, var avatar_url: String, var smallUrl: String, var detail_url: String)fun main() { val personMap = mapOf( &quot;id&quot; to 0, &quot;name&quot; to &quot;Lee&quot;, &quot;avatar_url&quot; to &quot;https://api.github.com/users/Lee&quot;, &quot;detail_url&quot; to &quot;https://api.github.com/users/Lee&quot; ) val humanFromMap: Human = personMap.mapAs() println(humanFromMap)} 打印结果： 1Human(name=Lee, avatarUrl=https://api.github.com/users/Lee, detailUrl=https://api.github.com/users/Lee) 说明： 定义了名为FieldName的注解类，包含一个名为name的属性，使用于函数中的参数 改进之前的代码思路：将构造方法中的参数名当作了key值去map中取value时，若返回了null，则去判断这个构造方法的参数是否添加了注解，若有注解FieldName，则取出该注解实例中的name值，否则返回null，之后再走之前逻辑 通过parameter.annotations获取标注在该参数上的所有注解，再通过filterIsInstance&lt;FieldName&gt;()筛选中注解FieldName的实例组成的列表，再通过firstOrNull()方法，取第一个实例，再取其name属性值，再将name中的属性值作为key值，去map中取value 该注解只能给单个的属性修改name，若有多个不匹配的属性则要添加多个比较繁琐 #2. 创建支持数据类的注解MappingStrategy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Target(AnnotationTarget.CLASS)annotation class MappingStrategy(val klass: KClass&lt;out NameStrategy&gt;)interface NameStrategy { fun mapTo(name: String): String}object UnderScoreToCamel : NameStrategy { override fun mapTo(name: String): String { return name.toCharArray().fold(StringBuilder()) { acc, c -&gt; when (acc.lastOrNull()) { '_' -&gt; acc[acc.lastIndex] = c.toUpperCase() else -&gt; acc.append(c) } acc }.toString() }}object CamelToUnderScore : NameStrategy { override fun mapTo(name: String): String { return name.toCharArray().fold(StringBuilder()) { acc, c -&gt; when { c.isUpperCase() -&gt; acc.append('_').append(c.toLowerCase()) else -&gt; acc.append(c) } acc }.toString() }}inline fun &lt;reified To : Any&gt; Map&lt;String, Any?&gt;.mapAs(): To { return To::class.primaryConstructor!!.let { it.parameters.map { parameter -&gt; parameter to (this[parameter.name] ?: (parameter.annotations.filterIsInstance&lt;FieldName&gt;().firstOrNull()?.name?.let(this::get)) ?: To::class.findAnnotation&lt;MappingStrategy&gt;()?.klass?.objectInstance?.mapTo(parameter.name!!)?.let(this::get) ?: if (parameter.type.isMarkedNullable) null else throw IllegalArgumentException(&quot;${parameter.name} is required but missing.&quot;)) }.toMap() .let(it::callBy) }}@MappingStrategy(CamelToUnderScore::class)data class Human(val name: String, val avatarUrl: String, val detailUrl: String)data class Person( var id: Int, var name: String, var avatar_url: String, var smallUrl: String, var detail_url: String)fun main() { val personMap = mapOf( &quot;id&quot; to 0, &quot;name&quot; to &quot;Lee&quot;, &quot;avatar_url&quot; to &quot;https://api.github.com/users/Lee&quot;, &quot;detail_url&quot; to &quot;https://api.github.com/users/Lee&quot; ) val humanFromMap: Human = personMap.mapAs() println(humanFromMap)} 打印结果： 1Human(name=Lee, avatarUrl=https://api.github.com/users/Lee, detailUrl=https://api.github.com/users/Lee) 说明： 定义名为MappingStrategy的注解，接口类型为KClass的策略类，这个策略类必须实现接口NameStrategy，该接口中有一个函数mapTo()，功能是将入参name转为另一个name，使用于类上 该注解用于解决多个参数名称不匹配的问题，避免多次使用注解FieldName 创建一个实现接口NameStrategy的单例类UnderScoreToCamel，用于 将下划线风格的属性名称转为驼峰风格的属性名称。将传入的name转为字符数组，再通过fold()函数遍历每个字符，acc是StringBuilder类型，每次循环都将当前字符c添加到该属性中，判断如果acc最后一位是下划线，就将下划线的位置替换为大写的当前字符，否则就继续给acc添加当前字符。之后返回StringBuilder类型的acc，最后再调用toString()方法转为字符串。 创建一个实现接口NameStrategy的单例类CamelToUnderScore，用于 将驼峰风格的属性名称转为下划线风格的属性名称。实现逻辑与UnderScoreToCamel类似，只是判断条件变为了：如果当前字符c是大写的，就在其之前加个下划线，再添加小写的该字符；否则就直接给acc添加当前字符。之后返回StringBuilder类型的acc，最后再调用toString()方法转为字符串。 因为策略不需要每次做映射的时候都去创建，所以两个实现接口NameStrategy的策略类都定义为单例类型 之后再对mapAs()方法进行改造，在判断了FieldName注解之后，再判断注解MappingStrategy： 先获取要转换成的类的To上修饰的注解MappingStrategy 再获取该注解类中的策略类的KClass 因为策略类是单例，调用objectInstance，创建出该单例的实例，若存在则不会再次创建 再调用该单例中的mapTo方法，将目标类To中的参数名称按策略中的规则转换为其它风格的名称 最后再使用该名称去map中取出对应的value值 给Human数据类添加注解MappingStrategy，可以看到该数据类中属性名字是驼峰类型的，而Person中对应的属性名字是下划线类型的，要将person转为human，则策略类使用CamelToUnderScore，否则无法在map中找到应对的属性名 #六、 示例 – 注解处理器版 Model 映射 上一章节中讲述通过注解处理不同命名风格的属性的映射，但是每次都要调用自己写的mapAs()。 本章主要讲如何通过注解处理器自动生成modul自己的mapAs()方法 #1. 简述java编译过程 编译流程： 词法分析：词法分析的输入是 源程序 (即java文件)，输出是识别出的 记号流。目的是识别单词。单词至少分以下几类：关键字 (保留字)、标识符、字面量、特殊符号 语法分析：输入是词法分析器返回的 记号流，输出是 语法树。目的是得到语言结构并以树的形式表示。对于声明性语句，进行符号表的查填，对于可执行语句，检查结构合理的表达式运算是否有意义。 语义分析：根据语义规则对语法树中的语法单元 进行静态语义检查，如类型检查和转换等，目的在于保证语法正确的结构在语义分析上也是合法的。 中间代码生成(可选)：生成一种既接近目标语言，又与具体机器无关的表示，便于代码优化与代码生成。 (到目前为止，编译器与解释器可以一致) 中间代码优化(可选)：局部优化、循环优化、全局优化等；优化实际上是一个等价变换，变换前后的指令序列完成同样的功能，但在占用的空间上和程序执行的时间上都更省、更有效 目标代码生成：不同形式的目标代码—汇编语言形式、可重定位二进制代码形式、内存形式(Load-and-Go) 符号表管理：合理组织符号，便于各阶段查找\\填写等。 出错处理 说明： 抽象语法树 (Abstract Syntax Tree, AST) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的结构。 将源文件进行解析，构造抽象语法树，符号表填充，最输出扩展名为.class的字节码文件 在编译过程中会调用注解处理器APT(Annotation Process Tool) 扫描和处理注解，按照一定的规则，生成相应的java文件，然后再进行编译，注解处理器一般生成新的源文件，而不是更改之前源文件的语法树 参考文章：.java文件编译过程和执行过程分析 代码生成三方工具： 生成Java代码： JavaPoet 生成Kotlin代码： KotlinPoet #2. 开源库KotlinPoet 官网： KotlinPoet KotlinPoet是一个用于生成扩展名为.kt的kotlin文件的开源库，他支持Kotlin和Java语句 12345678910111213141516171819202122val personClass = ClassName(&quot;cn.lee.kotlin&quot;, &quot;Person&quot;)val file = FileSpec.builder(&quot;cn.lee.kotlin&quot;, &quot;KotlinPoetTest&quot;) .addType(TypeSpec.classBuilder(&quot;Person&quot;) .primaryConstructor(FunSpec.constructorBuilder() .addParameter(&quot;name&quot;, String::class) .build()) .addProperty(PropertySpec.builder(&quot;name&quot;, String::class) .initializer(&quot;name&quot;) .build()) .addProperty(PropertySpec.builder(&quot;age&quot;, Int::class) .initializer(&quot;18&quot;) .build()) .addFunction(FunSpec.builder(&quot;printContent&quot;) .addStatement(&quot;println(%P)&quot;, &quot;name= \\$name&quot;) .build()) .build()) .addFunction(FunSpec.builder(&quot;main&quot;) .addParameter(&quot;args&quot;, String::class, KModifier.VARARG) .addStatement(&quot;%T(args[0]).printContent()&quot;, personClass) .build()) .build()file.writeTo(System.out) 打印结果： 12345678910111213141516171819package cn.lee.kotlinimport kotlin.Intimport kotlin.Stringclass Person( val name: String) { val age: Int = 18 fun printContent() { println(&quot;&quot;&quot;name= $name&quot;&quot;&quot;) }}fun main(vararg args: String) { Person(args[0]).printContent()} 说明： ClassName作用是提供一个全称类名。该类必须是顶级成员 FileSpec用于创建Kotlin文件内容。内容包含顶级对象 （如类、对象、函数、属性和类型别名）, 通过Builder创建 FileSpec.builder方法中两个入参分别是创建的内容的文件所在包名及创建的内容的文件名 addType()方法是创建一个类。它接收一个TypeSpec对象作为参数 addFunction()方法是创建一个函数。它接收一个FunSpec对象作为参数 TypeSpec用于生成类、接口或枚举声明 TypeSpec.classBuilder()方法中的入参是创建的类的类名 primaryConstructor()方法是\b给要创建的类添加主构造器，其入参为FunSpec.constructorBuilder创建的构造器对象 addProperty()方法为类添加属性。其入参为PropertySpec对象 addFunction()方法为类添加函数。其入参为FunSpec对象 PropertySpec用于生成属性 PropertySpec.builder()方法中第一个入参是属性名称，第二个入参是属性类型 initializer()方法是为创建的属性赋初值，入参必须是String类型 若该方法创建的属性与FunSpec.constructorBuilder语句创建构造器时添加的属性名称一致时，会将属性合并到构造器中声明 FunSpec用于生成函数的声明 FunSpec.constructorBuilder()用于创建一个构造器函数 FunSpec.builder方法用于创建一个函数。它接收一个String对象作为参数，该参数即为创建的函数的名字 addParameter()方法为函数添加入参。第一个参数一般是入参名称，第二个参数是入参类型，第三个参数是入参修饰符 addStatement()方法为函数的函数体添加一条语句。第一个参数是具体语句，第二个参数是第一个参数中具体语句要使用的可变的内容，如字符串、类等。 用到第二个参数时 第一个参数需要添加占位符，第二个参数类型由占位符确定，占位符一定要大写 占位符 含义 示例 说明 %S 替换字符串 .addStatement(“return %S”, name) 只能替换一般文本，如果有$会将其进行转义 %P 替换含有$的字符串，即字符串模板 .addStatement(“println(%P)”, “name= $name”) 会将$符号作为正常文本 %T 替换某个类 .addStatement(“return %T()”, Date::class) .addStatement(“%T(args[0]).printContent()”, ClassName(“cn.lee.kotlin”, “Person”)) 若替换的是在 生成代码时恰好可用的类，则第二个参数是某个类的class引用，此时会自动将该类的包导入； 若要引用了一个不存在的类 (生成代码时尚未存在)，则第二个参数是ClassName对象 上述代码生成的文件KotlinPoetTest.kt地址：module名称/build/generated/source/kapt/debug/cn/lee/kotlin #3. 注解处理器AbstractProcessor #1. 自定义注解处理器 AbstractProcessor类是Java API提供的扫描源码并解析注解的框架，可以继承该抽象类来实现自己的解析注解逻辑。 自定义注解处理器所在的类是帮助我们生成需要的代码源文件的，我们最后需要的是他生成的文件，最后打包进apk也是他生成的文件，自定义注解处理器所在的类本身是不需要打包的，所以自定义注解处理类不需要放到打包的工程Module中。 继承AbstractProcessor的类需要实现以下四个方法： init()方法 会被注解处理工具调用，在这里可以做一些 初始化 的工作 process()方法 相当于每个处理器的主函数main()，在这里写扫描、评估和处理注解的代码，以及生成代码。 该方法提供两个参数： java.lang.model.element.TypeElement对象的Set集合：处理注解的过程要经过一个或者多个回合才能完成。每个回合中注解处理器都会被调用，并且接收到一个以在当前回合中已经处理过的注解类型的Type为元素的Set集合。 javax.annotation.processing.RoundEnvironment对象：通过这个对象可以访问到当前或者之前的回合中处理的Element元素 (即可以被注解类型注解的元素，如类、方法、参数等等)，只有被注解处理器注册的注解类型注解过的元素才会被处理。 getSupportedSourceVersion()方法 指定使用的Java版本，通常这里返回SourceVersion.latestSupported()，默认返回SourceVersion.RELEASE_6，该方法可以使用注解 @SupportedSourceVersion替代 getSupportedAnnotationTypes()方法 指定这个注解处理器是注册给哪个注解的。注意: 它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称，即注解器所支持的注解类型集合，如果没有这样的类型，则返回一个空集合，该方法可以使用注解 @SupportedAnnotationTypes替代 #2. 声明自定义注解处理器 需要在处理器所在module的main目录中创建resources文件夹 再在resources文件夹下创建META-INF.services的文件夹 最后在META-INF.services的文件夹中创建文件javax.annotation.processing.Processor 之后在该文件中写入自定义注解处理器的类全称 #4. 注解解析器Element element指的是一系列与之相关的接口集合，它们位于javax.lang.model.element包下面。 element是代表程序的一个元素，这个元素可以是：包、类/接口、属性变量、方法/方法形参、泛型参数。 element是java-apt (编译时注解处理器) 技术的基础 可以将element看作是java编译过程中语法分析后得出的语法树，每个类都是一个树，一个类是最外层的根节点，类变量和实例变量是根节点下的一个子节点，方法是另一个根节点，而方法中的变量又可以看成这个方法的子节点，依次类推下去。通过面向对象的方法我们将这个节点抽象出一个element类，这个类就提取出变量节点或者方法节点的一些相同的属性，Element就作为一个顶级的父类。 各种element所代表的元素类型如下图所示： 说明： PackageElement 代表包的接口 TypeElement 代表java程序中的类或者接口。提供访问该类型和其内部成员的一些方法。注意：枚举类型看做是类,注解类型看做是接口 VariableElement 代表一个字段,枚举常量,方法或者构造器的参数,本地变量,try-with-resource中的resource 变量,或者是异常参数 try-with-resources语句是一种声明了一种或多种资源的try语句。资源是指在程序用完了之后必须要关闭的对象try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。任何实现了java.lang.AutoCloseable接口的对象，和实现了java.io.Closeable接口的对象，都可以当做资源使用 TypeParameterElement 代表泛型类,接口,方法或者构造器的形式类型参数。一个类型参数就对应的一个类型变量 ExecutableElement 代表一个类或者接口的方法,构造器,或者初始块(静态或者实例的),包括注解类型。是Parameterizable的子接口 #5. 实现注解处理器版 Model 映射 #1. 创建注解 在自己创建的目录apt下创建 名为annotations的module 123456789101112131415161718192021222324252627//build.gradleplugins { id 'java' id 'org.jetbrains.kotlin.jvm'}group 'cn.lee.kotlin'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { mavenCentral()}dependencies { implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot; testImplementation group: 'junit', name: 'junit', version: '4.12'}compileKotlin { kotlinOptions.jvmTarget = &quot;1.8&quot;}compileTestKotlin { kotlinOptions.jvmTarget = &quot;1.8&quot;} 1234567//ModeMap.ktpackage cn.lee.kotlin.annotations.apt@Retention(AnnotationRetention.BINARY)@Target(AnnotationTarget.CLASS)annotation class ModelMap 说明： 在该module中创建了一个注解类ModelMap 该注解类作用于类上，且注解信息记录在编译之后的二进制文件中，但对反射不可见 #2. 创建注解处理器 #1. 添加依赖包 在自己创建的目录apt下创建 名为compiler的module 1234567891011121314151617181920212223242526272829303132//build.gradleplugins { id 'java' id 'org.jetbrains.kotlin.jvm'}group 'cn.lee.kotlin'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { jcenter()}dependencies { implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot; implementation &quot;com.squareup:kotlinpoet:1.4.3&quot; implementation &quot;com.bennyhuo.aptutils:aptutils:1.7.1&quot; implementation project(&quot;:apt:annotations&quot;) testImplementation group: 'junit', name: 'junit', version: '4.12'}compileKotlin { kotlinOptions.jvmTarget = &quot;1.8&quot;}compileTestKotlin { kotlinOptions.jvmTarget = &quot;1.8&quot;} 说明： 注解处理器所在的module需要添加注解module的依赖以方便读取注解 注解处理器要根据注解生成对应Kotlin代码，所以添加KotlinPoet的依赖 为了方便的编写注解处理器，添加了bennyhuo老师的开源库aptutils #2. 创建处理器 创建文件名为ModelMapProcessor的注解处理器 1234567891011121314151617181920212223242526272829303132333435363738394041//ModelMapProcessor.kt@SupportedAnnotationTypes(&quot;cn.lee.kotlin.annotations.apt.ModelMap&quot;)@SupportedSourceVersion(SourceVersion.RELEASE_8)class ModelMapProcessor: AbstractProcessor() { override fun init(processingEnv: ProcessingEnvironment) { super.init(processingEnv) AptContext.init(processingEnv) } override fun process(annotations: MutableSet&lt;out TypeElement&gt;, roundEnv: RoundEnvironment): Boolean { roundEnv.getElementsAnnotatedWith(ModelMap::class.java) .forEach { element -&gt; element.enclosedElements.filterIsInstance&lt;ExecutableElement&gt;() .firstOrNull { it.simpleName() == &quot;&lt;init&gt;&quot; } ?.let { val typeElement = element as TypeElement FileSpec.builder(typeElement.packageName(), &quot;${typeElement.simpleName()}\\$\\$ModelMap&quot;) .addFunction( FunSpec.builder(&quot;toMap&quot;) .receiver(typeElement.asType().asKotlinTypeName()) .addStatement(&quot;return mapOf(${it.parameters.joinToString {&quot;&quot;&quot;&quot;${it.simpleName()}&quot; to ${it.simpleName()}&quot;&quot;&quot; }})&quot;) .build() ) .addFunction( FunSpec.builder(&quot;to${typeElement.simpleName()}&quot;) .addTypeVariable(TypeVariableName(&quot;V&quot;)) .receiver(MAP.parameterizedBy(STRING, TypeVariableName(&quot;V&quot;))) .addStatement( &quot;return ${typeElement.simpleName()}(${it.parameters.joinToString{ &quot;&quot;&quot;this[&quot;${it.simpleName()}&quot;] as %T &quot;&quot;&quot; } })&quot;, *it.parameters.map { it.asType().asKotlinTypeName() }.toTypedArray() ) .build() ) .build().writeToFile() } } return true }} 说明： 该示例中指定该处理器只支持注解ModelMap 该示例中初始化了开源库aptutils中的AptContext 该示例中使用注解指定了java版本为1.8 通过上下文roundEnv的getElementsAnnotatedWith()方法获取被某注解标注的元素，该方法入参为注解的java的class，返回的是一个元素集合 再通过forEach语句对元素列表中每个元素进行处理 element.enclosedElements 语句返回该元素所包含的元素列表。类或接口被认为包含了它直接声明的字段、方法、构造函数和成员类型。包直接包含了顶级类和接 口，但不包含其子包 .filterIsInstance&lt;ExecutableElement&gt;()语句返回某类元素实例列表。此时是从上条语句中得到的元素列表中过滤出ExecutableElement类型的元素实例 firstOrNull语句返回符合筛选条件的对象，此时它的筛选条件是it.simpleName() == &quot;&lt;init&gt;&quot;,即筛选出构造器对象 将element强转为TypeElement类型的属性typeElement 使用KotlinPoet中的FileSpec.builder语句来创建kotlin文件内容 typeElement.packageName()为开源库aptutils中对TypeElement类的扩展方法，用于获取该element所在的顶级元素的包名。如此创建的kotlin文件所在的包名即为该元素所在顶级元素的包名 ${typeElement.simpleName()}\\$\\$ModelMap，是取被标注的类的简单名字加上两个$符号再加上字符串ModelMap,最后拼接成的字符串即为创建的kotlin文件的名字 通过addFunction()方法为创建的kotlin文件添加了名为toMap的函数，该函数功能是将主构造器中的参数生成一个Map,并将其返回。 通过receiver()为toMap函数添加receiver，即toMap函数为该receiver的扩展函数。此时我们使用入参为TypeName类型参数的receiver()方法，使用aptutils的typeElement.asType().asKotlinTypeName()方法，可以解决Kotlin中一些类型映射问题，避免在Kotlin文件中出现Java的类型，而直接使用typeElement.asClassName()获取的TypeName类型，就可能会出现在生成的Kotlin代码中使用Java的类 通过addStatement()方法为函数添加一行代码，实现的代码示例为：return mapOf(&quot;name&quot; to name, &quot;age&quot; to age) joinToString()方法功能为遍历集合元素，为集合元素间添加分隔符，组成一个新的字符串并返回。默认分隔符为逗号。 ${it.parameters.joinToString {&quot;&quot;&quot;&quot;${it.simpleName()}&quot; to ${it.simpleName()}&quot;&quot;&quot; }}语句作用是遍历主构造器中的参数列表，将参数列表组成键值对，所以to前的参数名称添加了双引号，后面的没有。 通过addFunction()方法为创建的kotlin文件添加函数，函数名为to加上被注解@ModelMap所修饰的类的简单类名。该函数功能是根据Map生成被@ModelMap标注的类对象。 通过addTypeVariable()为该函数声明一个泛型，通过语句TypeVariableName()定义该泛型名称,此时声明该泛型为V 通过receiver()为该函数添加receiver，MAP.parameterizedBy()方法返回一个设置了Key和value类型的Map，此时key为String，value就是之前声明的泛型V 通过addStatement()方法为该函数添加一条语句，生成代码示例为：Human(this[&quot;name&quot;] as String , this[&quot;age&quot;] as Int) 通过it.parameters.joinToString()方法遍历主构造器中参数列表，取出以参数名为Key的存于Map中的value值，因为value值对应的map中的类型是泛型可以是任何类型，所以在此处还要进行类型转换，使用%T。注意：有几个形参就会有几个%T *it.parameters.map { it.asType().asKotlinTypeName() }.toTypedArray()是addStatement()方法的第二个参数，用于替换%T，第二个参数是变长参数，而我们最后返回的是一个数组，所以需要加星号，将数组展开便于传值。 最后通过aptutils中的writeToFile()方法将文件内容与入到文件中 #3. 添加处理器声明 创建好注解处理器后，我们需要告诉编译器在编译的时候使用哪个注解处理器 说明： 在javax.annotation.processing.Processor文件中写入自定义注解处理器的类全称：cn.lee.kotlin.annotations.apt.compiler.ModelMapProcessor #3. 测试注解处理器 在主Module下进行测试 #1. build.gradle.kts配置 12345678910111213141516171819202122232425262728//build.gradle.ktsimport org.jetbrains.kotlin.config.KotlinCompilerVersionplugins { id (&quot;com.android.application&quot;) id (&quot;kotlin-android&quot;) kotlin(&quot;kapt&quot;) kotlin(&quot;jvm&quot;) version &quot;1.4.30&quot; ...}android { ... compileOptions { sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 kotlinOptions.jvmTarget = &quot;1.8&quot; }}dependencies { ... implementation(kotlin(&quot;stdlib-jdk8&quot;, KotlinCompilerVersion.VERSION)) //注解处理器示例 kapt (project(&quot;:apt:compiler&quot;)) implementation (project(&quot;:apt:annotations&quot;))} 说明： 添加kapt的插件支持 设置kotlin在编译时使用的jvmTarget是1.8版本 添加注解模块的运行时依赖 自定义注解处理器所在的module并不是运行时的依赖，我们只需要处理器生成的文件 Kapt官网 #2. 创建测试文件 123456789101112131415161718import cn.lee.kotlin.annotations.apt.ModelMapfun main() { val person = Person(&quot;Lee&quot;, 18) val human = person.toMap().toHuman() println(person) println(human)}//fun Human.toMap() = mapOf(&quot;name&quot; to name, &quot;age&quot; to age)//fun &lt;V&gt; Map&lt;String, V&gt;.toHuman() = Human(this[&quot;name&quot;] as String , this[&quot;age&quot;] as Int)@ModelMapdata class Human(val name: String, val age :Int)@ModelMapdata class Person(val name: String, val age :Int, val address:String = &quot;china&quot;) 打印结果如下： 12Person(name=Lee, age=18, address=china)Human(name=Lee, age=18) 说明： 创建两个数据类Human、Person，为这两个类添加注解@ModelMap，如此对应生成的文件名为Human$$ModelMap.kt、Person$$ModelMap.kt,地址如下： 在main()函数中创建Person对象person，再将person转为Map,再将Map转为了Human 生成的两个文件内容如下： 1234567891011//Human$$ModelMap.ktpackage cn.ltt.projectcollection.kotlin.annotationlabimport kotlin.Intimport kotlin.Stringimport kotlin.collections.Mapfun Human.toMap() = mapOf(&quot;name&quot; to name, &quot;age&quot; to age)fun &lt;V&gt; Map&lt;String, V&gt;.toHuman() = Human(this[&quot;name&quot;] as String , this[&quot;age&quot;] as Int ) 123456789101112//Person$$ModelMap.ktpackage cn.ltt.projectcollection.kotlin.annotationlabimport kotlin.Intimport kotlin.Stringimport kotlin.collections.Mapfun Person.toMap() = mapOf(&quot;name&quot; to name, &quot;age&quot; to age, &quot;address&quot; to address)fun &lt;V&gt; Map&lt;String, V&gt;.toPerson() = Person(this[&quot;name&quot;] as String , this[&quot;age&quot;] as Int , this[&quot;address&quot;] as String ) #七、Kotlin编译器插件 #1. 编译器插件工作机制 在Java平台上，会将*.kt文件编译为*.class文件，而编译器插件会基于编译好的*.class文件直接修改该文件的内容，注解处理器会创建新的类参与编译。 #2. AllOpen插件 #1. AllOpen插件介绍 Kotlin 的类及其成员默认是 final 的，可以使用AllOpen插件去掉final修饰符 AllOpen插件包括两个插件： AllOpen-Intellij：为开发者提供便利，可以在编写代码时直接继承由AllOpen插件去掉final修饰符的类 AllOpen-Gradle：真正完成编译器插件逻辑 #2. AllOpen插件源码 源码地址：https://github.com/JetBrains/kotlin/blob/master/plugins/allopen/allopen-cli/src/AllOpenDeclarationAttributeAltererExtension.kt 1234567891011121314151617181920212223242526272829303132//AllOpenDeclarationAttributeAltererExtension.ktpackage org.jetbrains.kotlin.allopen...abstract class AbstractAllOpenDeclarationAttributeAltererExtension : DeclarationAttributeAltererExtension, AnnotationBasedExtension { companion object { val ANNOTATIONS_FOR_TESTS = listOf(&quot;AllOpen&quot;, &quot;AllOpen2&quot;, &quot;test.AllOpen&quot;) } override fun refineDeclarationModality( modifierListOwner: KtModifierListOwner, declaration: DeclarationDescriptor?, containingDeclaration: DeclarationDescriptor?, currentModality: Modality, isImplicitModality: Boolean ): Modality? { if (currentModality != Modality.FINAL || modifierListOwner.isPrivate()) { return null } val descriptor = declaration as? ClassDescriptor ?: containingDeclaration ?: return null if (descriptor.hasSpecialAnnotation(modifierListOwner)) { return if (!isImplicitModality &amp;&amp; modifierListOwner.hasModifier(KtTokens.FINAL_KEYWORD)) Modality.FINAL // Explicit final else Modality.OPEN } return null }} 说明： 在refineDeclarationModality()方法中实现去掉final的逻辑 先判断如果没有final修饰符，或类是private的话都不做任何处理 再定义一个属性descriptor值是强转为ClassDescriptor类型的declaration或是不为空的containingDeclaration，否则不做任何处理 之后判断类是否被对应的注解标注，若没有则不做处理 之后再判断是否手动添加的final，若是手动添加的则返回final，否则返回open #3. NoArg插件 #1. NoArg插件介绍 NoArg插件，给数据类加一个注解，使用数据类在编译时生成一个无参构造器，但无法在代码里直接访问该构造器，只能通过反射拿到 NoArg插件包括两个插件： NoArg-Intellij：为开发者提供便利，可以在反编译时直接看到生成的无参构造器 NoArg-Gradle：真正完成编译器插件逻辑 #2. NoArg插件源码 #1. NoArg-Gradle关键源码 源码地址：https://github.com/JetBrains/kotlin/blob/master/plugins/noarg/noarg-cli/src/AbstractNoArgExpressionCodegenExtension.kt 1234567891011121314151617181920212223242526272829303132//AbstractNoArgExpressionCodegenExtension.ktpackage org.jetbrains.kotlin.noargabstract class AbstractNoArgExpressionCodegenExtension(val invokeInitializers: Boolean) : ExpressionCodegenExtension, AnnotationBasedExtension { private fun ImplementationBodyCodegen.generateNoArgConstructor() { ... functionCodegen.generateMethod(JvmDeclarationOrigin.NO_ORIGIN, constructorDescriptor, object : CodegenBased(state) { override fun doGenerateBody(codegen: ExpressionCodegen, signature: JvmMethodSignature) { codegen.v.load(0, AsmTypes.OBJECT_TYPE) if (isParentASealedClassWithDefaultConstructor) { codegen.v.aconst(null) codegen.v.visitMethodInsn( Opcodes.INVOKESPECIAL, superClassInternalName, &quot;&lt;init&gt;&quot;, &quot;(Lkotlin/jvm/internal/DefaultConstructorMarker;)V&quot;, false ) } else { codegen.v.visitMethodInsn(Opcodes.INVOKESPECIAL, superClassInternalName, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false) } if (invokeInitializers) { generateInitializers(codegen) } codegen.v.visitInsn(Opcodes.RETURN) } }) }} 说明： 因为要添加一个无参的构造器，所以直接对字节码进行操作 其中有一条语句判断invokeInitializers是否为true：为true，则执行generateInitializers()方法，该方法用于生成构造器 #2. NoArg-Intellij关键源码 源码地址：https://github.com/JetBrains/kotlin/blob/master/plugins/noarg/noarg-ide/src/IdeArgExpressionCodegenExtension.kt 1234567891011//IdeArgExpressionCodegenExtension.ktpackage org.jetbrains.kotlin.noarg.ideclass IdeNoArgExpressionCodegenExtension(project: Project) : AbstractNoArgExpressionCodegenExtension(invokeInitializers = false) { private val cachedAnnotationsNames = CachedAnnotationNames(project, NO_ARG_ANNOTATION_OPTION_PREFIX) override fun getAnnotationFqNames(modifierListOwner: KtModifierListOwner?): List&lt;String&gt; = cachedAnnotationsNames.getAnnotationNames(modifierListOwner)} 说明： invokeInitializers设置为了false，所以IntelliJ反编译Kotlin看不到invokeInitializers为true的效果 #4. 其它实用插件 常用插件名称 作用 适用范围 android-extensions 合成View属性、生成对应的字节码 省略了findViewById语句，可以直接使用布局文件中声明的viewId当作View的属性来访问View kotlin-serialization 为序列化类生成serializer,支持跨平台 用于数据类的序列化及反序列化，支持跨平台，生成的serializer可以给java平台生成字节码，还可以给js、native生成对应javascript、机器码等 #5. 总结 Kotlin编译器插件不仅支持Java平台，还支持Js平台、Native平台等，是跨平台的 注解处理器 Kotlin编译器插件 输出形式 源码 字节码 能力范围 新增类，不能修改 新增、修改已有类 依赖约束 依赖注解 可深入编译器细节 API状态 稳定，公开 未公开，未来可期 支持平台 Java虚拟机 跨平台 上手难度 要对Java编译过程有一些了解，熟悉符号表 掌握目标代码 (字节码、机器码) 生成 #八、 参考文章 https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-metadata/ https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/ 正确使用Kotlin注解，兼容Java代码 .java文件编译过程和执行过程分析 Android APT（Java注解应用） java-apt的实现之Element详解 javax.lang.model.element源码解析","link":"/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/"},{"title":"Kotlin学习系列五：类型进阶","text":"一、前言 二、 类的构造器 1. 基本写法 2. 类的继承 3. 副构造器 4. 构造同名的工厂函数 三、 类与成员的可见性 1. 可见性对比 2. 修饰对象 3. internal与default的对比 4. 构造器的可见性 5. 属性的可见性 6. 顶级声明的可见性 四、 类属性的延迟初始化 1. 延迟初始化原因 2. 延迟初始化实现 1. 为需要延迟初始化的成员赋空值 2. 使用关键字lateinit 3. 使用lazy 4. 方案对比 五、 代理(委托) Delegate 1. 接口代理 2. 属性代理(委托) 1. 直接委托 2. lazy 懒加载委托 3. Delegates.observable 观察者委托 4. 自定义属性代理类 5. 自定义属性代理 6. 委托案例-1：属性可见性封装 7. 委托案例-2：数据与 View 的绑定 8. 委托案例-3：ViewModel 委托 六、 单例 object 1. 单例定义 2. 访问object的成员 3. 静态成员@JvmStatic 1. 在单例中使用@JvmStatic 2. 在普通类中使用@JvmStatic 4. @JvmField 1. 在单例中使用@JvmField 2. 在普通类中使用@JvmField 5. object的构造器 七、内部类inner class 1. 内部类定义 2. 内部类实例化 3. 单例object的内部object 4. 匿名内部类 八、数据类data class 1. 数据类定义 2. component 3. 数据类解构 4. JavaBean 与 data class 区别 5. data class 总结 九、枚举类enum class 1. 枚举类定义 2. 枚举类属性 3. 枚举类构造器 4. 枚举类实现接口 1. 统一实现 2. 各自实现 5. 为枚举定义扩展 6. 枚举类条件分支 7. 枚举类比较大小 8. 枚举类区间 十、密封类sealed class 1. 密封类概念 2. 密封类定义 3. 密封类的子类 4. 密封类子类分支 5. 密封类使用 6. 密封类和枚举类对比 十一、内联类inline class 1. 内联类概念 2. 内联类定义 3. 内联类方法 4. 内联类属性 5. 内联类继承关系 6. 内联类编译优化 7. 内联类使用场景 1. 内联类官方例子 2. 使用内联类模拟枚举 8. 内联类的限制 9. 别名 (typealias) 与内联类 (inline class) 区别 十二、示例 - 数据类序列化 1. 引入工具 1. Gson 2. Moshi 3. Kotlinx.serialization 2. 示例代码 1. 简单序列化json 2. 带默认参数的json序列化 1. Gson处理默认参数 2. Moshi处理默认参数 3. K.S处理默认参数 3. 带init块或成员初始化的数据类序列化 1. Gson序列化带init块的数据类 2. Moshi序列化带init块的数据类 3. K.S序列化带init块的数据类 3. 框架对比 十三、示例 - 递归整型列表 十四、参考文章 #一、前言 本文主要讲述Kotlin 类型进阶 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶 kotlin学习系列十一：协程应用 #二、 类的构造器 #1. 基本写法 将构造器写到类的定义上 123class Person constructor(var age:Int, name:String) {} 说明： 如上定义一个类Person，其中关键字constructor可省略 同时定义了类内的属性age, 类内全局可见 同时定义了一个形参name，构造器内可见 (init 块，属性初始化） init 块： 12345678910class Person(var age:Int, name:String) { var name: String init { this.name = name } val firstName = name.split(&quot; &quot;)[0] init { println(&quot;firstName:$firstName&quot;) }} 说明： init块类似于主构造器 的方法体，init块可以有多个 多个init块会按从上到下 的顺序合并执行，上面示例执行顺序如下： 123456789class Person(var age: Int, name: String) { var name: String var firstName: String init { this.name = name firstName = name.split(&quot; &quot;)[0] }} Java中有类似功能，名为构造块 1234567891011121314151617public static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } { System.out.println(&quot;Person-构造块&quot;); } static { System.out.println(&quot;Person-静态构造块&quot;); }} 说明： java中执行顺序为：静态构造块 --&gt;构造块 --&gt;构造方法 构造块访问不到构造方法内的形参 #2. 类的继承 Kotlin中类的继承需要在子类后而加:父类构造器 1234567891011121314class Person(var age: Int,name: String) :Animal(){ var personName: String var firstName: String init { this.personName = name firstName = name.split(&quot; &quot;)[0] }}abstract class Animal(var name: String) { constructor():this(&quot;unknown&quot;)} #3. 副构造器 定义了主构造器后，在类内部再定义的构造器都被称为副构造器 123456fun main() { val person = Person()}class Person(var age: Int,name: String){ constructor():this(20, &quot;unknown&quot;)} 说明： 副构造器必须调用主构造器 若子类没有主构造器，则不必在继承父类时调用构造器，可在副构造器时调用父类的构造器 123456789class Person :Animal{ var personName: String constructor(personName: String): super(&quot;unknown&quot;){ this.personName = personName }}abstract class Animal(var name: String) {} 建议创建类时采用主构造器 + 默认参数的方式，这样构造路径较少，减少复杂度 @JvmOverloads注解 作用： 主构造器的默认参数 在Java代码中可以以重载的形式调用，即可省略 12345//kotlinclass Person @JvmOverloads constructor(var age: Int = 18,name: String){ constructor():this(20, &quot;unknown&quot;)} 12//javaPerson person = new Person(&quot;lee&quot;); 如上，若kotlin中主构造器前不加@JvmOverloads注解，则java中的调用语句会报错。 #4. 构造同名的工厂函数 在Kotlin中，定义了一个类情况下，还可以定义同名的函数，该同名函数一般用于构建同名类对象 12val str = String()val str1 = String(charArrayOf('1','2')) 如上，第一个语句调用的是类String的构造器来创建一个String对象，第二条语句是调用的函数String()来创建一个String对象，该函数入参为CharArray。还可以自定义同名的函数，如下 123fun String(ints: IntArray): String { return ints.contentToString()} #三、 类与成员的可见性 #1. 可见性对比 可见性类型 Java Kotlin public 公开 与 java 相同，默认类型 internal X 模块内可见 default 包内可见，默认 X protected 包内及子类可见 类内及子类可见 private 类内可见 类或文件内可见 #2. 修饰对象 可见性类型 顶级声明 类 成员 public 可以 可以 可以 internal 可以 可以 可以 protected 不可 不可 可以 private 可以 可以 可以 说明： internal虽然所有都可以修饰，但是被修饰的对象是模块内可见 private虽然所有都可以修饰，但是修饰顶级声明和类时，只是文件内可见；修饰成员的话只是类内可见 模块：在一次调用命令kotlinc的文件当中，internal可见，直观的讲，大致可认为一个Jar包、一个aar #3. internal与default的对比 一般由 SDK 或公共组件开发者用于隐藏模块内部细节实现 default可通过外部创建相同包名来访问，访问控制非常弱 default会导致不同抽象层次的类聚集到相同包之下 internal可方便处理内外隔离，提升模块代码内聚、减少接口暴露 internal修饰的Kotlin类或成员在Java当中可直接访问，此时若想Java不能调用，需要借助注解@JvmName()为将类或成员添加一个Java识别的不符合 java 命名规范的名称 123456//kotlininternal class Person(var name: String = &quot;Lee&quot;, var age:Int = 18) { internal fun printPerson() { println(&quot;Person{name=$name, age=$age}&quot;) }} 123//javaPerson person = new Person();person.printPerson$ProjectCollection_app(); 如上所示，在kotlin中声明了一个internal的类Person，其中有一个用于打印信息的函数printPerson()，正常情况下，在Java文件中，创建Person对象后，可直接调用该函数，在java中该函数名字是方法名 $ 模块名 1234567//kotlininternal class Person(var name: String = &quot;Lee&quot;, var age:Int = 18) { @JvmName(&quot;123&quot;) internal fun printPerson() { println(&quot;Person{name=$name, age=$age}&quot;) }} 123//javaPerson person = new Person();person.123(); 如上所示，为函数printPerson()添加了注解@JvmName, 让java识别该函数名为123, 但因Java不支持该命名方式，所以不可以调用该函数 #4. 构造器的可见性 在声明类时若要为声明的主构造器限制作用域，则不可以省略关键字constructor 比如说要将该类写成一个单例或写成工厂，则应该将构造器私有化 1class Person private constructor(var age:Int, var name:String) #5. 属性的可见性 可在声明属性时直接加可见性关键字进行修饰 1class Person private constructor(private var age:Int, var name:String) 如上所示，将属性age私有化，则创建对象person后，无法访问age属性。 还可以为属性的setter添加可见性 123456class Person(var name: String, private var age:Int) { var firstName: String = &quot;&quot; private set(value) { field = value }} 不可以设置getter的可见性，因为getter可见性要与属性保持一致 setter的可见性不得大于属性的可见性 #6. 顶级声明的可见性 顶级声明批文件内直接定义的属性、函数、类等 顶级声明不支持projected，在kotlin中只有子类可见的含义 顶级声明被private修饰表示文件内部可见 #四、 类属性的延迟初始化 #1. 延迟初始化原因 类属性必须在构造时初始化 某些成员只有在类构造之后才会被初始化 12345678private TextView mTvName;@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mTvName = findViewById(R.id.tv_name);} 如上，Android中创建了一个名为mTvName的TextView，并在onCreate()方法中为其赋值。但是转换为Kotlin代码时却会在声明变量时报错，因为没有初始化，此时可将变量先定义为可空，然后赋空，再在onCreate()方法中为其赋正确的值。 #2. 延迟初始化实现 #1. 为需要延迟初始化的成员赋空值 1234567private var mTvName: TextView? = nulloverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_test) mTvName = findViewById(R.id.tv_name);} 如上，将变量mTvName初始化为了null，再在onCreate()方法中为其赋正确的值，虽然解决了要延后初始化的问题，但每次使用mTvName的属性时都要将其做判空处理或进行类型强转。为解决以上问题可使用关ß键字lateinit #2. 使用关键字lateinit 可在需要延迟初始化的成员声明前加上关键字lateinit 1234567private lateinit var mTvName: TextViewoverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_test) mTvName = findViewById(R.id.tv_name);} 说明： 使用关键字lateinit修饰的属性必须定义为var，允许再次赋值 关键字lateinit会让编译器忽略变量的初始化，不支持Int等基本类型，只能修饰非基本类型 在Kotlin的 1.2 版本之后，为属性添加了扩展方法isInitialized，可使用该方法来判断被lateinit修饰的属性是否被初始化，已初始化返回true 必须在能够完全确定变量值的生命周期下使用lateinit 不要在复杂的逻辑中使用lateinit，否则可读性会很差，不能很清晰的知道在哪里初始化 #3. 使用lazy 123private val mTvName by lazy { findViewById&lt;TextView&gt;(R.id.tv_name)} 说明： 如上代码使用的是属性代理，lazy本身是属性代理的实现，只有mTvName首次被访问时才会执行lambda表达式内代码 如上将声明和初始化放到了一起，可读性较强 #4. 方案对比 方案名称 优缺点 推荐 可空类型 增代码复杂度；初始化与声明分离；调用处需要做判空处理 不推荐 lateinit 初始化与声明分离；调用处虽无需判空处理，但潜在的初始化问题可能被掩盖 一般 lazy 初始化与声明内聚；无需声明可空类型 推荐 #五、 代理(委托) Delegate 接口代理： 某对象代替某个类实现某个接口 属性代理： 某对象代替某属性实现getter/setter方法 代理模式主要由三部分组成： 1. 协议：用来指定代理双方可以做什么，必须做什么。 2. 代理：根据指定的协议，完成委托方要实现的功能。 3. 委托：根据指定的协议，指定代理去完成什么功能。 #1. 接口代理 123456789interface TextWatcher { fun beforeTextChanged() fun onTextChanged() fun afterTextChanged();} 如上声明一个接口TextWatcher，其中三个方法，用于监听文本改变之前，文本改变时，文本改变之后三个状态。 12345678910111213class TextWatcherImpl : TextWatcher { override fun beforeTextChanged() { println(&quot;beforeTextChanged&quot;) } override fun onTextChanged() { println(&quot;onTextChanged&quot;) } override fun afterTextChanged() { println(&quot;afterTextChanged&quot;) }} 如上所示，正常的一个类实现接口时，需要将接口的所有方法全部实现。此时若有一个业务场景：需要在afterTextChanged()方法内做一些其它逻辑，其它两个方法还沿用之前的逻辑，此时应创建一个wrapper类，包装一下TextWathcerImpl 123456789101112131415class TextWatcherImplWrapper(val watcher: TextWatcher) : TextWatcher { override fun beforeTextChanged() { watcher.beforeTextChanged() } override fun onTextChanged() { watcher.onTextChanged() } override fun afterTextChanged() { watcher.afterTextChanged() println(&quot;wrapper&quot;) }} 如上所示，创建一个类TextWatcherImplWrapper除了继承TextWatcherImpl类的功能外，在afterTextChanged()方法里又做了其它操作，相较于TextWatcherImpl类，除了在afterTextChanged()方法做了修改，另外两个方法没有修改，但是还必须创建出来 12345678class TextWatcherImplWrapper(val watcher: TextWatcher) : TextWatcher by watcher { override fun afterTextChanged() { watcher.afterTextChanged() println(&quot;wrapper&quot;) }} 说明： by关键字可以看作是委托，将某操作委托给某对象 by watcher作用是使对象watcher代替类TextWatcherImplWrapper实现接口TextWatcher，而watcher是作为一个参数传入的 TextWatcherImplWrapper相当于一个壳，它虽然实现了TextWatcher接口，但并不关心它怎么实现，具体的实现由传入的watcher对象实现 对于对象watcher的唯一要求是实现了被代理的接口也就是TextWatcher 使用此方法后，只需要在包装类内实现需要修改的方法即可，编译器会在编译时将其它方法添加到该类内，编译后的TextWatcherImplWrapper代码如下： 123456789101112131415161718192021222324252627public final class TextWatcherImplWrapper implements TextWatcher { @NotNull private final TextWatcher watcher; public TextWatcherImplWrapper(@NotNull TextWatcher watcher) { this.watcher = watcher; } @NotNull public final TextWatcher getWatcher() { return this.watcher; } public void beforeTextChanged() { this.watcher.beforeTextChanged(); } public void onTextChanged() { this.watcher.onTextChanged(); } public void afterTextChanged() { this.watcher.afterTextChanged(); String var1 = &quot;wrapper&quot;; System.out.println(var1); }} 说明： 以上代码显示， TextWatcher 接口的三个方法的实现委托给了传入的对象watcher。 Kotlin的委托类提供了 语法层面的委托模式。 通过 by 关键字，就可以自动将接口里的方法委托给一个对象，从而可以帮我们省略很多接口方法适配的模板代码。 #2. 属性代理(委托) Kotlin “代理类”代理的是接口方法，而“代理属性”委托的，则是属性的 getter、setter。 我们知道 val 定义的属性，它只有 get() 方法；而 var 定义的属性，既有 get() 方法，也有 set() 方法。Kotlin 提供了好几种标准委托，其中包括两个属性之间的直接委托、by lazy 懒加载委托、Delegates.observable 观察者委托，以及 by map 映射委托。前面两个的使用频率比较高，后面两个频率比较低。 #1. 直接委托 直接委托即将属性A 委托给属性B，从Kotlin1.4开始，我们可以直接在语法层面将 “属性A”委托给“属性B”，就像下面这样： 1234class Item { var count: Int = 0 var total: Int by ::count} 说明： 以上代码定义了两个变量，count 和 total，其中 total 的值与 count 完全一致，因为我们把 total 这个属性的 getter 和 setter 都委托给了 count。 使用by关键字，代表 total 属性的 getter、setter 会被委托出去。 ::count 代表 total 被委托给了 count。这里的 “::count” 是属性的引用，它跟我们前面学过的函数引用是一样的概念。 total 和 count 两者之间的委托关系一旦建立，就代表了它们两者的 getter 和 setter 会完全绑定在一起，反编译后代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class Item { private int count; @NotNull private final KMutableProperty0 total$delegate = new Item$total$2((Item)this); public final int getCount() { return this.count; } public final void setCount(int var1) { this.count = var1; } public final int getTotal() { KProperty0 var1 = (KProperty0)this.total$delegate; Object var3 = null; return ((Number)var1.get()).intValue(); } public final void setTotal(int var1) { KMutableProperty0 var2 = this.total$delegate; Object var4 = null; Integer var5 = var1; var2.set(var5); }}// Item$total$2.javapackage cn.xdf.pad.launchtasks;import kotlin.Metadata;import kotlin.jvm.internal.MutablePropertyReference0Impl;import org.jetbrains.annotations.Nullable;final class Item$total$2 extends MutablePropertyReference0Impl { Item$total$2(Item var1) { super(var1, Item.class, &quot;count&quot;, &quot;getCount()I&quot;, 0); } @Nullable public Object get() { return ((Item)this.receiver).getCount(); } public void set(@Nullable Object value) { ((Item)this.receiver).setCount(((Number)value).intValue()); }} 说明： 底层生成一个名为Item$total$2的delegate来实现代理关系 调用 total的setter方法及getter方法时会通过生成的delegate来调用count的setter方法及getter方法 因为 total被委托了setter及getter，所以total不需要存值，没有field 总结： 直接委托特性，其实对我们 软件版本之间的兼容 很有帮助。假设 Item 是服务端接口的返回数据，1.0 版本的时候，我们的 Item 当中只 count 这一个变量而到了 2.0 版本的时候，我们需要将 count 修改成 total，这时候问题就出现了，如果我们直接将 count 修改成 total，我们的老用户就无法正常使用了。但如果我们借助委托，就可以很方便地实现这种兼容。我们可以定义一个新的变量 total，然后将其委托给 count，这样的话，2.0 的用户访问 total，而 1.0 的用户访问原来的 count，由于它们是委托关系，也不必担心数值不一致的问题。 #2. lazy 懒加载委托 懒加载，就是对于一些需要消耗计算机资源的操作，我们希望它在被访问的时候才去触发，从而避免不必要的资源开销。 lazy 的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@file:kotlin.jvm.JvmName(&quot;LazyKt&quot;)import kotlin.reflect.KPropertypublic actual fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable { private var initializer: (() -&gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress(&quot;UNCHECKED_CAST&quot;) return _v1 as T } return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else &quot;Lazy value not initialized yet.&quot; private fun writeReplace(): Any = InitializedLazyImpl(value)}@kotlin.internal.InlineOnlypublic inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value 说明： lazy实际上是一个函数，它接收了一个函数，即lazy为高阶函数 lazy函数返回一个lazy对象，该对象代理了某个对象的实例的某属性的getter lazy只能代理只读属性 （即用val修饰的属性） 的getter 其lazy的扩展函数getValue(), 其中入参thisRef: Any?表示属性所在类的实例；property: KProperty&lt;*&gt;表示所代理的属性的引用 123class Person(val name: String) { val firstName by lazy { name.split(&quot; &quot;)[0] }} 如上，接口lazy的实例代理了类Person的实例的属性firstName的getter方法，每次访问firstName时都会将lazy内的值返回出来，只有第一次调用时会计算，之后会存储起来。经过编译器编译后如下： 12345678910111213141516171819202122232425262728293031323334public final class Person { @NotNull private final Lazy firstName$delegate; @NotNull private final String name; @NotNull public final List getFirstName() { Lazy var1 = this.firstName$delegate; return (List)var1.getValue(); } @NotNull public final String getName() { return this.name; } public Person(@NotNull String name) { this.name = name; this.firstName$delegate = LazyKt.lazy((Function0)(new Function0() { // $FF: synthetic method // $FF: bridge method public Object invoke() { return this.invoke(); } @NotNull public final List invoke() { return StringsKt.split$default((CharSequence)Person.this.getName(), new char[]{&quot; &quot;.charAt(0)}, false, 0, 6, (Object)null); } })); }} #3. Delegates.observable 观察者委托 Delegates.observable源码如下： 123456789101112package kotlin.propertiesimport kotlin.reflect.KPropertypublic object Delegates {public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) { override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) }}... 1234567891011121314151617181920212223package kotlin.propertiesimport kotlin.reflect.KPropertypublic abstract class ObservableProperty&lt;V&gt;(initialValue: V) : ReadWriteProperty&lt;Any?, V&gt; { private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: V, newValue: V): Boolean = true protected open fun afterChange(property: KProperty&lt;*&gt;, oldValue: V, newValue: V): Unit {} public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): V { return value } public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: V) { val oldValue = this.value if (!beforeChange(property, oldValue, value)) { return } this.value = value afterChange(property, oldValue, value) }} 123456789package kotlin.propertiesimport kotlin.reflect.KPropertypublic interface ReadWriteProperty&lt;in T, V&gt; : ReadOnlyProperty&lt;T, V&gt; { public override operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V public operator fun setValue(thisRef: T, property: KProperty&lt;*&gt;, value: V)} 说明： Delegates.observable返回了一个对象ObservableProperty, 该对象实现了接口ReadWriteProperty，因此有getValue()方法和setValue()方法，因此所代理的属性应为可读写属性 （即用 var 声明的属性） 接口ReadWriteProperty的getValue()方法和setValue()方法第一个参数为该属性所在类，第二个参数为所要代理的属性 ObservableProperty的实例代理了属性的getter和setter 在setValue()方法中会执行afterChange()函数，afterChange()函数包含三个入参property表示当前属性，oldValue表示改变之前的值，value表示改变之后的值 示例代码如下： 1234567class Person(var name: String) { //代理getter val firstName by lazy { name.split(&quot; &quot;)[0] } var secondName: String by Delegates.observable(name.split(&quot; &quot;)[1]) { property, oldValue, newValue -&gt; println(&quot;value changed from $oldValue -&gt; $newValue&quot;) }} 说明： 定义属性时使用关键字by定义要代理属性的对象 Delegates.observable对象后跟的lambda表达式即为上面提到的afterChange()函数，它可以获取当前属性、改变之前的值、改变之后的值 #4. 自定义属性代理类 经过看lazy和observale源码可以发现，他们之所以可以代理属性，是因为实现了getVaue()、setValue()这两个运算符，所以只要实现了这两个运算符可即代理属性 123456789101112131415161718fun main() { var str:String by ProxyX(&quot;321&quot;) println(str) str = &quot;123&quot; println(str)}class ProxyX(private var initialValue: String) { private var value = initialValue operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { return &quot;$value-Proxy&quot; } operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) { this.value = this.value + value }} 打印结果为 12321-Proxy321123-Proxy 说明： 声明了一个代理类ProxyX，代理可读写属性，传入一个初始值，实现getValue()方法和setValue()方法 getValue()方法功能为：取值时返回一个字符串，该字符串是值加一个常量 setValue()方法功能为：将新添加的值拼接到原值的后面 对于var修饰的属性，我们必须要有 getValue、setValue 这两个方法，同时，这两个方法必须有 operator 关键字修饰。 由于我们的 str 属性是 String 类型的，为了实现对它的委托，getValue 的返回值类型，以及 setValue 的参数类型，都必须是 String 类型或者是它的父类。大部分情况下，这三处的类型都应该是一致的。 而如果你觉得这样的写法实在很繁琐，也可以借助 Kotlin 提供的 ReadWriteProperty、ReadOnlyProperty 这两个接口，来自定义委托。 123456789public fun interface ReadOnlyProperty&lt;in T, out V&gt; { public operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V}public interface ReadWriteProperty&lt;in T, V&gt; : ReadOnlyProperty&lt;T, V&gt; { public override operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V public operator fun setValue(thisRef: T, property: KProperty&lt;*&gt;, value: V)} #5. 自定义属性代理 实现效果： 将.properties文件中的内容以变量的方式展示，以方便用户读写，文件中包含author、version、desc等信息 在工程里的resources文件夹下创建Config.properties文件，如下图所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class PropertiesDelegate(private val path: String, private val defaultValue: String = &quot;&quot;) { private lateinit var url: URL private val properties: Properties by lazy { val prop = Properties() url = try { javaClass.getResourceAsStream(path).use { prop.load(it) } javaClass.getResource(path)!! } catch (e: Exception) { try { ClassLoader.getSystemClassLoader().getResourceAsStream(path).use { prop.load(it) } ClassLoader.getSystemClassLoader().getResource(path)!! } catch (e: Exception) { FileInputStream(path).use { prop.load(it) } URL(&quot;file://${File(path).canonicalPath}&quot;) } } prop } operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { return properties.getProperty(property.name, defaultValue) } operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) { properties.setProperty(property.name, value) File(url.toURI()).outputStream().use { properties.store(it, &quot;Hello&quot;) } }}abstract class AbsProperties(path: String) { protected val prop = PropertiesDelegate(path)}class Config: AbsProperties(&quot;Config.properties&quot;) { var author by prop var version by prop var desc by prop}fun main() { val config = Config() println(config.author) println(config.version) config.version = &quot;1.1.0&quot; println(config.desc) println(config.version)} 说明： resources文件夹下内容编译完成后会被复制到classpath下，所以使用ClassLoader可以读取到文件 resources文件夹内容编译后位置如下图所示： 上述代码创建一个Properties的代理类PropertiesDelegate，入参为一个地址，功能为：获取该地址文件里的所有属性值。 注意创建的变量名要与Config.properties文件中的键值对里的键名一致，否则无法读取出属性 代理类PropertiesDelegate也可以重新设置属性值，设置的属性值保存在编译后的文件内，并没有改变源文件，在修改时会自动添加所写的comments即Hello，并且自动添加了修改时间，效果上看上去就像是一个提交纪录 #6. 委托案例-1：属性可见性封装 在软件设计当中，我们会遇到这样的需求：对于某个成员变量 data，我们希望类的外部可以访问它的值，但不允许类的外部修改它的值。因此我们经常会写出类似这样的代码： 1234567891011class Model { var data: String = &quot;&quot; // ① private set private fun load() { // 网络请求 data = &quot;请求结果&quot; }} 说明： 我们将 data 属性的 set 方法声明为 private 的，这时候，data 属性的 set 方法只能从类的内部访问，这就意味着类的外部无法修改 data 的值了，但类的外部仍然可以访问 data 的值。这样的代码模式很常见，我们在 Java 当中也经常使用，不过当我们的 data 类型从 String 变成集合以后就不行了。 123456789101112131415class Model { val data: MutableList&lt;String&gt; = mutableListOf() private fun load() { // 网络请求 data.add(&quot;Hello&quot;) }}fun main() { val model = Model() // 类的外部仍然可以修改data model.data.add(&quot;World&quot;)} 说明： 对于集合而言，即使我们将其定义为只读变量 val，类的外部一旦获取到 data 的实例，它仍然可以调用集合的 add() 方法修改它的值。这个问题在 Java 当中几乎没有优雅的解法。只要你暴露了集合的实例给外部，外部就可以随意修改集合的值。这往往也是 Bug 的来源，这样的 Bug 还非常难排查。 小知识： 1. 使用val修饰的变量是只读变量，指该变量没有setter方法，只有getter方法，也就是说该 变量无法被重新赋值 2. mutable集合指集合可变，也就是说集合元素可以变化，因此使用val修饰mutableList类型的变量data指的是data不会被重新赋一个其它的集合，但是data可以修改它的元素 上述提到的问题可以使用 两个属性之间的委托 的方法来解决 123456789class Model { val data: List&lt;String&gt; by ::_data private val _data: MutableList&lt;String&gt; = mutableListOf() fun load() { _data.add(&quot;Hello&quot;) }} 说明： 在上面的代码中，我们定义了两个变量，一个变量是公开的“data”，它的类型是 List，这是 Kotlin 当中不可修改的 List，它是没有 add、remove 等方法的。接着，我们通过委托语法，将 data 的 getter 委托给了 _data 这个属性。而 _data 这个属性的类型是 MutableList，这是 Kotlin 当中的可变集合，它是有 add、remove 方法的。由于它是 private 修饰的，类的外部无法直接访问，通过这种方式，我们就成功地将修改权保留在了类的内部，而类的外部访问是不可变的 List，因此类的外部只能访问数据。 #7. 委托案例-2：数据与 View 的绑定 在 Android 当中，如果我们要对“数据”与“View”进行绑定，我们可以用 DataBinding，不过 DataBinding 太重了，也会影响编译速度。其实，除了 DataBinding 以外，我们还可以借助 Kotlin 的自定义委托属性来实现类似的功能。这种方式不一定完美，但也是一个有趣的思路。这里我们以 TextView 为例： 123456operator fun TextView.provideDelegate(value: Any?, property: KProperty&lt;*&gt;) = object : ReadWriteProperty&lt;Any?, String?&gt; { override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String? = text override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String?) { text = value }} 说明： 以上的代码，我们为 TextView 定义了一个扩展函数 TextView.provideDelegate，而这个扩展函数的返回值类型是 ReadWriteProperty。通过这样的方式，我们的 TextView 就相当于支持了 String 属性的委托，并且将String值与TextView的text绑定到一起。 它的使用方法如下： 123456789101112131415val textView = findViewById&lt;textView&gt;(R.id.textView)var message: String? by textViewtextView.text = &quot;Hello&quot;println(message)message = &quot;World&quot;println(textView.text)结果：HelloWorld 说明： 我们通过委托的方式，将 message 委托给了 textView。这意味着，message 的 getter 和 setter 都将与 TextView 关联到一起。 当我们修改 textView 的 text 属性，由于我们的 message 也委托给了 textView，因此这时候，println(message) 的结果也会变成“Hello”。 当我们修改 message 的值，由于 message 的 setter 也委托给了 textView，因此这时候，println(textView.text) 的结果会跟着变成“World”。 #8. 委托案例-3：ViewModel 委托 在 Android 当中，我们会经常用到 ViewModel 来存储界面数据。同时，我们不会直接创建 ViewModel 的实例，而对应的，我们会使用委托的方式来实现。 123// MainActivity.ktprivate val mainViewModel: MainViewModel by viewModels() 说明： 如上所示通过viewModels()方法实现mainViewModel的委托 我们先来看看 viewModels() 是如何实现的： 1234567891011121314151617public inline fun &lt;reified VM : ViewModel&gt; ComponentActivity.viewModels( noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; { val factoryPromise = factoryProducer ?: { defaultViewModelProviderFactory } return ViewModelLazy(VM::class, { viewModelStore }, factoryPromise)}public interface Lazy&lt;out T&gt; { public val value: T public fun isInitialized(): Boolean} 说明： 如上代码所示，viewModels() 是 Activity 的一个扩展函数。也是因为这个原因，我们才可以直接在 Activity 当中直接调用 viewModels() 这个方法。另外，我们注意到，viewModels() 这个方法的返回值类型是 Lazy，那么，它是如何实现委托功能的呢？ 1public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value 实际上，Lazy 类在外部还定义了一个扩展函数 getValue()，这样，我们的只读属性的委托就实现了。而 Android 官方这样的代码设计，就再一次体现了职责划分、关注点分离的原则。Lazy 类只包含核心的成员，其他附属功能，以扩展的形式在 Lazy 外部提供。 #六、 单例 object #1. 单例定义 Kotlin中使用关键字object来定义饿汉式单例 123object Singleton {} 如上代码所示，只需要关键字object后加一个类名即可创建一个饿汉式单例，它等价于Java中如下所示的单例定义： 123public class Singleton { public static final Singleton INSTANCE = new Singleton();} #2. 访问object的成员 object定义的单例可以当做类一样去添加成员属性，成员函数 1234567891011object Singleton { var value: Int = 26 fun plus() { value++ }}fun main() { Singleton.plus() println(&quot;value${Singleton.value}&quot;)} 1234public static void main(String[] args) { Singleton.INSTANCE.plus(); System.out.println(&quot;value:&quot;+ Singleton.INSTANCE.getValue());} 如上所示，在kotlin定义了一个单例Singleton，在kotlin中调用时直接使用单例的名字即可调用，但是在java调用时需要加一个INSTANCE，上述定义单例代码经过编译反后的class文件代码如下： 1234567891011121314151617181920212223242526public final class Singleton { private static int value; @NotNull public static final Singleton INSTANCE; public final int getValue() { return value; } public final void setValue(int var1) { value = var1; } public final void plus() { int var10000 = value++; } private Singleton() { } static { Singleton var0 = new Singleton(); INSTANCE = var0; value = 26; }} #3. 静态成员@JvmStatic 因kotlin是跨平台语言，其中C语言、JavaScript等都没有静态成员概念，所在kotlin没有静态成员的概念，但可以使用注解JvmStatic来模拟。 #1. 在单例中使用@JvmStatic 1234567891011object Singleton { @JvmStatic var value: Int = 26 @JvmStatic fun plus() { value++ }}fun main() { Singleton.plus() println(&quot;value${Singleton.value}&quot;)} 1234public static void main(String[] args) { Singleton.plus(); System.out.println(&quot;value:&quot;+ Singleton.getValue());} 说明： 如上所示，在kotlin中定义单例时为其成员添加了注解@JvmStatic。 在kotlin中调用单例成员时没有任何变化 在java中调用单例成员时可省略INSTANCE，可直接视同其调用静态成员 上述定义添加注解的单例代码经过反编译后的class文件代码如下： 123456789101112131415161718192021222324252627public final class Singleton { private static int value; @NotNull public static final Singleton INSTANCE; public static final int getValue() { return value; } public static final void setValue(int var0) { value = var0; } @JvmStatic public static final void plus() { int var10000 = value++; } private Singleton() { } static { Singleton var0 = new Singleton(); INSTANCE = var0; value = 26; }} #2. 在普通类中使用@JvmStatic 注解JvmStatic只能使用在单例或普通类的伴生对象里的成员上 伴生对象 (companion objects)： 是一个类的伴生对象，定义一个类时可以同时在类内定义定义一个object 12345678910111213class Foo { companion object { @JvmField var value:String = &quot;Test&quot; @JvmStatic fun y() { println(&quot;Test&quot;) } }}fun main() { Foo.y() println(&quot;value:${Foo.value}&quot;)} 1234public static void main(String[] args) { Foo.y(); System.out.println(&quot;value:&quot;+ Foo.value);} 说明： 如上所示，在kotlin中定义伴生对象时使用companion object 在kotlin中调用类的伴生对象中的静态成员时，直接使用类名即可 在java中调用类的伴生对象中的静态成员时，直接使用类名即可 上述定义伴生对象的类代码经过反编译后的class文件代码如下： 1234567891011121314151617181920212223242526272829public final class Foo { @JvmField @NotNull public static String value = &quot;Test&quot;; @NotNull public static final Foo.Companion Companion = new Foo.Companion((DefaultConstructorMarker)null); @JvmStatic public static final void y() { Companion.y(); } public static final class Companion { @JvmStatic public final void y() { String var1 = &quot;Test&quot;; boolean var2 = false; System.out.println(var1); } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }} #4. @JvmField 注解@JvmField作用： 不生成getter/setter，但不会给所修饰的属性添加静态属性，只是该属性变成public #1. 在单例中使用@JvmField 1234567891011object Singleton { @JvmField var value: Int = 26 @JvmStatic fun plus() { value++ }}fun main() { Singleton.plus() println(&quot;value${Singleton.value}&quot;)} 123456//javapublic static void main(String[] args) { Singleton.plus(); System.out.println(&quot;value:&quot;+ Singleton.value);} 说明： 如上所示，为单例中的属性value添加注解@JvmField kotlin中调用并没有改变 java中调用时直接使用该变量名，它成为了一个全局静态变量 上述定义添加注解的单例代码经过反编译后的class文件代码如下： 1234567891011121314151617181920public final class Singleton { @JvmField public static int value; @NotNull public static final Singleton INSTANCE; @JvmStatic public static final void plus() { int var10000 = value++; } private Singleton() { } static { Singleton var0 = new Singleton(); INSTANCE = var0; value = 26; }} #2. 在普通类中使用@JvmField 12345678class Foo { @JvmField var x: Int = 22}fun main() { val foo = Foo() println(foo.x)} 1234public static void main(String[] args) { Foo foo = new Foo(); System.out.println(foo.x);} 说明： 如上所示，在普通类中使用注解@JvmField修饰一个属性 注解@JvmField并没有给属性静态属性，所以必须要声明一个对象再调用它 上述定义添加注解的普通类经过反编译后的class文件代码如下： 1234public final class Foo { @JvmField public int x = 22;} #5. object的构造器 kotlin中使用object定义的单例不能自定义构造器，系统会自动生成一个无参构造器，但是可以自定义若干个init块 kotlin中单例可以与普通类一样继承或实现其它的类或接口 123456object Singleton { @JvmField var value: Int = 26 init { value *= 2 }} 上述代码经过反编译后的class文件代码如下： 12345678910111213141516public final class Singleton { @JvmField public static int value; @NotNull public static final Singleton INSTANCE; private Singleton() { } static { Singleton var0 = new Singleton(); INSTANCE = var0; value = 26; value *= 2; }} #七、内部类inner class #1. 内部类定义 在Java中定义内部类，只需在一个类内再定义一个类，类内的类即为内部类，内部类分为一般内部类、静态内部类。一般内部类持有外部类的引用，所以有可能引起内存泄露，静态内部类没有外部类的引用，所以不能直接调用外部的方法。 12345678public class Outer { class Inner { } static class StaticInner { }} 在kotlin中定义非静态内部类 使用关键字inner，而不加关键字的类内类是静态内部类 1234class Outer { inner class Inner class StaticInner} #2. 内部类实例化 对于内部类的实例化，java和kotlin操作相同。 初始化非静态内部类时需要先构造外部类对象 ，然后再拿对象去初始化内部类 初始化静态内部类时，只引用了外部类的类名 ，不需要初始化外部类 12//kotlin --非静态内部类val inner = Outer().Inner() 12//java --非静态内部类Outer.Inner inner = new Outer().new Inner(); 12//kotlin --静态内部类val staticInner = Outer.StaticInner() 12//java --静态内部类Outer.StaticInner inner = new Outer.StaticInner(); #3. 单例object的内部object 123object OuterObject { object InnerObject} object一旦定义完成后即会被实例化，不存在非静态的情况，故不可用inner修饰 #4. 匿名内部类 java中的匿名内部类表现形式如下： 1234567new Runnable() { @Override public void run() { }}; kotlin中的匿名内部类形式如下： 12345object: Runnable { override fun run() { TODO(&quot;Not yet implemented&quot;) }} 1234567891011val btn: Button = Button(context)btn.post { object: Runnable, Closeable { override fun run() { TODO(&quot;Not yet implemented&quot;) } override fun close() { }}} 说明： 匿名内部类如果定义在非静态区域内就会持有外部引用，容易造成内存泄漏。 静态区域 即静态方法、静态类。在kotlin中如果定义在伴生对象中或顶级函数内都不会持有外部引用 如上所示，kotlin中定义匿名内部类只是省略了名字，并且可以继承父类或实现多个接口 实现多个接口的匿名内部类的类型为 交叉类型，如上代码Buttn的post方法里的匿名内部类类型为Cloneable &amp; Runnable 若java中要实现kotlin中匿名内部类的可以继承父类或实现多个接口的效果，可以使用本地类 本地类 本地类又称为局部内部类，理解为有名字的匿名类。它是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的 12345678910111213141516public static void main(String[] args) { class PreOperation implements Runnable, Closeable { @Override public void close() throws IOException { } @Override public void run() { } } PreOperation preOperation = new PreOperation(); preOperation.run();} #八、数据类data class #1. 数据类定义 只需要在普通类前面加关键字data即为数据类。 数据类对标java中的bean类，但两者并不相等 数据类必须至少有一个主构造函数参数 12class Person(var name: String, var age: Int)data class Book(val id: Long, val name: String, val brand:Person) #2. component 定义在主构造器中的属性又称之为 component，数据类所有的东西都基于component实现，如下所示为上述代码反编译class文件后代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public final class Computer { private final long id; @NotNull private final String name; @NotNull private final Person brand; public final long getId() { return this.id; } @NotNull public final String getName() { return this.name; } @NotNull public final Person getBrand() { return this.brand; } public Computer(long id, @NotNull String name, @NotNull Person brand) { this.id = id; this.name = name; this.brand = brand; } public final long component1() { return this.id; } @NotNull public final String component2() { return this.name; } @NotNull public final Person component3() { return this.brand; } @NotNull public final Computer copy(long id, @NotNull String name, @NotNull Person brand) { return new Computer(id, name, brand); } @NotNull public String toString() { return &quot;Computer(id=&quot; + this.id + &quot;, name=&quot; + this.name + &quot;, brand=&quot; + this.brand + &quot;)&quot;; } public int hashCode() { long var10000 = this.id; int var1 = (int)(var10000 ^ var10000 &gt;&gt;&gt; 32) * 31; String var10001 = this.name; var1 = (var1 + (var10001 != null ? var10001.hashCode() : 0)) * 31; Person var2 = this.brand; return var1 + (var2 != null ? var2.hashCode() : 0); } public boolean equals(@Nullable Object var1) { if (this != var1) { if (var1 instanceof Computer) { Computer var2 = (Computer)var1; if (this.id == var2.id &amp;&amp; Intrinsics.areEqual(this.name, var2.name) &amp;&amp; Intrinsics.areEqual(this.brand, var2.brand)) { return true; } } return false; } else { return true; } } // $FF: synthetic method public static Computer copy$default(Computer var0, long var1, String var3, Person var4, int var5, Object var6) { if ((var5 &amp; 1) != 0) { var1 = var0.id; } if ((var5 &amp; 2) != 0) { var3 = var0.name; } if ((var5 &amp; 4) != 0) { var4 = var0.brand; } return var0.copy(var1, var3, var4); }} 说明： 数据类会自动生成N个component，序号顺序即为主构造器中参数顺序 可以根据component方法获取数据类的属性值 1234val computer = Computer(1001L, &quot;mackBook Pro&quot;, Person(&quot;Apple&quot;, 45))val id = computer.component1()val name = computer.component2()val brand = computer.component3() 相较于普通类，数据类还自动创建了copy()、toString()、hashCode()、equals()等方法 #3. 数据类解构 数据类解构就是将一个数据类解构 (destructure) 为多个变量，也就是意味着一个解构声明会一次性创建多个变量 Pair的源码如下： 12345678//Pair类源码public data class Pair&lt;out A, out B&gt;( public val first: A, public val second: B) : Serializable { public override fun toString(): String = &quot;($first, $second)&quot;} 12val pair = &quot;Hello&quot; to &quot;World&quot;val(hello, world) = pair 说明： 如上所示，先声明一个Pair类型的属性pair，之后将pair解构成变量hello和world Pair类是一个数据类，有两个component 上述代码反编译class文件后代码如下： 123Pair pair = TuplesKt.to(&quot;Hello&quot;, &quot;World&quot;);String var6 = (String)pair.component1();String world = (String)pair.component2(); 由此可见数据类解构是借助component实现的 上一节中定义的Computer实现类可以使用如下代码解构： 1234fun main() { val computer = Computer(31L, &quot;mackBook Pro&quot;, Person(&quot;Apple&quot;, 45)) val(id, name, brand) = computer} #4. JavaBean 与 data class 区别 JavaBean data class 构造方法 默认无参构造 属性作为参数 字段 字段私有，Getter/Setter 公开 属性 继承性 可继承也可被继承 不可被继承 component 无 相等性、解析等 数据类不可被继承原因：违反相等性的对称性和传递性 假设定义一个数据基类BaseClass内含一个属性name，之后再定义一个数据子类ChildClass继承了BaseClass，并在其基础上又扩展了一个属性age。之后再创建如下三个实例 实例 name 值 age 值 基类BaseClass的实例：a Lee 无 子类BaseClass的实例：b Lee 18 子类BaseClass的实例：c Lee 20 则： 表达式 结果 原因 a == b true 双等号其实是调用的类实例 a 的equals方法，由反编译的代码可知equals方法只比较本类有的属性，而两个实例的name属性值相同，故相等 b == a false 实例 b 的equals方法，要比较name和age两个属性，而实例a没有age属性，故不相等 a == c true 同第一条原因 c == a false 同第二条原因 b == c false 虽然实例b和实例c都有name和age两个属性，但是age属性值不同，故不相等 由上表可知： a == b 但是 b != a违反了相等性的对称性 a == b 并且 a == c 但b != c违反了相等性的传递性 #5. data class 总结 提供了JavaBean的功能 被final字段修饰不可被继承 核心的Component，它导致必须有有参数的主构造器，并决定了数据类的相等性，还可解构数据类 定义一个数据类应该将其当作一个纯数据结构来使用，大多数情况下不需要额外实现，即一般省略{} 数据类的属性类型最好为基本类型、String、其它数据类等，以此保证不会有逻辑，保证数据类是纯数据 Component不可以自定义Getter/Setter，以保证数据特性不会被篡改 数据类的属性最好使用val修饰，使属性不可变，以保证其同一个对象的hashcode和equals结果前后一样 将data class当作JavaBean使用 问题： 必须有有参数的主构造器；被 final 修饰不可被继承。 解决方案： 使用NoArg插件，给数据类加一个注解，使用数据类在编译时生成一个无参构造器，但无法在代码里直接访问该构造器，只能通过反射拿到。 使用AllOpen插件，去掉final修饰，以保证数据类可以被继承 实例： 123456789101112131415//build.gradle.ktsplugins { ... id (&quot;org.jetbrains.kotlin.plugin.allopen&quot;) version &quot;1.4.21&quot; id (&quot;org.jetbrains.kotlin.plugin.noarg&quot;) version &quot;1.4.21&quot;}noArg { invokeInitializers = true annotations(&quot;cn.ltt.projectcollection.kotlin.DataClassAnnotation&quot;)}allOpen { annotations(&quot;cn.ltt.projectcollection.kotlin.DataClassAnnotation&quot;)} 1234package cn.ltt.projectcollection.kotlin;public @interface DataClassAnnotation {} 说明： 插件需要添加到module模块下的build.gradle.kts中 如上所示，将注解DataClassAnnotation会导致被标注的类生成无参构造函数且类本身及其所有成员会变为开放 invokeInitializers为false时，只会调用被标注的类的父类的构造方法；为true时会调用被标注类的init块，默认为false。 参考文章：https://www.kotlincn.net/docs/reference/compiler-plugins.html 123456789@DataClassAnnotationdata class Computer(val id: Long, val name: String, val brand:Person) { init{ println(name) }}fun main() { val computer = Computer::class.java.newInstance()} 将注解添加到类Computer上，并通过反射生成一个Computer的实例 反编译Computer类的class文件后代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Computer { private final long id; @NotNull private final String name; @NotNull private final Person brand; public long getId() { return this.id; } @NotNull public String getName() { return this.name; } @NotNull public Person getBrand() { return this.brand; } public Computer(long id, @NotNull String name, @NotNull Person brand) { Intrinsics.checkNotNullParameter(name, &quot;name&quot;); Intrinsics.checkNotNullParameter(brand, &quot;brand&quot;); super(); this.id = id; this.name = name; this.brand = brand; String var5 = this.getName(); boolean var6 = false; System.out.println(var5); } public final long component1() { return this.getId(); } @NotNull public final String component2() { return this.getName(); } @NotNull public final Person component3() { return this.getBrand(); } @NotNull public final Computer copy(long id, @NotNull String name, @NotNull Person brand) { Intrinsics.checkNotNullParameter(name, &quot;name&quot;); Intrinsics.checkNotNullParameter(brand, &quot;brand&quot;); return new Computer(id, name, brand); } // $FF: synthetic method public static Computer copy$default(Computer var0, long var1, String var3, Person var4, int var5, Object var6) { if (var6 != null) { throw new UnsupportedOperationException(&quot;Super calls with default arguments not supported in this target, function: copy&quot;); } else { if ((var5 &amp; 1) != 0) { var1 = var0.getId(); } if ((var5 &amp; 2) != 0) { var3 = var0.getName(); } if ((var5 &amp; 4) != 0) { var4 = var0.getBrand(); } return var0.copy(var1, var3, var4); } } @NotNull public String toString() { return &quot;Computer(id=&quot; + this.getId() + &quot;, name=&quot; + this.getName() + &quot;, brand=&quot; + this.getBrand() + &quot;)&quot;; } public int hashCode() { long var10000 = this.getId(); int var1 = (int)(var10000 ^ var10000 &gt;&gt;&gt; 32) * 31; String var10001 = this.getName(); var1 = (var1 + (var10001 != null ? var10001.hashCode() : 0)) * 31; Person var2 = this.getBrand(); return var1 + (var2 != null ? var2.hashCode() : 0); } public boolean equals(@Nullable Object var1) { if (this != var1) { if (var1 instanceof Computer) { Computer var2 = (Computer)var1; if (this.getId() == var2.getId() &amp;&amp; Intrinsics.areEqual(this.getName(), var2.getName()) &amp;&amp; Intrinsics.areEqual(this.getBrand(), var2.getBrand())) { return true; } } return false; } else { return true; } } public Computer() { }} 说明： 可以看到类computer已经没有final修饰了，它可以被继承，且computer里的属性的Getter/Setter也没有了final修饰 相较于之前的反编译后的代码，现在在最后的位置多了一个无参的构造器 虽然在插件noarg里将invokeInitializers置为了true，但是IntelliJ在反编译时没有识别到该属性，所以在无参构造器中没有init块中的代码，但是gradle可以识别到该属性，所以在运行时会执行init块中代码，会打印出computer类实例的name值 #九、枚举类enum class #1. 枚举类定义 使用关键字 enum 123enum State { START, FINISHED} 123enum class State { START, FINISHED} #2. 枚举类属性 Java: 可以通过枚举项的name()方法，获取枚举项的名称 可以通过枚举项的ordinal()方法，获取枚举项的在枚举声明里的位置 12System.out.println(State.START.name());System.out.println(State.START.ordinal()); Kotlin: 枚举项有属性name，持有枚举项的名称 枚举项有属性ordinal，持有枚举项在枚举声明中的位置 枚举有方法values，该方法返回枚举项列表 12println(State.START.name)println(State.START.ordinal) #3. 枚举类构造器 Java: 12345678enum State { START(0), FINISHED(1); int id; State(int id) { this.id = id; }} Kotlin: 123enum class State(val id: Int) { START(0), FINISHED(1)} 说明： 声明构造器后，每个枚举项都要调用构造器。只有通过这种方式来创建有构造器的枚举项。 #4. 枚举类实现接口 #1. 统一实现 Java: 12345678enum State implements Runnable{ START, FINISHED; @Override public void run() { System.out.println(&quot;For every state&quot;); }} Kotlin: 1234567enum class State : Runnable { START, FINISHED; override fun run() { println(&quot;For every state&quot;) }} 说明： 如上所示，每个枚举项的run方法实现都是同样的 其中Kotlin中最后一个枚举项后必须加上分号，否则报错：Expecting ';' after the last enum entry or '}' to close enum class body #2. 各自实现 Java: 12345678910111213enum State implements Runnable { START { @Override public void run() { System.out.println(&quot;For START&quot;); } }, FINISHED { @Override public void run() { System.out.println(&quot;For FINISHED&quot;); } }} Kotlin: 123456789101112enum class State : Runnable { START { override fun run() { println(&quot;For START&quot;) } }, FINISHED { override fun run() { println(&quot;For FINISHED&quot;) } }} 说明： 每个实例单独实现run方法，这样各个枚举项就只调用自己的run方法 枚举的父类是Enum，所以不能继承其它类 #5. 为枚举定义扩展 123456fun State.next(): State { return State.values().let { val nextOrdinal = (ordinal + 1) % it.size it[nextOrdinal] }} 说明： 枚举也是一个类，可以为其定义扩展方法 如上代码为枚举类State定义了一个扩展方法next()，该方法可以获取某个枚举项的下一个枚举，且是循环的 #6. 枚举类条件分支 12345val state = State.STARTval value = when(state) { State.START -&gt; {0} State.FINISHED -&gt; {1}} 说明： 枚举是有限个数的，所以可以将其作为条件分支 #7. 枚举类比较大小 1234val state = State.STARTif (state &lt;= State.FINISHED) { println(&quot;yes&quot;)} 说明： 同一个枚举类下的枚举项之间可以比较大小 枚举项之间比较的是ordinal #8. 枚举类区间 枚举是有顺序的，可以创建枚举区间 123456789enum class Status { NEW, RUNNABLE, RUNNING, BLOCKED, DEAD}fun main() { val statusRange = Status.NEW .. Status.BLOCKED val status = Status.RUNNING println(status in statusRange)} 说明： 如上所示，先创建了一个线程状态的枚举类，之后又创建了一个枚举项的区间 判断某个状态是否在某几个状态之内，这时使用区间会很方便 #十、密封类sealed class #1. 密封类概念 密封类是一种特殊的抽象类，它首先是一个抽象类，其次才是密封类，即密封类可以被继承 密封类的子类定义只能在与自身相同的文件中，即其子类只在一个有限范围内 密封类的子类的个数是有限的 #2. 密封类定义 使用关键字sealed来定义密封类 1234567sealed class PlayerState { var id:Int = 0 constructor() constructor(id:Int) { this.id = id }} 上述代码反编译后代码如下： 123456789101112131415161718public abstract class PlayerState { private int id; public final int getId() { return this.id; } public final void setId(int var1) { this.id = var1; } private PlayerState() { } private PlayerState(int id) { this.id = id; }} 说明： 密封类是一个抽象类 密封类的构造方法是私有的 #3. 密封类的子类 12345object Idle : PlayerState()class Playing(val song: String): PlayerState()class Error(val errorInfo: String):PlayerState() 说明： Idle是一个普通单例对象 Playing类的实例每次播放的歌曲不同，所以它每次的实例不一样 Error类的实例每次错误信息不同，所以它每次的实例也不一样 但是Idle、Playing、 Error的类型是一样的 继承密封类的时候要调用父类的构造器 #4. 密封类子类分支 密封类的子类是可数的，分支就可完备，就可以使用when分支语句 123456789101112val state : PlayerState = Idlewhen(state) { Idle -&gt; { println(&quot;Idle&quot;) } is Playing -&gt; { println(&quot;Playing&quot;) } is Error -&gt; { println(&quot;Error&quot;) }} #5. 密封类使用 1234567891011121314151617181920212223242526272829303132333435363738fun main() { val player = Player() player.play(&quot;The Nights&quot;)}sealed class PlayerStateobject Idle : PlayerState()class Playing(val song: String): PlayerState() { fun start(){} fun stop(){}}class Error(val errorInfo: String):PlayerState() { fun recover() {}}class Player { var state: PlayerState = Idle fun play(song: String) { this.state = when(val state = this.state) { Idle -&gt; { Playing(song).also(Playing::start) } is Playing -&gt; { state.stop() Playing(song).also(Playing::start) } is Error -&gt; { state.recover() Playing(song).also(Playing::start) } } }} 说明： 定义一个播放状态的密封类PlayerState，然后三个类实现密封类：Idle初始化状态类、Playing播放状态类、Error错误状态类 创建一个播放器类Player，该类中的方法play()通过when语句判断不同的状态采用不同的处理方案：如果是Idle状态直接播放；如果是Playing状态则先将停止播放再播放新歌曲；如果是Error状态则先复位再播放新歌曲。 其中Playing和Error状态的判断还进行了智能类型转换，以方便调用各自状态类中的方法。 其中的also方法会将receiver返回，所以实现了状态机state的流转。 when语句在kotlin1.3以后可以在其中创建一个新变量 #6. 密封类和枚举类对比 密封类 枚举类 状态实现 子类继承 类实例化 状态可数 子类可数 实例可数 状态差异 类型差异 值差异 说明： 密封类可以让子类继承子类可以是object类，而枚举类内的枚举对象都是枚举类的实例 #十一、内联类inline class #1. 内联类概念 内联类是对某一个类型的包装 内联类是类似于java装箱类型 (Float, Double等) 的一种类型 编译器会尽可能使用被包装的类型进行优化 内联类在Kotlin 1.3版本中处于公测阶段，谨慎使用 #2. 内联类定义 使用关键字inline来定义内联类 1inline class BoxInt(val value:Int) 说明： 如上代码所示，定义内联类BoxInt是对类型Int的包装 被包装的类型只能定义在主构造器内 主构造器只能是public 主构造器只能有一个参数即被包装的类型， 主构造器里的参数只能用val修饰 #3. 内联类方法 12345inline class BoxInt(val value:Int) { operator fun inc():BoxInt { return BoxInt(value + 1) }} 说明： 内联类可以定义方法，如上代码所示，定义了一个重载运算符的函数inc(),如此可以执行运行符++ #4. 内联类属性 12345inline class BoxInt(val value: Int) { val name get() = &quot;BoxInt($value)&quot;} 说明： Inline class cannot have properties with backing fields 内联类可以定义只有getter的属性，即内联类只能定义方法 #5. 内联类继承关系 123456789inline class BoxInt(val value: Int) : Comparable&lt;Int&gt; { override fun compareTo(other: Int): Int { return value.compareTo(other) }}fun main() { val boxInt = BoxInt(5) println(boxInt &gt; 10)} 说明： 如上代码内联类BoxInt实现了接口Comparable，则BoxInt类型的对象可以与Int类型比较大小 内联类可以实现接口 内联类不能继承父类，也不能被继承 #6. 内联类编译优化 1234567fun main() { var boxInt = BoxInt(5) val newValue = boxInt.value * 200 println(newValue) boxInt++ println(boxInt)} 将如上代码反编译后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public final class BoxInt implements Comparable { private final int value; public int compareTo(int var1) { return compareTo-impl(this.value, var1); } // $FF: synthetic method // $FF: bridge method public int compareTo(Object var1) { return this.compareTo(((Number)var1).intValue()); } public final int getValue() { return this.value; } // $FF: synthetic method private BoxInt(int value) { this.value = value; } public static final int inc_xSVgFbQ/* $FF was: inc-xSVgFbQ*/(int $this) { return constructor-impl($this + 1); } public static int compareTo_impl/* $FF was: compareTo-impl*/(int $this, int other) { return Intrinsics.compare($this, other); } public static int constructor_impl/* $FF was: constructor-impl*/(int value) { return value; } // $FF: synthetic method public static final BoxInt box_impl/* $FF was: box-impl*/(int v) { return new BoxInt(v); } public static String toString_impl/* $FF was: toString-impl*/(int var0) { return &quot;BoxInt(value=&quot; + var0 + &quot;)&quot;; } public static int hashCode_impl/* $FF was: hashCode-impl*/(int var0) { return var0; } public static boolean equals_impl/* $FF was: equals-impl*/(int var0, Object var1) { if (var1 instanceof BoxInt) { int var2 = ((BoxInt)var1).unbox-impl(); if (var0 == var2) { return true; } } return false; } public static final boolean equals_impl0/* $FF was: equals-impl0*/(int p1, int p2) { return p1 == p2; } // $FF: synthetic method public final int unbox_impl/* $FF was: unbox-impl*/() { return this.value; } public String toString() { return toString-impl(this.value); } public int hashCode() { return hashCode-impl(this.value); } public boolean equals(Object var1) { return equals-impl(this.value, var1); }}public static final void main() { int boxInt = BoxInt.constructor-impl(5); int newValue = boxInt * 200; System.out.println(newValue); boxInt = BoxInt.inc-xSVgFbQ(boxInt); BoxInt var4 = BoxInt.box-impl(boxInt); System.out.println(var4);} 编译优化说明： 调用类BoxInt的constructor-impl方法为属性boxInt赋值，而constructor-impl方法只是将形参返回，即第一条语句优化为：var boxInt: Int = 5 第二条语句直接使用类型为被封闭类型的boxInt属性：val newValue = boxInt * 200 打印语句只是将属性打印 第四条作为为自加一的语句调用类BoxInt的inc-xSVgFbQ方法，而该方法又调用了contructor-impl方法，只是入参传入的是其本身的值加一 而最后一条语句是打印类BoxInt的实例，即调用该类的toString()方法，所以将之前的boxInt属性再装箱。调用BoxInt类的box-impl方法，创建一个BoxInt的实例，之后打印该实例 综上所述，只有在必要的时候才使用包装类型，大多数情况下优化为被包装的类型 #7. 内联类使用场景 #1. 内联类官方例子 1234public inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable&lt;UInt&gt; {...} 说明： 如上所示无符号整型是有符号整形的包装 所有的无符号类型都是对应有符号类型的包装 #2. 使用内联类模拟枚举 123456789101112131415161718192021222324252627282930313233inline class State(val ordinal:Int) { companion object { val Start = State(0) val Running = State(1) val Finished = State(2) } fun values() = arrayOf(Start, Finished) val name: String get() { return when (ordinal) { 0 -&gt; { &quot;Start&quot; } 1 -&gt; { &quot;Running&quot; } 2 -&gt; { &quot;Finished&quot; } else -&gt; { &quot;other&quot; } } }}fun main() { setState(State.Running)}fun setState(state:State) { println(&quot;setState-State:$state&quot;)} 说明： 枚举的内存开销大 如上所示，创建一个内联类State模拟枚举，该类提供了values函数和只有getter的name属性，State类的单例中创建了三个内联对象 在java中使用注解IntDef、StingDef等来模拟枚举类，虽然IDE会报错但是可以编译通过。但是在kotlin中该注解不会起到规定范围的作用 内联类虽然在companion object中定义了几个对象，但编译器会将其优化为整型，如此相较于枚举内存开销更小 在某函数中设置该内联类类型时，只能传该内联类单例中定义的对象 两种语言模拟枚举类的区别：在java中使用注解IntDef、StingDef等，虽然IDE会报错但是可以编译通过，而kotlin中的使用内联类，IDE会报错且不会编译通过 #8. 内联类的限制 主构造器必须有且仅有一个只读属性 (被包装的类型) 不能定义有backing-field的其它属性 被包装类型必须不能是泛型类型，必须是一个确定的类型 不能继承父类也不能被继承 内联类不能定义为其他类的内部类 以上的限制是为了编译器优化类型 #9. 别名 (typealias) 与内联类 (inline class) 区别 typealias inline class 类型 没有新类型 有包装类型产生 实例 与原类型一致 必要时使用包装类型 场景 类型更直观 优化包装类型性能 说明： typealias是为某类型定义了一个别名，而内联类是将某类型进行包装 typealias是为程序员看的更直观，而内联类是为编译器优化类型的 #十二、示例 - 数据类序列化 常用的三个Kotlin中的Json序列化工具： Gson框架是Google的。官网：https://github.com/google/gson Moshi是大神JakeWharton等人写的。官网：https://github.com/square/moshi Kotlinx.serialization是Kotlin官方提供的。官网：https://github.com/Kotlin/kotlinx.serialization #1. 引入工具 #1. Gson 直接在在模块下的build.gradle文件里的dependences块添加依赖即可 12345//app/src/build.gradle.ktsdependencies { //Gson implementation (&quot;com.google.code.gson:gson:2.8.6&quot;)} #2. Moshi 要先添加一下插件，再添加依赖 1234567891011//app/src/build.gradle.ktsplugins { kotlin(&quot;kapt&quot;)}dependencies { implementation(&quot;com.squareup.moshi:moshi:1.11.0&quot;) implementation( &quot;com.squareup.moshi:moshi-kotlin:1.8.0&quot;) // for KotlinJsonAdapterFactory kapt( &quot;com.squareup.moshi:moshi-kotlin-codegen:1.11.0&quot;) // for generated Json Adapter} #3. Kotlinx.serialization 要先添加一下插件，再添加依赖 12345678//app/src/build.gradle.ktsplugins { ... kotlin(&quot;plugin.serialization&quot;) version &quot;1.4.30&quot;}dependencies { implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.1.0&quot;)} #2. 示例代码 Kotlin版本： Kotlin version 1.4.20-release-308 (JRE 1.8.0_251-b08) Kotlin Plugin版本： 1.4.31 #1. 简单序列化json 1234567891011121314151617181920212223242526272829303132333435fun main() { val jsonStr = &quot;&quot;&quot;{&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:20}&quot;&quot;&quot; val person = Person(&quot;Lee&quot;, 18) //Gson println(&quot;Gson&quot;) val gson = Gson() println(gson.toJson(person)) println(gson.fromJson(jsonStr, Person::class.java)) println() //Moshi println(&quot;Moshi&quot;) val moshi = Moshi.Builder() .add(KotlinJsonAdapterFactory()) .build() val jsonAdapter = moshi.adapter(Person::class.java) println(jsonAdapter.toJson(person)) println(jsonAdapter.fromJson(jsonStr)) println() println(&quot;Kotlinx.serialization&quot;) val data = PersonForSerialize(&quot;Lee&quot;, 18) println(Json.encodeToString(PersonForSerialize.serializer(),data)) println(Json.decodeFromString(PersonForSerialize.serializer(),jsonStr))}data class Person(val name: String, val age: Int)@Serializabledata class PersonForrSerialize(val name: String, val age: Int) 打印结果如下： 1234567891011Gson{&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}Person(name=Lee, age=20)Moshi{&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}Person(name=Lee, age=20)Kotlinx.serialization{&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonFroSerialize(name=Lee, age=20) 说明： 区别： Gson Moshi Kotlinx.serialization 对Json对象的需求 无 无 需要Json对象的类添加注解@Serializable 需要创建工具类对象 需要 需要，且还要再创建对应json对象的adapter 不需要 Moshi在使用Builder模式创建对象时还要添加KotlinJsonAdapterFactory以支持kotlin Kotlinx.serialization使用方法encodeToString和decodeFromString序列化json是，第一个参数要传递对应json的数据类的serizlizer对象 注解@Serializable会将添加该注解的类的序列化工具生成到对应类的伴生对象中，添加该注解的类PersonForSerizlize反编译后的关键代码如下： 12345678910111213141516171819202122232425262728293031public final class PersonFroSerialize { ...@NotNullpublic static final PersonFroSerialize.Companion Companion = new PersonFroSerialize.Companion((DefaultConstructorMarker)null);... public static final class Companion { private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } @NotNull public final KSerializer serializer() { return (KSerializer)PersonFroSerialize.$serializer.INSTANCE; }} public static final class $serializer implements GeneratedSerializer { @NotNull public static final PersonFroSerialize.$serializer INSTANCE; // $FF: synthetic field private static final SerialDescriptor $$serialDesc; private $serializer() { } ...}} #2. 带默认参数的json序列化 #1. Gson处理默认参数 12345678910111213//Gsonfun main() { val jsonStr = &quot;&quot;&quot;{&quot;name&quot;:&quot;Lee&quot;}&quot;&quot;&quot; val person = PersonWithDefaults(&quot;Lee&quot;) //Gson val gson = Gson() println(gson.toJson(person)) println(gson.fromJson(jsonStr, PersonWithDefaults::class.java))}data class PersonWithDefaults(val name: String, val age: Int = 18) 打印结果： 12{&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithDefaults(name=Lee, age=0) 说明： Gson在将带有默认参数的数据类序列化时会将默认参数带上 Gson在反序列化时会通过反射来判断有没有默认无参的构造方法，如果没有的话会通过UnSafe类直接创建对象，所以反序列化时数据类的默认参数不会起作用 #2. Moshi处理默认参数 12345678910111213141516171819202122232425//Moshifun main() { val jsonStr = &quot;&quot;&quot;{&quot;name&quot;:&quot;Lee&quot;}&quot;&quot;&quot; //方法一 val moshi = Moshi.Builder()// .add(KotlinJsonAdapterFactory()) .build() val jsonAdapter = moshi.adapter(PersonWithDefaultsAnnotation::class.java) println(jsonAdapter.toJson(PersonWithDefaultsAnnotation(&quot;Lee&quot;))) println(jsonAdapter.fromJson(jsonStr)) println() //方法二 val moshi = Moshi.Builder() .add(KotlinJsonAdapterFactory()) .build() val jsonAdapter = moshi.adapter(PersonWithDefaults::class.java) println(jsonAdapter.toJson(person)) println(jsonAdapter.fromJson(jsonStr))}@JsonClass(generateAdapter = true)data class PersonWithDefaultsAnnotation(val name: String, val age: Int = 18)data class PersonWithDefaults(val name: String, val age: Int = 18) 打印结果： 12345{&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithDefaults(name=Lee, age=18){&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithDefaults(name=Lee, age=18) 说明： 由打印结果可以看出，Moshi序列化和反序列化都可以支持默认值 方法一需要使用注解处理器，还需要添加远程依赖包：com.squareup.moshi:moshi-kotlin-codegen:1.11.0 注解@JsonClass(generateAdapter = true)会在路径：build/generated/source/kapt/debug/注解文件所在包名/下生成JsonAdapter，用以对被注解的类进行序列化与反序列化，路径如下图所示： 方法二不需要添加注解，但是需要远程依赖包：com.squareup.moshi:moshi-kotlin:1.11.0，之后在创建Moshi对象时添加KotlinJsonAdapterFactory对象 #3. K.S处理默认参数 12345678910//kotlinx.serializationfun main() { val jsonStr = &quot;&quot;&quot;{&quot;name&quot;:&quot;Lee&quot;}&quot;&quot;&quot; println(Json.encodeToString(PersonWithDefaults.serializer(),PersonWithDefaults(&quot;Lee&quot;))) println(Json.decodeFromString(PersonWithDefaults.serializer(),jsonStr))}@Serializabledata class PersonWithDefaults(val name: String, val age: Int = 18) 打印结果： 12{&quot;name&quot;:&quot;Lee&quot;}PersonWithDefaults(name=Lee, age=18) 说明： 由打印结果可以看出，kotlinx.serialization在序列化时忽略了默认参数，反序列化时支持默认参数 注解@Serializable会在数据类的伴生对象中创建序列化和反序列化的工具 #3. 带init块或成员初始化的数据类序列化 #1. Gson序列化带init块的数据类 1234567891011121314151617fun main() { val gson = Gson() println(gson.toJson(PersonWithInits(&quot;Lee&quot;, 18))) val person = gson.fromJson(jsonStr, PersonWithInits::class.java) println(person) println(person.firstName)}@DataClassAnnotationdata class PersonWithInits(val name: String, val age:Int) { init { println(&quot;PersonWithInits#init()&quot;) } val firstName by lazy { name.split(&quot; &quot;)[0] }} 打印结果： 12345PersonWithInits#init(){&quot;firstName$delegate&quot;:{&quot;initializer&quot;:{},&quot;_value&quot;:{}},&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithInits#init()PersonWithInits(name=Lee, age=18)Lee 说明： Gson每次构造数据类时会检查数据类有没有默认无参构造器，若没有的话，则会通过UnSafe类创建数据类实例。通过UnSafe创建的实例不会调用init块和成员初始化代码 数据类默认是没有无参构造器的，可以使用前面数据类章节中提到的NoArg插件 如上代码所示，数据类添加了使用NoArg插件的注解@DataClassAnnotation使用该数据类有了无参构造方法 如上打印结果所示，数据类有了无参构造方法，则Gson可以执行数据类中的init块的代码 #2. Moshi序列化带init块的数据类 123456789101112131415161718192021222324252627282930313233343536373839404142fun main() { val jsonStr = &quot;&quot;&quot;{&quot;name&quot;:&quot;Lee&quot;, &quot;age&quot;:18}&quot;&quot;&quot; //方法一 val moshi = Moshi.Builder()// .add(KotlinJsonAdapterFactory()) .build() val jsonAdapter = moshi.adapter(PersonWithInitsAnnotation::class.java) println(jsonAdapter.toJson(PersonWithInitsAnnotation(&quot;Lee&quot;, 18))) val person = jsonAdapter.fromJson(jsonStr) println(person) println(person?.firstName) //方法二 val moshi2 = Moshi.Builder() .add(KotlinJsonAdapterFactory()) .build() val jsonAdapter2 = moshi2.adapter(PersonWithInits::class.java) println(jsonAdapter2.toJson(PersonWithInits(&quot;Lee&quot;, 18))) val person2 = jsonAdapter2.fromJson(jsonStr) println(person2) println(person2?.firstName)}@JsonClass(generateAdapter = true)data class PersonWithInitsAnnotation(val name: String, val age:Int) { init { println(&quot;PersonWithInits#init()&quot;) } val firstName by lazy { name.split(&quot; &quot;)[0] }}data class PersonWithInits(val name: String, val age:Int) { init { println(&quot;PersonWithInits#init()&quot;) } val firstName by lazy { name.split(&quot; &quot;)[0] }} 打印结果： 12345678910PersonWithInits#init(){&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithInits#init()PersonWithInitsAnnotation(name=Lee, age=18)LeePersonWithInits#init(){&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithInits#init()PersonWithInits(name=Lee, age=18)Lee 说明： 使用注解@JsonClass和使用反射KotlinJsonAdapterFactory这两种方式都会执行init块和成员变量的初始化 Moshi反序列化时会调用数据类的构造器生成数据类对象 #3. K.S序列化带init块的数据类 123456789101112131415161718fun main() { val jsonStr = &quot;&quot;&quot;{&quot;name&quot;:&quot;Lee&quot;, &quot;age&quot;:18}&quot;&quot;&quot; println(Json.encodeToString(PersonWithInits.serializer(), PersonWithInits(&quot;Lee&quot;, 18))) val person = Json.decodeFromString(PersonWithInits.serializer(), jsonStr) println(person) println(person.firstName)}@Serializabledata class PersonWithInits(val name: String, val age:Int) { init { println(&quot;PersonWithInits#init()&quot;) } val firstName by lazy { name.split(&quot; &quot;)[0] }} 打印结果： 12345PersonWithInits#init(){&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:18}PersonWithInits#init()PersonWithInits(name=Lee, age=18)Lee 说明： kotlinx.serialization会执行init块和成员变量的初始化 注解@Serializable会在数据类的伴生对象中生成序列化和反序列化的工具 #3. 框架对比 Gson Moshi K.S 空类型 否 反射、注解 是 默认值 否 反射、注解 否 init块 NoArg插件 反射、注解 是 java类 是 是 否 跨平台 否 否 是 说明： 如果使用的纯java工程，建议使用Gson和Moshi 如果使用的java和kotlin混合工程，建议使用Moshi 如果使用的纯kotlin工程，建议使用K.S #十三、示例 - 递归整型列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485fun main() { //[0,1,2,3] //实现方式一// val list = IntList.Cons(0, IntList.Cons(1, IntList.Cons(2, IntList.Cons(3, IntList.Nil)))) val list = intListOf(0,1,2,3) println(list) println(list.joinToString('-')) println(list.sum()) val (first, second, third) = list println(&quot;$first, $second, $third&quot;)}//实现嵌套列表fun intListOf(vararg ints: Int): IntList { return when(ints.size) { 0 -&gt; IntList.Nil else -&gt; { IntList.Cons( ints[0], intListOf(*(ints.slice(1 until ints.size).toIntArray())) ) } }}//扩展方法--求和fun IntList.sum(): Int { return when (this) { IntList.Nil -&gt; 0 is IntList.Cons -&gt; { return head + tail.sum() } }}operator fun IntList.component1(): Int? { return when(this) { IntList.Nil -&gt; null is IntList.Cons -&gt; { head } }}operator fun IntList.component2(): Int? { return when(this) { IntList.Nil -&gt; null is IntList.Cons -&gt; { tail.component1() } }}operator fun IntList.component3(): Int? { return when(this) { IntList.Nil -&gt; null is IntList.Cons -&gt; { tail.component2() } }}sealed class IntList { //链的最后一个 object Nil: IntList() { override fun toString(): String { return &quot;Nil&quot; } } data class Cons(val head: Int, val tail:IntList): IntList() { override fun toString(): String { return &quot;$head, $tail&quot; } } fun joinToString(sep: Char = ','):String { return when(this) { Nil -&gt; { &quot;Nil&quot; } is Cons -&gt; { &quot;${head}$sep${tail.joinToString(sep)}&quot; } } }} 打印结果： 12340, 1, 2, 3, Nil0-1-2-3-Nil60, 1, 2 说明： 在一个数组前加星号，表示将该数组元素变成一个个的参数传递给变长参数 (vararg) 因为密封类的子类有限，所以可以使用when语句判断密封类 密封类中的joinToString()方法、它的扩展方法sum()和数据类Cons的toString()方法都使用了递归操作 只要有component()方法就可以解构,列表定义了几个component方法，就可以解构几个元素 #十四、参考文章 https://www.runoob.com/w3cnote/java-inner-class-intro.html https://www.kotlincn.net/docs/reference/compiler-plugins.html https://www.kotlincn.net/docs/reference/compiler-plugins.html https://www.kotlincn.net/docs/reference/kapt.html","link":"/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/"},{"title":"kotlin学习系列十三：协程源码篇一","text":"一、前言 二、 集合操作符 1. 场景模拟：统计学生成绩 2. 过滤 3. 转换 4. 分组 5. 分割 6. 求和 7. 操作符总结 三、 协程源码的地图 1. 协程源码的结构 1. 基础层：协程基础元素 2. 中间层：kotlinx.coroutines-common 3. 平台层 2. 如何研究协程源码？ 3. Kotlin 源码编译细节 #一、前言 本文主要讲述Kotlin 协程中的集合操作符及协程源码结构 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程一 kotlin学习系列十：协程二 kotlin学习系列十一：协程三 kotlin学习系列十二：协程四 kotlin学习系列十四：协程源码篇二 协程创建 kotlin学习系列十五：协程源码篇三 #二、 集合操作符 当学习一门知识的时候，总是离不开 What、Why 和 How。在前面的文章当中，已经弄清楚了 Kotlin 是什么，以及为什么要用 Kotlin。那么在这个系列里，主要是来解决 How 的问题，以此从根源上搞清楚 Kotlin 的底层实现原理。 Kotlin 的集合 API，本质上是一种数据处理的模式。 什么是数据处理模式？可以想象一下：对于 1~10 的数字来说，找出其中的偶数，那么这就是一种过滤的行为。计算出 1~10 的总和，那么这就是一种求和的行为。所以从数据操作的角度来看，Kotlin 的操作符就可以分为几个大类：过滤、转换、分组、分割、求和。 接下来，通过一个统计学生成绩的案例，来分析 Kotlin 的集合 API 的使用场景 #1. 场景模拟：统计学生成绩 为了研究 Kotlin 集合 API 的使用场景，来模拟一个实际的生活场景：统计学生成绩。 123456789101112131415161718192021222324252627data class Student( val name: String = &quot;&quot;, val score: Int = 0)val class1 = listOf( Student(&quot;小明&quot;, 83), Student(&quot;小红&quot;, 92), Student(&quot;小李&quot;, 50), Student(&quot;小白&quot;, 67), Student(&quot;小琳&quot;, 72), Student(&quot;小刚&quot;, 97), Student(&quot;小强&quot;, 57), Student(&quot;小林&quot;, 86))val class2 = listOf( Student(&quot;大明&quot;, 80), Student(&quot;大红&quot;, 97), Student(&quot;大李&quot;, 53), Student(&quot;大白&quot;, 64), Student(&quot;大琳&quot;, 76), Student(&quot;大刚&quot;, 92), Student(&quot;大强&quot;, 58), Student(&quot;大林&quot;, 88)) 这里定义了一个数据类 Student，然后有一个集合，当中对应的就是学生的名字和成绩。 接下来，就以这个场景来研究 Kotlin 的集合 API。 #2. 过滤 比如说，希望过滤 1 班里不及格的学生，就可以用 filter{} 这个操作符，这里的 filter 其实就是过滤的意思。 123456789private fun filterNotPass() { val result = class1.filter { it.score &lt; 60 } println(result)}/*[Student(name=小李, score=50), Student(name=小强, score=57)]*/ 以上代码段的逻辑很简单，读起来就像英语文本一样，这里重点来看看 filter{} 的源代码： 12345678910public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; { // 创建了新的ArrayList&lt;T&gt;()集合 return filterTo(ArrayList&lt;T&gt;(), predicate)}public inline fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Iterable&lt;T&gt;.filterTo(destination: C, predicate: (T) -&gt; Boolean): C { for (element in this) if (predicate(element)) destination.add(element) return destination} 可以看到 filter{} 其实是一个高阶函数，它只有唯一的参数“predicate: (T) -&gt; Boolean”，这就是它的 过滤条件及过滤标准，只有符合这个过滤条件的数据才会被保留下来。 而且，对于 List.filter{} 来说，它的内部还会创建一个新的 ArrayList&lt;T&gt;()，然后将符合过滤条件的元素添加进去，再返回这个新的集合。 而除了 filter{} 以外，Kotlin 还提供了 filterIndexed{}，它的作用其实和 filter{} 一样，只是会额外带上集合元素的 index，即它的参数类型是“predicate: (index: Int, T) -&gt; Boolean”。 还有一个是 filterIsInstance()，它的作用是过滤集合当中特定类型的元素。如下所示： 123456789101112131415161718192021222324252627inline fun &lt;reified T&gt; create(): T { return Proxy.newProxyInstance( T::class.java.classLoader, arrayOf(T::class.java) ) { proxy, method, args -&gt; return@newProxyInstance method.annotations // 注意这里 .filterIsInstance&lt;GET&gt;() .takeIf { it.size == 1 } ?.let { invoke(&quot;$baseUrl${it[0].value}&quot;, method, args) } } as T}// inline + reified = 类型实化// ↓ ↓public inline fun &lt;reified R&gt; Iterable&lt;*&gt;.filterIsInstance(): List&lt;@kotlin.internal.NoInfer R&gt; { return filterIsInstanceTo(ArrayList&lt;R&gt;())}// inline + reified = 类型实化// ↓ ↓public inline fun &lt;reified R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;*&gt;.filterIsInstanceTo(destination: C): C { for (element in this) if (element is R) destination.add(element) return destination} 可以看到，filterIsInstance 的源代码逻辑也非常简单，其中最关键的，就是它借助了 inline、reified 这两个关键字，实现了 类型实化。它的作用就是让 Kotlin 的“伪泛型”变成“真泛型”。 #3. 转换 现在，还是基于学生成绩统计的场景。不过，这次的需求是要把学生的名字隐藏掉一部分，原本的“小明”“小红”，要统一变成“小某某”。 那么对于这样的需求，用 map{} 就可以实现了。 12345678910111213141516private fun mapName() { val result = class1.map { it.copy(name = &quot;小某某&quot;) } println(result)}/*[Student(name=小某某, score=83), Student(name=小某某, score=92), Student(name=小某某, score=50),Student(name=小某某, score=67), Student(name=小某某, score=72),Student(name=小某某, score=97), Student(name=小某某, score=57),Student(name=小某某, score=86)]*/ 这里需要注意，虽然 map 这个单词的意思是“地图”，但在当前的语境下，map 其实是 转换、映射的意思。 另外，map 的源码也很简单： 12345678910public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)}public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C { for (item in this) destination.add(transform(item)) return destination} 本质上，map 就是对每一个集合元素都进行一次 transform() 方法的调用，它的类型是“transform: (T) -&gt; R”。 除了 map 以外，还有一个比较有用的转换 API，flatten。它的作用是将嵌套的集合“展开、铺平 成为一个非嵌套的集合”。来看一个简单的例子： 12345678910private fun testFlatten() { val list = listOf(listOf(1, 2, 3), listOf(4, 5, 6)) val result = list.flatten() println(result)}/*[1, 2, 3, 4, 5, 6]*/ 假设，现在想要过滤出 1 班、2 班当中所有未及格的同学，就可以结合 flatten、filter 来实现。 123456789101112131415private fun filterAllNotPass() { val result = listOf(class1, class2) .flatten() .filter { it.score &lt; 60 } println(result)}/*[Student(name=小李, score=50),Student(name=小强, score=57),Student(name=大李, score=53),Student(name=大强, score=58)]*/ 在上面的代码中，首先将嵌套的集合用 flatten 展平，得到 1 班、2 班所有同学的成绩，然后直接使用 filter 就完成了。 12345678// flatten 源代码public fun &lt;T&gt; Iterable&lt;Iterable&lt;T&gt;&gt;.flatten(): List&lt;T&gt; { val result = ArrayList&lt;T&gt;() for (element in this) { result.addAll(element) // 注意addAll() } return result} 在上面flatten的源码中可以看到，本质上，flatten 就是一个 for 循环，然后对每一个内部集合进行 addAll()。 #4. 分组 现在，还是基于学生成绩统计的场景。这次，希望把学生们按照成绩的分数段进行分组：50~59 的学生为一组、60~69 的学生为一组、70~79 的学生为一组，以此类推。 对于这样的需求，可以使用 Kotlin 提供的 groupBy{}。比如说： 1234567891011121314private fun groupStudent() { val result = class1.groupBy { &quot;${it.score / 10}0分组&quot; } println(result)}/*{80分组=[Student(name=小明, score=83), Student(name=小林, score=86)], 90分组=[Student(name=小红, score=92), Student(name=小刚, score=97)], 50分组=[Student(name=小李, score=50), Student(name=小强, score=57)], 60分组=[Student(name=小白, score=67)], 70分组=[Student(name=小琳, score=72)]}*/ groupBy{} 的意思就是以什么标准进行分组 。在这段代码里，是以分数除以 10 得到的数字进行分组的，最终它的 返回值类型其实是 Map&lt;String, List&lt;Student&gt;&gt;。 12345678910111213141516171819202122232425public inline fun &lt;T, K&gt; Iterable&lt;T&gt;.groupBy(keySelector: (T) -&gt; K): Map&lt;K, List&lt;T&gt;&gt; { return groupByTo(LinkedHashMap&lt;K, MutableList&lt;T&gt;&gt;(), keySelector)}public inline fun &lt;T, K, M : MutableMap&lt;in K, MutableList&lt;T&gt;&gt;&gt; Iterable&lt;T&gt;.groupByTo(destination: M, keySelector: (T) -&gt; K): M { for (element in this) { val key = keySelector(element) // 注意这里 val list = destination.getOrPut(key) { ArrayList&lt;T&gt;() } list.add(element) } return destination}public inline fun &lt;K, V&gt; MutableMap&lt;K, V&gt;.getOrPut(key: K, defaultValue: () -&gt; V): V { val value = get(key) return if (value == null) { val answer = defaultValue() put(key, answer) answer } else { value }} 从 groupBy 的源代码中可以看到，它的本质就是用 for 循环遍历元素，然后使用 keySelector() 计算出 Map 的 Key，再把其中所有的元素添加到对应 Key 当中去。注意，在代码这里使用了一个 getOrPut(key) { ArrayList() }，它的作用就是尝试获取对应的 key 的值，如果不存在的话，就将 ArrayList() 存进去。 #5. 分割 还是基于学生成绩统计的场景。这次，希望找出前三名和倒数后三名的学生。做法其实也很简单，使用 take() 就可以实现了。 123456789101112131415161718private fun takeStudent() { val first3 = class1 .sortedByDescending { it.score } .take(3) val last3 = class1 .sortedByDescending { it.score } .takeLast(3) println(first3) println(last3)}/*[Student(name=小刚, score=97), Student(name=小红, score=92), Student(name=小林, score=86)][Student(name=小白, score=67), Student(name=小强, score=57), Student(name=小李, score=50)]*/ 在上面的代码中，先按照分数进行了降序排序，然后使用了 take、takeLast 从列表当中取出前三个和后三个数据，它们分别代表了：成绩排在前三名、后三名的同学。而除了 take 以外，还有 drop、dropLast，它们的作用是 剔除。 12345678910111213private fun dropStudent() { val middle = class1 .sortedByDescending { it.score } .drop(3) .dropLast(3) // 剔除前三名、后三名，剩余的学生 println(middle)}/*[Student(name=小明, score=83), Student(name=小琳, score=72)]*/ 在上面的代码中，先把学生按照分数降序排序，然后剔除了前三名和后三名，得到了中间部分的学生。 另外 Kotlin 还提供了 slice，使用这个 API，同样可以取出学生中的前三名、后三名。 12345678910111213141516171819private fun sliceStudent() { val first3 = class1 .sortedByDescending { it.score } .slice(0..2) val size = class1.size val last3 = class1 .sortedByDescending { it.score } .slice(size - 3 until size) println(first3) println(last3)}/*[Student(name=小刚, score=97), Student(name=小红, score=92), Student(name=小林, score=86)][Student(name=小白, score=67), Student(name=小强, score=57), Student(name=小李, score=50)]*/ 可以看到，slice 的作用是根据 index 来分割集合的，当它与 Range（特定范围）相结合的时候，代码的可读性也是不错的。 #6. 求和 接着来看 Kotlin 的求和 API。这一次还是基于学生成绩统计的场景，希望计算全班学生的总分。 可以使用 Kotlin 提供的 sumOf、reduce、fold。 123456789101112131415161718192021222324private fun sumScore() { val sum1 = class1.sumOf { it.score } val sum2 = class1 .map { it.score } .reduce { acc, score -&gt; acc + score } val sum3 = class1 .map { it.score } .fold(0) { acc, score -&gt; acc + score } println(sum1) println(sum2) println(sum3)}/*604604604*/ 总的来说，sumOf 能做到的事情，reduce 可以想办法做；而 reduce 可以做到的事情，fold 也可以做到。它们的使用场景是具备包含关系的。 sumOf{} 仅可以用于数字类型的数据进行求和的场景。 reduce 本质上是对数据进行遍历，然后进行某种“广义求和”的操作，这里不局限于数字类型。使用 reduce，也可以进行字符串拼接。相当于说，这里的求和规则，是从外部传进来的。 fold 对比 reduce 来说，只是多了一个初始值，其他都跟 reduce 一样。 比如，下面这段代码，就使用了 reduce、fold 进行了字符串拼接： 123456789101112131415161718private fun joinScore() { val sum2 = class1 .map { it.score.toString() } .reduce { acc, score -&gt; acc + score } val sum3 = class1 .map { it.score.toString() } .fold(&quot;Prefix=&quot;) { acc, score -&gt; acc + score } println(sum2) println(sum3)}/*8392506772975786Prefix=8392506772975786*/ 所以，reduce 就是 fold 的一种特殊情况。也就是说，fold 不需要初始值的时候，就是 reduce。看看它们的源码定义： 12345678910111213141516public inline fun &lt;S, T : S&gt; Iterable&lt;T&gt;.reduce(operation: (acc: S, T) -&gt; S): S { val iterator = this.iterator() if (!iterator.hasNext()) throw UnsupportedOperationException(&quot;Empty collection can't be reduced.&quot;) var accumulator: S = iterator.next() while (iterator.hasNext()) { accumulator = operation(accumulator, iterator.next()) } return accumulator}public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R { var accumulator = initial for (element in this) accumulator = operation(accumulator, element) return accumulator} 根据以上定义，可以发现 fold 和 reduce 的名字虽然看起来很高大上，但它们的实现原理其实非常简单，就是一个简单的 for 循环。而 reduce 之所以看起来比 fold 要复杂一点的原因在于，reduce 需要兼容集合为空的情况，fold 不需要，因为 fold 具备初始值。 #7. 操作符总结 Kotlin 的集合 API，主要分为这几个大类：过滤、转换、分组、分割、求和。 过滤，filter、filterIsInstance，前者是以条件过滤，后者是以类型过滤，后者运用了 Kotlin 的类型实化。 转换，map、flatten，前者是转换集合元素，后者是转换集合的嵌套层级，flatten 会把嵌套的集合展平。 分组，groupBy，即以什么标准进行分组，它的返回值类型往往会是 Map&lt;K, List&lt;T&gt;&gt;。 分割，take、drop、slice。take 代表从集合中提取，drop 代表从集合中剔除，slice 代表以特定范围 （Range） 进行切割。 求和，sumOf、reduce、fold。sumOf 只适用于数字类型的求和，reduce、fold 则能够以特定规则对集合元素进行“广义的求和”，其中的“求和规则”可以灵活自定义，比如字符串拼接。 #三、 协程源码的地图 协程的源码非常复杂。在 Kotlin 协程 1.6.0 版本中，仅仅是协程跟 JVM 相关的源代码，就有 27789 行。如果算上 JavaScript 平台、Native 平台，以及单元测试相关的代码，Kotlin 协程库当中的源代码有接近 10 万行。面对这么多的源代码，根本不可能一行一行去分析。 因此，在研究 Kotlin 协程的源代码的时候，要有一定的技巧。这里分享两个小技巧： 理解 Kotlin 协程的源码结构。 Kotlin 协程的源代码分布在多个模块之中，每个模块都会包含特定的协程概念。相应的，它的各个概念也有特定的层级结构，只有弄清楚各个概念之间的关系，并且建立一个类似“地图”的知识结构，在研究源码的时候，才不会那么容易迷失。 明确研究源码的目标。 不可能一次性看完协程所有的源代码，所以在读源码的过程中，一定要有明确的目标。比如是想要了解挂起函数的原理，还是想学习协程的启动流程。 不管是什么技术，研究它的底层原理永远不是一件容易的事情。 先来构建一个协程源码的知识地图，掌握了这张地图之后，再去学习协程的实现原理时，就可以在脑海中快速查找和定位相关模块对应的源代码，也不会迷失方向了。 #1. 协程源码的结构 Kotlin 协程是一个独立的框架。如果想要使用 Kotlin 协程，需要单独进行依赖。 Kotlin 的协程源码分为了三个层级，自底向上分别是： 基础层：Kotlin 库当中定义的协程基础元素； 中间层：协程框架通用逻辑 kotlinx.coroutines-common； 平台层：这个是指协程在特定平台的实现，比如说 JVM、JS、Native。 所以，需要分别从这三个层级来了解协程源码的目录结构、作用类别，以及对应的功能模块的源代码。也就是说，为了研究 Kotlin 协程的原理，不仅要读协程框架的源码，同时还要读 Kotlin 标准库的源码。接下来，一个个来看。 #1. 基础层：协程基础元素 比如，像是协程当中的一些基础概念，Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics 等等，这些概念都是定义在 Kotlin 标准库当中的。 那么，Kotlin 官方为什么要这么做呢？这其实是一种解耦 的思想。Kotlin 标准库当中的基础元素，就像是构造协程框架的“砖块 ”一样。简单的几个基础概念，将它们组合到一起，就可以实现功能强大的协程框架。 实际上，现在的 kotlinx.coroutines 协程框架，就是基于以上几种协程基础元素构造出来的。如果哪天 GitHub 上突然冒出一款新的 Kotlin 协程框架，也不要觉得意外，因为构造协程的砖块就在那里，每个人都可以借助这些基础元素来构建自己的协程框架。 不过就目前来说，还是 Kotlin 官方封装的协程框架功能最强大，所以开发者也都会选择 kotlinx.coroutines。另外 Kotlin 是支持跨平台的，所以协程其实也存在跨平台的实现。在 Kotlin 官方的协程框架当中，大致分了两层：common 中间层和平台层。 #2. 中间层：kotlinx.coroutines-common kotlinx.coroutines 源代码当中的 common 子模块，里面包含了 Kotlin 协程框架的通用逻辑。前面了解过的大部分知识点，都来自于这个模块，比如 launch、async、CoroutineScope、CoroutineDispatcher、Job、Deferred、Channel、Select、Flow 等。 虽然说，开发者使用那些底层的协程基础元素，也能够写代码，但它们终归是不如 Flow 之类的 API 好用的。而 kotlinx.coroutines-common 这个模块，就是 Kotlin 官方提供的一个协程的中间层。借助这些封装过后的高级协程概念，就可以直接去解决工作中的实际问题了。 在这个 common 中间层里，只有纯粹的协程框架逻辑，不会包含任何特定的平台特性。而 Kotlin 其实是支持 3 种平台的：JVM、JavaScript、Native。所以针对平台的支持逻辑，都在下面的平台层当中。 #3. 平台层 在 core 模块之下，有几个与 common 平级的子模块，即 JVM、JavaScript、Native。这里面，才是 Kotlin 协程与某个平台产生关联的地方。 Kotlin 的协程，最终都是运行在线程之上的。所以，当 Kotlin 在不同平台上运行的时候，最终还需要映射到对应的线程模型之上。这里就以 JVM 和 JavaScript 为例： 可以看到，同样的协程概念，在 JVM、JavaScript 两个平台上会有不同的实现： 同样是线程，在 JVM 是线程池，而 JavaScript 则是 JS 线程； 同样是事件循环，两者也会有不同的实现方式； 同样是异步任务，JVM 是 Future，JavaScript 则是 Promise。 可见，虽然协程的“平台层”是建立在 common 层之上的，但它同时又为协程在特定平台上提供了对应的支持。 到这里，就已经弄清楚 Kotlin 协程的源码结构了。这个源码的结构，也就相当于协程知识点的地图 。有了这个地图以后，在后面遇到问题的时候，才知道去哪里找答案。比如说，当想知道 Kotlin 的协程是如何运行在线程之上的，那么肯定要到平台层，去找 JVM 的具体实现。 #2. 如何研究协程源码？ 读 Kotlin 协程的源代码，就像是一场原始森林里的探险一样。不仅要有一张清晰的地图，同时还要有 明确的目标。 比如应着重探究挂起函数的原理、协程启动原理、Dispatchers 原理、CoroutineScope 原理、Channel 原理，还有 Flow 的原理。这些都是 Kotlin 协程当中最基础、最重要的知识点，掌握了它们的原理以后，在工作中使用协程时也会更有底气。就算遇到了问题，也可以通过读源码找到解决方案。 不过，即使有了探索的目标也还不够，在正式开始之前，还需要做一些额外的准备工作。 首先，要掌握好协程的调试技巧。 其次，要彻底弄懂协程的基础元素。 所以接下来，面对协程源码的三层结构：基础层、中间层、平台层，必须自底向上，一步步进行分析。 #3. Kotlin 源码编译细节 在平时用 Kotlin 协程的时候，一般只会使用依赖的方式： 12implementation &quot;org.jetbrains.kotlin:kotlin-stdlib&quot;implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0' 不过使用这种方式，会经常遇到某些类看不到源代码实现的情况。比如，kotlin.coroutines.intrinsics 这个包下的源代码： 解决方案如下： 首先，当遇到依赖包当中无法查看的类时，可以去 GitHub 下载 Kotlin 和 Coroutines 的源代码，然后按照上面画的“协程源码地图”去找对应的源代码实现。 然后，在 IDE 当中导入这两个工程的时候，可能也会遇到各种各样的问题。这时候，需要参考这两个链接里的内容：Coroutine Contributing Guidelines、Kotlin Build environment requirements，来配置好 Kotlin 和 Coroutines 的编译环境。 完成了这两个工程的导入工作以后，就可以看到 Kotlin 和协程所有的源代码了。这里不仅有它们的核心代码，还会有跨平台实现、编译器实现，以及对应的单元测试代码。这样后面在读 Kotlin 源码的时候，才会有更大的自由度。","link":"/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/"},{"title":"kotlin学习系列十一：协程三","text":"一、前言 二、 Channel 1. Channel 是管道 2. Channel 参数解析 1. 案例 1：capacity = UNLIMITED 2. 案例2：capacity = CONFLATED 3. 案例3：onBufferOverflow 用法 4. 案例4：onBufferOverflow 用法2 5. 案例5：onUndeliveredElement 作用 3. Channel 关闭引发的问题 1. produce{} 2. receive()方法 3. channel.consumeEach {} 4. 为什么说 Channel 是“热”的？ 5. Channel 的能力都是通过“组合”得来的 三、 Flow 1. Flow 就是“数据流” 2. Flow 的创建 3. Flow 中间操作符 1. Flow 生命周期 1. onStart 2. onCompletion 2. Flow catch 处理异常 3. 切换 Context：flowOn、launchIn 4. 下游：终止操作符 5. 为什么说 Flow 是“冷”的？ 6. Flow 实践 四、 select 1. select 就是选择“更快的结果” 2. select 和 async 3. select 和 Channel 5. select 实战 #一、前言 本文主要讲述Kotlin 协程中的 Channel 以及 Flow 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程一 kotlin学习系列十：协程二 kotlin学习系列十二：协程四 #二、 Channel 前面学习的挂起函数、async，它们一次都只能返回一个结果。但在某些业务场景下，往往需要协程返回多个结果，比如微信等软件的 IM 通道接收的消息，或者是手机 GPS 定位返回的经纬度坐标需要实时更新。那么，在这些场景下，我们之前学习的协程知识就无法直接解决了。而 Channel，就是专门用来做这种事情的。 #1. Channel 是管道 Channel 就是一个管道。Channel 这个管道的其中一端，是发送方；管道的另一端是接收方。而管道本身，则可以用来传输数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 代码段1fun main() = runBlocking { // 1，创建管道 val channel = Channel&lt;Int&gt;() launch { // 2，在一个单独的协程当中发送管道消息 (1..3).forEach { channel.send(it) // 挂起函数 logX(&quot;Send: $it&quot;) } } launch { // 3，在一个单独的协程当中接收管道消息 for (i in channel) { // 挂起函数 logX(&quot;Receive: $i&quot;) } } logX(&quot;end&quot;)}/*================================endThread:main @coroutine#1================================================================Receive: 1Thread:main @coroutine#3================================================================Send: 1Thread:main @coroutine#2================================================================Send: 2Thread:main @coroutine#2================================================================Receive: 2Thread:main @coroutine#3================================================================Receive: 3Thread:main @coroutine#3================================================================Send: 3Thread:main @coroutine#2================================// 4，程序不会退出*/ 说明： 通过运行的结果，首先可以看到的就是：coroutine#2、coroutine#3，这两个协程是交替执行的。这段代码，其实和我们第 13 讲当中提到的“互相协作”的模式是类似的，两个协程会轮流执行。 还可以看出来，Channel 可以跨越不同的协程进行通信。在“coroutine#1”当中创建的 Channel，然后分别在 coroutine#2、coroutine#3 当中使用 Channel 来传递数据。 另外在代码中，还有四个注释： 注释 1，通过“Channel()”这样的方式，就可以创建一个管道。其中传入的泛型 Int，就代表了这个管道里面传递的数据类型。也就是说这里创建的 Channel，就是用于传递 Int 数据的。 注释 2，创建了一个新的协程，然后在协程当中调用了 send() 方法，发送数据到管道里。其中的 send() 方法是一个挂起函数。 注释 3，在另一个协程当中，通过遍历 channel，将管道当中的数据都取了出来。这里，使用的是 for 循环。 注释 4，通过运行结果，还可以发现一个细节，那就是程序在输出完所有的结果以后，并不会退出。主线程不会结束，整个程序还会处于运行状态。 要解决主线程不能退出的问题，只需要加一行代码即可。 1234567891011121314151617181920212223// 代码段2fun main() = runBlocking { val channel = Channel&lt;Int&gt;() launch { (1..3).forEach { channel.send(it) logX(&quot;Send: $it&quot;) } channel.close() // 变化在这里 } launch { for (i in channel) { logX(&quot;Receive: $i&quot;) } } logX(&quot;end&quot;)} 所以，channel 其实也是一种协程资源，在用完 channel 以后，如果我们不去主动关闭它的话，是会造成不必要的资源浪费的。在上面的案例中，如果我们忘记调用“channel.close()”，程序将永远不会停下来。 #2. Channel 参数解析 12345678// 代码段3public fun &lt;E&gt; Channel( capacity: Int = RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND, onUndeliveredElement: ((E) -&gt; Unit)? = null): Channel&lt;E&gt; {} 如上为Channel 的部分源代码，可以看到，当调用“Channel()”的时候，感觉像是在调用一个构造函数，但实际上它却只是一个普通的顶层函数。这个函数带有一个泛型参数 E，另外还有三个参数。 第一个参数，capacity，代表了管道的容量。日常生活中的管道，自身也是有容量的，即使接收方不将数据取走，管道本身也可以存储一些数据。而 Kotlin 的 Channel，在默认情况下是“RENDEZVOUS”，也就代表了 Channel 的容量为 0。 题外话：RENDEZVOUS 这个单词源自法语。它有约会、碰面的意思，可以理解为“发送方、接收方，不见不散”。 除此之外，capacity 还有其他几种情况，比如说： UNLIMITED，代表了无限容量； CONFLATED，代表了容量为 1，新的数据会替代旧的数据； BUFFERED，代表了具备一定的缓存容量，默认情况下是 64，具体容量由这个 VM 参数决定 “kotlinx.coroutines.channels.defaultBuffer”。 第二个参数，onBufferOverflow，也就是指当指定了 capacity 的容量，等管道的容量满了时，Channel 的应对策略是怎么样的。这里，它主要有三种做法： SUSPEND，当管道的容量满了以后，如果发送方还要继续发送，就会挂起当前的 send() 方法。由于它是一个挂起函数，所以可以以非阻塞的方式，将发送方的执行流程挂起，等管道中有了空闲位置以后再恢复。 DROP_OLDEST，顾名思义，就是丢弃最旧的那条数据，然后发送新的数据； DROP_LATEST，丢弃最新的那条数据。这里要注意，这个动作的含义是丢弃当前正准备发送的那条数据，而管道中的内容将维持不变。 下图可以清晰描述上面的几种模式： 第三个参数，onUndeliveredElement，它其实相当于一个异常处理回调。当管道中的某些数据没有被成功接收的时候，这个回调就会被调用。 为了对这三个参数有个更具体的认识，来看几个代码的案例。 #1. 案例 1：capacity = UNLIMITED 12345678910111213141516171819202122232425262728293031// 代码段4fun main() = runBlocking { // 变化在这里 val channel = Channel&lt;Int&gt;(capacity = Channel.Factory.UNLIMITED) launch { (1..3).forEach { channel.send(it) println(&quot;Send: $it&quot;) } channel.close() // 变化在这里 } launch { for (i in channel) { println(&quot;Receive: $i&quot;) } } println(&quot;end&quot;)}}/*输出结果：endSend: 1Send: 2Send: 3Receive: 1Receive: 2Receive: 3*/ 以上代码对比 代码段 1，其实只改动了一点点。在创建 Channel 的时候，设置了 capacity = Channel.Factory.UNLIMITED。不过，通过分析运行的结果，可以发现代码的运行顺序就跟之前完全不一样了。 对于发送方来说，由于 Channel 的容量是无限大的，所以发送方可以一直往管道当中塞入数据，等数据都塞完以后，接收方才开始接收。这跟之前的交替执行是不一样的。 #2. 案例2：capacity = CONFLATED 123456789101112131415161718192021222324252627282930313233// 代码段5fun main() = runBlocking { // 变化在这里 val channel = Channel&lt;Int&gt;(capacity = Channel.Factory.CONFLATED) launch { (1..3).forEach { channel.send(it) println(&quot;Send: $it&quot;) } channel.close() } launch { for (i in channel) { println(&quot;Receive: $i&quot;) } } println(&quot;end&quot;)}/*输出结果：endSend: 1Send: 2Send: 3Receive: 3*/ 可以看到，当设置 capacity = CONFLATED 的时候，发送方也会一直发送数据，而且，对于接收方来说，它永远只能接收到最后一条数据。 #3. 案例3：onBufferOverflow 用法 123456789101112131415161718192021222324252627282930313233343536// 代码段6fun main() = runBlocking { // 变化在这里 val channel = Channel&lt;Int&gt;( capacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST ) launch { (1..3).forEach { channel.send(it) println(&quot;Send: $it&quot;) } channel.close() } launch { for (i in channel) { println(&quot;Receive: $i&quot;) } } println(&quot;end&quot;)}/*输出结果：endSend: 1Send: 2Send: 3Receive: 3*/ 如上代码可以运用 onBufferOverflow 与 capacity，来实现 CONFLATED 的效果。可以看出来，其实 capacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST，就代表了 capacity = CONFLATED。 #4. 案例4：onBufferOverflow 用法2 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 代码段7fun main() = runBlocking { // 变化在这里 val channel = Channel&lt;Int&gt;( capacity = 3, onBufferOverflow = BufferOverflow.DROP_LATEST ) launch { (1..3).forEach { channel.send(it) println(&quot;Send: $it&quot;) } channel.send(4) // 被丢弃 println(&quot;Send: 4&quot;) channel.send(5) // 被丢弃 println(&quot;Send: 5&quot;) channel.close() } launch { for (i in channel) { println(&quot;Receive: $i&quot;) } } println(&quot;end&quot;)}/*输出结果：endSend: 1Send: 2Send: 3Send: 4Send: 5Receive: 1Receive: 2Receive: 3*/ 可见，onBufferOverflow = BufferOverflow.DROP_LATEST 就意味着，当 Channel 容量满了以后，之后再继续发送的内容，就会直接被丢弃。 #5. 案例5：onUndeliveredElement 作用 1234567891011121314151617181920212223242526272829// 代码段8fun main() = runBlocking { // 无限容量的管道 val channel = Channel&lt;Int&gt;(Channel.UNLIMITED) { println(&quot;onUndeliveredElement = $it&quot;) } // 等价这种写法// val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = { println(&quot;onUndeliveredElement = $it&quot;) }) // 放入三个数据 (1..3).forEach { channel.send(it) } // 取出一个，剩下两个 channel.receive() // 取消当前channel channel.cancel()}/*输出结果：onUndeliveredElement = 2onUndeliveredElement = 3*/ 可以看到，onUndeliveredElement 的作用，就是一个回调，当发送出去的 Channel 数据无法被接收方处理的时候，就可以通过 onUndeliveredElement 这个回调，来进行监听。 它的使用场景一般都是用于接收方对数据是否被消费特别关心的场景。比如说，发送出去的消息，接收方是不是真的收到了？对于接收方没收到的信息，发送方就可以灵活处理了，比如针对这些没收到的消息，发送方可以先记录下来，等下次重新发送。 #3. Channel 关闭引发的问题 #1. produce{} 在前面提到的代码段 1 里，由于忘记调用了 close()，所以会导致程序一直运行无法终止。这个问题其实是很严重的。为了解决这一问题，Kotlin 官方提供了另一种创建 Channel 的方式，也就是 produce{} 高阶函数 。 123456789101112131415161718192021// 代码段9fun main() = runBlocking { // 变化在这里 val channel: ReceiveChannel&lt;Int&gt; = produce { (1..3).forEach { send(it) logX(&quot;Send: $it&quot;) } } launch { // 3，接收数据 for (i in channel) { logX(&quot;Receive: $i&quot;) } } logX(&quot;end&quot;)} 以上代码中，使用 produce{} 以后，就不用再去调用 close() 方法了，因为 produce{} 会自动调用 close() 方法。 #2. receive()方法 12345678910111213141516171819202122232425// 代码段10fun main() = runBlocking { // 1，创建管道 val channel: ReceiveChannel&lt;Int&gt; = produce { // 发送3条数据 (1..3).forEach { send(it) } } // 调用4次receive() channel.receive() // 1 channel.receive() // 2 channel.receive() // 3 channel.receive() // 异常 logX(&quot;end&quot;)}/*输出结果：ClosedReceiveChannelException: Channel was closed*/ 在前面所有的代码当中，都是以 for 循环来迭代 channel 当中的元素的，但实际上，channel 还有一个 receive() 方法，它是与 send(it) 对应的。在上面代码中，只调用了 3 次 send()，却调用 4 次 receive()。 当第 4 次调用 receive() 的时候，代码会抛出异常“ClosedReceiveChannelException”，这其实也代表： Channel 已经被关闭了。所以这也就说明了，produce {}确实会调用 close() 方法。不然的话，第 4 次 receive() 会被挂起，而不是抛出异常。 123456789101112131415161718192021222324252627282930// 代码段11fun main() = runBlocking { val channel: Channel&lt;Int&gt; = Channel() launch { (1..3).forEach { channel.send(it) } } // 调用4次receive() channel.receive() // 1 println(&quot;Receive: 1&quot;) channel.receive() // 2 println(&quot;Receive: 2&quot;) channel.receive() // 3 println(&quot;Receive: 3&quot;) channel.receive() // 永远挂起 logX(&quot;end&quot;)}/*输出结果Receive: 1Receive: 2Receive: 3*/ 以上代码可见，第 4 次调用 receive()，就会导致程序被永久挂起，后面的 logX(&quot;end&quot;) 是没有机会继续执行的。也就是说，直接使用 receive() 是很容易出问题。 Channel 其实还有两个属性：isClosedForReceive、isClosedForSend。这两个属性，就可以用来判断当前的 Channel 是否已经被关闭。由于 Channel 分为发送方和接收方，所以这两个参数也是针对这两者的。 对于发送方来说，可以使用“isClosedForSend”来判断当前的 Channel 是否关闭； 对于接收方来说，可以使用“isClosedForReceive”来判断当前的 Channel 是否关闭。 1234567891011121314151617181920212223242526272829303132// 代码段12fun main() = runBlocking { // 1，创建管道 val channel: ReceiveChannel&lt;Int&gt; = produce { // 发送3条数据 (1..3).forEach { send(it) println(&quot;Send $it&quot;) } } // 使用while循环判断isClosedForReceive while (!channel.isClosedForReceive) { val i = channel.receive() println(&quot;Receive $i&quot;) } println(&quot;end&quot;)}/*输出结果Send 1Receive 1Receive 2Send 2Send 3Receive 3end*/ 以上代码看起来是可以正常工作了。但是，仍然不建议用这种方式。因为，当为管道指定了 capacity 以后，以上的判断方式将会变得不可靠！原因是 1.6.0 版本的协程库，运行这样的代码会崩溃，如下所示： 123456789101112131415161718192021222324252627282930// 代码段13fun main() = runBlocking { // 变化在这里 val channel: ReceiveChannel&lt;Int&gt; = produce(capacity = 3) { // 变化在这里 (1..300).forEach { send(it) println(&quot;Send $it&quot;) } } while (!channel.isClosedForReceive) { val i = channel.receive() println(&quot;Receive $i&quot;) } logX(&quot;end&quot;)}/*输出结果// 省略部分Receive 300Send 300ClosedReceiveChannelException: Channel was closed*/ 所以，最好不要用 channel.receive()。即使配合 isClosedForReceive 这个判断条件，直接调用 channel.receive() 仍然是一件非常危险的事情！ #3. channel.consumeEach {} 实际上，除了可以使用 for 循环以外，还可以使用 Kotlin 提供的另一个高阶函数：channel.consumeEach {}。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 代码段14fun main() = runBlocking { val channel: ReceiveChannel&lt;Int&gt; = produce(capacity = 3) { (1..300).forEach { send(it) println(&quot;Send $it&quot;) } } // 变化在这里 channel.consumeEach { println(&quot;Receive $it&quot;) } logX(&quot;end&quot;)}/*部分输出结果：Send 1Thread:main @coroutine#2Send 2Thread:main @coroutine#2Send 3Thread:main @coroutine#2Send 4Thread:main @coroutine#2Receive 1Thread:main @coroutine#1Receive 2Thread:main @coroutine#1Receive 3Thread:main @coroutine#1Receive 4Thread:main @coroutine#1Receive 5Thread:main @coroutine#1Send 5Thread:main @coroutine#2Send 6Thread:main @coroutine#2Send 7Thread:main @coroutine#2...*/ 所以，想要读取 Channel 当中的数据时，一定要使用 for 循环，或者是 channel.consumeEach {}，千万不要直接调用 channel.receive()。 补充：在某些特殊场景下，如果必须要自己来调用 channel.receive()，那么可以考虑使用 receiveCatching()，它可以防止异常发生。 #4. 为什么说 Channel 是“热”的？ Channel 其实就是用来传递“数据流”的。注意，这里的数据流，指的是多个数据组合形成的流。前面挂起函数、async 返回的数据，就像是水滴一样，而 Channel 则像是自来水管当中的水流一样。 在业界一直有一种说法：Channel 是“热”的。也是因为这句话，在 Kotlin 当中，也经常把 Channel 称为“热数据流”。 1234567891011121314151617181920212223// 代码段15fun main() = runBlocking { // 只发送不接受 val channel = produce&lt;Int&gt;(capacity = 10) { (1..3).forEach { send(it) println(&quot;Send $it&quot;) } } println(&quot;end&quot;)}/*输出结果：endSend 1Send 2Send 3程序结束*/ 在上面的代码中，定义了一个 Channel，管道的容量是 10，然后发送了 3 个数据。但在代码中并没有消费 Channel 当中的数据。所以，这种“不管有没有接收方，发送方都会工作”的模式，就是我们将其认定为“热”的原因。 这就有点像是一个热心的饭店服务员，不管你有没有提要求，服务员都会给你端茶送水，把茶水摆在你的饭桌上。当你想要喝水的时候，就可以直接从饭桌上拿了 （当你想要数据的时候，就可以直接从管道里取出来了）。又或者，Channel 的发送方，其实就像是“自来水厂”，不管你是不是要用水，自来水厂都会把水送到你家门口的管道当中来。这样当你想要用水的时候，打开水龙头就会马上有水了。 123456789101112131415161718192021// 代码段16fun main() = runBlocking { val channel = produce&lt;Int&gt;(capacity = 0) { (1..3).forEach { println(&quot;Before send $it&quot;) send(it) println(&quot;Send $it&quot;) } } println(&quot;end&quot;)}/*输出结果：endBefore send 1程序将无法退出*/ 当把 capacity 改成 0 以后，可以看到 Channel 的发送方仍然是会工作的，只是说，在它调用 send() 方法的时候，由于接收方还未就绪，且管道容量为 0，所以它会被挂起。所以，它仍然还是有在工作的。最直接的证据就是：这个程序将无法退出，一直运行下去。这个后果更加严重！ 但是，总的来说，不管接收方是否存在，Channel 的发送方一定会工作。对应的，你可以想象成：虽然你的饭桌已经没有空间了，但服务员还是端来了茶水站在了你旁边，只是没有把茶水放在你桌上，等饭桌有了空间，或者你想喝水了，你就能马上喝到。 至于自来水的那个场景，可以想象成，你家就在自来水厂的门口，你们之间的管道容量为 0，但这并不意味着自来水厂没有工作。 #5. Channel 的能力都是通过“组合”得来的 1234// 代码段17public interface Channel&lt;E&gt; : SendChannel&lt;E&gt;, ReceiveChannel&lt;E&gt; {} 如上 Channel 的源代码定义，Channel 本身只是一个接口。 而且，Channel 本身并没有什么方法和属性，它其实只是 SendChannel、ReceiveChannel 这两个接口的组合。也就是说，Channel 的所有能力，都是来自于 SendChannel、ReceiveChannel 这两个接口。 1234567891011121314151617181920212223242526272829303132333435363738394041// 代码段18public interface SendChannel&lt;in E&gt; public val isClosedForSend: Boolean public suspend fun send(element: E) // 1，select相关 public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt; // 2，非挂起函数的接收 public fun trySend(element: E): ChannelResult&lt;Unit&gt; public fun close(cause: Throwable? = null): Boolean public fun invokeOnClose(handler: (cause: Throwable?) -&gt; Unit)}public interface ReceiveChannel&lt;out E&gt; { public val isClosedForReceive: Boolean public val isEmpty: Boolean public suspend fun receive(): E public suspend fun receiveCatching(): ChannelResult&lt;E&gt; // 3，select相关 public val onReceive: SelectClause1&lt;E&gt; // 4，select相关 public val onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt; // 5，非挂起函数的接收 public fun tryReceive(): ChannelResult&lt;E&gt; public operator fun iterator(): ChannelIterator&lt;E&gt; public fun cancel(cause: CancellationException? = null)} 在上面的源码中，大部分的接口其实已经见过了。只有 5 个还没见过： 注释 1、3、4，它们是跟 select 相关的，后续会有介绍。 注释 2、5，是专门为非协程环境提供的 API，也就是说，当不在协程作用域的时候，也可以调用这两个方法来操作 Channel。不过大部分情况下，我们都应该优先使用挂起函数版本的 API。 所以，如果说 Channel 是一个管道，那么 SendChannel、ReceiveChannel 就是组成这个管道的两个零件。 其实对于 Channel 来说，也可以实现对外暴露不变性集合的思路 12345678910111213141516171819202122232425// 代码段19class ChannelModel { // 对外只提供读取功能 val channel: ReceiveChannel&lt;Int&gt; by ::_channel private val _channel: Channel&lt;Int&gt; = Channel() suspend fun init() { (1..3).forEach { _channel.send(it) } }}fun main() = runBlocking { val model = ChannelModel() launch { model.init() } model.channel.consumeEach { println(it) }} 也就是对于 Channel 来说，它的 send() 就相当于集合的写入 API，当想要做到“对写入封闭，对读取开放”的时候，就可以用之前学过的知识轻松做到。 而这一切，都得益于 Channel 的能力都是通过“组合”得来的。 #三、 Flow Flow，可以说是在 Kotlin 协程当中自成体系的知识点。Flow 极其强大、极其灵活。简单的异步场景，可以直接使用挂起函数、launch、async；至于复杂的异步场景，就可以使用 Flow。在很多技术领域，Flow 已经开始占领 RxJava 原本的领地，在 Android 领域，Flow 甚至还要取代原本 LiveData 的地位。 #1. Flow 就是“数据流” Flow 这个单词有“流”的意思，比如 Cash Flow 代表了“现金流”；Traffic Flow 代表了“车流”；Flow 在 Kotlin 协程当中，其实就是“数据流”的意思。因为 Flow 当中“流淌”的，都是数据。 上面的动图，可以简单描述 Flow 的行为模式，可以看到，Flow 和 Channel 不一样，Flow 并不是只有“发送”“接收”两个行为，它当中流淌的数据是可以在中途改变的。 Flow 的数据发送方，称之为“上游”；数据接收方称之为“下游”。跟现实生活中一样，上下游其实也是相对的概念。比如可以看到下面的图，对于中转站 2 来说，中转站 1 就相当于它的上游。 另外，也可以看到，在发送方、接收方的中间，是可以有多个“中转站”的。在这些中转站里，就可以对数据进行一些处理了。其实，Flow 这样的数据模型，在现实生活中也存在，比如说长江，它有发源地和下游，中间还有很多大坝、水电站，甚至还有一些污水净化厂。 #2. Flow 的创建 1234567891011121314151617181920212223// 代码段1fun main() = runBlocking { flow { // 上游，发源地 emit(1) // 挂起函数 emit(2) emit(3) emit(4) emit(5) }.filter { it &gt; 2 } // 中转站1 .map { it * 2 } // 中转站2 .take(2) // 中转站3 .collect{ // 下游 println(it) }}/*输出结果： 68*/ 结合着之前的图片来分析这段代码，可以轻易的分析出它的执行结果。因为 Flow 的这种链式调用的 API，本身就非常符合人的阅读习惯。 而且，Flow 写出来的代码非常清晰易懂，可以对照前面的示意图来看一下上面代码的执行逻辑： 简单分析一下上述代码： flow{}，是一个高阶函数，它的作用就是创建一个新的 Flow。在它的 Lambda 当中，可以使用 emit() 这个挂起函数往下游发送数据，这里的 emit 其实就是“发射”“发送”的意思。上游创建了一个“数据流”，同时也要负责发送数据。这跟现实生活也是一样的：长江里的水从上游产生，这是天经地义的。所以，对于上游而言，只需要创建 Flow，然后发送数据即可，其他的都交给中转站和下游。 filter{}、map{}、take(2)，它们是中间操作符，就像中转站一样，它们的作用就是对数据进行处理。Flow 最大的优势，就是它的操作符跟集合操作符高度一致。只要会用 List、Sequence，那就可以快速上手 Flow 的操作符，这中间几乎没有额外的学习成本。 collect{}，也被称为终止操作符或者末端操作符，它的作用其实只有一个：终止 Flow 数据流，并且接收这些数据。 除了使用 flow{} 创建 Flow 以外，还可以使用 flowOf() 这个函数。所以，从某种程度上讲，Flow 跟 Kotlin 的集合其实也是有一些相似之处的。 1234567891011121314151617181920212223242526// 代码段2fun main() = runBlocking { flowOf(1, 2, 3, 4, 5).filter { it &gt; 2 } .map { it * 2 } .take(2) .collect { println(it) } listOf(1, 2, 3, 4, 5).filter { it &gt; 2 } .map { it * 2 } .take(2) .forEach { println(it) }}/*输出结果6868*/ 从上面的代码中，可以看到 Flow API 与集合 API 之间的共性。listOf 创建 List，flowOf 创建 Flow。遍历 List，使用 forEach{}；遍历 Flow，使用 collect{}。 在某些场景下，甚至可以把 Flow 当做集合来使用，或者反过来，把集合当做 Flow 来用。 1234567891011121314151617181920212223242526272829303132// 代码段3fun main() = runBlocking { // Flow转List flowOf(1, 2, 3, 4, 5) .toList() .filter { it &gt; 2 } .map { it * 2 } .take(2) .forEach { println(it) } // List转Flow listOf(1, 2, 3, 4, 5) .asFlow() .filter { it &gt; 2 } .map { it * 2 } .take(2) .collect { println(it) }}/*输出结果6868*/ 在这段代码中，使用了 Flow.toList()、List.asFlow() 这两个扩展函数，让数据在 List、Flow 之间来回转换，而其中的代码甚至不需要做多少改变。 到这里，展现三种创建 Flow 的方式，下面以表格的形式总结一下。 现在知道 Flow 的 API 总体分为三个部分：上游、中间操作、下游。其中对于上游来说，一般有三种创建方式，这些也都需要好好掌握。那么接下来，重点看看中间操作符。 #3. Flow 中间操作符 中间操作符 （Intermediate Operators），除了之前提到的 map、filter、take 这种从集合那边“抄”来的操作符之外，还有一些特殊的操作符需要特别注意。这些操作符跟 Kotlin 集合 API 是没关系的，它们是专门为 Flow 设计的。 #1. Flow 生命周期 在 Flow 的中间操作符当中，onStart、onCompletion 这两个是比较特殊的。它们是以操作符的形式存在，但实际上的作用，是监听生命周期回调。 #1. onStart onStart，它的作用是注册一个监听事件：当 flow 启动以后，它就会被回调。具体可以看下面这个例子： 12345678910111213141516171819202122232425262728293031// 代码段4fun main() = runBlocking { flowOf(1, 2, 3, 4, 5) .filter { println(&quot;filter: $it&quot;) it &gt; 2 } .map { println(&quot;map: $it&quot;) it * 2 } .take(2) .onStart { println(&quot;onStart&quot;) } // 注意这里 .collect { println(&quot;collect: $it&quot;) }}/*输出结果onStartfilter: 1filter: 2filter: 3map: 3collect: 6filter: 4map: 4collect: 8*/ 可以看到，onStart 的执行顺序，并不是严格按照上下游来执行的。虽然 onStart 的位置是处于下游，而 filter、map、take 是上游，但 onStart 是最先执行的。因为它本质上是一个回调，不是一个数据处理的中间站。 相应的，filter、map、take 这类操作符，它们的执行顺序是跟它们的位置相关的。最终的执行结果，也会受到位置变化的影响。 123456789101112131415161718192021222324// 代码段5fun main() = runBlocking { flowOf(1, 2, 3, 4, 5) .take(2) // 注意这里 .filter { println(&quot;filter: $it&quot;) it &gt; 2 } .map { println(&quot;map: $it&quot;) it * 2 } .onStart { println(&quot;onStart&quot;) } .collect { println(&quot;collect: $it&quot;) }}/*输出结果onStartfilter: 1filter: 2*/ 可见，在以上代码中，将 take(2) 的位置挪到了上游的起始位置，这时候程序的执行结果就完全变了。 #2. onCompletion 理解了 onStart 以后，onCompletion 也就很好理解了。 12345678910111213141516171819202122232425// 代码段6fun main() = runBlocking { flowOf(1, 2, 3, 4, 5) .onCompletion { println(&quot;onCompletion&quot;) } // 注意这里 .filter { println(&quot;filter: $it&quot;) it &gt; 2 } .take(2) .collect { println(&quot;collect: $it&quot;) }}/*输出结果filter: 1filter: 2filter: 3collect: 3filter: 4collect: 4onCompletion*/ 和 onStart 类似，onCompletion 的执行顺序，跟它在 Flow 当中的位置无关。onCompletion 只会在 Flow 数据流执行完毕以后，才会回调。 Flow.onCompletion{} 和 Job.invokeOnCompletion{} 这个生命周期回调类似，onCompletion{} 在面对以下三种情况时都会进行回调： 情况 1，Flow 正常执行完毕； 情况 2，Flow 当中出现异常； 情况 3，Flow 被取消。 对于情况 1，已经在上面的代码中验证过了。接下来，我们看看后面两种情况： 12345678910111213141516171819202122232425262728293031323334353637// 代码段7fun main() = runBlocking { launch { flow { emit(1) emit(2) emit(3) }.onCompletion { println(&quot;onCompletion first: $it&quot;) } .collect { println(&quot;collect: $it&quot;) if (it == 2) { cancel() // 1 println(&quot;cancel&quot;) } } } delay(100L) flowOf(4, 5, 6) .onCompletion { println(&quot;onCompletion second: $it&quot;) } .collect { println(&quot;collect: $it&quot;) // 仅用于测试，生产环境不应该这么创建异常 throw IllegalStateException() // 2 }}/*collect: 1collect: 2cancelonCompletion first: JobCancellationException: // 3collect: 4onCompletion second: IllegalStateException // 4*/ 在上面的注释 1 当中，在 collect{} 里调用了 cancel 方法，这会取消掉整个 Flow，这时候，flow{} 当中剩下的代码将不会再被执行。最后，onCompletion 也会被调用，同时，注意 注释 3，这里还会带上对应的异常信息 JobCancellationException。 同样的，根据注释 2、4，也能分析出一样的结果。 而且从上面的代码里，也可以看到，当 Flow 当中发生异常以后，Flow 就会终止。 #2. Flow catch 处理异常 前面已经介绍过，Flow 主要有三个部分：上游、中间操作、下游。那么，Flow 当中的异常，也可以根据这个标准来进行分类，也就是异常发生的位置。对于发生在上游、中间操作这两个阶段的异常，可以直接使用 catch 这个操作符来进行捕获和进一步处理。如下所示： 12345678910111213141516171819202122// 代码段8fun main() = runBlocking { val flow = flow { emit(1) emit(2) throw IllegalStateException() emit(3) } flow.map { it * 2 } .catch { println(&quot;catch: $it&quot;) } // 注意这里 .collect { println(it) }}/*输出结果：24catch: java.lang.IllegalStateException*/ 所以，catch 这个操作符，其实就相当于平时使用的 try-catch 的意思。只是说，后者是用于普通的代码，而前者是用于 Flow 数据流的，两者的核心理念是一样的。不过，考虑到 Flow 具有上下游的特性，catch 这个操作符的作用是和它的位置强相关的。 catch 的作用域，仅限于 catch 的上游。换句话说，发生在 catch 上游的异常，才会被捕获，发生在 catch 下游的异常，则不会被捕获。为此，可以换一个写法： 123456789101112131415161718192021// 代码段9fun main() = runBlocking { val flow = flow { emit(1) emit(2) emit(3) } flow.map { it * 2 } .catch { println(&quot;catch: $it&quot;) } .filter { it / 0 &gt; 1} // 故意制造异常 .collect { println(it) }}/*输出结果Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 从上面代码的执行结果里，可以看到，catch 对于发生在它下游的异常是无能为力的。打个比方说，长江上面的污水处理厂，当然只能处理它上游的水，而对于发生在下游的污染，是无能为力的。 那么，发生在上游源头，还有发生在中间操作的异常，处理起来其实很容易，只需要留意 catch 的作用域即可。最后就是发生在下游末尾处的异常了。 对于发生在下游的异常，就不能用 catch 操作符了。最简单的办法，其实是使用 try-catch，把 collect{} 当中可能出现问题的代码包裹起来。比如像下面这样： 123456789101112131415// 代码段10fun main() = runBlocking { flowOf(4, 5, 6) .onCompletion { println(&quot;onCompletion second: $it&quot;) } .collect { try { println(&quot;collect: $it&quot;) throw IllegalStateException() } catch (e: Exception) { println(&quot;Catch $e&quot;) } }} 所以，针对 Flow 当中的异常处理，主要有两种手段：一个是 catch 操作符，它主要用于上游异常的捕获；而 try-catch 这种传统的方式，更多的是应用于下游异常的捕获。 #3. 切换 Context：flowOn、launchIn 前面介绍过，Flow 非常适合复杂的异步任务。在大部分的异步任务当中，都需要频繁切换工作的线程。对于耗时任务，需要线程池当中执行，对于 UI 任务，需要在主线程执行。而在 Flow 当中，借助 flowOn 这一个操作符，就可以灵活实现以上的需求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 代码段11fun main() = runBlocking { val flow = flow { logX(&quot;Start&quot;) emit(1) logX(&quot;Emit: 1&quot;) emit(2) logX(&quot;Emit: 2&quot;) emit(3) logX(&quot;Emit: 3&quot;) } flow.filter { logX(&quot;Filter: $it&quot;) it &gt; 2 } .flowOn(Dispatchers.IO) // 注意这里 .collect { logX(&quot;Collect $it&quot;) }}/*输出结果================================StartThread:DefaultDispatcher-worker-1 @coroutine#2================================================================Filter: 1Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Emit: 1Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Filter: 2Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Emit: 2Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Filter: 3Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Emit: 3Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Collect 3Thread:main @coroutine#1================================*/ flowOn 操作符也是和它的位置强相关的。它的作用域跟前面的 catch 类似：flowOn 仅限于它的上游。 在上面的代码中，flowOn 的上游，就是 flow{}、filter{} 当中的代码，所以，它们的代码全都运行在 DefaultDispatcher 这个线程池当中。只有 collect{} 当中的代码是运行在 main 线程当中的。对应的，如果挪动一下上面代码中 flowOn 的位置，会发现执行结果就会不一样，比如这样： 1234567891011121314// 代码段12flow.flowOn(Dispatchers.IO) // 注意这里 .filter { logX(&quot;Filter: $it&quot;) it &gt; 2 } .collect { logX(&quot;Collect $it&quot;) }/*输出结果：filter当中的代码会执行在main线程*/ 这里的代码执行结果，很容易就能推测出来，因为 flowOn 的作用域仅限于上游，所以它只会让 flow{} 当中的代码运行在 DefaultDispatcher 当中，剩下的代码则执行在 main 线程。 但是到这里，就会遇到一个类似 catch 的困境：如果想要指定 collect 当中的 Context，该怎么办呢？最简单的办法，就是用前面学过的：withContext{}。 1234567891011121314151617181920// 代码段13// 不推荐flow.flowOn(Dispatchers.IO) .filter { logX(&quot;Filter: $it&quot;) it &gt; 2 } .collect { withContext(mySingleDispatcher) { logX(&quot;Collect $it&quot;) } }/*输出结果：collect{}将运行在MySingleThreadfilter{}运行在mainflow{}运行在DefaultDispatcher*/ 在上面的代码中，直接在 collect{} 里使用了 withContext{}，所以它的执行就交给了 MySingleThread。不过，有的时候，想要改变除了 flowOn 以外所有代码的 Context。比如，希望 collect{}、filter{} 都运行在 MySingleThread。那么这时候，可以考虑使用 withContext{} 进一步扩大包裹的范围，就像下面这样： 123456789101112131415161718192021// 代码段14// 不推荐withContext(mySingleDispatcher) { flow.flowOn(Dispatchers.IO) .filter { logX(&quot;Filter: $it&quot;) it &gt; 2 } .collect{ logX(&quot;Collect $it&quot;) }}/*输出结果：collect{}将运行在MySingleThreadfilter{}运行在MySingleThreadflow{}运行在DefaultDispatcher*/ 不过，这种写法终归是有些丑陋，因此，Kotlin 官方还提供了另一个操作符，launchIn。 12345678910111213141516171819// 代码段15val scope = CoroutineScope(mySingleDispatcher)flow.flowOn(Dispatchers.IO) .filter { logX(&quot;Filter: $it&quot;) it &gt; 2 } .onEach { logX(&quot;onEach $it&quot;) } .launchIn(scope)/*输出结果：onEach{}将运行在MySingleThreadfilter{}运行在MySingleThreadflow{}运行在DefaultDispatcher*/ 可以看到，在这段代码中，不再直接使用 collect{}，而是借助了 onEach{} 来实现类似 collect{} 的功能。同时在最后使用了 launchIn(scope)，把它上游的代码都分发到指定的线程当中。 12345// 代码段16public fun &lt;T&gt; Flow&lt;T&gt;.launchIn(scope: CoroutineScope): Job = scope.launch { collect() // tail-call} 上面是 launchIn 的源代码，它的定义极其简单： 12345// 代码段16public fun &lt;T&gt; Flow&lt;T&gt;.launchIn(scope: CoroutineScope): Job = scope.launch { collect() // tail-call} 由此可见，launchIn 从严格意义来讲，应该算是一个下游的终止操作符，因为它本质上是调用了 collect()。 因此，上面的代码段 16，也会等价于下面的写法： 12345678910111213141516171819202122232425262728// 代码段17fun main() = runBlocking { val scope = CoroutineScope(mySingleDispatcher) val flow = flow { logX(&quot;Start&quot;) emit(1) logX(&quot;Emit: 1&quot;) emit(2) logX(&quot;Emit: 2&quot;) emit(3) logX(&quot;Emit: 3&quot;) } .flowOn(Dispatchers.IO) .filter { logX(&quot;Filter: $it&quot;) it &gt; 2 } .onEach { logX(&quot;onEach $it&quot;) } scope.launch { // 注意这里 flow.collect() } delay(100L)} 所以，总的来说，对于 Flow 当中的线程切换，可以使用 flowOn、launchIn、withContext，但其实，flowOn、launchIn 就已经可以满足需求了。另外，由于 Flow 当中直接使用 withContext 是很容易引发其他问题的，因此，withContext 在 Flow 当中是不被推荐的，即使要用，也应该谨慎再谨慎。，因为 Kotlin 不允许在 withContext 里 调用 emit() 是因为 emit() 默认不是线程安全的 #4. 下游：终止操作符 最后，就到了下游阶段，来看看终止操作符 （Terminal Operators） 的含义和使用。 这里的 Terminal，其实有终止、末尾、终点的意思。 在 Flow 当中，终止操作符的意思就是终止整个 Flow 流程的操作符。这里的“终止”，其实是跟前面的“中间”操作符对应的。 具体来说，就是在 filter 操作符的后面，还可以继续添加其他的操作符，比如说 map，因为 filter 本身就是一个“中间”操作符。但是，collect 操作符之后，无法继续使用 map 之类的操作，因为 collect 是一个“终止”操作符，代表 Flow 数据流的终止。 Flow 里面，最常见的终止操作符就是 collect。除此之外，还有一些从集合当中“抄”过来的操作符，也是 Flow 的终止操作符。比如 first()、single()、fold{}、reduce{}。 另外，将 Flow 转换成集合的时候，它本身也就意味着 Flow 数据流的终止。比如说，前面用过的 toList： 12345678910111213// 代码段18fun main() = runBlocking { // Flow转List flowOf(1, 2, 3, 4, 5) .toList() // 注意这里 .filter { it &gt; 2 } .map { it * 2 } .take(2) .forEach { println(it) }} 在上面的代码中，当调用了 toList() 以后，往后所有的操作符，都不再是 Flow 的 API 调用了，虽然它们的名字没有变，filter、map，这些都只是集合的 API。所以，严格意义上讲，toList 也算是一个终止操作符。 #5. 为什么说 Flow 是“冷”的？ 如果理解了之前所说的 Channel 为什么是“热”的，那么就一定可以理解 Flow 为什么是“冷”的。现在模仿前面的 Channel 代码，写一段 Flow 的代码，两相对比之下其实马上就能发现它们之间的差异。 12345678910111213141516171819202122232425262728293031// 代码段19fun main() = runBlocking { // 冷数据流 val flow = flow { (1..3).forEach { println(&quot;Before send $it&quot;) emit(it) println(&quot;Send $it&quot;) } } // 热数据流 val channel = produce&lt;Int&gt;(capacity = 0) { (1..3).forEach { println(&quot;Before send $it&quot;) send(it) println(&quot;Send $it&quot;) } } println(&quot;end&quot;)}/*输出结果：endBefore send 1// Flow 当中的代码并未执行*/ Channel 之所以被认为是“热”的原因，是因为不管有没有接收方，发送方都会工作。那么对应的，Flow 被认为是“冷”的原因，就是因为只有调用终止操作符之后，Flow 才会开始工作。 Flow 不仅是“冷”的，它还是“懒”的。为了暴露出它的这个特点，稍微改造一下代码段 1，然后加一些日志： 123456789101112131415161718192021222324252627282930313233343536// 代码段20fun main() = runBlocking { flow { println(&quot;emit: 3&quot;) emit(3) println(&quot;emit: 4&quot;) emit(4) println(&quot;emit: 5&quot;) emit(5) }.filter { println(&quot;filter: $it&quot;) it &gt; 2 }.map { println(&quot;map: $it&quot;) it * 2 }.collect { println(&quot;collect: $it&quot;) }}/*输出结果：emit: 3filter: 3map: 3collect: 6emit: 4filter: 4map: 4collect: 8emit: 5filter: 5map: 5collect: 10*/ 通过上面的运行结果，可以发现，Flow一次只会处理一条数据。虽然它也是 Flow“冷”的一种表现，但这个特性准确来说是“懒”。 结合“服务员端茶送水”的场景思考，Flow 不仅是一个“冷淡”的服务员，还是一个“懒惰”的服务员：明明饭桌上有 3 个人需要喝水，但服务员偏偏不一次性上 3 杯水，而是要这 3 个人，每个人都叫服务员一次，服务员才会一杯一杯地送 3 杯水过来。 对比 Channel 的思维模型来看的话： 提示：Flow 默认情况下是“懒惰”的，但也可以通过配置让它“勤快”起来。 #6. Flow 实践 Flow 非常适合复杂的异步任务场景。借助它的 flowOn、launchIn，可以写出非常灵活的代码。比如说，在 Android、Swing 之类的 UI 平台之上，可以这样写： 12345678910111213141516171819202122232425// 代码段21fun main() = runBlocking { fun loadData() = flow { repeat(3){ delay(100L) emit(it) logX(&quot;emit $it&quot;) } } // 模拟Android、Swing的UI val uiScope = CoroutineScope(mySingleDispatcher) loadData() .map { it * 2 } .flowOn(Dispatchers.IO) // 1，耗时任务 .onEach { logX(&quot;onEach $it&quot;) } .launchIn(uiScope) // 2，UI任务 delay(1000L)} 这段代码很容易理解，让耗时任务在 IO 线程池执行，更新 UI 则在 UI 线程。如果结合前面学过的 Flow 操作符，还可以设计出更加有意思的代码： 1234567891011121314151617181920212223242526272829303132// 代码段22fun main() = runBlocking { fun loadData() = flow { repeat(3) { delay(100L) emit(it) logX(&quot;emit $it&quot;) } } fun updateUI(it: Int) {} fun showLoading() { println(&quot;Show loading&quot;) } fun hideLoading() { println(&quot;Hide loading&quot;) } val uiScope = CoroutineScope(mySingleDispatcher) loadData() .onStart { showLoading() } // 显示加载弹窗 .map { it * 2 } .flowOn(Dispatchers.IO) .catch { throwable -&gt; println(throwable) hideLoading() // 隐藏加载弹窗 emit(-1) // 发生异常以后，指定默认值 } .onEach { updateUI(it) } // 更新UI界面 .onCompletion { hideLoading() } // 隐藏加载弹窗 .launchIn(uiScope) delay(10000L)} 在以上代码中，通过监听 onStart、onCompletion 的回调事件，就可以实现 Loading 弹窗的显示和隐藏。而对于出现异常的情况，也可以在 catch{} 当中调用 emit()，给出一个默认值，这样就可以有效防止 UI 界面出现空白。不得不说，以上代码的可读性是非常好的。 #四、 select select，在 Kotlin 1.6 当中，仍然是一个实验性的特性（Experimental）。但是， select 具有较强的实用性。select 可以说是软件架构当中非常重要的一个组件，在很多业务场景下，select 与 Deferred、Channel 结合以后，在大大提升程序的响应速度的同时，还可以提高程序的灵活性、扩展性。 #1. select 就是选择“更快的结果” 由于 select 的工作机制比较抽象，先来假设一个场景，看看 select 适用于什么样的场景。 客户端，想要查询一个商品的详情。目前有两个服务：缓存服务，速度快但信息可能是旧的；网络服务，速度慢但信息一定是最新的。 对于这个场景，如果实现其中的逻辑的话，能够实现类似这样的代码逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 代码段1fun main() = runBlocking { suspend fun getCacheInfo(productId: String): Product? { delay(100L) return Product(productId, 9.9) } suspend fun getNetworkInfo(productId: String): Product? { delay(200L) return Product(productId, 9.8) } fun updateUI(product: Product) { println(&quot;${product.productId}==${product.price}&quot;) } val startTime = System.currentTimeMillis() val productId = &quot;xxxId&quot; // 查询缓存 val cacheInfo = getCacheInfo(productId) if (cacheInfo != null) { updateUI(cacheInfo) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) } // 查询网络 val latestInfo = getNetworkInfo(productId) if (latestInfo != null) { updateUI(latestInfo) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) }}data class Product( val productId: String, val price: Double)/*输出结果xxxId==9.9Time cost: 112xxxId==9.8Time cost: 314*/ 考虑到缓存服务速度更快，先去查询缓存服务，如果查询到了信息，就会去更新 UI 界面。之后去查询网络服务，拿到最新的信息之后，我们再来更新 UI 界面。也就是这样： 第一步：查询缓存信息； 第二步：缓存服务返回信息，更新 UI； 第三步：查询网络服务； 第四步：网络服务返回信息，更新 UI。 这种做法的好处在于，用户可以第一时间看到商品的信息，虽然它暂时会展示旧的信息，但由于同时查询了网络服务，旧缓存信息也马上会被替代成新的信息。这样的做法，可以最大程度保证用户体验。 不过，以上整个流程都是建立在“缓存服务一定更快”的前提下的，万一缓存服务出了问题，它的速度变慢了，甚至是超时、无响应呢？ 这时候，你回过头来分析 代码段 1 的话，你就会发现：程序执行流程会卡在第二步，迟迟无法进行第三步。具体来说，是因为 getCacheInfo() 它是一个挂起函数，只有这个程序执行成功以后，才可以继续执行后面的任务。可以把 getCacheInfo() 当中的 delay 时间修改成 2000 毫秒，去验证一下。 12345678/*执行结果：xxxId==9.9Time cost: 2013xxxId==9.8Time cost: 2214*/ 面对这样的场景，其实需要一个可以灵活选择的语法：“两个挂起函数同时执行，谁返回的速度更快，就选择谁”。这其实就是 select 的典型使用场景。 #2. select 和 async 上面的这个场景，可以用 async 搭配 select 来使用。async 可以实现并发，select 则可以选择最快的结果。 12345678910111213141516171819202122232425262728293031// 代码段2fun main() = runBlocking { val startTime = System.currentTimeMillis() val productId = &quot;xxxId&quot; // 1，注意这里 // ↓ val product = select&lt;Product?&gt; { // 2，注意这里 async { getCacheInfo(productId) } .onAwait { // 3，注意这里 it } // 4，注意这里 async { getNetworkInfo(productId) } .onAwait { // 5，注意这里 it } } if (product != null) { updateUI(product) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) }}/*输出结果xxxId==9.9Time cost: 127*/ 从上面的执行结果，可以看到，由于缓存的服务更快，所以，select 确实选择了更快的那个结果。代码中一共有四个注释： 注释 1，使用 select 这个高阶函数包裹了两次查询的服务，同时传入了泛型参数 Product，代表要选择的数据类型是 Product。 注释 2，4 中，使用了 async 包裹了 getCacheInfo()、getNetworkInfo() 这两个挂起函数，这是为了让这两个查询实现并发执行。 注释 3，5 中，使用 onAwait{} 将执行结果传给了 select{}，而 select 才能进一步将数据返回给 product 局部变量。注意，这里使用的 onAwait{}，而不是 await()。 现在，假设，缓存服务出现了问题，需要 2000 毫秒才能返回： 12345678910111213// 代码段3suspend fun getCacheInfo(productId: String): Product? { // 注意这里 delay(2000L) return Product(productId, 9.9)}/*输出结果xxxId==9.8Time cost: 226*/ 这时候，通过执行结果，可以发现，select 可以在缓存服务出现问题的时候，灵活选择网络服务的结果。从而避免用户等待太长的时间，得到糟糕的体验。 不过，“代码段 1”和“代码段 2”其实并不是完全等价的。因为在代码段 2 当中，用户大概率是会展示旧的缓存信息。但实际场景下，是需要进一步更新最新信息的。其实，在代码段 2 的基础上，也可以轻松实现，只是说，需要为 Product 这个数据类增加一个标记。 12345678// 代码段4data class Product( val productId: String, val price: Double, // 是不是缓存信息 val isCache: Boolean = false) 然后对 代码段 2 进行一些改造： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 代码段5fun main() = runBlocking { suspend fun getCacheInfo(productId: String): Product? { delay(100L) return Product(productId, 9.9) } suspend fun getNetworkInfo(productId: String): Product? { delay(200L) return Product(productId, 9.8) } fun updateUI(product: Product) { println(&quot;${product.productId}==${product.price}&quot;) } val startTime = System.currentTimeMillis() val productId = &quot;xxxId&quot; // 1，缓存和网络，并发执行 val cacheDeferred = async { getCacheInfo(productId) } val latestDeferred = async { getNetworkInfo(productId) } // 2，在缓存和网络中间，选择最快的结果 val product = select&lt;Product?&gt; { cacheDeferred.onAwait { it?.copy(isCache = true) } latestDeferred.onAwait { it?.copy(isCache = false) } } // 3，更新UI if (product != null) { updateUI(product) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) } // 4，如果当前结果是缓存，那么再取最新的网络服务结果 if (product != null &amp;&amp; product.isCache) { val latest = latestDeferred.await()?: return@runBlocking updateUI(latest) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) }}/*输出结果：xxxId==9.9Time cost: 120xxxId==9.8Time cost: 220*/ 说明： 对比代码段 1 和代码段 5 的执行结果，会发现代码段 5 的总体耗时更短。 另外在上面的代码中，还有几个注释： 首先看注释 1，将 getCacheInfo()、getNetworkInfo() 提取到了 select 的外部，让它们通过 async 并发执行。 注释 2，仍然是通过 select 选择最快的那个结果，接着在注释 3 这里第一时间更新 UI 界面。 注释 4，判断当前的 product 是不是来自于缓存，如果是的话，还需要用最新的信息更新 UI。 然后在这里，假设缓存服务出现了问题，需要 2000 毫秒才能返回： 12345678910111213// 代码段6suspend fun getCacheInfo(productId: String): Product? { // 注意这里 delay(2000L) return Product(productId, 9.9)}/*输出结果xxxId==9.8Time cost: 224*/ 可以看到，代码仍然可以正常执行。其实，当前的这个例子很简单，不使用 select 同样也可以实现。不过，select 这样的代码模式的优势在于，扩展性非常好。 下面，可以再来假设一下，现在有了多个缓存服务。 对于这个问题，其实只需要稍微改动一下代码段 3 就行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 代码段7fun main() = runBlocking { val startTime = System.currentTimeMillis() val productId = &quot;xxxId&quot; val cacheDeferred = async { getCacheInfo(productId) } // 变化在这里 val cacheDeferred2 = async { getCacheInfo2(productId) } val latestDeferred = async { getNetworkInfo(productId) } val product = select&lt;Product?&gt; { cacheDeferred.onAwait { it?.copy(isCache = true) } // 变化在这里 cacheDeferred2.onAwait { it?.copy(isCache = true) } latestDeferred.onAwait { it?.copy(isCache = false) } } if (product != null) { updateUI(product) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) } if (product != null &amp;&amp; product.isCache) { val latest = latestDeferred.await() ?: return@runBlocking updateUI(latest) println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;) }}/*输出结果xxxId==9.9Time cost: 125xxxId==9.8Time cost: 232*/ 可以看到，当增加一个缓存服务进来的时候，代码只需要做很小的改动，就可以实现。所以，总的来说，对比传统的挂起函数串行的执行流程，select 这样的代码模式，不仅可以提升程序的整体响应速度，还可以大大提升程序的灵活性、扩展性。 #3. select 和 Channel 在前面的内容提到过，在协程中返回一个内容的时候，可以使用挂起函数、async，但如果要返回多个结果的话，就要用 Channel 和 Flow。那么，来看看 select 和 Channel 的搭配使用。 这里，有两个管道，channel1、channel2，它们里面的内容分别是 1、2、3；a、b、c，通过 select，将它们当中的数据收集出来并打印。 对于这个问题，如果不借助 select 来实现的话，其实可以大致做到，但结果不会令人满意。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 代码段8fun main() = runBlocking { val startTime = System.currentTimeMillis() val channel1 = produce { send(1) delay(200L) send(2) delay(200L) send(3) delay(150L) } val channel2 = produce { delay(100L) send(&quot;a&quot;) delay(200L) send(&quot;b&quot;) delay(200L) send(&quot;c&quot;) } channel1.consumeEach { println(it) } channel2.consumeEach { println(it) } println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;)}/*输出结果123abcTime cost: 989*/ 可以看到，通过普通的方式，代码是串行执行的，执行结果并不符合预期。channel1 执行完毕以后，才会执行 channel2，程序总体的执行时间，也是两者的总和。最关键的是，如果 channel1 当中如果迟迟没有数据的话，程序会一直卡着不执行。 当然，以上的问题，通过其他方式也可以解决，但最方便的解决方案，还是 select。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 代码段9fun main() = runBlocking { val startTime = System.currentTimeMillis() val channel1 = produce { send(&quot;1&quot;) delay(200L) send(&quot;2&quot;) delay(200L) send(&quot;3&quot;) delay(150L) } val channel2 = produce { delay(100L) send(&quot;a&quot;) delay(200L) send(&quot;b&quot;) delay(200L) send(&quot;c&quot;) } suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; { // 1， 选择channel1 channel1.onReceive{ it.also { println(it) } } // 2， 选择channel1 channel2.onReceive{ it.also { println(it) } } } repeat(6){// 3， 选择6次结果 selectChannel(channel1, channel2) } println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;)}/*输出结果1a2b3cTime cost: 540*/ 从程序的执行结果中，可以看到，程序的输出结果符合预期，同时它的执行耗时，也比代码段 8 要少很多。上面的代码中有几个注释： 注释 1 和 2，onReceive{} 是 Channel 在 select 当中的语法，当 Channel 当中有数据以后，它就会被回调，通过这个 Lambda，可以将结果传出去。 注释 3，这里执行了 6 次 select，目的是要把两个管道中的所有数据都消耗掉。管道 1 有 3 个数据、管道 2 有 3 个数据，所以加起来，需要选择 6 次。这时候，假设 channel1 出了问题，它不再产生数据了，看看程序会怎么样执行。 123456789101112131415161718192021222324252627282930313233343536373839404142// 代码段10fun main() = runBlocking { val startTime = System.currentTimeMillis() val channel1 = produce&lt;String&gt; { // 变化在这里 delay(15000L) } val channel2 = produce { delay(100L) send(&quot;a&quot;) delay(200L) send(&quot;b&quot;) delay(200L) send(&quot;c&quot;) } suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; { channel1.onReceive{ it.also { println(it) } } channel2.onReceive{ it.also { println(it) } } } // 变化在这里 repeat(3){ selectChannel(channel1, channel2) } println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;)}/*输出结果abcTime cost: 533*/ 在上面的代码中，将 channel1 当中的 send() 都删除了，并且，repeat() 的次数变成了 3 次，因为管道里只有三个数据了。 这时候，会发现，select 也是可以正常执行的。不过，有时候可能并不清楚每个 Channel 当中有多少个数据，比如说，这里如果还是写 repeat(6) 的话，程序就会出问题了。 1234567891011// 代码段11// 仅改动这里repeat(6){ selectChannel(channel1, channel2)}/*崩溃：Exception in thread &quot;main&quot; ClosedReceiveChannelException: Channel was closed*/ 由于 channel2 当中只有 3 个数据，它发送完数据以后就会被关闭，而 select 是会被调用 6 次的，所以就会触发上面的 ClosedReceiveChannelException 异常。 在前面，学过 receiveCatching() 这个方法，它可以封装 Channel 的结果，防止出现 ClosedReceiveChannelException。类似的，当 Channel 与 select 配合的时候，可以使用 onReceiveCatching{} 这个高阶函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 代码段12fun main() = runBlocking { val startTime = System.currentTimeMillis() val channel1 = produce&lt;String&gt; { delay(15000L) } val channel2 = produce { delay(100L) send(&quot;a&quot;) delay(200L) send(&quot;b&quot;) delay(200L) send(&quot;c&quot;) } suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; { channel1.onReceiveCatching { it.getOrNull() ?: &quot;channel1 is closed!&quot; } channel2.onReceiveCatching { it.getOrNull() ?: &quot;channel2 is closed!&quot; } } repeat(6) { val result = selectChannel(channel1, channel2) println(result) } println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;)}/*输出结果abcchannel2 is closed!channel2 is closed!channel2 is closed!Time cost: 541程序不会立即退出*/ 这时候，即使不知道管道里有多少个数据，也不用担心崩溃的问题。在 onReceiveCatching{} 这个高阶函数当中，可以使用 it.getOrNull() 来获取管道里的数据，如果获取的结果是 null，就代表管道已经被关闭了。 不过，上面的代码仍然还有一个问题，那就是，当得到所有结果以后，程序不会立即退出，因为 channel1 一直在 delay()。这时候，当完成 6 次 repeat() 调用以后，将 channel1、channel2 取消即可。 123456789101112131415161718192021222324252627282930313233343536373839// 代码段13fun main() = runBlocking { val startTime = System.currentTimeMillis() val channel1 = produce&lt;String&gt; { delay(15000L) } val channel2 = produce { delay(100L) send(&quot;a&quot;) delay(200L) send(&quot;b&quot;) delay(200L) send(&quot;c&quot;) } suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; { channel1.onReceiveCatching { it.getOrNull() ?: &quot;channel1 is closed!&quot; } channel2.onReceiveCatching { it.getOrNull() ?: &quot;channel2 is closed!&quot; } } repeat(6) { val result = selectChannel(channel1, channel2) println(result) } // 变化在这里 channel1.cancel() channel2.cancel() println(&quot;Time cost: ${System.currentTimeMillis() - startTime}&quot;)} 这时候，对比一下代码段 13 和代码段 10 的话，就会发现程序的执行效率提升的同时，扩展性和灵活性也更好了。 提示：这种将多路数据以非阻塞的方式合并成一路数据的模式，在其他领域也有广泛的应用，比如说操作系统、Java NIO（Non-blocking I/O）等等。 #5. select 实战 当 Deferred、Channel 与 select 配合的时候，它们原本的 API 会多一个 on 前缀。 1234567891011121314151617181920212223242526public interface Deferred : CoroutineContext.Element { public suspend fun join() public suspend fun await(): T // select相关 public val onJoin: SelectClause0 public val onAwait: SelectClause1&lt;T&gt;}public interface SendChannel&lt;in E&gt; public suspend fun send(element: E) // select相关 public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;}public interface ReceiveChannel&lt;out E&gt; { public suspend fun receive(): E public suspend fun receiveCatching(): ChannelResult&lt;E&gt; // select相关 public val onReceive: SelectClause1&lt;E&gt; public val onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;} 所以，只要记住了 Deferred、Channel 的 API，是不需要额外记忆 select 的 API 的，只需要在原本的 API 的前面加上一个 on 就行了。 另外要注意，当 select 与 Deferred 结合使用的时候，当并行的 Deferred 比较多的时候，往往需要在得到一个最快的结果以后，去取消其他的 Deferred。比如说，对于 Deferred1、Deferred2、Deferred3、Deferred4、Deferred5，其中 Deferred2 返回的结果最快，这时候，往往会希望取消其他的 Deferred，以节省资源。那么在这个时候，可以使用类似这样的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152fun main() = runBlocking { suspend fun &lt;T&gt; fastest(vararg deferreds: Deferred&lt;T&gt;): T = select { fun cancelAll() = deferreds.forEach { it.cancel() } for (deferred in deferreds) { deferred.onAwait { cancelAll() it } } } val deferred1 = async { delay(100L) println(&quot;done1&quot;) // 没机会执行 &quot;result1&quot; } val deferred2 = async { delay(50L) println(&quot;done2&quot;) &quot;result2&quot; } val deferred3 = async { delay(10000L) println(&quot;done3&quot;) // 没机会执行 &quot;result3&quot; } val deferred4 = async { delay(2000L) println(&quot;done4&quot;) // 没机会执行 &quot;result4&quot; } val deferred5 = async { delay(14000L) println(&quot;done5&quot;) // 没机会执行 &quot;result5&quot; } val result = fastest(deferred1, deferred2, deferred3, deferred4, deferred5) println(result)}/*输出结果done2result2*/ 所以，借助这样的方式，不仅可以通过 async 并发执行协程，也可以借助 select 得到最快的结果，而且，还可以避免不必要的资源浪费。","link":"/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/"},{"title":"kotlin学习系列十：协程二","text":"一、前言 二、 Job 1. Job 生命周期 三、 Deffered 四、Job 与结构化并发 五、CoroutineContext 1. Context 的应用 1. launch() 2. withContext() 3. runBlocking() 4. 内置Dispatcher 2. 万物皆有Context 1. CoroutineScope 2. Job 和 Dispatcher 3. CoroutineName 4. CoroutineExceptionHandler 六、实战：网络请求框架 KtHttp 1. 以Java思维简单实现网络请求框架 2. 函数式思维重构KtHttp 3. 支持异步请求（Call）的 KtHttp 1. 创建 Callback 2. 创建 KtCall 类 3. 创建 ApiService 及修改 invoke 方法 4. 测试代码 5. 同时支持同步和异步 4. 支持挂起函数的 KtHttp 1. 解法一：扩展 KtCall 1. 扩展出 await 函数 2. 实现 await 函数 3. suspendCoroutine{} 不支持取消 4. 使用 suspendCancellableCoroutine{} 实现 await 函数 七、参考文章 #一、前言 本文主要讲述Kotlin 协程中的 Job、Deferred、CoroutineContext以及实现一个简单网络框架 KtHttp 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程一 kotlin学习系列十一：协程三 #二、 Job Job 其实就是协程的句柄。从某种程度上讲，当我们用 launch 和 async 创建一个协程以后，同时也会创建一个对应的 Job 对象。另外，Job 也是我们理解协程生命周期、结构化并发的关键知识点。通过 Job 暴露的 API，我们还可以让不同的协程之间互相配合，从而实现更加复杂的功能。 #1. Job 生命周期 上一章中学习 launch、async 的时候，了解到它们两个返回值类型分别是 Job 和 Deferred。 12345// 代码段1public interface Deferred&lt;out T&gt; : Job { public suspend fun await(): T} Deferred 的源代码如上所示，它其实也是继承自 Job 的。对应的，它只是多了一个泛型参数 T，还多了一个返回类型为 T 的 await() 方法。所以，不管是 launch 还是 async，它们本质上都会返回一个 Job 对象。 通过 Job 对象，主要可以做两件事情： 使用 Job 监测协程的生命周期状态。 使用 Job 操控协程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 代码段2fun main() = runBlocking { val job = launch { delay(1000L) } job.log() // ① job.cancel() // ② job.log() // ③ delay(1500L)}/** * 打印Job的状态信息 */fun Job.log() { logX(&quot;&quot;&quot; isActive = $isActive isCancelled = $isCancelled isCompleted = $isCompleted &quot;&quot;&quot;.trimIndent())}/** * 控制台输出带协程信息的log */fun logX(any: Any?) { println(&quot;&quot;&quot;================================$anyThread:${Thread.currentThread().name}================================&quot;&quot;&quot;.trimIndent())}/*输出结果：================================isActive = trueisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================isActive = falseisCancelled = trueisCompleted = falseThread:main @coroutine#1================================*/ 说明： 在上面这段代码当中，定义了一个 Job.log() 扩展函数，它的作用就是打印 Job 的生命周期状态。通过调用这个函数，就可以知道对应的协程处于什么状态。 注释①, 的调用结果，“isActive = true”，这代表了当前的协程处于活跃状态。 注释②，调用了 job.cancel() 以后，协程任务就会被取消。因此，注释③ 处的调用结果就会变成“isCancelled = true”，这代表了协程任务处于取消状态。 由此可以知道： job.log()，其实就是在监测协程； job.cancel()，其实就是在操控协程 而除了 job.cancel() 可以操控协程以外，还可以使用 job.start() 来启动协程任务，一般来说，它都是搭配“CoroutineStart.LAZY”来使用的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 代码段3fun main() = runBlocking { // 变化在这里 // ↓ val job = launch(start = CoroutineStart.LAZY) { logX(&quot;Coroutine start!&quot;) delay(1000L) } delay(500L) job.log() job.start() // 变化在这里 job.log() delay(500L) job.cancel() delay(500L) job.log() delay(2000L) logX(&quot;Process end!&quot;)}/*输出结果：================================isActive = falseisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================isActive = trueisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================Coroutine start!Thread:main @coroutine#2================================================================isActive = falseisCancelled = trueisCompleted = trueThread:main @coroutine#1================================================================Process end!Thread:main @coroutine#1================================*/ 说明： 根据以上代码的运行结果，可以发现，当使用 CoroutineStart.LAZY 作为启动模式的时候，协程任务被 launch 以后，并不会立即执行，即使我们在代码中 delay 了 500 毫秒，launch 内部的&quot;Coroutine start!&quot;也仍然没有输出。这是典型的懒加载行为模式。 当在外部调用了 job.start() 以后，job 的状态才变成了 Active 活跃。而当调用了 cancel 以后，job 的状态才变成 isCancelled、isCompleted。 由此，整理出 Job 整个的生命周期如下图： 从图中，可以看到，对于协程的 Job 来说，它有两种初始状态，如果 Job 是以懒加载的方式创建的，那么它的初始状态将会是 New；而如果一个协程是以非懒加载的方式创建的，那么它的初始状态就会是 Active。 仔细看第四段输出结果，会发现，当调用 cancel 以后，会出现一个奇怪的现象：isCancelled = true、isCompleted = true。也就是说，当协程任务被取消以后，isCancelled 和 isCompleted 同时都是 true。但这跟上面的流程图并不一致！这是为什么呢？这是因为，协程认为由于某种原因取消的协程，也仍然是一种“结束状态”，这其实也就对应了流程图中的“最终状态”。 换句话说，流程图当中的 New、Active、Completing、Cancelling、Completed、Cancelled 这些状态，都是 Job 内部私有的状态。而 Job 对外暴露出的 isCompleted 并不是与其一一对应的。Job 内部私有的 Completed、Cancelled 状态，都会认为是外部的 isCompleted 状态。 测试了协程 cancel() 方法以后，再来看看协程正常执行完毕的情况： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 代码段4fun main() = runBlocking { val job = launch(start = CoroutineStart.LAZY) { logX(&quot;Coroutine start!&quot;) delay(1000L) } delay(500L) job.log() job.start() job.log() delay(1100L) // ① job.log() delay(2000L) // ② logX(&quot;Process end!&quot;)}================================isActive = falseisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================isActive = trueisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================Coroutine start!Thread:main @coroutine#2================================================================isActive = falseisCancelled = falseisCompleted = trueThread:main @coroutine#1================================================================Process end!Thread:main @coroutine#1================================ 说明： 在这段代码中，可以清晰地看到，协程的状态从 Start 到 Active，最后到 Completed 注释① 处，为了等待 job 任务执行完毕，在外面等待了 1100 毫秒，这种方式其实并不好，因为大部分情况下，很难从外部判断协程需要多长的时间才能结束（比如网络请求任务、下载任务）。 注释② 处，使用 delay(2000L) 的方式，希望在 job 执行完毕以后输出“Process end!”，这样的代码，也是建立在“知道 Job 只需要 1000 毫秒就能执行完毕”的前提。 如果协程内部的 delay 远大于外部的 delay，以上的运行结果就会完全不一样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 代码段5fun main() = runBlocking { val job = launch(start = CoroutineStart.LAZY) { logX(&quot;Coroutine start!&quot;) delay(4000L) // 变化在这里 } delay(500L) job.log() job.start() job.log() delay(1100L) job.log() delay(2000L) logX(&quot;Process end!&quot;)}/*输出结果：================================isActive = falseisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================isActive = trueisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================Coroutine start!Thread:main @coroutine#2================================================================isActive = trueisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================Process end!Thread:main @coroutine#1================================到这里，job仍然还在delay，整个程序并没有完全退出。*/ 说明： 当将 job 内部的 delay 改为 4000 毫秒以后，执行结果就完全不一样了，无法监测到 isCompleted 状态。 如果实际运行了上面的代码，会发现“Process end!”输出以后，程序并没有立即结束，而是等待了大约 900 毫秒才结束，这是因为 runBlocking 会一直阻塞，等到 job 任务执行完毕以后才真正退出。 为了更加灵活地等待和监听协程的结束事件，可以用 job.join() 以及 invokeOnCompletion {} 来优化上面的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 代码段6fun main() = runBlocking { suspend fun download() { // 模拟下载任务 val time = (Random.nextDouble() * 1000).toLong() logX(&quot;Delay time: = $time&quot;) delay(time) } val job = launch(start = CoroutineStart.LAZY) { logX(&quot;Coroutine start!&quot;) download() logX(&quot;Coroutine end!&quot;) } delay(500L) job.log() job.start() job.log() job.invokeOnCompletion { job.log() // 协程结束以后就会调用这里的代码 } job.join() // 等待协程执行完毕 logX(&quot;Process end!&quot;)}/*运行结果：================================isActive = falseisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================isActive = trueisCancelled = falseisCompleted = falseThread:main @coroutine#1================================================================Coroutine start!Thread:main @coroutine#2================================================================Delay time: = 252Thread:main @coroutine#2================================================================Coroutine end!Thread:main @coroutine#2================================================================isActive = falseisCancelled = falseisCompleted = trueThread:main @coroutine#2================================================================Process end!Thread:main @coroutine#1================================*/ 说明： invokeOnCompletion {} 的作用，其实就是监听协程结束的事件。需要注意的是，它和前面的 isCompleted 类似，如果 job 被取消了，invokeOnCompletion {} 这个回调仍然会被调用。 job.join() 其实是一个“挂起函数”，它的作用就是：挂起当前的程序执行流程，等待 job 当中的协程任务执行完毕，然后再恢复当前的程序执行流程。 至此，就对 Job 的两种使用场景都已经有了充分认识了。大概看看 Job 的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 代码段7public interface Job : CoroutineContext.Element { // 省略部分代码 // ------------ 状态查询API ------------ public val isActive: Boolean public val isCompleted: Boolean public val isCancelled: Boolean public fun getCancellationException(): CancellationException // ------------ 操控状态API ------------ public fun start(): Boolean public fun cancel(cause: CancellationException? = null) public fun cancel(): Unit = cancel(null) public fun cancel(cause: Throwable? = null): Boolean // ------------ 等待状态API ------------ public suspend fun join() public val onJoin: SelectClause0 // ------------ 完成状态回调API ------------ public fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle public fun invokeOnCompletion( onCancelling: Boolean = false, invokeImmediately: Boolean = true, handler: CompletionHandler): DisposableHandle} 说明： Kotlin 官方对 Job 的 API 做了更加详细的划分，但实际上来说都属于“监测状态”“操控状态”这两个大的范畴。 如何理解 Job 是协程的句柄”这句话呢？可以从现实生活中找例子，来建立大致的思维模型。Job 和协程的关系，就有点像“遥控器和空调的关系”。 空调遥控器可以监测空调的运行状态；Job 也可以监测协程的运行状态； 空调遥控器可以操控空调的运行状态，Job 也可以简单操控协程的运行状态。 #三、 Deffered Deferred 其实就是继承自 Job 的一个接口，它并没有在 Job 的基础上扩展出很多其他功能，最重要的就是 await() 这个方法。 12345678910111213141516171819202122232425262728293031// 代码段8fun main() = runBlocking { val deferred = async { logX(&quot;Coroutine start!&quot;) delay(1000L) logX(&quot;Coroutine end!&quot;) &quot;Coroutine result!&quot; } val result = deferred.await() println(&quot;Result = $result&quot;) logX(&quot;Process end!&quot;)}/*输出结果：================================Coroutine start!Thread:main @coroutine#2================================================================Coroutine end!Thread:main @coroutine#2================================Result = Coroutine result!================================Process end!Thread:main @coroutine#1================================*/ 从代码的执行结果中，可以发现，deferred.await() 这个方法，不仅可以获取协程的执行结果，它还会阻塞当前协程的执行流程，直到协程任务执行完毕。在这一点的行为上，await() 和 join() 是类似的。 12345678// 代码段9public interface Deferred&lt;out T&gt; : Job {// 注意这里// ↓ public suspend fun await(): T} 根据await()的函数签名，可以看到，await() 这个方法其实是一个挂起函数，这也就意味着，这个方法拥有挂起和恢复的能力。如果当前的 Deferred 任务还没执行完毕，那么，await() 就会挂起当前的协程执行流程，等待 Deferred 任务执行完毕，再恢复执行后面剩下的代码。 说明： 由上图所得 await() 后面的代码，虽然看起来是阻塞了，但它只是执行流程被挂起和恢复的一种表现。 上图也描述了之前 job.join() 的行为模式，在协程执行完毕之前，后面的协程代码都被暂时挂起了，等到协程执行完毕，才有机会继续执行。 总的来说，Deferred 只是比 Job 多了一个 await() 挂起函数而已，通过这个挂起函数，可以等待协程执行完毕的同时，还可以直接拿到协程的执行结果。 #四、Job 与结构化并发 协程的优势在于结构化并发。Kotlin 协程的结构化并发，它的重要性，是仅次于“挂起函数”的。也就是说，“结构化并发”是 Kotlin 协程的第二大优势。 简单来说，“结构化并发”就是：带有结构和层级的并发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 代码段10fun main() = runBlocking { val parentJob: Job var job1: Job? = null var job2: Job? = null var job3: Job? = null parentJob = launch { job1 = launch { delay(1000L) } job2 = launch { delay(3000L) } job3 = launch { delay(5000L) } } delay(500L) parentJob.children.forEachIndexed { index, job -&gt; when (index) { 0 -&gt; println(&quot;job1 === job is ${job1 === job}&quot;) 1 -&gt; println(&quot;job2 === job is ${job2 === job}&quot;) 2 -&gt; println(&quot;job3 === job is ${job3 === job}&quot;) } } parentJob.join() // 这里会挂起大约5秒钟 logX(&quot;Process end!&quot;)}/*输出结果：job1 === job is truejob2 === job is truejob3 === job is true// 等待大约5秒钟================================Process end!Thread:main @coroutine#1================================*/ 说明： 在上面的代码中，一共定义了 4 个 Job，parentJob 是最外层的 launch 返回的对象，而在这个 launch 的内部，还额外嵌套了三个 launch，它们的 Job 对象分别赋值给了 job1、job2、job3。 对“parentJob.children”进行了遍历，然后逐一对比了它们与 job1、job2、job3 的引用是否相等 （“===”代表了引用相等，即是否是同一个对象）。 根据打印结果，可以确定，job1、job2、job3 其实就是 parentJob 的 children。也就是说，使用 launch 创建出来的协程，是存在父子关系的。 Job 的源代码中还有两个 API 是用来描述父子关系的。 12345678910111213// 代码段11public interface Job : CoroutineContext.Element { // 省略部分代码 // ------------ parent-child ------------ public val children: Sequence&lt;Job&gt; @InternalCoroutinesApi public fun attachChild(child: ChildJob): ChildHandle} 可以看到，每个 Job 对象，都会有一个 children 属性，它的类型是 Sequence，它是一个惰性的集合，可以对它进行遍历。而 attachChild() 则是一个协程内部的 API，用于绑定 ChildJob 。用一个简单的结构图来描述上面 4 个 Job 之间的关系： 那么，这样的父子关系到底意味着什么呢？“parentJob.join()”这行代码会被挂起大约 5 秒钟。注意调用的是 parentJob 的 join() 方法，但是，它会等待其内部的 job1、job2、job3 全部执行完毕，才会恢复执行。换句话说，只有当 job1、job2、job3 全部执行完毕，parentJob 才算是执行完毕了。 所以说：结构化并发就是带有结构和层级的并发。 实际上，协程不像之前学过的线程，线程之间是不存在父子关系的，但协程之间是会存在父子关系的。不过协程的这种父子关系并不明显，如果不深入 Job 的源码，就无法意识到这一点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 代码段12fun main() = runBlocking { val parentJob: Job var job1: Job? = null var job2: Job? = null var job3: Job? = null parentJob = launch { job1 = launch { logX(&quot;Job1 start!&quot;) delay(1000L) logX(&quot;Job1 done!&quot;) // ①，不会执行 } job2 = launch { logX(&quot;Job2 start!&quot;) delay(3000L) logX(&quot;Job2 done!&quot;) // ②，不会执行 } job3 = launch { logX(&quot;Job3 start!&quot;) delay(5000L) logX(&quot;Job3 done!&quot;)// ③，不会执行 } } delay(500L) parentJob.children.forEachIndexed { index, job -&gt; when (index) { 0 -&gt; println(&quot;job1 === job is ${job1 === job}&quot;) 1 -&gt; println(&quot;job2 === job is ${job2 === job}&quot;) 2 -&gt; println(&quot;job3 === job is ${job3 === job}&quot;) } } parentJob.cancel() // 变化在这里 logX(&quot;Process end!&quot;)}/*输出结果：================================Job1 start!Thread:main @coroutine#3================================================================Job2 start!Thread:main @coroutine#4================================================================Job3 start!Thread:main @coroutine#5================================job1 === job is truejob2 === job is truejob3 === job is true================================// 这里不会等待5秒钟Process end!Thread:main @coroutine#1================================*/ 说明： 这段代码，最大的改变就在于将“parentJob.join”改为了“parentJob.cancel()”。从运行结果中可以看到，即使调用的只是 parentJob 的 cancel() 方法，并没有碰过 job1、job2、job3，但是它们内部的协程任务也全都被取消了。用一个简单的动图来描述它们之间的关系： 由此，当以结构化的方式构建协程以后， join()、cancel() 等操作，也会以结构化的模式来执行。 #五、CoroutineContext 协程的 Context，在 Kotlin 当中具体的名字，叫做 CoroutineContext。从概念上讲，CoroutineContext 它只是个上下文而已，实际开发中最常见的用处就是切换线程池。 #1. Context 的应用 #1. launch() 123456789public fun CoroutineScope.launch(// 这里// ↓ context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job {} 由上面launch 的部分源码可知，CoroutineContext 其实就是函数的第一个参数，它有默认值 EmptyCoroutineContext，顾名思义，这就是一个空的上下文对象。而如果想要指定 launch 工作的线程池的话，就需要自己传 context 这个参数。 #2. withContext() 1234567891011121314151617181920212223242526272829303132333435fun main() = runBlocking { val user = getUserInfo() logX(user)}suspend fun getUserInfo(): String { logX(&quot;Before IO Context.&quot;) withContext(Dispatchers.IO) { logX(&quot;In IO Context.&quot;) delay(1000L) } logX(&quot;After IO Context.&quot;) return &quot;BoyCoder&quot;}/*输出结果：================================Before IO Context.Thread:main @coroutine#1================================================================In IO Context.Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================After IO Context.Thread:main @coroutine#1================================================================BoyCoderThread:main @coroutine#1================================*/ “Dispatchers.IO”，就是 Kotlin 官方提供的一个 CoroutineContext 对象。从上面代码中看到，当在 withContext() 这里指定线程池以后，Lambda 当中的代码就会被分发到 DefaultDispatcher 线程池中去执行，而它外部的所有代码仍然还是运行在 main 之上。 其实，Kotlin 官方还提供了挂起函数版本的 main() 函数，所以代码也可以改成这样： 12345suspend fun main() { val user = getUserInfo() logX(user)} 注意：挂起函数版本的 main() 的底层做了很多封装，虽然它可以省去写 runBlocking 的麻烦，但不利于学习阶段的探索和研究。等到深入理解协程以后，就可以直接用“suspend main()”写 Demo 了。 #3. runBlocking() 123public fun &lt;T&gt; runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T { ...} 由上面runBlocking()源码可以看到，它的第一个参数也是 CoroutineContext。 123456789101112131415161718192021222324252627// 变化在这里// ↓fun main() = runBlocking(Dispatchers.IO) { val user = getUserInfo() logX(user)}/*输出结果：================================Before IO Context.Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================In IO Context.Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================After IO Context.Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================BoyCoderThread:DefaultDispatcher-worker-1 @coroutine#1================================*/ 根据打印结果发现，所有的代码都运行在 DefaultDispatcher 这个线程池当中了。 #4. 内置Dispatcher 而 Kotlin 官方除了提供了 Dispatchers.IO 以外，还提供了 Dispatchers.Main、Dispatchers.Unconfined、Dispatchers.Default 这几种内置 Dispatcher。 Dispatchers.Main，它只在 UI 编程平台才有意义，在 Android、Swing 之类的平台上，一般只有 Main 线程才能用于 UI 绘制。这个 Dispatcher 在普通的 JVM 工程当中，是无法直接使用的。 Dispatchers.Unconfined，代表无所谓，当前协程可能运行在任意线程之上。 Dispatchers.Default，它是用于 CPU 密集型任务的线程池。一般来说，它内部的线程个数是与机器 CPU 核心数量保持一致的，不过它有一个最小限制 2。 Dispatchers.IO，它是用于 IO 密集型任务的线程池。它内部的线程数量一般会更多一些 （比如 64 个），具体线程的数量可以通过参数来配置：kotlinx.coroutines.io.parallelism。 需要特别注意的是，Dispatchers.IO 底层是可能复用 Dispatchers.Default 当中的线程的。之前示例代码中使用的都是 Dispatchers.IO，但实际运行的线程却是 DefaultDispatcher 这个线程池。 123456789101112131415161718192021222324252627// 变化在这里// ↓fun main() = runBlocking(Dispatchers.Default) { val user = getUserInfo() logX(user)}/*输出结果：================================Before IO Context.Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================In IO Context.Thread:DefaultDispatcher-worker-2 @coroutine#1================================================================After IO Context.Thread:DefaultDispatcher-worker-2 @coroutine#1================================================================BoyCoderThread:DefaultDispatcher-worker-2 @coroutine#1================================*/ 当 Dispatchers.Default 线程池当中有富余线程的时候，它是可以被 IO 线程池复用的。可以看到，后面三个结果的输出都是在同一个线程之上的，这就是因为 Dispatchers.Default 被 Dispatchers.IO 复用线程导致的。如果换成自定义的 Dispatcher，结果就会不一样了。 12345678910111213141516171819202122232425262728293031323334val mySingleDispatcher = Executors.newSingleThreadExecutor { Thread(it, &quot;MySingleThread&quot;).apply { isDaemon = true }}.asCoroutineDispatcher()// 变化在这里// ↓fun main() = runBlocking(mySingleDispatcher) { val user = getUserInfo() logX(user)}public fun ExecutorService.asCoroutineDispatcher(): ExecutorCoroutineDispatcher = ExecutorCoroutineDispatcherImpl(this)/*输出结果：================================Before IO Context.Thread:MySingleThread @coroutine#1================================================================In IO Context.Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================After IO Context.Thread:MySingleThread @coroutine#1================================================================BoyCoderThread:MySingleThread @coroutine#1================================*/ 在上面的代码中，通过 asCoroutineDispatcher() 这个扩展函数，创建了一个 Dispatcher。从这可以看到，Dispatcher 的本质仍然还是线程。这也再次验证了之前的说法：协程运行在线程之上。 然后当给 runBlocking 传入自定义的 mySingleDispatcher 以后，程序运行的结果就不一样了，由于它底层并没有复用线程，因此只有“In IO Context”是运行在 DefaultDispatcher 这个线程池的，其他代码都运行在 mySingleDispatcher 之上。 另外，除了要注意Dispatchers.IO外，还要注意Dispatchers.Unconfined 12345678910fun main() = runBlocking { logX(&quot;Before launch.&quot;) // 1 launch { logX(&quot;In launch.&quot;) // 2 delay(1000L) logX(&quot;End launch.&quot;) // 3 } logX(&quot;After launch.&quot;) // 4} 它们的执行顺序应该是：1、4、2、3。但要注意，同样的代码模式在特殊的环境下，结果可能会不一样。比如在 Android 平台，或者是如果指定了 Dispatchers.Unconfined 这个特殊的 Dispatcher，它的这种行为模式也会被打破。 1234567891011121314151617181920212223242526272829303132fun main() = runBlocking { logX(&quot;Before launch.&quot;) // 1// 变化在这里// ↓ launch(Dispatchers.Unconfined) { logX(&quot;In launch.&quot;) // 2 delay(1000L) logX(&quot;End launch.&quot;) // 3 } logX(&quot;After launch&quot;) // 4}输出结果：================================Before launch.Thread:main @coroutine#1================================================================In launch.Thread:main @coroutine#2================================================================After launchThread:main @coroutine#1================================================================End launch.Thread:kotlinx.coroutines.DefaultExecutor @coroutine#2================================ 以上代码的运行顺序就变成了：1、2、4、3。 注意“End launch”运行的线程“DefaultExecutor”，其实 Unconfined 代表的意思就是，当前协程可能运行在任何线程之上，不作强制要求。由此可见，Dispatchers.Unconfined 其实是很危险的。所以，不应该随意使用 Dispatchers.Unconfined。 #2. 万物皆有Context 在 Kotlin 协程当中，但凡是重要的概念，都或多或少跟 CoroutineContext 有关系：Job、Dispatcher、CoroutineExceptionHandler、CoroutineScope，甚至挂起函数，它们都跟 CoroutineContext 有着密切的联系。甚至，它们之中的 Job、Dispatcher``、CoroutineExceptionHandler 本身，就是 Context。 #1. CoroutineScope 之前提到要调用 launch，就必须先有“协程作用域”，也就是 CoroutineScope。 12345678910111213// 注意这里// ↓public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job {}// CoroutineScope 源码public interface CoroutineScope { public val coroutineContext: CoroutineContext} 由上面CoroutineScope 的源码，可见它其实就是一个简单的接口，而这个接口只有唯一的成员，就是 CoroutineContext。所以，CoroutineScope 只是对 CoroutineContext 做了一层封装而已，它的核心能力其实都来自于 CoroutineContext。而 CoroutineScope 最大的作用，就是可以批量控制协程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445fun main() = runBlocking { // 仅用于测试，生成环境不要使用这么简易的CoroutineScope val scope = CoroutineScope(Job()) scope.launch { logX(&quot;First start!&quot;) delay(1000L) logX(&quot;First end!&quot;) // 不会执行 } scope.launch { logX(&quot;Second start!&quot;) delay(1000L) logX(&quot;Second end!&quot;) // 不会执行 } scope.launch { logX(&quot;Third start!&quot;) delay(1000L) logX(&quot;Third end!&quot;) // 不会执行 } delay(500L) scope.cancel() delay(1000L)}/*输出结果：================================First start!Thread:DefaultDispatcher-worker-1 @coroutine#2================================================================Third start!Thread:DefaultDispatcher-worker-3 @coroutine#4================================================================Second start!Thread:DefaultDispatcher-worker-2 @coroutine#3================================*/ 在上面的代码中，创建了一个简单的 CoroutineScope，接着，使用这个 scope 连续创建了三个协程，在 500 毫秒以后，就调用了 scope.cancel()，这样一来，代码中每个协程的“end”日志就不会输出了。这同样体现了协程结构化并发的理念，相同的功能，借助 Job 也同样可以实现。 #2. Job 和 Dispatcher 如果说 CoroutineScope 是封装了 CoroutineContext，那么 Job 就是一个真正的 CoroutineContext 了。 123456public interface Job : CoroutineContext.Element {}public interface CoroutineContext { public interface Element : CoroutineContext {}} 上面这段代码可以看出：Job 继承自 CoroutineContext.Element，而 CoroutineContext.Element 仍然继承自 CoroutineContext，这就意味着 Job 是间接继承自 CoroutineContext 的。所以说，Job 确实是一个真正的 CoroutineContext，所以如下代码也是正确的： 1234fun main() = runBlocking { val job: CoroutineContext = Job()} 12345678910111213public interface CoroutineContext { public operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? public operator fun plus(context: CoroutineContext): CoroutineContext {} public fun minusKey(key: Key&lt;*&gt;): CoroutineContext public fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R public interface Key&lt;E : Element&gt;} 由上面的CoroutineContext部分源码中的 get()、plus()、minusKey()、fold() 这几个方法，可以看到 CoroutineContext 的接口设计，就跟集合 API 一样。准确来说，它的 API 设计和 Map 十分类似。 所以，完全可以把 CoroutineContext 当作 Map 来用。 123456789101112131415161718192021222324@OptIn(ExperimentalStdlibApi::class)fun main() = runBlocking { // 注意这里 val scope = CoroutineScope(Job() + mySingleDispatcher) scope.launch { // 注意这里 logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher) delay(1000L) logX(&quot;First end!&quot;) // 不会执行 } delay(500L) scope.cancel() delay(1000L)}/*输出结果：================================trueThread:MySingleThread @coroutine#2================================*/ 在上面的代码中，使用了“Job() + mySingleDispatcher”这样的方式创建 CoroutineScope，代码之所以这么写，是因为 CoroutineContext 的 plus() 进行了操作符重载。 1234// 操作符重载// ↓public operator fun &lt;E : Element&gt; plus(key: Key&lt;E&gt;): E? 另外，还使用了“coroutineContext[CoroutineDispatcher]”这样的方式，访问当前协程所对应的 Dispatcher。这也是因为 CoroutineContext 的 get()，支持了操作符重载。 1234// 操作符重载// ↓public operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? 在 Kotlin 当中很多集合也是支持 get() 方法重载的，比如 List、Map，我们都可以使用这样的语法：list[0]、map[key]，以数组下标的方式来访问集合元素。 Kotlin 官方的源代码当中大量使用了操作符重载来简化代码逻辑，而 CoroutineContext 就是一个最典型的例子。 从上面的代码中也可以看出：Dispatcher 本身也是 CoroutineContext，不然就无法实现“Job() + mySingleDispatcher”。最重要的是，当以这样的方式创建出 scope 以后，后续创建的协程就全部都运行在 mySingleDispatcher 这个线程之上了。 下面来探究一下 Dispatcher 到底是如何跟 CoroutineContext 建立关系。 12345678910111213141516171819public actual object Dispatchers { public actual val Default: CoroutineDispatcher = DefaultScheduler public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined public val IO: CoroutineDispatcher = DefaultIoScheduler public fun shutdown() { }}public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}public interface ContinuationInterceptor : CoroutineContext.Element {} 由上面 Dispatchers 的源码可见，Dispatchers 其实是一个 object 单例，它的内部成员的类型是 CoroutineDispatcher，而它又是继承自 ContinuationInterceptor，这个类则是实现了 CoroutineContext.Element 接口。由此可见，Dispatcher 确实就是 CoroutineContext。 #3. CoroutineName 除了上面几个重要的 CoroutineContext 之外，协程其实还有一些上下文还没提到的。比如 CoroutineName，当创建协程的时候，可以传入指定的名称。比如： 123456789101112131415161718192021222324@OptIn(ExperimentalStdlibApi::class)fun main() = runBlocking { val scope = CoroutineScope(Job() + mySingleDispatcher) // 注意这里 scope.launch(CoroutineName(&quot;MyFirstCoroutine!&quot;)) { logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher) delay(1000L) logX(&quot;First end!&quot;) } delay(500L) scope.cancel() delay(1000L)}/*输出结果：================================trueThread:MySingleThread @MyFirstCoroutine!#2 // 注意这里================================*/ 在上面的代码中，调用 launch 的时候，传入了“CoroutineName(“MyFirstCoroutine!”)”作为协程的名字。在后面输出的结果中，得到了“@MyFirstCoroutine!#2”这样的输出。由此可见，其中的数字“2”，其实是一个自增的唯一 ID。 #4. CoroutineExceptionHandler CoroutineContext 当中，还有一个重要成员是 CoroutineExceptionHandler，它主要负责处理协程当中的异常。 123456public interface CoroutineExceptionHandler : CoroutineContext.Element { public companion object Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt; public fun handleException(context: CoroutineContext, exception: Throwable)} 可以看到，CoroutineExceptionHandler 的接口定义其实很简单，CoroutineExceptionHandler 真正重要的，其实只有 handleException() 这个方法，如果要自定义异常处理器，就只需要实现该方法即可。 12345678910111213141516171819// 这里使用了挂起函数版本的main()suspend fun main() { val myExceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; println(&quot;Catch exception: $throwable&quot;) } val scope = CoroutineScope(Job() + mySingleDispatcher) val job = scope.launch(myExceptionHandler) { val s: String? = null s!!.length // 空指针异常 } job.join()}/*输出结果：Catch exception: java.lang.NullPointerException*/ 不过，虽然 CoroutineExceptionHandler 的用法看起来很简单，但当它跟协程“结构化并发”理念相结合以后，内部的异常处理逻辑是会很复杂。 最后，为清晰描述 CoroutineContext 元素之间的关系，画了如下张结构图： #六、实战：网络请求框架 KtHttp #1. 以Java思维简单实现网络请求框架 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Target(AnnotationTarget.VALUE_PARAMETER)@Retention(AnnotationRetention.RUNTIME)annotation class Field(val value: String)@Target(AnnotationTarget.FUNCTION)@Retention(AnnotationRetention.RUNTIME)annotation class GET(val value: String)/** * 任何支持Get API * 以 GitHub repositories API 为例： * https://api.github.com/search/repositories?q=stars:&gt;=10000 language:kotlin&amp;sort=stars */interface ApiService { @GET(&quot;/search/repositories&quot;) fun repos( @Field(&quot;q&quot;) q: String, @Field(&quot;sort&quot;) sort: String ): RepoList}data class RepoList( var total_count: Int?, var items: List&lt;Repo&gt;?,)data class Repo( var full_name: String?, var homepage: String?, var html_url: String?, var language: String?, var forks_count: String?, var topics: List&lt;String&gt;?, var owner: Owner?, var watchers: Int?)data class Owner( var login: String?, var html_url: String?, var type: String?)fun main() { val api: ApiService = KtHttpV1.create(ApiService::class.java) val data: RepoList = api.repos(&quot;stars:&gt;=10000 language:kotlin&quot;, &quot;stars&quot;) println(data)} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687object KtHttpV1 { private var okHttpClient: OkHttpClient = OkHttpClient() private var gson: Gson = Gson() var baseUrl = &quot;https://api.github.com&quot; fun &lt;T&gt; create(service: Class&lt;T&gt;): T { return Proxy.newProxyInstance( service.classLoader, arrayOf&lt;Class&lt;*&gt;&gt;(service) // 反射① 反射② // ↓ ↓ ) { proxy, method, args -&gt; // 反射③ val annotations = method.annotations for (annotation in annotations) { // 反射④ if (annotation is GET) { // 反射⑤ val url = baseUrl + annotation.value // 反射⑥ return@newProxyInstance invoke(url, method, args!!) } } return@newProxyInstance null } as T } private fun invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // ① 根据url拼接参数，也就是：url + ?q=stars:&gt;=10000 language:kotlin&amp;sort=stars // ② 使用okHttpClient进行网络请求 // ③ 使用gson进行JSON解析 // ④ 返回结果 // 条件判断 if (method.parameterAnnotations.size != args.size) return null // 解析完整的 url var url = path // ① val parameterAnnotations = method.parameterAnnotations for (i in parameterAnnotations.indices) { for (parameterAnnotation in parameterAnnotations[i]) { // ② if (parameterAnnotation is Field) { val key = parameterAnnotation.value val value = args[i].toString() if (!url.contains(&quot;?&quot;)) { // ③ url += &quot;?$key=$value&quot; } else { // ④ url += &quot;&amp;$key=$value&quot; } } } } // 执行网络请求 val request = Request.Builder() .url(url) .build() val response = okHttpClient.newCall(request).execute() // ⑤ val genericReturnType = method.genericReturnType val body = response.body val json = body?.string() // JSON 解析 val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType) // 返回值 return result }}/** * 只是为了模拟Java动态代理，实际更复杂 */class ApiImpl(val h: InvocationHandler) : Proxy(h), ApiService { override fun repos(q: String, sort: String): RepoList { val method: Method = ::repos.javaMethod!! val args = arrayOf(q, sort) return h.invoke(this, method, args) as RepoList }} 说明： 以上代码实现的 KtHttp，它的灵感来自于 Retrofit。Retrofit的底层使用了大量的泛型、注解和反射的技术。KtHttp 主要功能是请求了一个服务器的 API，然后在控制台输出了结果。通过这个 KtHttp，可以在程序当中访问任何服务器的 API，当前例子请求的github的中stars数量大于一万且语言类型为kotlin的仓库数据，且以stars数据进行排序。 定义三个数据类Owner、Repo、RepoList，用于描述服务器返回的内容。 定义两个注解GET、Field，一个用于修饰函数，一个用于修饰参数。这两个注解的 Retention 都是 AnnotationRetention.RUNTIME，这意味着这两个注解都是运行时可访问的。而这，也正好是后面要使用的反射的前提。 定义一个用于网络请求的接口ApiService，在这个接口当中，有两个注解： GET 注解，代表了这个网络请求应该是 GET 请求，这是HTTP请求的一种方式。GET 注解当中的“/search/repositories”，代表了 API 的 path，它是和 baseURL 拼接的； Field 注解，代表了 GET 请求的参数。Field 注解当中的值也会和 URL 拼接在一起。 之后在main()方法里进行网络请求： 调用 KtHttpV1.create() 方法，传入了 ApiService::class.java，参数的类型是Class，返回值类型是 ApiService。这就相当于创建了 ApiService 这个接口的实现类的对象。 调用 api.repos() 这个方法，传入了 stars:&gt;=10000 language:kotlin、stars 这两个参数，代表想查询stars数量大于一万且语言类型为kotlin的仓库数据，且以stars数据进行排序。 最后看一下网络请求的具体实现KtHttpV1： 在KtHttpV1.create() 方法当中，直接返回了 Proxy.newProxyInstance() 这个方法的返回值，最后再将其转换成了 T 类型，Proxy.newProxyInstance()方法可以动态创建传入参数的实例化对象。也就是传入的参数ApiService接口的实例化对象。 通过使用反射将注解当中的值 /search/repositories、q、sort 取出来，然后拼接到 URL 当中去。 在 反射注释① 处，method 的类型是反射后的 Method，在这个例子当中，它最终会代表被调用的方法，也就是 ApiService 接口里面的 repos() 这个方法。 在 反射注释② 处：args 的类型是对象的数组，在例子当中，它最终会代表方法的参数的值，也就是“api.repos(&quot;stars:&gt;=10000 language:kotlin&quot;, &quot;stars&quot;)”当中的stars:&gt;=10000 language:kotlin和stars。 在 反射注释③ 处：method.annotations，代表会取出 repos() 这个方法上面的所有注解，由于 repos() 这个方法上面可能会有多个注解，因此它是数组类型。 在 反射注释④ 处：使用 for 循环，遍历所有的注解，找到 GET 注解。 在 反射注释⑤ 处：找到 GET 注解以后，要取出 @GET(“/search/repositories”) 当中的/search/repositories，也就是“annotation.value”。这时候只需要用它与 baseURL 进行拼接，就可以得到完整的 URL。 在 反射注释⑥ 处：return@newProxyInstance，用的是 Lambda 表达式当中的返回语法，在得到完整的 URL 以后，将剩下的逻辑都交给了 invoke() 这个方法。 invoke()方法需要实现功能是 根据url拼接参数、使用okHttpClient进行网络请求、使用gson进行JSON解析、返回结果 在 注释① 处，method.parameterAnnotations，它的作用是取出方法参数当中的所有注解，在这个案例当中，repos() 这个方法当中涉及到两个注解，它们分别是@Field(“q”)、@Field(“sort”)。 在 注释② 处，由于方法当中可能存在其他注解，因此要筛选出想要的 Field 注解。 在 注释③ 处，这里是取出注解当中的值q，以及参数当中对应的值stars:&gt;=10000 language:kotlin进行拼接，URL 第一次拼接参数的时候，要用“?”分隔。 在 注释④ 处，这里是取出注解当中的值sort，以及参数当中对应的值stars进行拼接，后面的参数拼接格式，是用“&amp;”分隔。 在 注释⑤ 处，method.genericReturnType 取出 repos() 的返回值类型，也就是 RepoList，最终，用它来解析 JSON。 KtHttp，就是将 URL 的信息存储在了注解当中 （比如 q 和 sort），而实际的参数值，是在函数调用的时候传进来的 （比如 stars:&gt;=10000 language:kotlin和stars） 。通过泛型、注解、反射的结合，将这些信息集到一起，完成整个 URL 的拼接，最后才通过 OkHttp 完成的网络请求、Gson 完成的解析。可以看到使用 动态代理 + 注解 + 反射 实现的这个网络请求框架不必在代码当中去实现每一个接口，而是只要是符合这样的代码模式，任意的接口和方法，都可以直接传进去，灵活性非常的好。 #2. 函数式思维重构KtHttp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960interface ApiService2 { @GET(&quot;/search/repositories&quot;) fun repos( @Field(&quot;q&quot;) q: String, @Field(&quot;sort&quot;) sort: String ): RepoList}object KtHttpV2 { private val okHttpClient by lazy { OkHttpClient() } private val gson by lazy { Gson() } var baseUrl = &quot;https://api.github.com&quot; inline fun &lt;reified T&gt; create(): T { return Proxy.newProxyInstance( T::class.java.classLoader, // ① arrayOf(T::class.java) // ② ) { _, method, args -&gt; // ③ return@newProxyInstance method.annotations .filterIsInstance&lt;GET&gt;() .takeIf { it.size == 1 } ?.let { invoke(&quot;$baseUrl${it[0].value}&quot;, method, args) } } as T } fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? = method.parameterAnnotations .takeIf { method.parameterAnnotations.size == args.size } ?.mapIndexed { index, it -&gt; Pair(it, args[index]) } ?.fold(url, ::parseUrl) ?.let { Request.Builder().url(it).build() } ?.let { okHttpClient.newCall(it).execute().body?.string() } ?.let { gson.fromJson(it, method.genericReturnType) } private fun parseUrl(acc: String, pair: Pair&lt;Array&lt;Annotation&gt;, Any&gt;) = pair.first.filterIsInstance&lt;Field&gt;() .first() .let { field -&gt; if (acc.contains(&quot;?&quot;)) { &quot;$acc&amp;${field.value}=${pair.second}&quot; } else { &quot;$acc?${field.value}=${pair.second}&quot; } }}fun main() { val data: RepoList = KtHttpV2.create&lt;ApiServiceV2&gt;().repos( q = &quot;stars:&gt;=10000 language:kotlin&quot;, sort = &quot;stars&quot; ) println(data)} 说明： KtHttpV2是使用了函数式思维重构的KtHttp，功能一致，只是实现代码更多使用了Kotlin语言特性。 okHttpClient、gson 这两个成员通过 by lazy 委托的方式实现懒加载。 再看create()方法: 之前代码 create() 会接收一个Class类型的参数。其实，针对这样的情况，完全可以省略掉这个参数。正常情况下，泛型参数类型会被擦除，这就是 Java 的泛型被称为“伪泛型”的原因。而通过使用 inline 和 reified 这两个关键字，就能实现 类型实化，也就是“真泛型”，进一步，就可以在代码 注释① 、注释② 的地方，使用“T::class.java”来得到 Class 对象。 在看 注释③ 处： 首先，通过 method.annotations，来获取 method 的所有注解； 接着，用 filterIsInstance()，来筛选出想要找的 GET 注解。这里的 filterIsInstance 其实是 filter 的升级版，也就是过滤的意思； 之后，判断 GET 注解的数量，它的数量必须是 1，其他的都不行，这里的 takeIf 其实相当于 if； 最后，通过拼接出 URL，然后将程序执行流程交给 invoke() 方法。这里的&quot;?.let{}&quot;相当于判空。 再看invoke()方法： 第一步，通过 method.parameterAnnotations，获取方法当中所有的参数注解，在这里也就是@Field(&quot;q&quot;)、@Field(&quot;sort&quot;)。 第二步，通过 takeIf 来判断，参数注解数组的数量与参数的数量相等，也就是说 @Field(&quot;q&quot;)、@Field(&quot;sort&quot;)的数量是 2，那么[&quot;stars:&gt;=10000 language:kotlin&quot;, &quot;stars&quot;]的 size 也应该是 2，它必须是一一对应的关系。 第三步，将@Field(&quot;q&quot;)与&quot;stars:&gt;=10000 language:kotlin&quot;进行配对，将 @Field(&quot;sort&quot;)与&quot;stars&quot;进行配对。这里的 mapIndexed，其实就是 map 的升级版，它本质还是一种映射的语法，“注解数组类型”映射成了“Pair 数组”，只是多了一个 index 而已。 第四步，使用 fold 与 parseUrl() 这个方法，拼接出完整的 URL，也就是：https://api.github.com/search/repositories?q=stars:&gt;=10000 language:kotlin&amp;sort=stars。 这里使用了函数引用的语法“::parseUrl”。而 fold 这个操作符，其实就是高阶函数版的 for 循环。 第五步，构建出 OkHttp 的 Request 对象，并且将 URL 传入了进去，准备做网络请求。 第六步，通过 okHttpClient 发起了网络请求，并且拿到了 String 类型的 JSON 数据。 最后，通过 Gson 解析出 JSON 的内容，并且返回 RepoList 对象。 再看看用于实现 URL 拼接的 parseUrl() 是如何实现的: 首先，从注解的数组里筛选出 Field 类型的注解； 接着，通过 first() 取出第一个 Field 注解，这里它也应该是唯一的； 最后，判断当前的 acc 是否已经拼接过参数，如果没有拼接过，就用“?”分隔，如果已经拼接过参数，就用“&amp;”分隔。 #3. 支持异步请求（Call）的 KtHttp 在之前 1.0、2.0 版本的代码中，KtHttp 是只支持同步请求的，所有代码都会在一个线程中执行，因此这样的代码如果运行在 Android、Swing 之类的 UI 编程平台上，会导致主线程卡死。 而异步代码，它跟同步代码最大的差异就是，有了一个 Callback，而且代码不再是按照顺序执行的了。 #1. 创建 Callback 为了实现异步请求，首先需要创建一个 Callback 接口，在这个 Callback 当中，可以拿到 API 请求的结果。 123456interface Callback&lt;T: Any&gt; { fun onSuccess(data: T) fun onFail(throwable: Throwable)} 说明： 在 Callback 这个接口里，有一个泛型参数 T，还有两个回调，分别是 onSuccess 代表接口请求成功，onFail 代表接口请求失败。 需要特别注意的是，这里运用了空安全思维当中的泛型边界“T: Any”，这样一来，就可以保证 T 类型一定是非空的。 #2. 创建 KtCall 类 创建好 Callback 后，还创建需要一个 KtCall 类，它的作用是承载 Callback，或者说，它是用来调用 Callback 的 12345678910111213141516171819202122232425class KtCall&lt;T: Any&gt;( private val call: Call, private val gson: Gson, private val type: Type) { fun call(callback: Callback&lt;T&gt;): Call { call.enqueue(object : okhttp3.Callback { override fun onFailure(call: Call, e: IOException) { callback.onFail(e) } override fun onResponse(call: Call, response: Response) { try { val t = gson.fromJson&lt;T&gt;(response.body?.string(), type) callback.onSuccess(t) } catch (e: Exception) { callback.onFail(e) } } }) return call }} 说明： KtCall 这个类仍然使用了泛型边界“T: Any”，另外，它还有几个关键的成员分别是：OkHttp 的 Call 对象、JSON 解析的 Gson 对象，以及反射类型 Type。 然后还有一个 call() 方法，它接收的是前面定义的 Callback 对象，返回的是 OkHttp 的 Call 对象。所以总的来说，call() 方法当中的逻辑会分为三个步骤： 使用 OkHttp 的 call 对象请求 API，这里需要注意的是，为了将请求任务派发到异步线程，需要使用 OkHttp 的异步请求方法 enqueue()。 根据请求结果，调用 callback.onSuccess() 或者是 callback.onFail()。如果请求成功了，在调用 onSuccess() 之前，还需要用 Gson 将请求结果进行解析，然后才返回，而且由于 API 返回的结果并不可靠，即使请求成功了，其中的 JSON 数据也不一定合法，所以这里一般还需要进行额外的判断。 返回 OkHttp 的 Call 对象。 #3. 创建 ApiService 及修改 invoke 方法 12345678interface ApiServiceV3 { @GET(&quot;/repo&quot;) fun repos( @Field(&quot;q&quot;) q: String, @Field(&quot;sort&quot;) sort: String ): KtCall&lt;RepoList&gt; // ①} 注释① 处是该版本和最初版本之间的最大区别，由于 repo() 方法的返回值类型是 KtCall，为了支持这种写法， invoke 方法就需要跟着做一些小的改动： 123456789101112131415161718192021222324252627282930313233343536// 这里也同样使用了泛型边界private fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { if (method.parameterAnnotations.size != args.size) return null var url = path val parameterAnnotations = method.parameterAnnotations for (i in parameterAnnotations.indices) { for (parameterAnnotation in parameterAnnotations[i]) { if (parameterAnnotation is Field) { val key = parameterAnnotation.value val value = args[i].toString() if (!url.contains(&quot;?&quot;)) { url += &quot;?$key=$value&quot; } else { url += &quot;&amp;$key=$value&quot; } } } } val request = Request.Builder() .url(url) .build() val call = okHttpClient.newCall(request) val genericReturnType = getTypeArgument(method) // 变化在这里 return KtCall&lt;T&gt;(call, gson, genericReturnType)}// 拿到 KtCall&lt;RepoList&gt; 当中的 RepoList类型private fun getTypeArgument(method: Method) = (method.genericReturnType as ParameterizedType).actualTypeArguments[0] 上述代码中大部分代码和初始版本的一样的，只是在最后封装了一个 KtCall 对象，直接返回。 #4. 测试代码 123456789101112131415161718192021222324252627282930313233343536373839private fun testAsync1() { // 创建api对象 val api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::class.java) // 获取ktCall val ktCall: KtCall&lt;RepoList&gt; = api.repos( q = &quot;stars:&gt;=10000 language:kotlin&quot;, sort = &quot;stars&quot; ) // 发起call异步请求 ktCall.call(object : Callback&lt;RepoList&gt; { override fun onSuccess(data: RepoList) { println(data) } override fun onFail(throwable: Throwable) { println(throwable) } })}private fun testAsync2() { KtHttpV3.create(ApiServiceV3::class.java) .repos( q = &quot;stars:&gt;=10000 language:kotlin&quot;, sort = &quot;stars&quot; ).call(object : Callback&lt;RepoList&gt; { override fun onSuccess(data: RepoList) { println(data) } override fun onFail(throwable: Throwable) { println(throwable) } })} 说明： 在testAsync1() 中一步步创建 API 对象、ktCall 对象，最后发起请求，但是会创建创建很多一次性临时对象。 推荐使用testAsync2()，采用链式调用的方式，减少了临时对象，且不必为临时变量取名字伤脑筋。 #5. 同时支持同步和异步 1234567891011121314151617181920interface ApiServiceV3 { @GET(&quot;/repo&quot;) fun repos( @Field(&quot;q&quot;) q: String, @Field(&quot;sort&quot;) sort: String ): KtCall&lt;RepoList&gt; @GET(&quot;/repo&quot;) fun reposSync( @Field(&quot;q&quot;) q: String, @Field(&quot;sort&quot;) sort: String ): RepoList // 注意这里}private fun testSync() { val api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::class.java) val data: RepoList = api.reposSync(q = &quot;stars:&gt;=10000 language:kotlin&quot;, sort = &quot;stars&quot;) println(data)} 注意 repoSync() 的返回值类型是 RepoList，而不是 KtCall 类型，这其实是初始版本的写法。写到这里，虽然 KtHttp 支持了异步请求，但原本的同步请求反而不支持了。所以，为了让 KtHttp 同时支持两种请求方式，只需要增加一个 if 判断即可： 1234567891011121314151617181920private fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略其他代码 return if (isKtCallReturn(method)) { val genericReturnType = getTypeArgument(method) KtCall&lt;T&gt;(call, gson, genericReturnType) } else { // 注意这里 val response = okHttpClient.newCall(request).execute() val genericReturnType = method.genericReturnType val json = response.body?.string() gson.fromJson&lt;Any?&gt;(json, genericReturnType) }}// 判断当前接口的返回值类型是不是KtCallprivate fun isKtCallReturn(method: Method) = getRawType(method.genericReturnType) == KtCall::class.java 在上面的代码中，定义了一个方法 isKtCallReturn()，它的作用是判断当前接口方法的返回值类型是不是 KtCall，如果是的话，就认为它是一个异步接口，这时候返回 KtCall 对象；如果不是，就认为它是同步接口。这样我们只需要将初始版本的逻辑挪到 else 分支，就可以实现兼容了。 #4. 支持挂起函数的 KtHttp 在日常的开发工作当中，也许经常会面临这样的一个问题：虽然很想用 Kotlin 的协程来简化异步开发，但公司的底层框架全部都是 Callback 写的，根本不支持挂起函数。 其实，当前的 KtHttp 就面临着类似的问题：3.0 版本只支持 Callback 异步调用，现在想要扩展出挂起函数的功能。这其实就是大部分 Kotlin 开发者会遇到的场景。 针对这个问题，主要有两种解法： 第一种解法，不改动 SDK 内部的实现，直接在 SDK 的基础上扩展出协程的能力。 第二种解法，改动 SDK 内部，让 SDK 直接支持挂起函数。下面先来看看第一种解法。 #1. 解法一：扩展 KtCall 这种方式有一个优势，那就是不需要改动 3.0 版本的任何代码。这种场景在工作中也是十分常见的，比如说，项目中用到的 SDK 是开源的，或者 SDK 是公司其他部门开发的，无法改动 SDK。 #1. 扩展出 await 函数 具体的做法，就是为 KtCall 这个类扩展出一个挂起函数。 12345/*注意这里 函数名称 ↓ ↓ */suspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = TODO() 在上面的代码中，定义了一个扩展函数 await()。首先，它是一个挂起函数，其次，它的扩展接收者类型是 KtCall，其中带着一个泛型 T，挂起函数的返回值也是泛型 T。而由于它是一个挂起函数，所以，代码就可以换成这样的方式来写了。 12345678fun main() = runBlocking { val ktCall = KtHttpV3.create(ApiServiceV3::class.java) .repos(q = &quot;stars:&gt;=10000 language:kotlin&quot;, sort = &quot;stars&quot;) val result = ktCall.await() // 调用挂起函数 println(result)} #2. 实现 await 函数 那么，现在就只剩下一个问题了：await() 具体该如何实现？在这里，需要用到 Kotlin 官方提供的一个顶层函数：suspendCoroutine{}，它的函数签名是这样的： 1234public suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T { // 省略细节} 从它的函数签名，可以发现，它是一个挂起函数，也是一个高阶函数，参数类型是“(Continuation) -&gt; Unit”，它其实就等价于挂起函数类型！ 所以，可以使用 suspendCoroutine{} 来实现 await() 方法： 123456789/*注意这里 ↓ */suspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = suspendCoroutine{ continuation -&gt; // ↑ // 注意这里 } 仔细分析这段代码的话，会发现 suspendCoroutine{} 的作用，其实就是将挂起函数当中的 continuation 暴露出来。 再来回顾一下 Continuation 这个接口： 123456public interface Continuation&lt;in T&gt; { public val context: CoroutineContext // 关键在于这个方法 public fun resumeWith(result: Result&lt;T&gt;)} 通过定义可以看到，整个 Continuation 只有一个方法，那就是 resumeWith()，根据它的名字就可以推测出，它是用于“恢复”的，参数类型是 Result。所以很明显，这就是一个带有泛型的“结果”，它的作用就是承载协程执行的结果。 所以，综合来看，就可以进一步写出这样的代码了： 12345678910111213suspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = suspendCoroutine { continuation -&gt; call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { continuation.resumeWith(Result.success(data)) } override fun onFail(throwable: Throwable) { continuation.resumeWith(Result.failure(throwable)) } }) } 以上代码逻辑就是，当网络请求执行成功以后，就调用 resumeWith()，同时传入 Result.success(data)；如果请求失败，我们就传入 Result.failure(throwable)，将对应的异常信息传进去。不过，可以借助 Kotlin 官方提供的扩展函数提升代码可读性。 12345678910111213suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T = suspendCoroutine { continuation -&gt; call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { continuation.resume(data) } override fun onFail(throwable: Throwable) { continuation.resumeWithException(throwable) } }) } #3. suspendCoroutine{} 不支持取消 到目前为止，await() 这个扩展函数其实就已经实现了。这时候，如果在协程当中调用 await() 方法的话，代码是可以正常执行的。不过，这种做法其实还有一点瑕疵，那就是不支持取消。 123456789101112131415161718192021222324252627282930313233343536373839404142fun main() = runBlocking { val start = System.currentTimeMillis() val deferred = async { KtHttpV3.create(ApiServiceV3::class.java) .repos(q = &quot;stars:&gt;=10000 language:kotlin&quot;, sort = &quot;stars&quot;) .await() } deferred.invokeOnCompletion { println(&quot;invokeOnCompletion!&quot;) } delay(50L) deferred.cancel() println(&quot;Time cancel: ${System.currentTimeMillis() - start}&quot;) try { println(deferred.await()) } catch (e: Exception) { println(&quot;Time exception: ${System.currentTimeMillis() - start}&quot;) println(&quot;Catch exception:$e&quot;) } finally { println(&quot;Time total: ${System.currentTimeMillis() - start}&quot;) }}suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T = suspendCoroutine { continuation -&gt; call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { println(&quot;Request success!&quot;) // ① continuation.resume(data) } override fun onFail(throwable: Throwable) { println(&quot;Request fail!：$throwable&quot;) continuation.resumeWithException(throwable) } }) } 1234567//输出结果：Time cancel: 536 // ②Request success! // ③invokeOnCompletion!Time exception: 3612 // ④Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28Time total: 3612 说明： 在 main 函数当中，在 async 里调用了挂起函数，接着 50ms 过去后，就去尝试取消协程。 这段代码中一共有三处地方需要注意： 结合注释①、③ 一起分析，即使调用了 deferred.cancel()，网络请求仍然会继续执行。根据“Catch exception:”输出的异常信息，发现当 deferred 被取消以后还去调用 await() 的时候，会抛出异常。 对比注释②、④ ，deferred.await() 虽然会抛出异常，但是它却耗时 3000ms。虽然 deferred 被取消了，但是当调用 await() 的时候，它并不会马上就抛出异常，而是会等到内部的网络请求执行结束以后，才抛出异常，在此之前都会被挂起。 综上所述，当使用 suspendCoroutine{} 来实现挂起函数的时候，默认情况下是不支持取消的。那么，具体该怎么做呢？其实也很简单，就是使用 Kotlin 官方提供的另一个 API： suspendCancellableCoroutine{}。 #4. 使用 suspendCancellableCoroutine{} 实现 await 函数 1234567891011121314151617181920212223suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =// 变化1// ↓ suspendCancellableCoroutine { continuation -&gt; val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { println(&quot;Request success!&quot;) continuation.resume(data) } override fun onFail(throwable: Throwable) { println(&quot;Request fail!：$throwable&quot;) continuation.resumeWithException(throwable) } })// 变化2// ↓ continuation.invokeOnCancellation { println(&quot;Call cancelled!&quot;) call.cancel() } } 当使用 suspendCancellableCoroutine{} 的时候，可以往 continuation 对象上面设置一个监听：invokeOnCancellation{}，它代表当前的协程被取消了，这时候，只需要将 OkHttp 的 call 取消即可。 这样一来，main() 函数就能保持不变，得到的输出结果却大不相同。 12345678910111213141516171819//suspendCoroutine结果：Time cancel: 536 Request success! invokeOnCompletion!Time exception: 3612 // ①Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28Time total: 3612//suspendCancellableCoroutine结果：Call cancelled!Time cancel: 464invokeOnCompletion!Time exception: 466 // ②Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28Time total: 466Request fail!：java.io.IOException: Canceled // ③ 对比注释①、② ，可以发现，后者是会立即响应协程取消事件的，所以当代码执行到 deferred.await() 的时候，会立即抛出异常，而不会挂起很长时间。另外，通过注释③ 这里的结果，也可以发现，OkHttp 的网络请求确实被取消了。 所以，可以得出一个结论，使用 suspendCancellableCoroutine{}，可以避免不必要的挂起，比如例子中的 deferred.await()；另外也可以节省计算机资源，因为这样可以避免不必要的协程任务，比如这里被成功取消的网络请求。 到这里，解法一就已经完成了。这种方式并没有改动 KtHttp 的源代码，而是以扩展函数来实现的。 #七、参考文章 Github公共搜索API Github公共搜索关键字说明","link":"/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/"},{"title":"kotlin学习系列十五：协程源码篇三 协程运行","text":"一、前言 二、 Dispatchers是如何工作的 1. Dispatchers 2. CoroutineDispatcher 拦截器 3. Dispatchers 小结 三、CoroutineScope 是如何管理协程的 1. 源码 #一、前言 本文主要讲述Kotlin 协程中的Dispatchers 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin协程源码：https://github.com/Kotlin/kotlinx.coroutines Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程一 kotlin学习系列十：协程二 kotlin学习系列十一：协程三 kotlin学习系列十二：协程四 kotlin学习系列十三：协程源码篇一 kotlin学习系列十四：协程源码篇二 协程创建 #二、 Dispatchers是如何工作的 上一章里提到，Kotlin 的 launch 会调用 startCoroutineCancellable()，接着又会调用 createCoroutineUnintercepted()，最终会调用编译器生成 SuspendLambda 实现类当中的 create() 方法。这样，协程就创建出来了。 接着，来探究一下协程是如何运行的。协程无法脱离线程运行，Kotlin 当中所有的协程，最终都是运行在线程之上的。那么，协程创建出来以后，它又是如何跟线程产生关联的？ #1. Dispatchers launch{}本质上是调用了 startCoroutineCancellable() 当中的 createCoroutineUnintercepted() 方法创建了协程。 1234567// 代码段1public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) { // 注意这里 // ↓ createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))} 那么下面，继续分析 createCoroutineUnintercepted(completion) 之后的 intercepted() 方法。 首先弄清楚 Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext 之间的关系。 123456789101112131415161718192021// 代码段2public actual object Dispatchers { public actual val Default: CoroutineDispatcher = DefaultScheduler public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined public val IO: CoroutineDispatcher = DefaultIoScheduler public fun shutdown() { }}public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}public interface ContinuationInterceptor : CoroutineContext.Element {}public interface Element : CoroutineContext {} Dispatchers 是一个单例对象，它当中的 Default、Main、Unconfined、IO，类型都是 CoroutineDispatcher，而它本身就是 CoroutineContext。所以，它们之间的关系就可以用下面这个图来描述。 12345678910111213141516171819202122232425262728293031323334353637383940// 代码段3fun main() { testLaunch() Thread.sleep(2000L)}private fun testLaunch() { val scope = CoroutineScope(Job()) scope.launch{ logX(&quot;Hello!&quot;) delay(1000L) logX(&quot;World!&quot;) }}/** * 控制台输出带协程信息的log */fun logX(any: Any?) { println( &quot;&quot;&quot;================================$anyThread:${Thread.currentThread().name}================================&quot;&quot;&quot;.trimIndent() )}/*输出结果================================Hello!Thread:DefaultDispatcher-worker-1 @coroutine#1================================================================World!Thread:DefaultDispatcher-worker-1 @coroutine#1================================*/ 在这段代码中，没有为 launch() 传入任何 CoroutineContext 参数，但通过执行结果，发现协程代码居然执行在 DefaultDispatcher，并没有运行在 main 线程之上。这是为什么呢？ 回过头来分析下 launch 的源代码 123456789101112131415// 代码段4public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job { // 1 val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine} launch 的第一个参数，context，它的默认值是 EmptyCoroutineContext。CoroutineContext 就相当于 Map，而 EmptyCoroutineContext 则相当于一个空的 Map。所以，可以认为，这里的 EmptyCoroutineContext 传了也相当于没有传，它的目的只是为了让 context 参数不为空而已。这其实也体现出了 Kotlin 的空安全思维，Kotlin 官方用 EmptyCoroutineContext 替代了 null。 注释 1 处这行代码会调用 newCoroutineContext(context)，将传入的 context 参数重新包装一下，然后返回。它具体的逻辑： 1234567891011// 代码段5public actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext { // 1 val combined = coroutineContext.foldCopiesForChildCoroutine() + context // 2 val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined // 3 return if (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == null) debug + Dispatchers.Default else debug} 注释 1，由于 newCoroutineContext() 是 CoroutineScope 的扩展函数，因此，可以直接访问 CoroutineScope 的 coroutineContext 对象，它其实就是 CoroutineScope 对应的上下文。foldCopiesForChildCoroutine() 的作用，其实就是将 CoroutineScope 当中的所有上下文元素都拷贝出来，然后跟传入的 context 参数进行合并。 这行代码，可以让子协程继承父协程的上下文元素。 注释 2，它的作用是在调试模式下，为协程对象增加唯一的 ID。在 代码段 3 的输出结果中看到的 “@coroutine#1”，其中的 数字“1” 就是在这个阶段生成的。 注释 3，如果合并过后的 combined 当中没有 CoroutineDispatcher，那么，就会默认使用 Dispatchers.Default。 Tips: 上面的代码可以延伸出一个问题，为什么协程默认的线程池是 Dispatchers.Default，而不是 Main 呢？ 答案其实也很简单，因为 Kotlin 协程是支持多平台的，Main 线程只在 UI 编程平台才有可用。因此，当协程没有指定 Dispatcher 的时候，就只能使用 Dispatchers.Default 了。毕竟，协程是无法脱离线程执行的。 所以 代码段 3 当中的协程执行在 Dispatchers.Default 的原因也就找到了：由于定义的 scope 没有指定 Dispatcher，同时 launch 的参数也没有传入 Dispatcher，最终在 newCoroutineContext() 的时候，会被默认指定为 Default 线程池。 #2. CoroutineDispatcher 拦截器 上一节开始提到的 startCoroutineCancellable()源码，其中的 createCoroutineUnintercepted() 方法，它的返回值类型就是 Continuation。而 intercepted() 方法，其实就是 Continuation 的扩展函数。 12345678910111213141516171819202122232425262728// 代码段6// Cancellable.ktpublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) { // 注意这里 // ↓ createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))}// IntrinsicsJvm.ktpublic actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; = (this as? ContinuationImpl)?.intercepted() ?: this// ContinuationImpl.ktinternal abstract class ContinuationImpl( completion: Continuation&lt;Any?&gt;?, private val _context: CoroutineContext?) : BaseContinuationImpl(completion) { constructor(completion: Continuation&lt;Any?&gt;?) : this(completion, completion?.context) @Transient private var intercepted: Continuation&lt;Any?&gt;? = null // 1 public fun intercepted(): Continuation&lt;Any?&gt; = intercepted ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this) .also { intercepted = it }} 从上面的代码中，可以看到，startCoroutineCancellable() 当中的 intercepted() 最终会调用 BaseContinuationImpl 的 intercepted() 方法。 注意 注释 1 处，intercepted() 方法首先会判断它的成员变量 intercepted 是否为空，如果为空，就会调用 context[ContinuationInterceptor]，获取上下文当中的 Dispatcher 对象。以 代码段 3 当中的逻辑为例，这时候的 Dispatcher 肯定是 Default 线程池。 然后，如果继续跟进 interceptContinuation(this) 方法的话，会发现程序最终会调用 CoroutineDispatcher 的 interceptContinuation() 方法。 123456789// 代码段7public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor { // 1 public final override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; = DispatchedContinuation(this, continuation)} 注意 注释 1，interceptContinuation() 直接返回了一个 DispatchedContinuation 对象，并且将 this、continuation 作为参数传了进去。这里的 this，其实就是这个抽象类CoroutineDispatcher, 以 代码段 3 当中的逻辑为例，其实就是 Dispatchers.Default。 所以，如果把 startCoroutineCancellable() 改写一下，它实际上会变成下面这样： 1234567891011121314151617// 代码段8public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) { createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))}// 等价// ↓public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) { // 1 val continuation = createCoroutineUnintercepted(completion) // 2 val dispatchedContinuation = continuation.intercepted() // 3 dispatchedContinuation.resumeCancellableWith(Result.success(Unit))} 在上面的代码中， 注释 1，2 都已经分析完了，现在只剩下 注释 3 了。这里的 resumeCancellableWith()，其实就是真正将协程任务分发到线程上的逻辑。继续跟进分析源代码： 123456789101112131415// 代码段9internal class DispatchedContinuation&lt;in T&gt;( @JvmField val dispatcher: CoroutineDispatcher, @JvmField val continuation: Continuation&lt;T&gt;) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation { inline fun resumeCancellableWith( result: Result&lt;T&gt;, noinline onCancellation: ((cause: Throwable) -&gt; Unit)? ) { // 省略，留到后面分析 }} 也就是，DispatchedContinuation 是实现了 Continuation 接口，同时，它使用了“类委托”的语法，将接口的具体实现委托给了它的成员属性 continuation。通过之前 代码段 7 的分析，可知它的成员属性 dispatcher 对应的就是 Dispatcher.Default，而成员属性 continuation 对应的则是 launch 当中传入的 SuspendLambda 实现类。 另外，DispatchedContinuation 还继承自 DispatchedTask。 123456789101112131415internal abstract class DispatchedTask&lt;in T&gt;( @JvmField public var resumeMode: Int) : SchedulerTask() {}internal actual typealias SchedulerTask = Taskinternal abstract class Task( @JvmField var submissionTime: Long, @JvmField var taskContext: TaskContext) : Runnable { constructor() : this(0, NonBlockingContext) inline val mode: Int get() = taskContext.taskMode // TASK_XXX} 可以看到，DispatchedContinuation 继承自 DispatchedTask，而 DispatchedTask 则是 SchedulerTask 的子类，SchedulerTask 是 Task 的类型别名，而 Task 实现了 Runnable 接口。因此，DispatchedContinuation 不仅是一个 Continuation，同时还是一个 Runnable, 也就意味着它可以被分发到 Java 的线程当中去执行。 123456789101112131415161718192021222324252627282930313233343536373839404142// 代码段9internal class DispatchedContinuation&lt;in T&gt;( @JvmField val dispatcher: CoroutineDispatcher, @JvmField val continuation: Continuation&lt;T&gt;) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation { inline fun resumeCancellableWith( result: Result&lt;T&gt;, noinline onCancellation: ((cause: Throwable) -&gt; Unit)? ) { val state = result.toState(onCancellation) // 1 if (dispatcher.isDispatchNeeded(context)) { _state = state resumeMode = MODE_CANCELLABLE // 2 dispatcher.dispatch(context, this) } else { // 3 executeUnconfined(state, MODE_CANCELLABLE) { if (!resumeCancelled(state)) { resumeUndispatchedWith(result) } } } }}public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor { // 默认是true public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true public abstract fun dispatch(context: CoroutineContext, block: Runnable)}internal object Unconfined : CoroutineDispatcher() { // 只有Unconfined会重写成false override fun isDispatchNeeded(context: CoroutineContext): Boolean = false} 注释 1，dispatcher.isDispatchNeeded()，通过查看 CoroutineDispatcher 的源代码，发现它的返回值始终都是 true。在它的子类当中，只有 Dispatchers.Unconfined 会将其重写成 false。这也就意味着，除了 Unconfined 以外，其他的 Dispatcher 都会返回 true。对于 代码段 3 当中的代码而言， Dispatcher 是默认的 Default，所以，代码将会进入注释 2 对应的分支。 注释 2，dispatcher.dispatch(context, this)，这里其实就相当于将代码的执行流程分发到 Default 线程池。dispatch() 的第二个参数要求是 Runnable，这里传入的是 this，这是因为 DispatchedContinuation 本身就间接实现了 Runnable 接口。 注释 3，executeUnconfined{}，它其实就对应着 Dispather 是 Unconfined 的情况，这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。 继续沿着 注释 2 进行分析，这里的 dispatcher.dispatch() 其实就相当于调用了 Dispatchers.Default.dispatch()。看看它的逻辑： 1234567891011// Dispatcher.ktpublic actual object Dispatchers { @JvmStatic public actual val Default: CoroutineDispatcher = DefaultScheduler}internal object DefaultScheduler : SchedulerCoroutineDispatcher( CORE_POOL_SIZE, MAX_POOL_SIZE, IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME) {} 从上面的代码中，可以看到，Dispatchers.Default 本质上是一个单例对象 DefaultScheduler，它是 SchedulerCoroutineDispatcher 的子类。 12345678910111213// Dispatcher.ktinternal open class SchedulerCoroutineDispatcher( private val corePoolSize: Int = CORE_POOL_SIZE, private val maxPoolSize: Int = MAX_POOL_SIZE, private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS, private val schedulerName: String = &quot;CoroutineScheduler&quot;,) : ExecutorCoroutineDispatcher() { private var coroutineScheduler = createScheduler() override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)} 根据以上代码，可以看到 Dispatchers.Default.dispatch() 最终会调用 SchedulerCoroutineDispatcher 的 dispatch() 方法，而它实际上调用的是 coroutineScheduler.dispatch()。 CoroutineScheduler 的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940internal class CoroutineScheduler( @JvmField val corePoolSize: Int, @JvmField val maxPoolSize: Int, @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS, @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME) : Executor, Closeable { override fun execute(command: Runnable) = dispatch(command) fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) { trackTask() // 1 val task = createTask(block, taskContext) // 2 val currentWorker = currentWorker() // 3 val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch) if (notAdded != null) { if (!addToGlobalQueue(notAdded)) { throw RejectedExecutionException(&quot;$schedulerName was terminated&quot;) } } val skipUnpark = tailDispatch &amp;&amp; currentWorker != null if (task.mode == TASK_NON_BLOCKING) { if (skipUnpark) return signalCpuWork() } else { signalBlockingWork(skipUnpark = skipUnpark) } } private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this } // 内部类 Worker internal inner class Worker private constructor() : Thread() { }} CoroutineScheduler 其实是 Java 并发包下的 Executor 的子类，它的 execute() 方法也被转发到了 dispatch()。 注释 1，将传入的 Runnable 类型的 block（也就是 DispatchedContinuation），包装成 Task。 注释 2，currentWorker()，拿到当前执行的线程。这里的 Worker 其实是一个内部类，它本质上仍然是 Java 的 Thread。 注释 3，currentWorker.submitToLocalQueue()，将当前的 Task 添加到 Worker 线程的本地队列，等待执行。 接下来分析 Work 是如何执行 Task 12345678910111213141516171819202122232425262728293031323334353637383940414243// CoroutineScheduler.ktinternal inner class Worker private constructor() : Thread() { override fun run() = runWorker() @JvmField var mayHaveLocalTasks = false private fun runWorker() { var rescanned = false while (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) { // 1 val task = findTask(mayHaveLocalTasks) if (task != null) { rescanned = false minDelayUntilStealableTaskNs = 0L // 2 executeTask(task) continue } else { mayHaveLocalTasks = false } if (minDelayUntilStealableTaskNs != 0L) { if (!rescanned) { rescanned = true } else { rescanned = false tryReleaseCpu(WorkerState.PARKING) interrupted() LockSupport.parkNanos(minDelayUntilStealableTaskNs) minDelayUntilStealableTaskNs = 0L } continue } tryPark() } tryReleaseCpu(WorkerState.TERMINATED) }} Worker 重写 Thread 的 run() 方法，然后把执行流程交给 runWorker() 注释 1，在 while 循环当中，会一直尝试从 Worker 的本地队列取 Task 出来，如果存在需要执行的 Task，就会进入下一步。 注释 2，executeTask(task)，其实就是执行对应的 Task。 接下来的逻辑，就是 最关键的部分 123456789101112131415161718192021222324252627282930internal inner class Worker private constructor() : Thread() { private fun executeTask(task: Task) { val taskMode = task.mode idleReset(taskMode) beforeTask(taskMode) // 1 runSafely(task) afterTask(taskMode) }}fun runSafely(task: Task) { try { // 2 task.run() } catch (e: Throwable) { val thread = Thread.currentThread() thread.uncaughtExceptionHandler.uncaughtException(thread, e) } finally { unTrackTask() }}internal abstract class Task( @JvmField var submissionTime: Long, @JvmField var taskContext: TaskContext) : Runnable { constructor() : this(0, NonBlockingContext) inline val mode: Int get() = taskContext.taskMode // TASK_XXX} 在 Worker 的 executeTask() 方法当中，会调用 runSafely() 方法，而在这个方法当中，最终会调用 task.run()。前面提到过 Task 本质上就是 Runnable，而 Runnable.run() 其实就代表了协程任务真正执行了！ task.run() 是执行的 DispatchedTask.run()。这里的 DispatchedTask 实际上是 DispatchedContinuation 的父类。 123456789101112131415161718192021222324252627282930313233343536373839404142internal class DispatchedContinuation&lt;in T&gt;( @JvmField val dispatcher: CoroutineDispatcher, @JvmField val continuation: Continuation&lt;T&gt;) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation { public final override fun run() { val taskContext = this.taskContext var fatalException: Throwable? = null try { val delegate = delegate as DispatchedContinuation&lt;T&gt; val continuation = delegate.continuation withContinuationContext(continuation, delegate.countOrElement) { val context = continuation.context val state = takeState() val exception = getExceptionalResult(state) val job = if (exception == null &amp;&amp; resumeMode.isCancellableMode) context[Job] else null if (job != null &amp;&amp; !job.isActive) { // 1 val cause = job.getCancellationException() cancelCompletedResult(state, cause) continuation.resumeWithStackTrace(cause) } else { if (exception != null) { // 2 continuation.resumeWithException(exception) } else { // 3 continuation.resume(getSuccessfulResult(state)) } } } } catch (e: Throwable) { fatalException = e } finally { val result = runCatching { taskContext.afterTask() } handleFatalException(fatalException, result.exceptionOrNull()) } }} 注释 1，在协程代码执行之前，它首先会判断当前协程是否已经取消。如果已经取消的话，就会调用 continuation.resumeWithStackTrace(cause) 将具体的原因传出去。 注释 2，判断协程是否发生了异常，如果已经发生了异常，则需要调用 continuation.resumeWithException(exception) 将异常传递出去。 注释 3，如果一切正常，则会调用 continuation.resume(getSuccessfulResult(state))，这时候，协程才会正式启动，并且执行 launch 当中传入的 Lambda 表达式。 #3. Dispatchers 小结 Dispatchers 是协程框架中与线程交互的关键，这里面主要涉及以下几个步骤： 第一步，createCoroutineUnintercepted(completion) 创建了协程的 Continuation 实例，紧接着就会调用它的 intercepted() 方法，将其封装成 DispatchedContinuation 对象。 第二步，DispatchedContinuation 会持有 CoroutineDispatcher、以及前面创建的 Continuation 对象。例子中的 CoroutineDispatcher 实际上就是 Default 线程池。 第三步，执行 DispatchedContinuation 的 resumeCancellableWith() 方法，这时候，就会执行 dispatcher.dispatch()，这就会将协程的 Continuation 封装成 Task 添加到 Worker 的本地任务队列，等待执行。这里的 Worker 本质上就是 Java 的 Thread。在这一步，协程就已经完成了线程的切换。 第四步，Worker 的 run() 方法会调用 runWork()，它会从本地的任务队列当中取出 Task，并且调用 task.run()。而它实际上调用的是 DispatchedContinuation 的 run() 方法，在这里，会调用 continuation.resume()，它将执行原本 launch 当中生成的 SuspendLambda 子类。这时候，launch 协程体当中的代码，就在线程上执行了。 #三、CoroutineScope 是如何管理协程的 #1. #源码 CoroutineScope.launch CoroutineScope.newCoroutineContext Dispatchers.kt Cancellable.kt IntrinsicsJvm.kt ContinuationImpl.kt CoroutineDispatcher.kt DispatchedContinuation.kt DispatchedTask.kt CoroutineScheduler.kt Tasks.kt Runnable.kt","link":"/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%94/"},{"title":"kotlin学习系列十二：协程四","text":"一、前言 二、 协程与并发 1. 区分协程与线程概念 2. 协程如何处理并发 1. 借鉴 Java 的并发思路 2. 协程当中的并发思路 1. 单线程并发 2. Mutex 3. Actor 3. 反思：可变状态 三、异常原因及处理 1. 取消异常（CancellationException） 场景 1：cancel() 不被响应 场景 2：结构被破坏 场景 3：未正确处理 CancellationException 2. 在协程当中处理普通的异常 1. try-catch 2. SupervisorJob 1. 不调用 await() 就不会发生异常 2. SupervisorJob 源码 3. CoroutineExceptionHandler 3. 总结 四、 实战：让KtHttp支持Flow 5.0 版本：Callback 转 Flow 1. callbackFlow 2. trySend() 与 trySendBlocking() 3. callbackFlow 的 close() 6.0 版本：直接支持 Flow #一、前言 本文主要讲述Kotlin 协程中的并发以及异常原因和处理 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程一 kotlin学习系列十：协程二 kotlin学习系列十一：协程三 kotlin学习系列十三：协程源码篇一 #二、 协程与并发 Kotlin 的协程仍然是基于线程运行的。但是，经过一层封装以后，Kotlin 协程面对并发问题的时候，它的处理手段其实跟 Java 就大不一样。 在 Java 世界里，并发往往需要多个线程一起工作，而多线程往往就会有共享的状态，这时候程序就要处理同步问题了。 但是，不要把协程与线程的概念混淆在一起。 #1. 区分协程与线程概念 1234567891011121314151617// 代码段1fun main() = runBlocking { var i = 0 // Default 线程池 launch(Dispatchers.Default) { repeat(1000) { i++ } } delay(1000L) println(&quot;i = $i&quot;)} 在这段代码里，在 Default 线程池上创建了一个协程，然后对变量 i 进行了 1000 次自增操作，接着又 delay 了一小会儿，防止程序退出，最后输出结果。 那么，在面对这段代码的时候，Default 线程池内部是多个线程，因此就需要考虑多线程同步的问题。其实，这就是典型的把协程、线程混淆的例子。 仔细分析上面的代码，会发现代码中压根就没有并发执行的任务，除了 runBlocking，只在 launch 当中创建了一个协程，所有的计算都发生在一个协程当中。所以，在这种情况下根本就不需要考虑同步的问题。 再来看看多个协程并发执行的例子。 1234567891011121314151617181920212223242526// 代码段2fun main() = runBlocking { var i = 0 val jobs = mutableListOf&lt;Job&gt;() // 重复十次 repeat(10){ val job = launch(Dispatchers.Default) { repeat(1000) { i++ } } jobs.add(job) } // 等待计算完成 jobs.joinAll() println(&quot;i = $i&quot;)}/*输出结果i = 9972*/ 在上面的代码中，创建了 10 个协程任务，每个协程任务都会工作在 Default 线程池，这 10 个协程任务，都会分别对 i 进行 1000 次自增操作。如果一切正常的话，代码的输出结果应该是 10000。但如果你实际运行这段代码，你会发现结果大概率不会是 10000。 出现这个问题的原因也很简单，这 10 个协程分别运行在不同的线程之上，与此同时，这 10 个协程之间还共享着 i 这个变量，并且它们还会以并发的形式对 i 进行自增，所以自然就会产生同步的问题。 所以：Kotlin 协程也需要处理多线程同步的问题。 #2. 协程如何处理并发 #1. 借鉴 Java 的并发思路 首先，由于 Kotlin 协程也是基于 JVM 的，所以，当我们面对并发问题的时候，脑子里第一时间想到的肯定是 Java 当中的同步手段，比如 synchronized、Atomic、Lock，等等。在 Java 当中，最简单的同步方式就是 synchronized 同步了。那么换到 Kotlin 里，就可以使用 @Synchronized 注解来修饰函数，也可以使用 synchronized(){}的方式来实现同步代码块。下面用 synchronized 来改造一下上面的 代码段 2： 123456789101112131415161718192021222324252627282930// 代码段3fun main() = runBlocking { var i = 0 val lock = Any() // 变化在这里 val jobs = mutableListOf&lt;Job&gt;() repeat(10){ val job = launch(Dispatchers.Default) { repeat(1000) { // 变化在这里 synchronized(lock) { i++ } } } jobs.add(job) } jobs.joinAll() println(&quot;i = $i&quot;)}/*输出结果i = 10000*/ 以上代码中，创建了一个 lock 对象，然后使用 synchronized(){} 将“i++”包裹了起来。这样就可以确保在自增的过程中不会出现同步问题。这时候，如果再运行代码，就会发现结果已经是 10000 了。 不过，在实际生产环境中，synchronized 在协程当中也不是一直都很好用的。毕竟，synchronized 是线程模型下的产物。 比如说，假设这里的自增操作需要一些额外的操作，需要用到挂起函数 prepare(): 1234567891011121314151617181920212223242526272829// 代码段4fun main() = runBlocking { suspend fun prepare(){ // 模拟准备工作 } var i = 0 val lock = Any() val jobs = mutableListOf&lt;Job&gt;() repeat(10){ val job = launch(Dispatchers.Default) { repeat(1000) { synchronized(lock) { // 编译器报错！ prepare() i++ } } } jobs.add(job) } jobs.joinAll() println(&quot;i = $i&quot;)} 这时候，就不能真地把协程看作是“Java 线程池的封装”，然后继续照搬 Java 的同步手段了。可以发现：synchronized(){} 当中调用挂起函数，编译器会报错！ 因为这里的挂起函数会被翻译成带有 Continuation 的异步函数，从而就造成了 synchronid 代码块无法正确处理同步。 另外从这个例子里，也可以看出：即使 Kotlin 协程是基于 Java 线程的，但它其实已经脱离 Java 原本的范畴了。所以，单纯使用 Java 的同步手段，是无法解决 Kotlin 协程里所有问题的。 #2. 协程当中的并发思路 由于 Java 的线程模型是阻塞式的，比如说 Thread.sleep()，所以在 Java 当中，并发往往就意味着多线程，而多线程则往往会有状态共享，而状态共享就意味着要处理同步问题。 但是，因为 Kotlin 协程具备挂起、恢复的能力，而且还有非阻塞的特点，所以在使用协程处理并发问题的时候，思路其实可以更宽。比如，可以使用单线程并发。 #1. 单线程并发 在 Kotlin 当中，单线程并发的实现其实非常轻松。不过如果有 Java 开发经验的话，也许会对这个说法产生疑问，因为在 Java 当中，并发往往就意味着多线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 代码段5fun main() = runBlocking { suspend fun getResult1(): String { logX(&quot;Start getResult1&quot;) delay(1000L) // 模拟耗时操作 logX(&quot;End getResult1&quot;) return &quot;Result1&quot; } suspend fun getResult2(): String { logX(&quot;Start getResult2&quot;) delay(1000L) // 模拟耗时操作 logX(&quot;End getResult2&quot;) return &quot;Result2&quot; } suspend fun getResult3(): String { logX(&quot;Start getResult3&quot;) delay(1000L) // 模拟耗时操作 logX(&quot;End getResult3&quot;) return &quot;Result3&quot; } val results: List&lt;String&gt; val time = measureTimeMillis { val result1 = async { getResult1() } val result2 = async { getResult2() } val result3 = async { getResult3() } results = listOf(result1.await(), result2.await(), result3.await()) } println(&quot;Time: $time&quot;) println(results)}/*输出结果================================Start getResult1Thread:main================================================================Start getResult2Thread:main================================================================Start getResult3Thread:main================================================================End getResult1Thread:main================================================================End getResult2Thread:main================================================================End getResult3Thread:main================================Time: 1066[Result1, Result2, Result3]*/ 在上面的代码中启动了三个协程，它们之间是并发执行的，每个协程执行耗时是 1000 毫秒，程序总耗时也是接近 1000 毫秒。而且，这几个协程是运行在同一个线程 main 之上的。 所以，当在协程中面临并发问题的时候，首先可以考虑：是否真的需要多线程？ 如果不需要的话，其实是可以不考虑多线程同步问题的。 那么，对于前面代码段 2 的例子来说，可以把计算的逻辑分发到单一的线程之上： 12345678910111213141516171819202122232425262728// 代码段6fun main() = runBlocking { val mySingleDispatcher = Executors.newSingleThreadExecutor { Thread(it, &quot;MySingleThread&quot;).apply { isDaemon = true } }.asCoroutineDispatcher() var i = 0 val jobs = mutableListOf&lt;Job&gt;() repeat(10) { val job = launch(mySingleDispatcher) { repeat(1000) { i++ } } jobs.add(job) } jobs.joinAll() println(&quot;i = $i&quot;)}/*输出结果i = 10000*/ 可见，在这段代码中，使用“launch(mySingleDispatcher)”，把所有的协程任务都分发到了单线程的 Dispatcher 当中，这样一来，就不必担心同步问题了。另外，如果仔细分析的话，上面创建的 10 个协程之间，其实仍然是并发执行的。 所以这时候，运行上面的代码，就一定可以得到正确的结果了：i = 10000。 #2. Mutex 在 Java 当中，其实还有 Lock 之类的同步锁。但由于 Java 的锁是阻塞式的，会大大影响协程的非阻塞式的特性。所以，在 Kotlin 协程当中，是不推荐直接使用传统的同步锁的，甚至在某些场景下，在协程中使用 Java 的锁也会遇到意想不到的问题。 为此，Kotlin 官方提供了“非阻塞式”的锁：Mutex。下面用 Mutex 来改造代码段 2。 12345678910111213141516171819202122232425// 代码段7fun main() = runBlocking { val mutex = Mutex() var i = 0 val jobs = mutableListOf&lt;Job&gt;() repeat(10) { val job = launch(Dispatchers.Default) { repeat(1000) { // 变化在这里 mutex.lock() i++ mutex.unlock() } } jobs.add(job) } jobs.joinAll() println(&quot;i = $i&quot;)} 在上面的代码中，使用 mutex.lock()、mutex.unlock() 包裹了需要同步的计算逻辑，这样一来，代码就可以实现多线程同步了，程序的输出结果也会是 10000。 实际上，Mutex 对比 JDK 当中的锁，最大的优势就在于支持挂起和恢复。它的源码定义如下： 1234567891011// 代码段8public interface Mutex { public val isLocked: Boolean // 注意这里 // ↓ public suspend fun lock(owner: Any? = null) public fun unlock(owner: Any? = null)} 可以看到，Mutex 是一个接口，它的 lock() 方法其实是一个挂起函数。而这就是实现非阻塞式同步锁的根本原因。 不过，在代码段 7 当中，对于 Mutex 的使用其实是错误的。因为这样的做法并不安全，有如下一个场景： 123456789101112131415161718192021222324252627282930// 代码段9fun main() = runBlocking { val mutex = Mutex() var i = 0 val jobs = mutableListOf&lt;Job&gt;() repeat(10) { val job = launch(Dispatchers.Default) { repeat(1000) { try { mutex.lock() i++ i/0 // 故意制造异常 mutex.unlock() } catch (e: Exception) { println(e) } } } jobs.add(job) } jobs.joinAll() println(&quot;i = $i&quot;)}// 程序无法退出 以上代码会在 mutex.lock()、mutex.unlock() 之间发生异常，从而导致 mutex.unlock() 无法被调用。这个时候，整个程序的执行流程就会一直卡住，无法结束。 所以，为了避免出现这样的问题，应该使用 Kotlin 提供的一个扩展函数：mutex.withLock{}。 12345678910111213141516171819202122232425262728293031323334// 代码段10fun main() = runBlocking { val mutex = Mutex() var i = 0 val jobs = mutableListOf&lt;Job&gt;() repeat(10) { val job = launch(Dispatchers.Default) { repeat(1000) { // 变化在这里 mutex.withLock { i++ } } } jobs.add(job) } jobs.joinAll() println(&quot;i = $i&quot;)}// withLock的定义public suspend inline fun &lt;T&gt; Mutex.withLock(owner: Any? = null, action: () -&gt; T): T { lock(owner) try { return action() } finally { unlock(owner) }} 可以看到，withLock{} 的本质，其实是在 finally{} 当中调用了 unlock()。这样一来，就再也不必担心因为异常导致 unlock() 无法执行的问题了。 #3. Actor Actor，是在很多编程语言当中都存在的一个并发同步模型。在 Kotlin 当中，也同样存在这样的模型，它本质上是基于 Channel 管道消息实现的。下面看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 代码段11sealed class Msgobject AddMsg : Msg()class ResultMsg( val result: CompletableDeferred&lt;Int&gt;) : Msg()fun main() = runBlocking { suspend fun addActor() = actor&lt;Msg&gt; { var counter = 0 for (msg in channel) { when (msg) { is AddMsg -&gt; counter++ is ResultMsg -&gt; msg.result.complete(counter) } } } val actor = addActor() val jobs = mutableListOf&lt;Job&gt;() repeat(10) { val job = launch(Dispatchers.Default) { repeat(1000) { actor.send(AddMsg) } } jobs.add(job) } jobs.joinAll() val deferred = CompletableDeferred&lt;Int&gt;() actor.send(ResultMsg(deferred)) val result = deferred.await() actor.close() println(&quot;i = ${result}&quot;)} 在这段代码中，定义了 addActor() 这个挂起函数，而它其实调用了 actor() 这个高阶函数。而这个函数的返回值类型其实是 SendChannel。由此可见，Kotlin 当中的 Actor 其实就是 Channel 的简单封装 。Actor 的多线程同步能力都源自于 Channel。 这里，借助密封类定义了两种消息类型，AddMsg、ResultMsg，然后在 actor{} 内部，处理这两种消息类型，如果收到了 AddMsg，则计算“i++”；如果收到了 ResultMsg，则返回计算结果。而在 actor{} 的外部，只需要发送 10000 次的 AddMsg 消息，最后再发送一次 ResultMsg，取回计算结果即可。 AddMsg、ResultMsg 是在多线程并行发送的，而 Channel 可以保证接收到的消息可以同步接收并处理。所以，Actor 本质上是基于 Channel 管道消息实现的。 补充：Kotlin 目前的 Actor 实现其实还比较简陋，在不远的将来，Kotlin 官方会对 Actor API 进行重构，具体可以参考这个 链接 。虽然它的 API 可能会改变，但核心理念应该是不会变的。 #3. 反思：可变状态 到现在为止，已经学习了三种协程并发的思路。不过还要反思一个问题：多线程并发，一定需要同步机制吗？ 前面提到过，多线程并发，往往会有共享的可变状态，而共享可变状态的时候，就需要考虑同步问题。 弄清楚这一点后，其实可以找到一个新的思路：避免共享可变状态。有了这个思路以后，代码其实就非常容易实现了： 123456789101112131415161718192021222324// 代码段12fun main() = runBlocking { val deferreds = mutableListOf&lt;Deferred&lt;Int&gt;&gt;() repeat(10) { val deferred = async (Dispatchers.Default) { var i = 0 repeat(1000) { i++ } return@async i } deferreds.add(deferred) } var result = 0 deferreds.forEach { result += it.await() } println(&quot;i = $result&quot;)} 在上面的代码中，不再共享可变状态 i，对应的，在每一个协程当中，都有一个局部的变量 i，同时将 launch 都改为了 async，让每一个协程都可以返回计算结果。 这种方式，相当于将 10000 次计算，平均分配给了 10 个协程，让它们各自计算 1000 次。这样一来，每个协程都可以进行独立的计算，然后将 10 个协程的结果汇总起来，最后累加在一起。 其实，上面的思路，也是借鉴自函数式编程的思想，因为在函数式编程当中，就是追求不变性、无副作用。不过，以上代码其实还是命令式的代码，如果用函数式风格来重构的话，代码会更加简洁。 1234567891011121314151617// 代码段13fun main() = runBlocking { val result = (1..10).map { async (Dispatchers.Default) { var i = 0 repeat(1000) { i++ } return@async i } }.awaitAll() .sum() println(&quot;i = $result&quot;)} 上面的代码中，使用函数式风格代码重构了代码段 12，仍然创建了 10 个协程，并发了计算了 10000 次自增操作。 函数式编程的一大优势就在于，它具有不变性、无副作用的特点，所以无惧并发编程。上面的这个代码案例，其实就体现出了 Kotlin 函数式编程的这个优势。 #三、异常原因及处理 比起 Kotlin 协程的语法知识点，协程的异常处理，其实更难掌握。协程就是互相协作的程序，协程是结构化的。 正因为 Kotlin 协程有这两个特点，这就导致它的异常处理机制与普通的程序完全不一样。 换句话说：如果把 Java 里的那一套异常处理机制，照搬到 Kotlin 协程里来，一定会水土不服。因为在普通的程序当中，使用 try-catch 就能解决大部分的异常处理问题，但是在协程当中，根据不同的协程特性，它的异常处理策略是随之变化的。 在 Kotlin 协程当中，通常把异常分为两大类，一类是取消异常 （CancellationException），另一类是其他异常。之所以要这么分类，是因为在 Kotlin 协程当中，这两种异常的处理方式是不一样的。或者说，在 Kotlin 协程所有的异常当中，需要把 CancellationException 单独拎出来，特殊对待。 #1. 取消异常（CancellationException） 要知道，当协程任务被取消的时候，它的内部是会产生一个 CancellationException 的。而协程的结构化并发，最大的优势就在于：如果我们取消了父协程，子协程也会跟着被取消。但是很多初学者都会遇到一个问题，那就是协程无法被取消。这里，主要涉及了三个场景，下面来一一分析下。 #场景 1：cancel() 不被响应 12345678910111213141516171819202122232425262728293031// 代码段1fun main() = runBlocking { val job = launch(Dispatchers.Default) { var i = 0 while (true) { Thread.sleep(500L) i ++ println(&quot;i = $i&quot;) } } delay(2000L) job.cancel() job.join() println(&quot;End&quot;)}/*输出结果i = 1i = 2i = 3i = 4i = 5// 永远停不下来*/ 在上面的代码中，启动了一个协程，在这个协程的内部，一直对 i 进行自增。过了 2000 毫秒以后，调用了 job.cancel()。但通过运行的结果，可以看到协程并不会被取消。这是为什么呢？ 因为协程是互相协作的程序。因此，对于协程任务的取消，也是需要互相协作的。协程外部取消，协程内部需要做出响应才行。具体来说，可以在协程体中加入状态判断： 12345678910111213141516171819202122232425262728293031// 代码段2fun main() = runBlocking { val job = launch(Dispatchers.Default) { var i = 0 // 变化在这里 while (isActive) { Thread.sleep(500L) i ++ println(&quot;i = $i&quot;) } } delay(2000L) job.cancel() job.join() println(&quot;End&quot;)}/*输出结果i = 1i = 2i = 3i = 4i = 5End*/ 在这段代码里，把 while 循环的条件改成了 while (isActive)，这就意味着，只有协程处于活跃状态的时候，才会继续执行循环体内部的代码。 这里，进一步分析 代码段 1 无法取消的原因：当调用 job.cancel() 以后，协程任务已经不是活跃状态了，但代码并没有把 isActive 作为循环条件，因此协程无法真正取消。 所以到这里，就可以总结出协程异常处理的第一准则了：协程的取消需要内部的配合。 #场景 2：结构被破坏 协程是结构化的，当取消父协程的时候，子协程也会跟着被取消，如下图： 但在某些情况下，嵌套创建的子协程并不会跟随父协程一起取消，比如下面这个案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 代码段3val fixedDispatcher = Executors.newFixedThreadPool(2) { Thread(it, &quot;MyFixedThread&quot;).apply { isDaemon = false }}.asCoroutineDispatcher()fun main() = runBlocking { // 父协程 val parentJob = launch(fixedDispatcher) { // 1，注意这里 launch(Job()) { // 子协程1 var i = 0 while (isActive) { Thread.sleep(500L) i ++ println(&quot;First i = $i&quot;) } } launch { // 子协程2 var i = 0 while (isActive) { Thread.sleep(500L) i ++ println(&quot;Second i = $i&quot;) } } } delay(2000L) parentJob.cancel() parentJob.join() println(&quot;End&quot;)}/*输出结果First i = 1Second i = 1First i = 2Second i = 2Second i = 3First i = 3First i = 4Second i = 4EndFirst i = 5First i = 6// 子协程1永远不会停下来*/ 以上代码中，创建了一个 fixedDispatcher，它是由两个线程的线程池实现的。接着，通过 launch 创建了三个协程，其中 parentJob 是父协程，随后等待 2000 毫秒，然后取消父协程。 不过，通过程序的运行结果发现，虽然“子协程 1 ”当中使用了 while(isActive) 作为判断条件，它也仍然无法被取消。其实，这里的主要原因还是在 注释 1 处，在创建子协程的时候，使用了 launch(Job()){}。而这种创建方式，就打破了原有的协程结构。下图描述了它们之间的父子关系。 根据这张图，可以看到“子协程 1 ”已经不是 parentJob 的子协程了，而对应的，它的父 Job 是在 launch 当中传入的 Job() 对象。所以，在这种情况下，调用 parentJob.cancel() 的时候，自然也就无法取消“子协程 1”了。 所以，如果稍微改动一下上面的代码，不传入 Job()，程序就可以正常运行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 代码段4fun main() = runBlocking { val parentJob = launch(fixedDispatcher) { // 变化在这里 launch { var i = 0 while (isActive) { Thread.sleep(500L) i ++ println(&quot;First i = $i&quot;) } } launch { var i = 0 while (isActive) { Thread.sleep(500L) i ++ println(&quot;Second i = $i&quot;) } } } delay(2000L) parentJob.cancel() parentJob.join() println(&quot;End&quot;)}/*输出结果First i = 1Second i = 1First i = 2Second i = 2First i = 3Second i = 3First i = 4Second i = 4End*/ 在上面的代码中，parentJob 与它内部的子协程 1 、子协程 2 之间是父子关系，因此它们两个都是会响应协程取消的事件的。这时候，它们之间的关系就变成了下图这样： 那么到这里，其实就可以总结出第二条准则了：不要轻易打破协程的父子结构！ #场景 3：未正确处理 CancellationException 其实，对于 Kotlin 提供的挂起函数，它们是可以自动响应协程的取消的，比如说，当把 Thread.sleep(500) 改为 delay(500) 以后，就不需要在 while 循环当中判断 isActive 了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 代码段5fun main() = runBlocking { val parentJob = launch(Dispatchers.Default) { launch { var i = 0 while (true) { // 变化在这里 delay(500L) i ++ println(&quot;First i = $i&quot;) } } launch { var i = 0 while (true) { // 变化在这里 delay(500L) i ++ println(&quot;Second i = $i&quot;) } } } delay(2000L) parentJob.cancel() parentJob.join() println(&quot;End&quot;)}/*输出结果First i = 1Second i = 1First i = 2Second i = 2First i = 3Second i = 3End*/ 实际上，对于 delay() 函数来说，它可以自动检测当前的协程是否已经被取消，如果已经被取消的话，它会抛出一个 CancellationException，从而终止当前的协程。 为了证明这一点，可以在以上代码的基础上，增加一个 try-catch。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 代码段6fun main() = runBlocking { val parentJob = launch(Dispatchers.Default) { launch { var i = 0 while (true) { // 1 try { delay(500L) } catch (e: CancellationException) { println(&quot;Catch CancellationException&quot;) // 2 throw e } i ++ println(&quot;First i = $i&quot;) } } launch { var i = 0 while (true) { delay(500L) i ++ println(&quot;Second i = $i&quot;) } } } delay(2000L) parentJob.cancel() parentJob.join() println(&quot;End&quot;)}/*输出结果First i = 1Second i = 1First i = 2Second i = 2First i = 3Second i = 3Second i = 4Catch CancellationExceptionEnd*/ 看注释 1 ，在用 try-catch 包裹了 delay() 以后，就可以在输出结果中，看到“Catch CancellationException”，这就说明 delay() 确实可以自动响应协程的取消，并且产生 CancellationException 异常。 不过，以上代码中，最重要的其实是 注释 2 ：“throw e”。当捕获到 CancellationException 以后，还要把它重新抛出去。而如果删去这行代码的话，子协程将同样无法被取消。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 代码段7fun main() = runBlocking { val parentJob = launch(Dispatchers.Default) { launch { var i = 0 while (true) { try { delay(500L) } catch (e: CancellationException) { println(&quot;Catch CancellationException&quot;) // 1，注意这里 // throw e } i ++ println(&quot;First i = $i&quot;) } } launch { var i = 0 while (true) { delay(500L) i ++ println(&quot;Second i = $i&quot;) } } } delay(2000L) parentJob.cancel() parentJob.join() println(&quot;End&quot;)}/*输出结果输出结果First i = 1Second i = 1First i = 2Second i = 2First i = 3Second i = 3Second i = 4..First i = 342825Catch CancellationException// 程序将永远无法终止*/ 可见，在这段代码中，把“throw e”这行代码注释掉，重新运行之后，程序就永远无法终止了。这主要是因为，捕获了 CancellationException 以后没有重新抛出去，就导致子协程无法正常取消。 所以到这里，可以总结出第三条准则：捕获了 CancellationException 以后，要考虑是否应该重新抛出来。 到这里，就通过协程取消异常的三个场景，总结了三条准则，来应对 CancellationException 这个特殊的异常。那么接下来，再来看看如何在协程当中处理普通的异常。 #2. 在协程当中处理普通的异常 #1. try-catch 在 Kotlin 协程当中，try-catch 并非万能的。有时候，即使你用 try-catch 包裹了可能抛异常的代码，软件仍然会崩溃。 12345678910111213141516171819202122// 代码段8fun main() = runBlocking { try { launch { delay(100L) 1 / 0 // 故意制造异常 } } catch (e: ArithmeticException) { println(&quot;Catch: $e&quot;) } delay(500L) println(&quot;End&quot;)}/*输出结果：崩溃Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 在这段代码中，使用 try-catch 包裹了 launch{}，在协程体内部，制造了一个异常。从运行结果这里可以看到，try-catch 并没有成功捕获异常，程序等待了 100 毫秒左右，最终还是崩溃了。 类似的，如果把代码段 8 当中的 launch 换成 async，结果也是差不多的： 12345678910111213141516171819202122232425// 代码段9fun main() = runBlocking { var deferred: Deferred&lt;Unit&gt;? = null try { deferred = async { delay(100L) 1 / 0 } } catch (e: ArithmeticException) { println(&quot;Catch: $e&quot;) } deferred?.await() delay(500L) println(&quot;End&quot;)}/*输出结果：崩溃Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 其实，这种 try-catch 失效的问题，主要就是因为，当协程体当中的“1/0 ”执行的时候，我程序已经跳出 try-catch 的作用域了。当然，要解决这两个问题也很容易。对于代码段 8 来说，可以挪动一下 try-catch 的位置，比如说这样： 1234567891011121314151617181920212223// 代码段10fun main() = runBlocking { launch { try { delay(100L) 1 / 0 // 故意制造异常 } catch (e: ArithmeticException) { println(&quot;Catch: $e&quot;) } } delay(500L) println(&quot;End&quot;)}/*输出结果：Catch: java.lang.ArithmeticException: / by zeroEnd*/ 也就是说，可以把 try-catch 挪到 launch{} 协程体内部。这样一来，它就可以正常捕获到 ArithmeticException 这个异常了。而对于代码段 9 的 async 的这个例子，其实有两种解决手段，其中一种跟上面的做法一样，把 try-catch 挪到了 async{} 协程体内部，比如这样： 1234567891011121314151617181920// 代码段11fun main() = runBlocking { var deferred: Deferred&lt;Unit&gt;? = null deferred = async { try { delay(100L) 1 / 0 } catch (e: ArithmeticException) { println(&quot;Catch: $e&quot;) } } deferred?.await() delay(500L) println(&quot;End&quot;)} 到这里，可以总结出第四条准则了：不要用 try-catch 直接包裹 launch、async。 #谣言一：使用 try-catch 包裹“deferred.await()” 接下来，再看看 async 避免异常的另外一种手段，可以使用 try-catch 包裹“deferred.await()”。来看看是否可行： 12345678910111213141516171819202122232425// 代码段12fun main() = runBlocking { val deferred = async { delay(100L) 1 / 0 } try { deferred.await() } catch (e: ArithmeticException) { println(&quot;Catch: $e&quot;) } delay(500L) println(&quot;End&quot;)}/*输出结果Catch: java.lang.ArithmeticException: / by zero崩溃：Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 那么，根据以上程序的运行结果可以看到，这样做其实是行不通的。 #谣言二：await() 如果不调用的话，async 当中的异常甚至不会发生 123456789101112131415161718// 代码段13fun main() = runBlocking { val deferred = async { delay(100L) 1 / 0 } delay(500L) println(&quot;End&quot;)}/*输出结果崩溃：Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 可见，async 当中产生异常，即使不调用 await() 同样是会导致程序崩溃的。 #2. SupervisorJob #1. 不调用 await() 就不会发生异常 实际上，如果要使用 try-catch 包裹“deferred.await()”的话，还需要配合 SupervisorJob 一起使用。也就是说，借助 SupervisorJob 来改造代码段 13 的话，就可以实现“不调用 await() 就不会产生异常而崩溃”。 123456789101112131415161718// 代码段14fun main() = runBlocking { val scope = CoroutineScope(SupervisorJob()) scope.async { delay(100L) 1 / 0 } delay(500L) println(&quot;End&quot;)}/*输出结果End*/ 可以看到，当使用 SupervisorJob 创建一个 scope 以后，用 scope.async{}启动协程后，只要不调用“deferred.await()”，程序就不会因为异常而崩溃。 所以同样的，也能用类似的办法来改造代码段 12 当中的逻辑： 1234567891011121314151617181920212223242526// 代码段15fun main() = runBlocking { val scope = CoroutineScope(SupervisorJob()) // 变化在这里 val deferred = scope.async { delay(100L) 1 / 0 } try { deferred.await() } catch (e: ArithmeticException) { println(&quot;Catch: $e&quot;) } delay(500L) println(&quot;End&quot;)}/*输出结果Catch: java.lang.ArithmeticException: / by zeroEnd*/ 在上面的代码中，仍然使用“scope.async {}”创建了协程，同时也用 try-catch 包裹“deferred.await()”，这样一来，这个异常就成功地被捕获了。 #2. SupervisorJob 源码 12345678910111213// 代码段16public fun SupervisorJob(parent: Job? = null) : CompletableJob = SupervisorJobImpl(parent)public interface CompletableJob : Job { public fun complete(): Boolean public fun completeExceptionally(exception: Throwable): Boolean} 根据以上代码，可以看到，SupervisorJob() 其实不是构造函数，它只是一个普通的顶层函数。而这个方法返回的对象，是 Job 的子类。 SupervisorJob 与 Job 最大的区别就在于，当它的子 Job 发生异常的时候，其他的子 Job 不会受到牵连。下图演示普通 Job 与 SupervisorJob 之间的差异。 这个是普通 Job，对于子 Job 出现异常时的应对策略。可以看到，由于 parentJob 是一个普通的 Job 对象，当 job1 发生异常之后，它会导致 parentJob 取消，进而导致 job2、job3 也受到牵连。而这时候，如果把 parentJob 改为 SupervisorJob，job1 发生异常的的话，就不会影响到其他的 Job 了。 所以，可以总结出第五条准则：灵活使用 SupervisorJob，控制异常传播的范围。 提示：并非所有情况下，都应该使用 SupervisorJob，有时候 Job 会更合适，这要结合实际场景分析。 #3. CoroutineExceptionHandler 由于协程是结构化的，当协程任务出现复杂的层级时，这两种手段其实都无法很好的应对。所以这个时候，就需要 CoroutineExceptionHandler 出场了。 对于 CoroutineExceptionHandler，它是 CoroutineContext 的元素之一，在创建协程的时候，可以指定对应的 CoroutineExceptionHandler。 1234567891011121314151617181920212223242526272829303132// 代码段17fun main() = runBlocking { val scope = CoroutineScope(coroutineContext) scope.launch { async { delay(100L) } launch { delay(100L) launch { delay(100L) 1 / 0 // 故意制造异常 } } delay(100L) } delay(1000L) println(&quot;End&quot;)}/*输出结果Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 在上面的代码中，模拟了一个复杂的协程嵌套场景。对于这样的情况，其实很难一个个在每个协程体里面去写 try-catch。所以这时候，为了捕获到异常，就可以使用 CoroutineExceptionHandler 了。 123456789101112131415161718192021222324252627282930313233343536// 代码段18fun main() = runBlocking { val myExceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; println(&quot;Catch exception: $throwable&quot;) } // 注意这里 val scope = CoroutineScope(coroutineContext + Job() + myExceptionHandler) scope.launch { async { delay(100L) } launch { delay(100L) launch { delay(100L) 1 / 0 // 故意制造异常 } } delay(100L) } delay(1000L) println(&quot;End&quot;)}/*Catch exception: ArithmeticException: / by zeroEnd*/ 以上代码中，定义了一个 CoroutineExceptionHandler，然后把它传入了 scope 当中，这样一来，就可以捕获其中所有的异常了。 #CoroutineExceptionHandler不起作用的情景 如果使用错误的话，CoroutineExceptionHandler 会不起作用。 12345678910111213141516171819202122232425262728293031// 代码段19fun main() = runBlocking { val myExceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; println(&quot;Catch exception: $throwable&quot;) } // 不再传入myExceptionHandler val scope = CoroutineScope(coroutineContext) scope.launch { async { delay(100L) } launch { delay(100L) // 变化在这里 launch(myExceptionHandler) { delay(100L) 1 / 0 } } delay(100L) } delay(1000L) println(&quot;End&quot;)}/*输出结果崩溃：Exception in thread &quot;main&quot; ArithmeticException: / by zero*/ 注意上面的注释，把自定义的 myExceptionHandler，放到出现异常的 launch 那里传了进去。按理说，程序的执行结果是不会发生变化才对的。但实际上，myExceptionHandler 并不会起作用，异常不会被它捕获。 对比代码段 18 和代码段 19 发现，myExceptionHandler 直接定义在发生异常的位置反而不生效，而定义在最顶层却可以生效！ 其实，出现这种现象的原因，就是因为：CoroutineExceptionHandler 只在顶层的协程当中才会起作用。也就是说，当子协程当中出现异常以后，它们都会统一上报给顶层的父协程，然后顶层的父协程才会去调用 CoroutineExceptionHandler，来处理对应的异常。 那么到这里，就可以总结出第六条准则了：使用 CoroutineExceptionHandler 处理复杂结构的协程异常，它仅在顶层协程中起作用。 #3. 总结 在 Kotlin 协程当中，异常主要分为两大类，一类是协程取消异常 （CancellationException） ，另一类是其他异常。为了处理这两大类问题，一共总结出了 6 大准则： 第一条准则：协程的取消需要内部的配合。 第二条准则：不要轻易打破协程的父子结构！ 这一点，其实不仅仅只是针对协程的取消异常，而是要贯穿于整个协程的使用过程中。协程的优势在于结构化并发，它的许多特性都是建立在这个特性之上的，如果无意中打破了它的父子结构，就会导致协程无法按照预期执行。 第三条准则：捕获了 CancellationException 以后，要考虑是否应该重新抛出来。 在协程体内部，协程是依赖于 CancellationException 来实现结构化取消的，有的时候出于某些目的需要捕获 CancellationException，但捕获完以后，还需要思考是否需要将其重新抛出来。 第四条准则：不要用 try-catch 直接包裹 launch、async。 考虑到协程代码的执行顺序与普通程序不一样，直接使用 try-catch 包裹 launch、async，是不会有任何效果的。 第五条准则：灵活使用 SupervisorJob，控制异常传播的范围。 SupervisorJob 是一种特殊的 Job，它可以控制异常的传播范围。普通的 Job，它会因为子协程当中的异常而取消自身，而 SupervisorJob 则不会受到子协程异常的影响。在很多业务场景下，都不希望子协程影响到父协程，所以 SupervisorJob 的应用范围也非常广。比如说 Android 当中的 viewModelScope，它就使用了 SupervisorJob，这样一来，App 就不会因为某个子协程的异常导致整个应用的功能出现紊乱。 第六条准则：使用 CoroutineExceptionHandler 处理复杂结构的协程异常，它仅在顶层协程中起作用。 传统的 try-catch 在协程当中并不能解决所有问题，尤其是在协程嵌套层级较深的情况下。这时候，Kotlin 官方提供了 CoroutineExceptionHandler 作为补充。有了它，可以轻松捕获整个作用域内的所有异常。 当遇到问题的时候，首先要分析是 CancellationException 导致的，还是其他异常导致的。接着就可以根据实际情况去思考，该用哪种处理手段了。 另外总结出的 6 大准则，其实都跟协程的结构化并发有着密切联系。由于协程之间存在父子关系，因此它的异常处理也是遵循这一规律的。而协程的异常处理机制之所以这么复杂，也是因为它的结构化并发特性。所以，除了这 6 大准则以外，还可以总结出一个核心理念：因为协程是“结构化的”，所以异常传播也是“结构化的”。 #四、 实战：让KtHttp支持Flow 在kotlin学习系列十的第六章第四节中 KtHttp 4.0 版本，为了支持挂起函数，有两种思路，一种是改造内部，另一种是扩展外部。同理，为了让 KtHttp 支持 Flow，这次的实战也是这两种思路。 5.0 版本，基于 4.0 版本的代码，从 KtHttp 的外部扩展 出 Flow 的能力。 6.0 版本，修改 KtHttp 内部 ，让它支持 Flow API。 这两种思路对应两种情况，在实际的工作中，往往没有权限修改第三方提供的 SDK，那么这时候，如果想要让 SDK 获得 Flow 的能力，就只能借助 Kotlin 的扩展函数，为它扩展出 Flow 的能力。而对于工程内部的代码，希望某个功能模块获得 Flow 的能力，就可以直接修改它的源代码，让它直接支持 Flow。 #5.0 版本：Callback 转 Flow 在kotlin学习系列十的第六章中 在 3.0 版本里，实现了 KtHttp 的异步 Callback 请求。之后在 4.0版本里，并没有改动 KtHttp 的源代码，而是直接在 KtCall 的基础上扩展了挂起函数的支持。回顾一下之前的代码： 123456789101112131415161718192021222324252627// 代码段1// 扩展函数suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =// 暴露挂起函数的continuation// ↓ suspendCancellableCoroutine { continuation -&gt; val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { println(&quot;Request success!&quot;) continuation.resume(data) } override fun onFail(throwable: Throwable) { println(&quot;Request fail!：$throwable&quot;) continuation.resumeWithException(throwable) } })// 响应取消事件// ↓ continuation.invokeOnCancellation { println(&quot;Call cancelled!&quot;) call.cancel() } } 上面这种做法非常适合针对第三方 SDK 的扩展，而这一切，都要归功于 Kotlin 的扩展函数特性。现在希望 KtHttp 支持 Flow，其实也同样可以借助扩展函数来实现。Kotlin 官方提供了一个 API：callbackFlow，它就是专门用于将 Callback 转为 Flow 的。 #1. callbackFlow Callback 转 Flow，用法跟 Callback 转挂起函数是差不多的。如果你去分析代码段 1 当中的代码模式，会发现 Callback 转挂起函数，主要有三个步骤。 第一步：使用 suspendCancellableCoroutine 执行 Callback 代码，等待 Callback 回调； 第二步：将 Callback 回调结果传出去，onSuccess 的情况就传结果，onFail 的情况就传异常； 第三步：响应协程取消事件 invokeOnCancellation{}。 所以使用 callbackFlow，也是这样三个步骤。 123456789101112131415161718192021// 代码段2fun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow { val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { // 1 trySend(data) } override fun onFail(throwable: Throwable) { // 2 close(throwable) } }) awaitClose { call.cancel() }} 从上面的代码中发现，callbackFlow 的底层用到了 Channel，所以你可以使用 trySend() 这样的 API。这个 API 其实就是 Channel.send() 的非挂起函数 版本的 API。但，它仍然还有优化空间。 #2. trySend() 与 trySendBlocking() 注释 1，这里使用 trySend()，虽然在这个案例当中用这个 API 确实没问题，但在大部分场景下，它其实是不够稳妥的。通过查看它的源码文档，会看到它的返回值类型是 ChannelResult，代表 trySend() 的执行结果是成功还是失败。 123// 代码段3public fun trySend(element: E): ChannelResult&lt;Unit&gt; 也就是说，如果往 Channel 当中成功地添加了元素，那么 trySend() 的返回值就是成功，如果当前的 Channel 管道已经满了，那么 trySend() 的返回值就是失败。 其实，当 Channel 管道容量已满的时候，更希望 trySend() 可以多等等，直到管道容量空闲以后再返回成功。所以这时候，可以使用 trySendBlocking() 来替代它。它是 Kotlin 协程 1.5 出现的一个新的 API。 123456789101112131415161718192021// 代码段4fun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow { val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { // 1，变化在这里 trySendBlocking(data) } override fun onFail(throwable: Throwable) { // 2 close(throwable) } }) awaitClose { call.cancel() }} 不过，这里仅仅只是改为 trySendBlocking() 仍然还不够，运行一下程序： 123456789101112131415161718192021222324252627282930// 代码段5interface ApiServiceV5 { @GET(&quot;/repo&quot;) fun repos( @Field(&quot;lang&quot;) lang: String, @Field(&quot;since&quot;) since: String ): KtCall&lt;RepoList&gt;}fun main() = runBlocking { testFlow()}private suspend fun testFlow() = KtHttpV5.create(ApiServiceV5::class.java) .repos(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) .asFlow() .catch { println(&quot;Catch: $it&quot;) } .collect { println(it) }/*输出正常程序不会终止*/ 可以看到，程序不会终止，其实，问题的原因也很简单，由于 callbackFlow 的底层是 Channel 实现的，在用完它以后，应该主动将其关闭或者释放。不然的话，它就会一直占用计算机资源。所以这时候，可以进一步完善 trySendBlocking() 这部分的代码。 12345678910111213141516171819202122232425262728// 代码段6fun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow { val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { // 1，变化在这里 trySendBlocking(data) .onSuccess { close() } .onFailure { close(it) } } override fun onFail(throwable: Throwable) { close(throwable) } }) awaitClose { call.cancel() }}/*输出结果输出正常程序等待一会后自动终止*/ 上面代码中的 onSuccess、onFailure 其实就相当于回调，在这里，不管是成功还是失败，都主动把 callbackFlow 当中的 Channel 关闭。这样一来，程序就可以正常终止了。 提示：在大部分场景下 trySendBlocking() 会比 trySend() 更稳妥一些，因为它会尽可能发送成功。但在某些特殊情况下，trySend() 也有它的优势，因为它不会出现阻塞问题。 现在为止，5.0 版本的代码已经算是合格了。 #3. callbackFlow 的 close() 下面介绍下 callbackFlow 的一些使用细节：close() 与 close(throwable)。 close() 这个方法，既可以传入异常，也可以不传入。不过，这两者在 callbackFlow 当中是有差异的。如果将代码段 6 当中所有的 close(throwable) 都改为不传异常的话，程序代码也会出现问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 代码段7// 错误示范！错误示范！错误示范！fun main() = runBlocking { testFlow()}private suspend fun testFlow() = KtHttpV5.create(ApiServiceV5::class.java) .repos(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) .asFlow() .catch { println(&quot;Catch: $it&quot;) } .collect { println(it) }fun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow { val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { trySendBlocking(data) .onSuccess { close() } .onFailure { // 变化在这里 close() } } override fun onFail(throwable: Throwable) { // 变化在这里 close() } }) awaitClose { call.cancel() }}/*断网执行以上代码：不会有任何结果，连异常信息都没有*/ 在以上代码中，断网执行了这段程序，但在控制台上看不到任何异常的输出信息。这就是因为，调用 close() 的时候没有传入异常信息。 所以，在 callbackFlow 当中的异常分支里，如果使用 close()，一定要带上对应的异常，就像代码段 6 的那样“close(throwable)”。或者，为了防止在开发的过程中忘记传入异常信息，可以使用 cancel() 方法。就像下面这样： 1234567891011121314151617181920212223242526272829// 代码段8fun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow { val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { trySendBlocking(data) .onSuccess { close() } .onFailure { // 变化在这里 cancel(CancellationException(&quot;Send channel fail!&quot;, it)) } } override fun onFail(throwable: Throwable) { // 变化在这里 cancel(CancellationException(&quot;Request fail!&quot;, throwable)) } }) awaitClose { call.cancel() }}/*断网执行Catch: java.util.concurrent.CancellationException: Request fail!*/ 根据这里的运行结果，可以看到，把 close() 改成 cancel() 以后，程序运行结果也符合预期。而 cancel 其实还有一个优势：就算不小心忘记传 throwable，还是可以看到一个 CancellationException。 不过总的来说，只要可以记住传入异常信息，close() 和 cancel() 两者的差别并不大。 另外还有一点，如果在 callbackFlow 当中还启动了其他的协程任务，close() 和 cancel() 也同样可以取消对应的协程。如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 代码段9fun main() = runBlocking { testFlow()}private suspend fun testFlow() = KtHttpV5.create(ApiServiceV5::class.java) .repos(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) .asFlow() // 注意这里 .catch { println(&quot;Catch: $it&quot;) } .collect { println(it) }fun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow { val job = launch { println(&quot;Coroutine start&quot;) delay(3000L) println(&quot;Coroutine end&quot;) // 没有机会执行 } job.invokeOnCompletion { println(&quot;Coroutine completed $it&quot;) } val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { trySendBlocking(data) .onSuccess { close() } .onFailure { cancel(CancellationException(&quot;Send channel fail!&quot;, it)) } } override fun onFail(throwable: Throwable) { cancel(CancellationException(&quot;Request fail!&quot;, throwable)) } }) awaitClose { call.cancel() }}/*断网执行Coroutine startCoroutine completed java.util.concurrent.CancellationException: Request fail!Catch: java.util.concurrent.CancellationException: Request fail!*/ 可以看到，由于协程是结构化的，所以，当取消 callbackFlow 的时候，在它内部创建的协程 job，也会跟着被取消。而且，它的异常信息也是一样的。 不过，如果把上面的 launch{} 改成了“launch(Job()){}”，那么，协程任务就不会跟随 callbackFlow 一起被取消了。这是因为，它们的协程的父子关系已经被破坏了！ 最后，awaitClose{} 这个挂起函数，它的作用其实就是监听 callbackFlow 的生命周期，当它被关闭或者取消的时候，应该同时把 OkHttp 当中的网络请求也取消掉。它的作用，跟代码段 1 当中的 continuation.invokeOnCancellation{} 是类似的。 #6.0 版本：直接支持 Flow 实际上，对于 KtHttp 来说，4.0 版本、5.0 版本都只是外部扩展，对 KtHttp 的内部源代码并没有做改动。 而对于 6.0 版本的开发，其实是希望 KtHttp 可以直接支持返回 Flow 类型的数据，也就是这样： 12345678910111213141516// 代码段10interface ApiServiceV5 { @GET(&quot;/repo&quot;) fun repos( @Field(&quot;lang&quot;) lang: String, @Field(&quot;since&quot;) since: String ): KtCall&lt;RepoList&gt; @GET(&quot;/repo&quot;) fun reposFlow( @Field(&quot;lang&quot;) lang: String, @Field(&quot;since&quot;) since: String ): Flow&lt;RepoList&gt; // 注意这里} 留意上面的代码注释，在 ApiServiceV5 当中，定义了一个接口方法 reposFlow()，它的返回值类型是 Flow，而不是之前的 KtCall。这样一来，在 main() 函数当中使用它的时候，就不需要使用 asFlow() 这个扩展函数了。就像下面这样： 123456789101112131415// 代码段11private suspend fun testFlow() = KtHttpV5.create(ApiServiceV5::class.java) .reposFlow(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) // 注意这里不需要asFlow，因为reposFlow()返回值类型就是Flow .catch { println(&quot;Catch: $it&quot;) } .collect { println(it) }fun main() = runBlocking { testFlow()} 可以看到，当把 reposFlow() 的返回值类型定义成 Flow 以后，就需要改动 KtHttp 的源代码了。因为，它的内部需要根据这种情况做一些特殊的判断。 其实，在前面 3.0 版本的开发中，就已经做过一次判断了。当时，特地判断了一下，返回值类型是 KtCall 还是T。重新回顾一下当时的代码细节： 12345678910111213141516171819// 代码段12private fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略部分代码 return if (isKtCallReturn(method)) { // 返回值类型是KtCall&lt;RepoList&gt; val genericReturnType = getTypeArgument(method) KtCall&lt;T&gt;(call, gson, genericReturnType) } else { // 返回值类型是 RepoList val response = okHttpClient.newCall(request).execute() val genericReturnType = method.genericReturnType val json = response.body?.string() gson.fromJson&lt;Any?&gt;(json, genericReturnType) }} 看到上面的代码，可以反应过来，如果要支持 Flow，只需要在这里判断一下，返回值类型是不是 Flow 即可。比如说： 12345678910111213141516171819202122232425262728293031323334353637// 代码段13private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略部分代码 return when { isKtCallReturn(method) -&gt; { val genericReturnType = getTypeArgument(method) KtCall&lt;T&gt;(call, gson, genericReturnType) } isFlowReturn(method) -&gt; { // 直接返回Flow flow&lt;T&gt; { // 请求API val genericReturnType = getTypeArgument(method) val response = okHttpClient.newCall(request).execute() val json = response.body?.string() val result = gson.fromJson&lt;T&gt;(json, genericReturnType) // 传出结果 emit(result) } } else -&gt; { val response = okHttpClient.newCall(request).execute() val genericReturnType = method.genericReturnType val json = response.body?.string() gson.fromJson&lt;Any?&gt;(json, genericReturnType) } }}// 判断返回值类型是不是 Flow&lt;T&gt;private fun isFlowReturn(method: Method) = getRawType(method.genericReturnType) == Flow::class.java 由于代码段 12 当中已经有了 if、else 两个条件分支了，再增加一个分支的话，选择了 when 表达式。这里，增加了一个 isFlowReturn(method) 的分支，意思就是判断返回值类型是不是 Flow，如果是的话，就直接使用 flow{} 创建一个 Flow 返回了。 至此， 6.0 版本的开发工作，其实就已经完成了。对比起 Callback 转 Flow，让 KtHttp 直接支持 Flow 确实要简单很多。从这一点上，也可以看到 Flow 的强大和易用性。 那么在这时候，就可以写一些简单的测试代码，来验证代码是否可靠了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 代码段14private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略部分代码 return when { isKtCallReturn(method) -&gt; { val genericReturnType = getTypeArgument(method) KtCall&lt;T&gt;(call, gson, genericReturnType) } isFlowReturn(method) -&gt; { // 增加日志 logX(&quot;Start out&quot;) flow&lt;T&gt; { logX(&quot;Start in&quot;) val genericReturnType = getTypeArgument(method) val response = okHttpClient.newCall(request).execute() val json = response.body?.string() val result = gson.fromJson&lt;T&gt;(json, genericReturnType) logX(&quot;Start emit&quot;) emit(result) logX(&quot;End emit&quot;) } } else -&gt; { val response = okHttpClient.newCall(request).execute() val genericReturnType = method.genericReturnType val json = response.body?.string() gson.fromJson&lt;Any?&gt;(json, genericReturnType) } }}private suspend fun testFlow() = KtHttpV5.create(ApiServiceV5::class.java) .reposFlow(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) .flowOn(Dispatchers.IO) //切换线程 .catch { println(&quot;Catch: $it&quot;) } .collect { logX(&quot;${it.count}&quot;) }/*输出结果================================Start outThread:main @coroutine#1================================================================Start inThread:DefaultDispatcher-worker-1 @coroutine#2================================================================Start emitThread:DefaultDispatcher-worker-1 @coroutine#2================================================================End emitThread:DefaultDispatcher-worker-1 @coroutine#2================================================================25Thread:main @coroutine#1================================程序结束*/ 在上面的代码中，增加了一些日志，同时在调用处增加了“flowOn(Dispatchers.IO)”。可以看到，这样一来整个网络请求就执行在了 DefaultDispatcher 这个线程池当中，而其他部分的代码，仍然执行在 main() 线程。这也是符合预期的。 然后，可以通过断网来模拟出现异常的情况： 1234567891011121314151617// 代码段15/*输出结果：================================Start outThread:main @coroutine#1================================================================Start inThread:DefaultDispatcher-worker-1 @coroutine#2================================Catch: java.net.UnknownHostException: nodename nor servname provided, or not known程序结束*/ 可以看到，程序的运行结果仍然是符合预期的。 下面，再来看看 6.0 完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 代码段16interface ApiServiceV5 { @GET(&quot;/repo&quot;) fun repos( @Field(&quot;lang&quot;) lang: String, @Field(&quot;since&quot;) since: String ): KtCall&lt;RepoList&gt; // 注释1 @GET(&quot;/repo&quot;) fun reposFlow( @Field(&quot;lang&quot;) lang: String, @Field(&quot;since&quot;) since: String ): Flow&lt;RepoList&gt;}object KtHttpV5 { private var okHttpClient: OkHttpClient = OkHttpClient() private var gson: Gson = Gson() var baseUrl = &quot;https://baseUrl.com&quot; fun &lt;T : Any&gt; create(service: Class&lt;T&gt;): T { return Proxy.newProxyInstance( service.classLoader, arrayOf&lt;Class&lt;*&gt;&gt;(service) ) { proxy, method, args -&gt; val annotations = method.annotations for (annotation in annotations) { if (annotation is GET) { val url = baseUrl + annotation.value return@newProxyInstance invoke&lt;T&gt;(url, method, args!!) } } return@newProxyInstance null } as T } private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { if (method.parameterAnnotations.size != args.size) return null var url = path val parameterAnnotations = method.parameterAnnotations for (i in parameterAnnotations.indices) { for (parameterAnnotation in parameterAnnotations[i]) { if (parameterAnnotation is Field) { val key = parameterAnnotation.value val value = args[i].toString() if (!url.contains(&quot;?&quot;)) { url += &quot;?$key=$value&quot; } else { url += &quot;&amp;$key=$value&quot; } } } } val request = Request.Builder() .url(url) .build() val call = okHttpClient.newCall(request) return when { isKtCallReturn(method) -&gt; { val genericReturnType = getTypeArgument(method) KtCall&lt;T&gt;(call, gson, genericReturnType) } isFlowReturn(method) -&gt; { logX(&quot;Start out&quot;) // 注释2 flow&lt;T&gt; { logX(&quot;Start in&quot;) val genericReturnType = getTypeArgument(method) val response = okHttpClient.newCall(request).execute() val json = response.body?.string() val result = gson.fromJson&lt;T&gt;(json, genericReturnType) logX(&quot;Start emit&quot;) emit(result) logX(&quot;End emit&quot;) } } else -&gt; { val response = okHttpClient.newCall(request).execute() val genericReturnType = method.genericReturnType val json = response.body?.string() gson.fromJson&lt;Any?&gt;(json, genericReturnType) } } } private fun getTypeArgument(method: Method) = (method.genericReturnType as ParameterizedType).actualTypeArguments[0] private fun isKtCallReturn(method: Method) = getRawType(method.genericReturnType) == KtCall::class.java private fun isFlowReturn(method: Method) = getRawType(method.genericReturnType) == Flow::class.java}fun main() = runBlocking { testFlow()}private suspend fun testFlow() = KtHttpV5.create(ApiServiceV5::class.java) .reposFlow(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) .flowOn(Dispatchers.IO) .catch { println(&quot;Catch: $it&quot;) } .collect { logX(&quot;${it.count}&quot;) } 最后，再来分析一下，为什么 6.0 的代码可以这么简单。这里有两个关键的地方： 注释 1 处的 reposFlow() 方法的定义，它其实是一个普通的函数，并不是挂起函数。换言之，虽然它的返回值类型是 Flow，但并不要求它在协程当中被调用。 另外，在注释 2 处，flow{} 这个高阶函数，它也只是一个普通函数，同样也不是挂起函数，这就意味着，它可以在普通函数里面直接调用。可以看看 flow{} 的定义： 12345// 代码段17// 不是挂起函数public fun &lt;T&gt; flow(@BuilderInference block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit): Flow&lt;T&gt; = SafeFlow(block) 所以，正因为以上这两点，就使得 Flow 的易用性非常高。 在 kotlin学习系列十一文章的Flow章节里， 有一张Flow“上游、下游”的示意图，现在可以进一步完善它，如下图： 也就是说，对于 Flow 的上游、中间操作符 而言，它们其实根本就不需要协程作用域，只有在下游调用 collect{} 的时候，才需要协程作用域。 因此，前面在写 main() 函数的时候，也可以换成这样的写法： 12345678910111213141516// 代码段18fun main() { // 协程作用域外 val flow = KtHttpV5.create(ApiServiceV5::class.java) .reposFlow(lang = &quot;Kotlin&quot;, since = &quot;weekly&quot;) .flowOn(Dispatchers.IO) .catch { println(&quot;Catch: $it&quot;) } runBlocking { // 协程作用域内 flow.collect { logX(&quot;${it.count}&quot;) } }} 可见，正因为 Flow 的上游不需要协程作用域，才可以轻松完成 6.0 版本的代码。","link":"/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/"},{"title":"Kotlin学习系列四：函数进阶","text":"一、前言 二、高阶函数 1. 高阶函数定义 2. 常见的高阶函数 1. forEach函数 2. map函数 3. 高阶函数调用 1. 传递函数引用 2. 使用表达式 3. 高阶函数示例 三、内联函数 1. 定义 2. 高阶函数更适合定义为内联函数 3. 内联高阶函数的return 1. local return 2. non-local return 3. 不允许non-local return 4. 内联属性 5. 内联函数的限制 四、几个实用的函数 1. 函数简单说明 2. 函数的实现 1. let函数 2. run函数 3. also函数 4. apply函数 5. use函数 6. with函数 实例 五、集合变换与序列 1. 遍历集合通常使用循环 1. for i … 2. for each … 3. forEach … 2. 集合的映射操作 1. filter 操作 3. map 操作 java中steam()和kotlin中的asSequence()对比： 1. java 中 steam() 后再变换集合 2. kotlin 中 asSequence() 后再变换集合 3. kotlin中直接对集合进行变换 3. flatMap 变换 3. kotlin中集合的聚合操作 1. fold 操作 2. zip 操作 六、SAM 转换 (Single Abstract Method) 1. java 的 SAM 2. kotlin 的 SAM 1. 匿名内部类转换为lambda表达式 2. kotlin 中的匿名内部类写法 3. java 和 kotlin 的 SAM 转换对比 1. java 的转换要求 2. kotlin 转换要求 3. 总结 4. SAM 转换的问题 七、示例 1. 统计字符个数 2. HTML DSL(领域特定语言) 3. 体验Gradle Kotlin DSL 八、 小技巧 1. 隐藏不需要显示的代码 2. 查看kotlin编译后的源码 1. 直接在Android Studio中查看 2. 使用命令javap反编译 #一、前言 本文主要讲述Kotlin 函数进阶 本文是对Bennyhuo老师讲解的Kotlin系列视频的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程初解 kotlin学习系列十：协程进阶 kotlin学习系列十一：协程应用 #二、高阶函数 #1. 高阶函数定义 高阶函数： 参数类型包含函数类型或返回值类型为函数类型的函数 12345678//参数类型包含函数类型fun needsFunction(block: () -&gt; Unit) { block()}//返回值类型是函数类型fun returnFunctions(): () -&gt;Long { return {System.currentTimeMillis()}} #2. 常见的高阶函数 #1. forEach函数 123public inline fun IntArray.forEach(action: (Int) -&gt; Unit): Unit { for (element in this) action(element)} forEach()函数作用是迭代集合，把每个元素取出来进行了某些操作。 forEach()作为IntArray类的扩展方法，该方法接收一个函数action作为参数，这个函数入参是一个Int, 返回Unit。在forEach()里直接调用函数action的invoke()方法。 #2. map函数 123public inline fun &lt;R&gt; IntArray.map(transform: (Int) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(size), transform)} map()函数作用是迭代集合，把每个元素取出来但是把元素转为另外的元素，并组成一个List map()函数作为IntArray类的扩展方法，该方法接收一个函数transform作为参数，这个函数入参是一个Int类型，返回一个R (R 为泛型） 类型。在map()里将函数transform作为一个参数传入另一个高阶函数mapTo() #3. 高阶函数调用 #1. 传递函数引用 在kotlin中，函数也是普通的类型，与Int、String等没什么区别 作为入参的函数可以直接传递函数引用，而不一定要传lambda表达式 123val a : IntArray = IntArray(3)a[0] = 4a.forEach(::println) 如上，将函数println的引用传入，因forEach()函数入参类型为(Int) -&gt; Unit而println函数有一个重载方法类型为(Int) -&gt; Unit，所以这样写完全可以。 #2. 使用表达式 按高阶函数的声明来看，应该在入参位置放一个函数 1a.forEach({ println(&quot;element $it&quot;)}) 若高阶函数的入参函数只有一个或最后一个入参是高阶函数，则可将lambda表达式移到小括号外面。 只有一个lambda表达式作为参数时可省略小括号 只有一个参数的lambda表达式的形参默认是it 12//将lambda表达式外移a.forEach() { println(&quot;element $it&quot;) } 12//省略小括号a.forEach { println(&quot;element $it&quot;) } #3. 高阶函数示例 统计指印斐波那契数列的时间 12345678910111213141516171819202122232425262728293031//region + 统计取斐波那契数列前11位所需时间fun main() { cost { val fibonacciNext = fibonacci() for (i in 0.. 10) { println(fibonacciNext) } }}//实现斐波那契数列求值，fun fibonacci(): () -&gt; Long { var first = 0L var second = 1L return { val next = first + second val current = first first = second second = next current }}fun cost(block: () -&gt; Unit) { val start = System.currentTimeMillis() block() println(&quot;${System.currentTimeMillis() - start} ms&quot;)}//endregion 打印结果如下： 1234567891011120112358132134553 ms 打印出斐波那契数列前 11 项，耗时 3ms。 说明： cost函数作用是统计函数block运行所需时间，cost入参为函数block，block函数不需要入参，且返回值为Unit fibonacci()函数实现了斐波那契数列取值，它返回一个lambda表达式，该表达式不需要入参，但返回了一具Long类型数值 #三、内联函数 #1. 定义 使用关键字 inlin 修饰的函数即为内联函数 编译时会将内联函数内定义的函数直接内联到真正的调用处 123456789public inline fun IntArray.forEach(action: (Int) -&gt; Unit): Unit { for (element in this) action(element)}fun main() { val ints = intArrayOf(1,2,3,4) ints.forEach { println(&quot;Hello $it&quot;) }} 如上，调用内联函数forEach其实是将函数forEach内定义的函数内联到调用处，如下所示： 123456fun main() { val ints = intArrayOf(1,2,3,4) for (element in ints) { println(&quot;Hello $element&quot;) }} #2. 高阶函数更适合定义为内联函数 内联函数的作用：减少了函数调用 12345678910fun main() { cost { println(&quot;hello&quot;) }}fun cost(block: () -&gt; Unit) { val start = System.currentTimeMillis() block() println(&quot;${System.currentTimeMillis() - start} ms&quot;)} 如上定义了一个以lambda表达式为入参的高阶函数cost, 而lambda是匿名函数的语法糖，每次调用函数cost时都会创建他的入参函数block，所以可以为高阶函数cost添加关键字inline修饰。 12345678910fun main() { cost { println(&quot;hello&quot;) }}inline fun cost(block: () -&gt; Unit) { val start = System.currentTimeMillis() block() println(&quot;${System.currentTimeMillis() - start} ms&quot;)} 这样在编译时会将函数cost内联到原始调用处，如下所示编译后class文件： 1234567891011121314151617public final class KotlinLabKt { public static final void cost(@NotNull Function0 block) { long start = System.currentTimeMillis(); block.invoke(); String var4 = System.currentTimeMillis() - start + &quot; ms&quot;; System.out.println(var4); } public static final void main() { long start$iv = System.currentTimeMillis(); String var4 = &quot;hello&quot;; System.out.println(var4); String var6 = System.currentTimeMillis() - start$iv + &quot; ms&quot;; System.out.println(var6); }} 如此，没有了调用函数cost的开销，也没有了创建lambda表达式的开销。 #3. 内联高阶函数的return #1. local return kotlin会给lambda表达式加一个默认的标签，标签名就是 @加上调用lambda表达式的高阶函数名一致。 1234567fun main() { val ints = intArrayOf(1,2,3,4) ints.forEach { if (it == 3) return@forEach println(&quot;element: $it&quot;) }} 打印结果为： 123element: 1element: 2element: 4 如上所示，先定义了一个有四个元素的Int数组，之后遍历数组，在元素为 3 时不执行打印语句。即return@forEach只起一次作用，类似于continue语句，它等价于如下语句： 1234567fun main() { val ints = intArrayOf(1,2,3,4) for (element in ints) { if (element == 3) continue println(&quot;element: $element&quot;) }} #2. non-local return 若return不加标签，且在高阶函数的入参表达式中return了，则是直接退出了调用高阶函数所在的外部函数 如下所示： 1234567891011fun main() { val ints = intArrayOf(1,2,3,4) ints.forEach { if (it == 3) return@forEach println(&quot;element: $it&quot;) } for (element in ints) { if (element == 3) continue println(&quot;element: $element&quot;) }} 打印结果为： 123456element: 1element: 2element: 4element: 1element: 2element: 4 但是，若去掉标签@forEach，只留return语句，则打印结果如下： 12element: 1element: 2 即return直接作用到了函数main()上，从函数main()上返回 #3. 不允许non-local return 若高阶函数的入参表达式的调用处与定义处不在同一个调用上下文，有可能存在不合法的non-local return 1234567inline fun Runnable(block: () -&gt; Unit): Runnable { return object : Runnable { override fun run() { block() } }} 定义如上代码时，在语句block()处报错Can't inline 'block' here: it may contain non-local returns. Add 'crossinline' modifier to parameter declaration 'block，即此处不允许出现non-local return。 关键字crossinline，表示表达式禁止nono-local return，但是表达式还可以内联，但要在声明的形参表达式前加上该关键字。 关键字noinline，表示禁止形参表达式被内联 1234567891011121314inline fun Runnable(corssinline block: () -&gt; Unit): Runnable { return object : Runnable { override fun run() { block() } }}inline fun Runnable(noinline block: () -&gt; Unit): Runnable { return object : Runnable { override fun run() { block() } }} #4. 内联属性 没有backing-field的属性的getting/setting可以被内联 12345678910var pocket: Double = 0.0var monkey: Double inline get() = pocket inline set(value) { pocket = value }fun main() { monkey = 5.0} 反编译后代码如下： 1234567891011121314151617181920212223242526private static double pocket; public static final double getPocket() { return pocket; } public static final void setPocket(double var0) { pocket = var0; } public static final double getMonkey() { return getPocket(); } public static final void setMonkey(double value) { setPocket(value); } public static final void main() { double value$iv = 5.0D; setPocket(value$iv); } // $FF: synthetic method public static void main(String[] var0) { main(); } 可以看到执行语句monkey = 5.0时直接调用了方法setPocket()，而不是调用monkey的setMonkey方法 #5. 内联函数的限制 public/protected的内联方法只能访问对应类的public成员 内联函数的内联函数参数不能被存储（赋值给变量） 内联函数的内联函数参数只能传递给其它内联函数参数 即： public只能访问public 内联只能访问内联 内联函数作为参数不能被存 #四、几个实用的函数 #1. 函数简单说明 高阶函数名 介绍 说明 let val r = X.let{x -&gt;R} 将 receiver 作为参数调用指定的函数 [block] 并返回其结果 run val r = X.run{this: X -&gt;R} 以 receiver 作为接收者调用指定的函数 [block] 并返回其结果 also val x = X.also{x -&gt; Unit} 将 receiver 作为参数调用指定的函数 [block] 并返回 receiver apply val x = X.apply{this: x -&gt; Unit} 将 receiver 作为接收者调用指定的函数 [block]，并返回 receiver use val r = Closeable.use{c -&gt; R} 在 Closeable 资源上执行给定的 [block] 函数，然后无论是否引发异常，都正确地将其关闭。 with with(X, X.() -&gt; R) 以给定的 [receiver] 作为接收者调用指定的函数 [block]，并返回其结果 #2. 函数的实现 #1. let函数 1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block(this)} #2. run函数 1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block()} #3. also函数 123456789@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block(this) return this} #4. apply函数 12345678@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block() return this} #5. use函数 1234567891011121314151617181920212223242526@InlineOnly@RequireKotlin(&quot;1.2&quot;, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = &quot;Requires newer compiler version to be inlined correctly.&quot;)public inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } var exception: Throwable? = null try { return block(this) } catch (e: Throwable) { exception = e throw e } finally { when { apiVersionIsAtLeast(1, 1, 0) -&gt; this.closeFinally(exception) this == null -&gt; {} exception == null -&gt; close() else -&gt; try { close() } catch (closeException: Throwable) { // cause.addSuppressed(closeException) // ignored here } } }} #6. with函数 1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return receiver.block()} with函数可以让我们创建一个以变量作为上下文的代码块，这样就不需要每次使用它时重复它的名字。 with可以简单理解为“有了”，“有了变量 X”。这样代码也显得简洁。 #实例 123456789101112131415161718192021222324class Person(var name: String, var age: Int)fun main() { val person = Person(&quot;Lee&quot;, 18) person.let(::println) person.run(::println) val person2 = person.also { it.name = &quot;Lee2&quot; } val person3 = person.apply { name = &quot;Lee3&quot; } with(person) { name = &quot;Lee4&quot; } File(&quot;build.gradle&quot;).inputStream().reader().buffered() .use { println(it.readLines()) }} #五、集合变换与序列 #1. 遍历集合通常使用循环 #1. for i … 12345fun main() { for (i in 1.. 10) { println(i) }} #2. for each … 1234val ints = intArrayOf(1,2,3,3,4,5)for (e in ints) { println(e)} #3. forEach … 123ints.forEach { println(it)} 注意：该方式不能continue或者break #2. 集合的映射操作 函数名 说明 filter 保留满足条件的元素 map 集合中的所有元素一一映射到其它元素构成新集合 flatMap 集合中的所有元素一一映射到新集合并合并这些集合得到新集合 #1. filter 操作 功能： 将集合 a 内所有满足条件的元素生成一个新集合 b 示例如下： 1234val list = arrayListOf&lt;Int&gt;(1,2,3,4,5,6)val list2 = list.filter { it % 2 == 0 }println(list.joinToString())println(list2.joinToString()) 打印结果为： 121, 2, 3, 4, 5, 62, 4, 6 java 8中有类似的操作： 12List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6);List&lt;Integer&gt; list2 = list.stream().filter( e -&gt; e % 2 == 0).collect(Collectors.toList()); 说明： filter操作不会操作原来的集合而是创建一个新的集合 java中是先将list转为stream流，再进行filter筛选操作 kotlin中也有与java类似的先转换再筛选的操作： 1list.asSequence().filter{it % 2 == 0} 说明： 先将集合转换为懒序列再将序列进行filter筛选操作 与将集合直接进行filter操作的区别只在于是懒汉式还是饿汉式 ArrayList 的 filter 操作源码： 1234567public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; { return filterTo(ArrayList&lt;T&gt;(), predicate)}public inline fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Iterable&lt;T&gt;.filterTo(destination: C, predicate: (T) -&gt; Boolean): C { for (element in this) if (predicate(element)) destination.add(element) return destination} #3. map 操作 功能： 将集合 a 内的所有元素进行一个操作得到新的元素集合 示例如下： 1234val list = arrayListOf&lt;Int&gt;(1,2,3,4,5,6)val list2 = list.map { it * 2 }println(list.joinToString())println(list2.joinToString()) 打印结果： 121, 2, 3, 4, 5, 62, 4, 6, 8, 10, 12 java中若要使用map操作，要先将集合转为流 (stream)，示例如下： 12List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6);List&lt;Integer&gt; list2 = list.stream().map( e -&gt; e % 2).collect(Collectors.toList()); 说明： map操作也是创建一个 ussr 的集合，集合中的元素是原集合元素进行一个操作映射出来的 kotlin中也有与java类似的先转换再映射的操作： 1list.asSequence().map{it % 2} 说明： 先将集合转换为懒序列再将序列进行map筛选操作 与将集合直接进行map操作的区别只在于是懒汉式还是饿汉式 ArrayList 的 map 操作源码： 12345678public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)}public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C { for (item in this) destination.add(transform(item)) return destination} #java中steam()和kotlin中的asSequence()对比： #1. java 中 steam() 后再变换集合 12345678910111213List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);list.stream() .filter(e -&gt; { System.out.println(&quot;filter:&quot; + e); return e % 2 == 0; }) .map(e -&gt; { System.out.println(&quot;map:&quot; + e); return e * 2; }) .forEach(e -&gt; { System.out.println(&quot;forEach:&quot; + e); }); 打印结果： 12345678filter:1filter:2map:2forEach:4filter:3filter:4map:4forEach:8 说明： 先定义一个只有四个元素的整型列表，之后将列表转为流，再筛选出偶数，再通过乘以 2 映射成一个新集合，最后打印新集合元素 从打印结果可以看出，会先通过filter判断元素是否为偶数：奇数不会再往下执行；若是偶数，则该元素会一直往下执行，最后打印出来，然后再判断下一个元素是否为偶数 java中的steam()是懒序列 #2. kotlin 中 asSequence() 后再变换集合 1234567891011val list = arrayListOf&lt;Int&gt;(1, 2, 3, 4)list.asSequence() .filter { println(&quot;filter:$it&quot;) it % 2 == 0 }.map { println(&quot;map:$it&quot;) it * 2 }.forEach { println(&quot;forEach:$it&quot;) } 打印结果： 12345678filter:1filter:2map:2forEach:4filter:3filter:4map:4forEach:8 说明： 定义一个只有四个元素的整数集合，之后将列表转为sequence()，再筛选出偶数，再通过乘以 2 映射成一个新集合，最后打印新集合元素 打印结果与java中的steam()结果完全一致，执行逻辑也一致。 kotlin中的asSequence()也是懒序列，只有在需要时才会执行变换，如果不需要则只是个公式，不会执行。若把forEach()操作去掉，则不会有打印信息 #3. kotlin中直接对集合进行变换 123456789list.filter { println(&quot;filter:$it&quot;) it % 2 == 0 }.map { println(&quot;map:$it&quot;) it * 2 }.forEach { println(&quot;forEach:$it&quot;) } 打印结果为： 12345678filter:1filter:2filter:3filter:4map:2map:4forEach:4forEach:8 说明： 该段代码对集合list进行了三个操作filter、map、forEach，只有当列表里所有元素都执行完一个操作之后，才会执行下一个操作。 kotlin中直接对集合进行变换是饿汉式的，不管需要不需要都会执行变换，若把forEach()操作去掉，也会有打印信息。 RxJava中的Obserable是懒汉式的 #3. flatMap 变换 功能： 将一个集合 a 内的每个元素通过某个操作得到一个集合，最后将每个元素映射的集合拼接成一个新集合 如图所示：转换操作是创建一个长度为原集合对应元素值大小的Int数组，该数组元素由index * 2构成 示例如下： 123list.flatMap { 0 until it }.joinToString().let(::println) 打印结果为： 10, 0, 1, 0, 1, 2, 0, 1, 2, 3 说明： map操作是将集合里每个元素映射成一个新元素，而flatMap操作是将集合里的每个元素映射成一个新集合 flatMap操作需要是的Iterable类型的数据，而0 until it生成的一个IntRange，该类型实现了Iterable ArrayList 的 flatMap 操作源码： 12345678910public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.flatMap(transform: (T) -&gt; Iterable&lt;R&gt;): List&lt;R&gt; { return flatMapTo(ArrayList&lt;R&gt;(), transform)}public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.flatMapTo(destination: C, transform: (T) -&gt; Iterable&lt;R&gt;): C { for (element in this) { val list = transform(element) destination.addAll(list) } return destination} #3. kotlin中集合的聚合操作 函数名 说明 sum 所有元素求和 reduce 将元素依次按规则聚合，结果与元素类型一致 fold 给定初始化值，将元素按规则聚合，结果与初始化值类型一致 说明： 聚合操作是将所有元素进行运算 reduce操作可以看作fold操作的简化版 #1. fold 操作 功能： 给定一个初始值，将元素进行某个操作，返回一个和初始值相同类型的结果 如上图所示，fold里的操作是初始值都与元素相加，而每次操作时的初始值都是上次的操作结果。 示例如下： 123456val list = arrayListOf&lt;Int&gt;(1, 2, 3, 4)println(list.fold(2) { acc, i -&gt; println(&quot;acc:$acc, i:$i&quot;) acc + i}) 打印结果为： 12345acc:2, i:1acc:3, i:2acc:5, i:3acc:8, i:412 说明： acc是初始值，i是原集合中的每个元素，所做的操作是将初始值与元素值相加 给fold操作一个初始值 2 即acc为 2，然后取第一个元素 1，两者相加为 3，然后 3 是取下一个元素时的初始值，如此往复，最后结果是初始值加上元素的累加结果，即 12 ArrayList 的 fold 操作源码： 12345public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R { var accumulator = initial for (element in this) accumulator = operation(accumulator, element) return accumulator} #2. zip 操作 功能： 将两个集合中对应下标的元素进行某个操作返回操作结果，最后将操作结果拼接成一个新集合 示例如下： 123456val array = arrayListOf&lt;String&gt;(&quot;x&quot;, &quot;y&quot;)list.zip(array){ a, b -&gt; println(&quot;a:$a, b:$b&quot;) arrayListOf(a, b)}.joinToString().let(::println) 打印结果为： 123a:1, b:xa:2, b:y[1, x], [2, y] 说明： a是原集合的元素，b是zip操作传入的集合的元素，所进行的操作是创建一个新集合，新集合元素是a和b 最后的结果是一新的集合，新集合的每个元素都是一个小集合 Collection 的 zip 操作源码： 12345678910111213public infix fun &lt;T, R&gt; Iterable&lt;T&gt;.zip(other: Iterable&lt;R&gt;): List&lt;Pair&lt;T, R&gt;&gt; { return zip(other) { t1, t2 -&gt; t1 to t2 }}public inline fun &lt;T, R, V&gt; Iterable&lt;T&gt;.zip(other: Iterable&lt;R&gt;, transform: (a: T, b: R) -&gt; V): List&lt;V&gt; { val first = iterator() val second = other.iterator() val list = ArrayList&lt;V&gt;(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10))) while (first.hasNext() &amp;&amp; second.hasNext()) { list.add(transform(first.next(), second.next())) } return list} 说明： 操作的执行次数是由最小的集合的元素个数决定的 进行操作的对象是两个集合中相同位置的元素 zip的默认操作是返回一个Pair #六、SAM 转换 (Single Abstract Method) #1. java 的 SAM Java中的lambda表达式没有自己的类型，必须有一个 单一方法的接口 来接收它。 12345678910ExecutorService executor = Executors.newCachedThreadPool();executor.submit(new Runnable() { @Override public void run() { System.out.println(&quot;run in Runnable&quot;); }});//等价于executor.submit(() -&gt; System.out.println(&quot;run in Runnable&quot;)); #2. kotlin 的 SAM #1. 匿名内部类转换为lambda表达式 kotlin中的lambda表达式即为匿名函数的语法糖，它是有自己类型的。 123456val executor = Executors.newCachedThreadPool()executor.submit(object : Runnable { override fun run() { println(&quot;run in runnable&quot;) }}) 如上所示，Runnable是一个匿名内部类，它转换成lambda表达式如下： 1executor.submit { println(&quot;run in runnable&quot;) } 也就是说()-&gt;Unit类型的lambda转换为了Runnable，但转换过程并非直接转换，实际上是创建了一个Runnable，然后在它的run方法中添加了lambda表达式，又因lambda表达式可以内联，所以可以把lambda表达式里的内容直接放到run方法中。 #2. kotlin 中的匿名内部类写法 如上一节所示传统的匿名内部类如下： 12345object : Runnable { override fun run() { println(&quot;run in runnable&quot;) }} 匿名内部类的简写： 1Runnable{ println(&quot;run in runnable&quot;) } 这两种写法完全等价，编译器都会生成如下函数： 1234567fun Runnable(block: () -&gt; Unit): Runnable { return object : Runnable { override fun run() { println(&quot;run in runnable&quot;) } } } #3. java 和 kotlin 的 SAM 转换对比 #1. java 的转换要求 java 8一个参数类型为只有一个方法的接口的方法，调用时可用lambda表达式做转换作为参数 即假设有一个方法，它只接收一个java接口，且这个接口只有一个方法，此时可将那个接口转换为lambda表达式 #2. kotlin 转换要求 一个参数类型为只有一个方法的 Java 接口 的java方法，调用时可用lambda表达式做转换作为参数 kotlin的需要与java一致，甚至更加严格。即只能是java的接口，若在kotlin中自定义的接口，即使只有一个函数也不能进行转换。 #3. 总结 Java Kotlin Java 接口 支持 支持 Kotlin 接口 支持 不支持 Java 方法 支持 支持 Kotlin 函数 支持 不支持，kotlin1.3 起，添加编译器参数也可以支持 抽象类 不支持 不支持 Java的lambda是假的，没有自己的类型，本质就是SAM, 转换为了java的接口 Kotlin的lambda是真的，有自己的函数类型，只是支持SAM 示例如下： 123456789101112131415161718192021222324252627282930313233fun main() { //报错 submit { } //正常 submit2 { } //正常 submitRunnable { println(&quot;ok&quot;) }}fun submitRunnable(runnable: Runnable) { runnable.run()}fun submit(invokable: Invokable) { invokable.invoke()}fun submit2(lambda: () -&gt; Unit) { lambda()}typealias FunctionX = () -&gt; Unitfun submit3(lambda: FunctionX) {}interface Invokable { fun invoke()} 说明： 自定义了一个只有方法invoke的接口Invokable，又定义了一个要以接口Invokable为入参的方法submit，接着定义了一个接口java接口Runnable做为参数的方法submitRunnable。 此时若调用方法submit时写成submit{}，编辑器会报错：Type mismatch. Required: Invokable Found: () → Unit，原因是参数需要Invokable接口而传进去了一个lambda表达式 调用函数submitRunnable()时将lambda表达传递进去是可以的，并未报错。这个是在Kotlin1.3 版本之后支持的 若需要在kotlin中支持入参是lambda，只需要入参定义为函数类型即接收一个函数，例如函数submit2和submit3 #4. SAM 转换的问题 若需要保存接口，且在增删接口时使用 lambda 表达，则增删时的lambda表达式肯定不是同一个接口，此时不能删除之前添加的接口 123456789101112131415public class CallbackManager { interface ViewCallback { void onChanged(int viewId); } public void registerCallback(ViewCallback callback) { mCallbacks.add(callback); } public void unregisterCallback(ViewCallback callback) { mCallbacks.remove(callback); } private HashSet&lt;ViewCallback&gt; mCallbacks = new HashSet&lt;&gt;();} 如上java定义了一个管理Callback的管理类，管理类提供了增删ViewCallback接口的功能 123456fun main() { val manager = CallbackManager() manager.registerCallback { println(&quot;onChanged$it&quot;) }} 如上，kotlin中使用该类，但传递进去的是一个lambda表达式，编译器转换后如下： 12345manager.registerCallback(object: CallbackManager.ViewCallback { override fun onViewCallback(viewId: Int) { println(&quot;onChanged$viewId&quot;) }}) 此时，因为传递进去的是一个匿名函数，无法标识该函数所以CallbackManager无法删除该接口了。 为lambda表达式关联一个变量，增删时使用这个变量 12345678910111213141516171819fun main() { val manager = CallbackManager() val onCallback = {viewId: Int -&gt; println(&quot;onChanged$viewId&quot;)} manager.registerCallback(onCallback) //编译器转换后的代码 manager.registerCallback(object: CallbackManager.ViewCallback { override fun onViewCallback(viewId: Int) { onCallback.invoke(viewId) } }) manager.unregisterCallback(onCallback) //编译器转换后的代码 manager.unregisterCallback(object: CallbackManager.ViewCallback { override fun onViewCallback(viewId: Int) { onCallback(viewId) } })} 如上所示： 将lambda表达式赋值给变量onCallback，此时调用管理类CallbackManager的registerCallback方法和unregisterCallback方法皆不会报错。 但是，可以看到编译器转换后的代码，不管理是在registerCallback方法和unregisterCallback方法中，都是重新创建onCallback，所以也不可能删除。 原因： 变量onCallback的类型并非是之前定义的接口ViewCallback类型，而是() -&gt; Unit，编译器会重新创建接口 解决方案： 为变量onCallback关联接口，而非lambda表达式，此时变量onCallback类型为ViewCallback接口类型，在添加和删除时就不会进行转换。例： 12345val onCallback = CallbackManager.ViewCallback {viewId: Int -&gt; println(&quot;onChanged$viewId&quot;)}manager.registerCallback(onCallback)manager.unregisterCallback(onCallback) 使用匿名内部类的方式为变量onCallback赋值，就是第一种方案里的lambda展示形式。例： 12345val onCallback = object : CallbackManager.ViewCallback { override fun onViewCallback(viewId: Int) { println(&quot;onChanged$viewId&quot;) }} #七、示例 #1. 统计字符个数 实现效果： 给定一个文件统计所有非空字符的出现次数 123456789fun main() { File(&quot;build.gradle&quot;).readText()//读文件，返回一个String .toCharArray()//将String 转为char[] .filterNot { it.isWhitespace() }//过滤空格 .groupBy { it }//按每个char字符分组 .map { it.key to it.value.size }.let(::println)} 打印结果： [(/, 7), (T, 2), (o, 40), (p, 16), (-, 4), (l, 35), (e, 50), (v, 4), (b, 8), (u, 13), (i, 33), (d, 21), (f, 3), (w, 1), (h, 6), (r, 24), (y, 4), (c, 17), (a, 20), (n, 26), (g, 11), (t, 29), (s, 22), (m, 5), (j, 6), (., 13), ({, 6), (x, 1), (k, 5), (_, 2), (=, 1), (', 2), (1, 1), (4, 2), (2, 1), (0, 3), ((, 5), (), 5), (}, 6), (&quot;, 4), (:, 6), ($, 1), (N, 1), (O, 1), (E, 1), (D, 3), (;, 1), (P, 1)] 说明： 函数fitlerNot()作用是将满足条件的元素过滤掉不参与之后操作 函数groupBy()作用是按lambda表达式返回结果作为依据进行分组，返回结果是一个map，key为 lambda 表达式返回结果，value为list，list元素为对应lambda结果的入参。 获取工程根目录下的build.gradle文件内的所有字符串，然后转为字符数组，接着过滤空格，再接字符分组，最后通过map函数得到对应字符及字符数量的Pair的list #2. HTML DSL(领域特定语言) 定义： 领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。 SQL是典型的DSL,而Gradle也是基于编程语言Groovy的DSL 手动简单编写kotlin中支持HTML DSL，可查看官方的实现库：https://github.com/kotlin/kotlinx.html 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798fun main() { val htmlContent = html { head { &quot;meta&quot; { &quot;charset&quot;(&quot;UTF-8&quot;) } } body { &quot;div&quot; { &quot;style&quot;( &quot;&quot;&quot; width: 200px; height: 200px; line-height: 200px; background-color: #C9394A; text-align: center &quot;&quot;&quot;.trimIndent() ) &quot;span&quot; { &quot;style&quot;( &quot;&quot;&quot; color: white; font-family: Microsoft YaHei &quot;&quot;&quot;.trimIndent() ) +&quot;Hello HTML DSL!!&quot; } } } }.render() File(&quot;Kotlin_html_DSL.html&quot;).writeText(htmlContent)}interface Node { fun render(): String}class StringNode(val content: String) : Node { override fun render(): String { return content }}//节点类class BlockNode(val name: String) : Node { //节点的子节点 val children = ArrayList&lt;Node&gt;() //节点的属性 val properties = HashMap&lt;String, Any&gt;() override fun render(): String { //&lt;html props&gt;XXX&lt;/html&gt; return &quot;&quot;&quot; &lt;$name ${properties.map { &quot;${it.key}='${it.value}'&quot; }.joinToString(&quot; &quot;)}&gt; ${children.joinToString(&quot;&quot;){it.render()}} &lt;/$name&gt; &quot;&quot;&quot;.trimIndent() } //因为这个函数需要两个receiver:String,和BlockNode，将其定义到BlockNode类里就自动有了该receiver operator fun String.invoke(block: BlockNode.() -&gt; Unit): BlockNode { val node = BlockNode(this) node.block() this@BlockNode.children += node return node } operator fun String.invoke(value: Any) { this@BlockNode.properties[this] = value } operator fun String.unaryPlus() { this@BlockNode.children += StringNode(this) }}fun html(block: BlockNode.() -&gt; Unit): BlockNode { val html = BlockNode(&quot;html&quot;) html.block() return html}//为顶级函数head添加一个receiver,使之成为扩展函数fun BlockNode.head(block: BlockNode.() -&gt; Unit): BlockNode { val head = BlockNode(&quot;head&quot;) head.block() this.children += head return head}fun BlockNode.body(block: BlockNode.() -&gt; Unit): BlockNode { val body = BlockNode(&quot;body&quot;) body.block() this.children += body return body} 生成的Kotlin_html_DSL.html文件内容如下： 123456789101112131415161718 &lt;html &gt; &lt;head &gt; &lt;meta charset='UTF-8'&gt; &lt;/meta&gt; &lt;/head&gt; &lt;body &gt; &lt;div style='width: 200px; height: 200px; line-height: 200px; background-color: #C9394A;text-align: center'&gt; &lt;span style='color: white;font-family: Microsoft YaHei'&gt; Hello HTML DSL!! &lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; #3. 体验Gradle Kotlin DSL Gradle DSL在5.0之前版本是Groovy DSL，在5.0版本之后引入了Kotlin DSL Groovy是动态语言，Kotlin是静态语言，IDE可以提示静态语言，体验更友好。 官网： https://www.kotlincn.net/docs/reference/using-gradle.html 简单示例如下： 123//setting.gradleinclude ':app'rootProject.name = &quot;ProjectCollection&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//build.gradleapply plugin: 'com.android.application'apply plugin: 'kotlin-android'android { compileSdkVersion 30 buildToolsVersion &quot;30.0.1&quot; defaultConfig { applicationId &quot;cn.ltt.projectcollection&quot; minSdkVersion 16 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 }}dependencies { implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) implementation 'androidx.appcompat:appcompat:1.2.0' implementation 'androidx.constraintlayout:constraintlayout:2.0.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.2' androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0' //Gson implementation 'com.google.code.gson:gson:2.8.6' //EventBus implementation 'org.greenrobot:eventbus:3.1.1' implementation 'com.jakewharton:butterknife:10.2.3' annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.3' implementation &quot;androidx.core:core-ktx:+&quot; implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version&quot; implementation &quot;com.squareup.retrofit2:retrofit:2.6.2&quot; implementation &quot;com.squareup.retrofit2:converter-gson:2.6.2&quot; implementation &quot;com.google.code.gson:gson:2.8.1&quot;}repositories { mavenCentral()} 转换为kotlin DSL如下： 123//setting.gradleinclude(&quot;:app&quot;)rootProject.name = &quot;ProjectCollection&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//build.gradleimport org.jetbrains.kotlin.config.KotlinCompilerVersionplugins { id (&quot;com.android.application&quot;) id (&quot;kotlin-android&quot;)}android { compileSdkVersion(30) buildToolsVersion(&quot;30.0.1&quot;) defaultConfig { applicationId = &quot;cn.ltt.projectcollection&quot; minSdkVersion(16) targetSdkVersion(30) versionCode = 1 versionName = &quot;1.0&quot; testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { getByName(&quot;release&quot;) { isMinifyEnabled = true proguardFiles(getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;), &quot;proguard-rules.pro&quot;) } } compileOptions { sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 }}dependencies { implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;)))) implementation(&quot;androidx.appcompat:appcompat:1.2.0&quot;) implementation( &quot;androidx.constraintlayout:constraintlayout:2.0.2&quot;) testImplementation( &quot;junit:junit:4.12&quot;) androidTestImplementation( &quot;androidx.test.ext:junit:1.1.2&quot;) androidTestImplementation( &quot;androidx.test.espresso:espresso-core:3.3.0&quot;) //Gson implementation (&quot;com.google.code.gson:gson:2.8.6&quot;) //EventBus implementation (&quot;org.greenrobot:eventbus:3.1.1&quot;) implementation (&quot;com.jakewharton:butterknife:10.2.3&quot;) annotationProcessor( &quot;com.jakewharton:butterknife-compiler:10.2.3&quot;) implementation( &quot;androidx.core:core-ktx:+&quot;) implementation(kotlin(&quot;stdlib-jdk7&quot;, KotlinCompilerVersion.VERSION)) implementation(&quot;com.squareup.retrofit2:retrofit:2.6.2&quot;) implementation(&quot;com.squareup.retrofit2:converter-gson:2.6.2&quot;) implementation(&quot;com.google.code.gson:gson:2.8.1&quot;)}repositories { mavenCentral()} 说明： 示例中Android Studio版本为4.1.2,Gradle版本为gradle-6.5-all,Gradle支持Android Studio的插件版本为4.1.1 将Groovy DSL改为kotlin DSL时，先将文件名添加一个后缀kts,例：settings.gradle.kts 不再支持ext的全局变量定义 参考示例： https://github.com/gradle/kotlin-dsl-samples/tree/master/samples/hello-android #八、 小技巧 #1. 隐藏不需要显示的代码 在需要折叠的代码块开始位置添加 //region + 说明, 在结束位置添加//endregion，之后使用快捷键ctrl -来将代码块折叠 在编辑器中添加如下代码： 12345//region + 演示折叠效果fun main() { println(&quot;hello&quot;)}//endregion 显示如下图： 再使用快捷键ctrl -，显示效果如下图： #2. 查看kotlin编译后的源码 #1. 直接在Android Studio中查看 步骤： 选择要查看的kotlin文件，然后点击Tools–&gt;Kotlin–&gt;Show Kotlin Bytecode, 如下图所示： 此时会打开Kotlin Bytecode窗口，如下所示： 点击Kotlin Bytecode窗口内左上角的 DECOMPILE 按钮就会打开一个新窗口显示出反编译后的的class源码，如下所示： #2. 使用命令javap反编译 步骤： 先在目录 app–&gt;build–&gt;tmp–&gt;kotlin-classes–&gt;debug–&gt;自己的包名 --&gt;kotlin下找到class源文件，如下图所示： 在命令行中进入到源文件所在目录，之后输入javap命令，结果如下所示：","link":"/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/"},{"title":"使用 Hexo 安装 GitHub 个人博客","text":"一、前言 二、Hexo 简介 三、搭建及发布 1. 安装 Git 2. 安装 Node.js 3. 安装 Hexo 4. GitHub 创建个人仓库 5. 将 Hexo 部署到 GitHub 上 6. 设置个人域名 四、Hexo 配置 1. hexo 基本配置 网站 网址 目录 Front-matter 2. 更换主题 安装 配置 更新 3. git 分支多终端操作 原理 上传分支 验证 4. 添加本地图片 5. 更换辅助解析 markdown 的库 安装 配置 6. MarkDown 文件添加目录 安装 配置 7. Hexo 引用本站文章 8. Hexo 支持 MathJax 公式 安装 配置 9. Hexo 支持 mermaid 图表 安装 配置 五、遇到的问题 1. 部署失败 2. 部署失败 3. 表格显示错误 4. 表格显示过多 5. No Layout #一、前言 之前一直使用 CSDN 来着，还有有些限制。后来想自己写 MarkDown 文件放到个人仓库里，之后就开始了自己搭建博客。本文基于 Mac 系统。 #二、Hexo 简介 Hexo 是一款基于 Node.js 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 GitHub 上，是搭建博客的首选框架。而且 Hexo 对中文的支持非常好。 &quot;快速、简洁且高效的博客框架&quot;这是它官网上的标语。 Hexo官网地址：https://hexo.io/ #三、搭建及发布 安装及发布步骤： 安装 Git 安装 Node.js 安装 Hexo GitHub 创建个人仓库 将 hexo 部署到 GitHub 上 设置个人域名 #1. 安装 Git Mac 系统自带 Git，可以在终端输入git --version看是否已安装，若未安装则在官网上下载安装包安装。 git官网地址：https://git-scm.com/ #2. 安装 Node.js Hexo 是基于 nodeJS 编写的，所以要安装一下 nodeJS 和里面的 npm 工具。 Nodejs官网：https://nodejs.org/en/ 从官网上下载安装包安装。之后可用如下命令校验是否安装成功： 12node -vnpm -v #3. 安装 Hexo 先创建一个文件夹 blog，然后cd到这个文件夹下，再输入如下命令： 1npm install -g hexo-cli 依旧用hexo -v查看一下版本，至此安装完成。 初始化一下 hexo 命令：hexo init blogName blogName 自己随意取名。 新建完成后，这个blogName文件夹目录下有如下文件目录： 名称 功能 node_modules 依赖包 public 存放生成的页面，最后上传个人仓库的也是这个文件夹下内容 scaffolds 生成文章的一些模板 source 用来存放你的文章 themes 主题 _config.yml 博客的配置文件 之后 cd bolgName进入这个blogName文件夹。 12hexo generatehexo server 最后可以使用如上命令打开 hexo 服务，在浏览器里输入localhost:4000就可以看到生成的博客了。最后使用ctrl+c关闭服务。 #4. GitHub 创建个人仓库 首先注册一个 GitHub 账号。 注册并登录后，点击New respository，新建仓库 仓库名称为&quot;你的用户名+.github.io&quot;，比如你的用户名为lee，则创建的仓库名为lee.github.io #5. 将 Hexo 部署到 GitHub 上 这一步主要是将 hexo 和 Github 关联起来，也就是将 hexo 生成的文章部署到 GitHub 上，打开配置文件_config.yml，滑到最后，个性如下内容 1234deploy: type: git repo: https://github.com/yourName/yourName.github.io.git branch: master 之后需要安装deploy-git，也就是 hexo 的部署命令，这样才能用命令将内容部署到 GitHub 上。 1npm install hexo-deployer-git --save 然后 1hexo deploy hexo 基本命令： 命令 功能 参数说明 hexo init [folder] 用于初始化本地文件夹为网站的根目录 folder 可选参数，不选默认当前目录 hexo new [layout] &lt; title&gt; 用于新建文章，可以简写为 hexo n layout 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定 title 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围 hexo clean 清除之前生成的静态文章等 hexo generate 生成静态文章，可以简写为 hexo g hexo deploy 部署文章，可以简写为 hexo d hexo server 命令用于启动本地服务器，可以简写为 hexo s 过一会儿之后就可以https://yourName.github.io这个网站看到你的博客了！ #6. 设置个人域名 去阿里云或腾讯云上去买一个域名，未设置。 #四、Hexo 配置 #1. hexo 基本配置 在文件根目录下的_config.yml就是整个 hexo 框架的配置文件了。可以在里面个性大部分配置。 详细见官网：https://hexo.io/zh-cn/docs/configuration #网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站的关键词。使用半角逗号 , 分隔多个关键词。 author 您的名字 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans 和 zh-CN。 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 其中，description 主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 参数用于主题显示文章的作者。 #网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 true pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 （对尾部的 index.html 无效） true permalink，也就是你生成某个文章时的那个链接格式。 比如说新建一个文件temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2020/05/13/temp 详细见官网：https://hexo.io/zh-cn/docs/permalinks #目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹，source_dir 下的子目录 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。 #Front-matter Front-matter 是文件最上方以---分隔的区域，用于指定个别文件的变量，举例如下： 123---title: Hello World--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 详细见官网：https://hexo.io/zh-cn/docs/front-matter #2. 更换主题 Hexo 默认主题为landscape，若感觉不好看，可以到官网主题中选择一个喜欢的主题进行修改。官网主题：https://hexo.io/themes/ 我选择的是：hexo-theme-Anatole-Core 效果如下： git地址如下：https://github.com/mrcore/hexo-theme-Anatole-Core 使用文档：https://github.com/Ben02/hexo-theme-Anatole/wiki/Index-Description 更换主题步骤： #安装 1234567git clone https://github.com/mrcore/hexo-theme-Anatole-Core.git themes/anatole-core或者直接下载主题zip包解压至主题目录下，重命名为anatole-core# 安装hexo-renderer-pugnpm install hexo-renderer-pug --save #配置 修改 hexo 根目录下的_config.yml ： theme: anatole-core 其他需要配置的地方请看themes/anatole-core/_comfig.yml #更新 12cd themes/anatole-coregit pull #3. git 分支多终端操作 #原理 由于hexo d上传部署到 github 的其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面，这是个隐藏文件夹。 其他文件 ，包括我们写在source里面的，和配置文件，主题文件，都没有上传到 github 所以可以利用 git 的分支管理，将源文件上传到 github 的另一个分支即可。 #上传分支 在 github 上新建一个 hexo 分支 将 hexo 分支内容克隆到本地，再把除。git 文件夹外内容全部删除 把除了.deploy_git外的所有博客源文件全部复制进来。 注意： 复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下内容： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 若之前克隆过 theme 中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为 git 不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样配置在别的电脑上就用不了了。 tip: Mac 系统显示与隐藏隐藏文件快捷键为：shift + command + . 之后将新内容提交到 github，可使用如下命令： 123git add .git commit –m &quot;add hexo&quot;git push 这样就上传完成了，其中node_modules、public、db.json已经被忽略掉了，不需要上传。 #验证 换台电脑，重走一遍之前的安装流程。之后将代码从 github 上下载下来，重新部署验证。 #4. 添加本地图片 把主页配置文件_config.yml里的post_asset_folder选项设置为true 在 hexo 目录下执行npm install hexo-asset-image --save安装一个可以上传本地图片的插件，地址：https://github.com/xcodebuild/hexo-asset-image 之后运行hexo n mdFileName来生成 md 文件，文件位置为/source/_posts, 文件夹内除了 mdFileName.md 文件还有一个同名的文件夹 之后若在 mdFileName.md 中引入图片，要先把图片复制到 mdFileName 这个文件夹中，然后只需要在 mdFileName.md 中按照 markdown 的格式引入图片：![你想输入的替代文字](mdFileName/图片名.jpg) 最后检查一下，运行hexo g生成页面后，进入 public\\ 年、月、日、mdFileName.html 文件中查看相关字段，若 html 标签内的语句是&lt;img src=&quot;年/月/日/mdFileName/图片名.png&quot;&gt;，则网页可以正常加载图片。 注意： mdFileName 是这个 md 文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要绝对路径。 参考：http://wonder4.me/2017/02/20/Using-Local-Image-in-Hexo/ #5. 更换辅助解析 markdown 的库 hexo-renderer-markdown-it提供了更丰富的 Markdown 解析和渲染。 #安装 卸载 Hexo 默认自带的 Markdown 渲染器 1npm un hexo-renderer-marked --save 安装 hexo-renderer-markdown-it 插件 1npm i hexo-renderer-markdown-it --save #配置 hexo-renderer-markdown-it的所有配置，均在Hexo的主要配置文件_config.yml中进行配置。 hexo-renderer-markdown-it提供的高级配置，在Hexo的_config.yml文件中配置以下内容： 123456789101112131415161718192021markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup anchors: level: 1 collisionSuffix: 'v' permalink: false permalinkClass: header-anchor permalinkSymbol: ¶ 详解见： https://www.jianshu.com/p/588ab3d22eb8 https://github.com/markdown-it/markdown-it #6. MarkDown 文件添加目录 MD 正常语法[TOC]，解析器解析不了，需要下载一个插件hexo-toc #安装 1npm install hexo-toc --save #配置 hexo-toc的所有配置，均在Hexo的主要配置文件_config.yml中进行配置。 12345678910# 目录插件toc: maxdepth: 3 class: toc slugify: transliteration decodeEntities: false anchor: position: after symbol: '#' style: header-anchor 之后，在 md 文件开头添加&lt;！-- toc --&gt;，解析成网页后会自动生成文章目录。 详解见： https://www.npmjs.com/package/hexo-toc #7. Hexo 引用本站文章 在编写文章的过程中，有时需要引用本站内的其他文章。此时可以通过内置的标签插件post_link来实现引用。 语法： {％ post_link 文章文件名（不需要后缀） 文章标题（可选项） %} 说明： 符号都是英文状态下的，文章标题不写默认显示的是文章文件名 举例： 引用文章 ADB常用命令，则语句如下： {％ post_link ADB常用命令 %} 或者修改显示标题 {％ post_link ADB常用命令 ADB %} #8. Hexo 支持 MathJax 公式 通过插件 hexo-math 来实现 hexo 中插入数学公式 #安装 1npm install hexo-math --save #配置 hexo-math的所有配置，均在Hexo的主要配置文件_config.yml中进行配置。 1234567891011121314# https://github.com/hexojs/hexo-mathmath: engine: 'mathjax' katex: css: 'https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css' options: throwOnError: false mathjax: css: 'https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css' options: conversion: display: false tex: svg: #9. Hexo 支持 mermaid 图表 #安装 https://github.com/webappdevelp/hexo-filter-mermaid-diagrams 123yarn add hexo-filter-mermaid-diagrams// 或npm install hexo-filter-mermaid-diagrams --save #配置 首先，在Hexo的主要配置文件_config.yml中进行配置。 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;10.9.1&quot; # upgraded for better compatibility options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 然后，在主题的文件里注入 mermaid 脚本，具体位置文件为：themes/Anatolo/layout/partial/layout.pug，在文件最后添加脚本代码如下： 12345678910111213// Mermaid diagrams supportif config.mermaid &amp;&amp; config.mermaid.enable script(src='https://unpkg.com/mermaid@' + config.mermaid.version + '/dist/mermaid.min.js') script. if (window.mermaid) { mermaid.initialize({ startOnLoad: true, securityLevel: 'loose', flowchart: { htmlLabels: true, useMaxWidth: true }, theme: 'default', logLevel: 1 }); } #五、遇到的问题 #1. 部署失败 12FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object 原因： 之前装的是 node14, node 版本太高了。 解决方案： 换成低版本的 node，比如 node12.14。 因为是回退版本，所以需要先卸载高版本的 node, 再安装低版本的 node. 官网下载 node.pkg 安装包的通过如下命令卸载 node 1sudo rm -rf /usr/local/{bin/{node,npm},lib/node_modules/npm,lib/node,share/man/*/node.*} 卸载node参考：https://www.jianshu.com/p/6dcfc0d3ea40 #2. 部署失败 12345678ERROR Process failed: _posts/使用Hexo安装GitHub个人博客.mdYAMLException: end of the stream or a document separator is expected at line 4, column 1: Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使 ... ^ at generateError (/Users/ltt/projects/puppet16.github.io/node_modules/js-yaml/lib/js-yaml/loader.js:167:10) at throwError (/Users/ltt/projects/puppet16.github.io/node_modules/js-yaml/lib/js-yaml/loader.js:173:9) at readDocument (/Users/ltt/projects/puppet16.github.io/node_modules/js-yaml/lib/js-yaml/loader.js:1539:5) at loadDocuments (/Users/ltt/projects/puppet16.github.io/node_modules/js-yaml/lib/js-yaml/loader.js:1575:5) 原因： md 文件要加一个 title 和 date 的头 解决方案： 在 md 文件开始位置添加如下代码： 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- #3. 表格显示错误 显示效果如图： 原因： 未严格按照表格格式书写，没有加对齐方式 解决方案： 添加对齐方式 #4. 表格显示过多 问题： 表格下一行的文字也算成了表格 原因： 在表格最后一行没有两个空格 解决方案： 在表格最后一行添加两个空格表示换行，再回车加一个空行 #5. No Layout 问题： 在多端操作时执行hexo g时警告：WARN No layout: index.html 原因 1： 缺少必要插件 解决文案： 运行命令npm ls --depth 0，以获取相关插件信息，如下图 可以看出缺少图片相关插件，使用相应命令安装上即可。 原因 2： 所用的主题文件是空，主题这个 git 仓库和 hexo 博客目录的 Git 仓库产生嵌套的冲突 解决方案： 删除冲突的主题文件内的 git 文件夹，重新提交 搭建 Hexo 参考文章：https://blog.csdn.net/sinat_37781304/article/details/82729029 Hexo常用命令参考：https://www.jianshu.com/p/a2d298e26dcd","link":"/2020/05/14/%E4%BD%BF%E7%94%A8Hexo%E5%AE%89%E8%A3%85GitHub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"kotlin学习系列十四：协程源码篇二 协程创建","text":"一、前言 二、 图解挂起函数 1. CPS 转换背后的细节 1. CPS 参数变化 2. CPS 返回值变化 2. 挂起函数的反编译 1. 函数能够挂起的情况 2. 协程未挂起的情况 3. 思考与实战 1. “挂起函数”与 CoroutineContext 的紧密联系 2. KtHttp 支持挂起函数 4. 总结 三、深入理解协程基础元素 1. Continuation 的两种用法 1. 实现挂起函数 2. 调用挂起函数 3. 在 Java 当中调用 Kotlin 挂起函数 2. suspendCoroutine{} 1. suspendCoroutineUninterceptedOrReturn 2. suspendCoroutineUninterceptedOrReturn 的功能和作用 3. 小结 四、深入理解协程的创建与启动–launch、sync 1. 协程启动的基础 API 2. startCoroutine() 实现原理 3. launch 是如何启动协程的 五、参考 #一、前言 本文主要讲述Kotlin 协程中的集合操作符及协程源码结构 本文是对朱涛老师讲解的Kotlin系列的总结笔记 Kotlin官网：https://kotlinlang.org/ Kotlin中文官网：https://www.kotlincn.net/ Kotlin源码：https://github.com/JetBrains/kotlin Kotlin 学习系列文章： kotlin学习系列一：内置类型 kotlin学习系列二：类与接口初解 kotlin学习系列三：表达式 kotlin学习系列四：函数进阶 kotlin学习系列五：类型进阶 kotlin学习系列六：泛型 kotlin学习系列七：反射 kotlin学习系列八：注解 kotlin学习系列九：协程一 kotlin学习系列十：协程二 kotlin学习系列十一：协程三 kotlin学习系列十二：协程四 kotlin学习系列十三：协程源码篇一 kotlin学习系列十五：协程源码篇三 协程运行 #二、 图解挂起函数 挂起函数，是整个 Kotlin 协程的核心。也正是因为挂起函数的原因，才可以使用协程简化异步任务。 #1. CPS 转换背后的细节 在前面的章节里初步介绍过挂起函数的用法：挂起函数，只是比普通的函数多了 suspend 关键字。有了这个 suspend 关键字以后，Kotlin 编译器就会特殊对待这个函数，将其转换成一个带有 Callback 的函数，这里的 Callback 就是 Continuation 接口。 而这个过程，称之为 CPS 转换： 以上的 CPS 转换过程中，函数的类型发生了变化：suspend ()-&gt;String 变成了 (Continuation)-&gt; Any?。这意味着，如果在 Java 里访问一个 Kotlin 挂起函数 getUserInfo()，会看到 getUserInfo() 的类型是 (Continuation)-&gt; Object，也就是：接收 Continuation 为参数，返回值是 Object。 而在这里，函数签名的变化可以分为两个部分：函数参数 的变化和函数返回值 的变化。 #1. CPS 参数变化 CPS 参数变化即 suspend() 变成 (Continuation) 的情况 123456789101112131415161718192021222324252627282930313233343536// 代码段1suspend fun testCoroutine() { val user = getUserInfo() val friendList = getFriendList(user) val feedList = getFeedList(user, friendList) log(feedList)}//挂起函数// ↓suspend fun getUserInfo(): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;BoyCoder&quot;}//挂起函数// ↓suspend fun getFriendList(user: String): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;Tom, Jack&quot;}//挂起函数// ↓suspend fun getFeedList(user: String, list: String): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;{FeedList..}&quot;} 上面这段代码，testCoroutine() 是一个挂起函数，它的内部依次调用了三个挂起函数。而如果从 Java 的角度来看待 testCoroutine() 的话，代码中所有的参数都会发生变化。如下所示： 1234567891011121314151617// 代码段2// 变化在这里// ↓fun testCoroutine(continuation: Continuation): Any? {// 变化在这里// ↓ val user = getUserInfo(continuation)// 变化在这里// ↓ val friendList = getFriendList(user, continuation)// 变化在这里// ↓ val feedList = getFeedList(friendList, continuation) log(feedList)} 可见，在这里的 testCoroutine() 当中，每一次函数调用的时候，continuation 都会作为最后一个参数传到挂起函数里。不过这一步是 Kotlin 编译器做的，开发者是无感知的。 为什么挂起函数可以调用挂起函数，普通函数则不能？ 其实，这个问题的答案，从 代码段 2 就可以看出来。如果 testCoroutine() 只是一个普通函数，那它就不会有 continuation 这个参数了，这样 getUserInfo()、getFriendList()、getFeedList() 这几个挂起函数自然也就无法被调用了。 #2. CPS 返回值变化 接下来看看 getUserInfo() 的返回值类型的变化： 12345678// 代码段3suspend fun getUserInfo(): String {}// 变化在这里// ↓fun getUserInfo(cont: Continuation): Any? {} 从上面的代码里，可以看到 getUserInfo() 的返回值类型从 String 变成“Any?”。Kotlin 官方之所以要弄这一套 CPS 转换规则，它必然是“等价转换”。也就是说，String 这个原本的返回值类型肯定不会消失，而是会换一种形式存在。 只是 String 存在的形式，经过 Kotlin 反编译成 Java 之后会丢失。如果直接在 Java 当中调用 getUserInfo() 的话，就会发现 String 这个返回值类型成为了 Continuation 的泛型类型。 所以，对于 getUserInfo() 这个方法，经过 CPS 转换后，它完整的函数签名应该是这样的： 12345678// 代码段4suspend fun getUserInfo(): String {}// 变化在这里// ↓fun getUserInfo(cont: Continuation&lt;String&gt;): Any? {} 挂起函数原本的返回值类型 String 只是挪了个地方，所以，Kotlin 编译器的 CPS 转换仍然是等价的转换。也就是：suspend () -&gt; String 转换成 (Continuation) -&gt; Any?。不过，这里的“Any?”又是干什么的呢？ 其实，挂起函数经过 CPS 转换后，它的返回值有一个重要作用：标志该挂起函数有没有被挂起。这听起来有点绕：挂起函数，就是可以被挂起的函数，它还能不被挂起吗？ 是的，挂起函数也能不被挂起。 首先理清几个概念。只要有 suspend 修饰的函数，它就是挂起函数，比如前面的例子： 123456789// 代码段5suspend fun getUserInfo(): String { withContext(Dispatchers.IO) { delay(1000L) } return &quot;BoyCoder&quot;} 当 getUserInfo() 执行到 withContext{} 的时候，就会返回 CoroutineSingletons.COROUTINE_SUSPENDED 表示函数被挂起了。 123456789// 代码段6// suspend 修饰// ↓suspend fun noSuspendFriendList(user: String): String{ // 函数体跟普通函数一样 return &quot;Tom, Jack&quot;} 这个方法，它的方法体跟普通函数一样。它跟一般的挂起函数有个区别：在执行的时候，它并不会被挂起，因为它就是个普通函数。当写出以下这样的代码后，IDE 也会提示，suspend 是多余的： 也就是，当调用 noSuspendFriendList() 这个挂起函数的时候，它不会真正挂起，而是会直接返回 String 类型：“no suspend”。针对这样的挂起函数，你可以把它看作是伪挂起函数 。 所以到这里，挂起函数经过 CPS 转换后，返回值变成“Any?”的原因也就清晰了：由于 suspend 修饰的函数，既可能返回 CoroutineSingletons.COROUTINE_SUSPENDED，也可能返回实际结果 “no suspend”，甚至可能返回 null，为了适配所有的可能性，CPS 转换后的函数返回值类型就只能是 Any? 了。 #2. 挂起函数的反编译 通过查看 Kotlin 反编译后的字节码，可以帮助理解 Kotlin 的底层原理。 不过，下面不会直接贴反编译后的代码，因为它的逻辑比较复杂。为了方便理解，接下来贴出的代码是用 Kotlin 翻译后大致等价的代码，改善了可读性，抹掉了不必要的细节。 #1. 函数能够挂起的情况 123456789101112// 代码段7suspend fun testCoroutine() { log(&quot;start&quot;) val user = getUserInfo() log(user) val friendList = getFriendList(user) log(friendList) val feedList = getFeedList(friendList) log(feedList)} 接下来分析 testCoroutine() 的函数体，它相当复杂，涉及到三个挂起函数的调用。 首先，在 testCoroutine() 函数里，会多出一个 ContinuationImpl 的子类，它是整个协程挂起函数的核心。 1234567891011121314151617181920212223242526// 代码段8fun testCoroutine(completion: Continuation&lt;Any?&gt;): Any? { // TestContinuation本质上是匿名内部类 class TestContinuation(completion: Continuation&lt;Any?&gt;?) : ContinuationImpl(completion) { // 表示协程状态机当前的状态 var label: Int = 0 // 协程返回结果 var result: Any? = null // 用于保存之前协程的计算结果 var mUser: Any? = null var mFriendList: Any? = null // invokeSuspend 是协程的关键 // 它最终会调用 testCoroutine(this) 开启协程状态机 // 状态机相关代码就是后面的 when 语句 // 协程的本质，可以说就是 CPS + 状态机 override fun invokeSuspend(_result: Result&lt;Any?&gt;): Any? { result = _result label = label or Int.Companion.MIN_VALUE return testCoroutine(this) } }} 代码中的这个 TestContinuation 类，是 Kotlin 编译器创建的匿名内部类，这里为了方便才用的 TestContinuation 这个名称。在这个类当中定义了几个成员变量： label 是用来代表协程状态机当中状态的； result 是用来存储当前挂起函数执行结果的； mUser、mFriendList 则是用来存储历史挂起函数执行结果的； invokeSuspend 这个函数，是整个状态机的入口，它会将执行流程转交给 testCoroutine() 进行再次调用。恢复协程是调用的 continuation.resumeWith，这个会调用 invokeSuspend 接下来是要判断 testCoroutine 是不是初次运行，如果是初次运行，就要创建一个 TestContinuation 的实例对象。 1234567891011121314// 代码段9// ↓fun testCoroutine(completion: Continuation&lt;Any?&gt;): Any? { ... val continuation = if (completion is TestContinuation) { completion } else { // 作为参数 // ↓ TestContinuation(completion) }} 也就是： invokeSuspend 最终会调用 testCoroutine，然后走到这个判断语句； 如果是初次运行，会创建一个 TestContinuation 对象，completion 作为参数； 这相当于用一个 新的 Continuation 包装了 旧的 Continuation； 如果不是初次运行，直接将 completion 赋值给 continuation； 这说明 continuation 在整个运行期间，只会产生一个实例，这能极大地节省内存开销 （对比 CallBack）。 接下来是几个变量的定义： 1234567891011121314151617// 代码段10// 三个变量，对应原函数的三个变量lateinit var user: Stringlateinit var friendList: Stringlateinit var feedList: String// result 接收协程的运行结果var result = continuation.result// suspendReturn 接收挂起函数的返回值var suspendReturn: Any? = null// CoroutineSingletons 是个枚举类// COROUTINE_SUSPENDED 代表当前函数被挂起了val sFlag = CoroutineSingletons.COROUTINE_SUSPENDED 上面的代码，分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。接着，来看看协程状态机的核心逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 代码段11when (continuation.label) { 0 -&gt; { // 检测异常 throwOnFailure(result) log(&quot;start&quot;) // 将 label 置为 1，准备进入下一次状态 continuation.label = 1 // 执行 getUserInfo suspendReturn = getUserInfo(continuation) // 判断是否挂起 if (suspendReturn == sFlag) { return suspendReturn } else { result = suspendReturn //go to next state } } 1 -&gt; { throwOnFailure(result) // 获取 user 值 user = result as String log(user) // 将协程结果存到 continuation 里 continuation.mUser = user // 准备进入下一个状态 continuation.label = 2 // 执行 getFriendList suspendReturn = getFriendList(user, continuation) // 判断是否挂起 if (suspendReturn == sFlag) { return suspendReturn } else { result = suspendReturn //go to next state } } 2 -&gt; { throwOnFailure(result) user = continuation.mUser as String // 获取 friendList 的值 friendList = result as String log(friendList) // 将协程结果存到 continuation 里 continuation.mUser = user continuation.mFriendList = friendList // 准备进入下一个状态 continuation.label = 3 // 执行 getFeedList suspendReturn = getFeedList(user, friendList, continuation) // 判断是否挂起 if (suspendReturn == sFlag) { return suspendReturn } else { result = suspendReturn //go to next state } } 3 -&gt; { throwOnFailure(result) user = continuation.mUser as String friendList = continuation.mFriendList as String feedList = continuation.result as String log(feedList) loop = false }} 在 testCoroutine() 这个方法体当中，一共调用了三个挂起函数，这三个挂起函数把整个方法体分割成了 4 个部分，这四个部分就是上面 when 表达式当中的 4 种情况。 when 表达式实现了协程状态机； continuation.label 是状态流转的关键，continuation.label 改变一次，就代表了挂起函数被调用了一次； 每次挂起函数执行完后，都会检查是否发生异常； testCoroutine 里的原本的代码，被拆分到状态机里各个状态中，分开执行； getUserInfo(continuation)、getFriendList(user, continuation)、getFeedList(friendList, continuation) 三个函数调用的是同一个 continuation 实例； 如果一个函数被挂起了，它的返回值会是 CoroutineSingletons.COROUTINE_SUSPENDED； 在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 continuation 中。 #2. 协程未挂起的情况 要验证也很简单，将其中一个挂起函数改成 伪挂起函数即可。 123456789101112131415161718192021// 代码段12// “伪”挂起函数// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数// ↓suspend fun noSuspendFriendList(user: String): String{ return &quot;Tom, Jack&quot;}suspend fun testNoSuspend() { log(&quot;start&quot;) val user = getUserInfo() log(user) // 变化在这里 // ↓ val friendList = noSuspendFriendList(user) log(friendList) val feedList = getFeedList(friendList) log(feedList)} testNoSuspend() 这样的一个函数体，反编译后的代码结构 跟前面的 testCoroutine() 是一致的，只是函数名字变了而已，Kotlin 编译器 CPS 转换的逻辑只认 suspend 关键字。 就算挂起函数内部并没有挂起的逻辑，Kotlin 编译器也照样会进行 CPS 转换。 12345678910111213141516171819202122232425262728293031// 代码段13when (continuation.label) { 0 -&gt; { ... } 1 -&gt; { ... // 变化在这里 // ↓ suspendReturn = noSuspendFriendList(user, continuation) // 判断是否挂起 if (suspendReturn == sFlag) { return suspendReturn } else { result = suspendReturn //go to next state } } 2 -&gt; { ... } 3 -&gt; { ... }} 那 testNoSuspend() 的协程状态机如下， continuation.label = 0, 2, 3 的情况都是不变的，唯独在 label = 1 的时候，suspendReturn == sFlag 这里会有区别。 对于“伪挂起函数”，suspendReturn == sFlag 是会走 else 分支的，在 else 分支里，协程状态机会直接进入下一个状态。 现在只剩最后一个问题： 123456789// 代码段14if (suspendReturn == sFlag) {} else { // 具体代码是如何实现的？ // ↓ //go to next state} 答案其实也很简单：如果你看协程状态机的字节码反编译后的 Java，会看到很多 label。协程状态机底层字节码，是通过 label 来实现这个 go to next state 的。由于 Kotlin 没有类似 goto 的语法，下面我伪代码来表示 go to next state 的逻辑。 123456789101112131415161718192021222324252627282930313233// 代码段15// 伪代码// Kotlin 没有这样的语法// ↓ ↓label: whenStartwhen (continuation.label) { 0 -&gt; { ... } 1 -&gt; { ... suspendReturn = noSuspendFriendList(user, continuation) if (suspendReturn == sFlag) { return suspendReturn } else { result = suspendReturn // 让程序跳转到 label 标记的地方 // 从而再执行一次 when 表达式 goto: whenStart } } 2 -&gt; { ... } 3 -&gt; { ... }} 需要注意的是：以上只是伪代码，它只是跟协程状态机字节码逻辑上“大致等价”。真实的字节码反编译出来的 Java 代码，它的可读性要差很多，也更难理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 代码段16// 看不懂也没关系，有个印象即可@Nullablepublic static final Object testCoroutine(@NotNull Continuation $completion) { Object $continuation; label37: { if ($completion instanceof &lt;TestSuspendKt$testCoroutine$1&gt;) { $continuation = (&lt;TestSuspendKt$testCoroutine$1&gt;)$completion; if ((((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label &amp; Integer.MIN_VALUE) != 0) { ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label -= Integer.MIN_VALUE; break label37; } } $continuation = new ContinuationImpl($completion) { // $FF: synthetic field Object result; int label; Object L$0; Object L$1; @Nullable public final Object invokeSuspend(@NotNull Object $result) { this.result = $result; this.label |= Integer.MIN_VALUE; return TestSuspendKt.testCoroutine(this); } }; } Object var10000; label31: { String user; String friendList; Object var6; label30: { Object $result = ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).result; var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch(((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label) { case 0: ResultKt.throwOnFailure($result); log(&quot;start&quot;); ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label = 1; var10000 = getUserInfo((Continuation)$continuation); if (var10000 == var6) { return var6; } break; case 1: ResultKt.throwOnFailure($result); var10000 = $result; break; case 2: user = (String)((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0; ResultKt.throwOnFailure($result); var10000 = $result; break label30; case 3: friendList = (String)((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$1; user = (String)((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0; ResultKt.throwOnFailure($result); var10000 = $result; break label31; default: throw new IllegalStateException(&quot;call to 'resume' before 'invoke' with coroutine&quot;); } user = (String)var10000; log(user); ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0 = user; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label = 2; var10000 = getFriendList(user, (Continuation)$continuation); if (var10000 == var6) { return var6; } } friendList = (String)var10000; log(friendList); ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0 = user; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$1 = friendList; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label = 3; var10000 = getFeedList(friendList, (Continuation)$continuation); if (var10000 == var6) { return var6; } } String feedList = (String)var10000; log(feedList); return Unit.INSTANCE;} 本质上来说，Kotlin 协程就是通过 label 代码段嵌套，配合 switch 巧妙构造出一个状态机结构，这种逻辑比较复杂，相对难懂一些。毕竟 Java 的 label 在实际开发中用的很少。 注意：Kotlin 挂起函数反编译出来的 Java 代码，会因为实际开发环境的不同出现细微差异。随着 Kotlin 编译器的发展，将来可能会对这部分逻辑进一步优化，但它的核心状态机思想是不会轻易改变的。 好，到现在，就已经彻底弄懂挂起函数的实现原理了。接下来，结合刚刚学习的内容，来进一步思考实战一下。 #3. 思考与实战 #1. “挂起函数”与 CoroutineContext 的紧密联系 Kotlin 协程的源代码其实分为三层，其中基础层当中的“基础概念”尤为重要。那么，Kotlin 官方提供了哪些与挂起函数相关的基础元素呢 首先想到的，肯定就是 Continuation.kt，在这里面，确实也可以找到一些跟挂起函数相关的基础元素。 123456789101112131415// 代码段17public interface Continuation&lt;in T&gt; { public val context: CoroutineContext public fun resumeWith(result: Result&lt;T&gt;)}@Suppress(&quot;WRONG_MODIFIER_TARGET&quot;)public suspend inline val coroutineContext: CoroutineContext get() { throw NotImplementedError(&quot;Implemented as intrinsic&quot;) } 在上面的代码中，最熟悉的就是 Continuation 这个接口了，除此之外，还有一个顶层的变量值得注意：suspend inline val coroutineContext。要知道，从来都是用 suspend 修饰函数的，从未见过 suspend 修饰变量的情况。 如果开发者自己依葫芦画瓢，创建一个类似的顶层变量的话，编译器甚至会报错： 123456// 代码段18// 报错public suspend inline val test: CoroutineContext get() = TODO() 由此可见，suspend 的这种用法只是一种特殊用法。结合“public suspend inline val”这几个关键字来看，其实可以大致推测出它的作用：它是一个只有在挂起函数作用域下，才能访问的顶层的不可变的变量。这里的 inline，意味着它的具体实现会被直接复制到代码的调用处。 1234567891011// 代码段19import kotlinx.coroutines.*import kotlin.coroutines.coroutineContext// 挂起函数能可以访问协程上下文吗？// ↓ suspend fun testContext() = coroutineContext 如果将上面的代码反编译成 Java 的话，它就会变成这样： 123456// 代码段20public static final Object testContext(Continuation $completion) { return $completion.getContext();} 由此可见，代码段 17 当中的“suspend inline val coroutineContext”，本质上就是 Kotlin 官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是 Kotlin 编译器来完成的。 1234567891011// 代码段19import kotlinx.coroutines.*import kotlin.coroutines.coroutineContext// Continuation当中的coroutineContext// ↓ suspend fun testContext() = coroutineContext 在挂起函数当中无法直接访问 Continuation 对象，但可以访问到 Continuation 当中的 coroutineContext。 正常情况下，想要访问 Continuation.coroutineContext，首先是要拿到 Continuation 对象的。但是，Kotlin 官方通过“suspend inline val coroutineContext”这个顶层变量，让开发者能直接拿到 coroutineContext，却对 Continuation 毫无感知。 所以，挂起函数与 CoroutineContext 确实有着紧密的联系。每个挂起函数当中都会有 Continuation，而每个 Continuation 当中都会有 coroutineContext。并且，在挂起函数当中，就可以直接访问当前的 coroutineContext。 #2. KtHttp 支持挂起函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556interface ApiServiceV7 { @GET(&quot;/repo&quot;) // 1，挂起函数 suspend fun reposSuspend( @Field(&quot;lang&quot;) lang: String, @Field(&quot;since&quot;) since: String ): RepoList}private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略 return when { isSuspend(method) -&gt; { // 2，支持挂起函数 } isKtCallReturn(method) -&gt; { // 省略 } isFlowReturn(method) -&gt; { // 省略 } else -&gt; { // 省略 } }}// 3，判断是不是挂起函数private fun isSuspend(method: Method) = method.kotlinFunction?.isSuspend ?: false// 4，真正执行网络请求的方法suspend fun &lt;T: Any&gt; realCall(call: Call, gson: Gson, type: Type): T = suspendCancellableCoroutine { continuation -&gt; call.enqueue(object : Callback { override fun onFailure(call: Call, e: IOException) { continuation.resumeWithException(e) } override fun onResponse(call: Call, response: okhttp3.Response) { try { val t = gson.fromJson&lt;T&gt;(response.body?.string(), type) continuation.resume(t) } catch (e: Exception) { continuation.resumeWithException(e) } } }) continuation.invokeOnCancellation { call.cancel() }} 这段代码一共有 4 个注释： 注释 1，这其实就是希望达到的效果，可以在 ApiServiceV 接口当中直接定义挂起函数。 注释 2，在 KtHttp 6.0 版本的基础上，我们在 invoke() 的 when 表达式里增加了一个分支：isSuspend()。 注释 3，isSuspend() 的实现有一个细节，这里使用了“method.kotlinFunction”，将 Java 的 method 转换成了 kotlinFunction，这样一来，它就变成了一个 Kotlin 反射的对象了。因此，就可以查询到一些 Kotlin 相关的信息，比如说，它是不是一个挂起函数。 注释 4，为了直接在挂起函数里执行网络请求，将 KtCall 当中的部分代码逻辑挪了进来。这个 realCall() 方法，它被定义成了一个挂起函数。 基于以上的分析，其实只需要借助反射，完成注释 2 处的代码逻辑，然后调用 realCall() 这个挂起函数就行了。 12345678910111213141516171819private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略 return when { isSuspend(method) -&gt; { // 1，反射获取类型信息 // 2，调用realCall() } isKtCallReturn(method) -&gt; { // 省略 } isFlowReturn(method) -&gt; { // 省略 } else -&gt; { // 省略 } }} 所以，接下来要做的事情大致可以分为两个部分。 第一个部分，获取类型信息，准备请求网络，这个部分其实很简单。但在第二个部分“支持挂起函数”这里会遇到问题： 12345678910111213141516171819202122private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略 return when { isSuspend(method) -&gt; { // 支持挂起函数 val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException() val call = okHttpClient!!.newCall(request) // 报错！！ realCall&lt;T&gt;() } isKtCallReturn(method) -&gt; { // 省略 } isFlowReturn(method) -&gt; { // 省略 } else -&gt; { // 省略 } }} 以上代码报错的原因也很容易理解，realCall() 是一个挂起函数，它无法在普通函数里被调用！所以这里就面临了一个问题：如何在普通 Kotlin 函数当中调用挂起函数？那么，首先可以想到的解决办法，就是强制类型转换： 12345678910111213141516171819202122232425private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略 return when { isSuspend(method) -&gt; { // 支持挂起函数 val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException() val call = okHttpClient!!.newCall(request) val continuation = args.last() as? Continuation&lt;T&gt; // 1，将挂起函数类型转换成，带Continuation的类型，报错 val func = ::realCall as (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any? func.invoke(call, gson, genericReturnType, continuation) } isKtCallReturn(method) -&gt; { // 省略 } isFlowReturn(method) -&gt; { // 省略 } else -&gt; { // 省略 } }} 留意代码中的 注释 1，尝试使用“函数引用”的方式，将 realCall() 转换成了带有 Continuation 的函数类型，这样就可以通过传入 Continuation，来调用 realCall() 这个挂起函数了。 不过，事与愿违，这种方法并不能奏效，因为这行代码会报错，原因是 realCall() 带有泛型，而 Kotlin 暂时不支持“函数引用带泛型”的语法。 所以在这里，为了让这个 Demo 能运行起来，可以定义一个临时方法： 123456789101112131415161718192021222324252627private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略 return when { isSuspend(method) -&gt; { // 支持挂起函数 val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException() val call = okHttpClient!!.newCall(request) val continuation = args.last() as? Continuation&lt;T&gt; // 1，使用临时方法消除泛型 val func = ::temp as (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any? func.invoke(call, gson, genericReturnType, continuation) } isKtCallReturn(method) -&gt; { // 省略 } isFlowReturn(method) -&gt; { // 省略 } else -&gt; { // 省略 } }}suspend fun temp(call: Call, gson: Gson, type: Type) = realCall&lt;RepoList&gt;(call, gson, type) 在上面的代码中，使用了一个临时方法消除了泛型 T，写死了返回值类型 RepoList。这样的代码，在 Demo 当中是可以运行的，这从侧面也能印证上面代码中的类型转换是成功的。 12345678910111213fun main() = runBlocking { val data: RepoList = KtHttpV7.create(ApiServiceV7::class.java).reposSuspend( lang = &quot;Kotlin&quot;, since = &quot;weekly&quot; ) println(data)}/*输出结果正常*/ 不过，这种做法明显不具备普适性 ，为了让 KtHttp 支持所有类型的 API 请求，必须要想其他的办法。具体来说，可以这样做： 12345678910111213141516171819202122232425262728293031private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? { // 省略 return when { isSuspend(method) -&gt; { // 支持挂起函数 val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException() val call = okHttpClient!!.newCall(request) val continuation = args.last() as? Continuation&lt;T&gt; val func = KtHttpV7::class.getGenericFunction(&quot;realCall&quot;) // 反射调用realCall() func.call(this, call, gson, genericReturnType, continuation) } isKtCallReturn(method) -&gt; { // 省略 } isFlowReturn(method) -&gt; { // 省略 } else -&gt; { // 省略 } }}// 2，获取方法的反射对象fun KClass&lt;*&gt;.getGenericFunction(name: String): KFunction&lt;*&gt; { return members.single { it.name == name } as KFunction&lt;*&gt; } 其实，这种思路跟前面的思路是类似的，仍然是对 realCall() 的类型进行了转换，只不过是通过反射来实现的而已。所以最重要的，还是要弄清楚 Kotlin 挂起函数 CPS 转换的细节。 #4. 总结 通过研究挂起函数的反编译代码，发现了 Kotlin 的挂起函数，本质上就是一个状态机。其中主要涉及到下面几个知识点，需要重点掌握好。 Kotlin 挂起函数的 CPS 转换，它的函数签名变化主要分为两个部分，第一部分是 参数的变化，挂起函数经过 Kotlin 编译器转换以后，它会多出一个 Continuation 类型的参数。第二部分是 返回值类型的变化，挂起函数原本的返回值类型，会被挪到 Continuation 当中作为泛型参数，比如 Continuation&lt;String&gt;，而转换过后的函数返回值类型会变成“Any?”类型。 当挂起函数经过反编译以后，它会变成 由 switch 和 label 组成的状态机结构。 为了便于研究，上面提供了大致等价的协程状态机代码：其中，when 表达式实现了协程状态机，而 continuation.label 则代表了当前状态机的具体状态，continuation.label 改变一次，就代表了挂起函数被调用了一次； 在一个挂起函数被调用的时候，它的返回值可能是具体的结果，也可能会是 CoroutineSingletons.COROUTINE_SUSPENDED，这时候就代表了这个函数被挂起了。 如何在Java 代码中调用 Kotlin 的挂起函数？ 比如，下面这个函数，如何在 Java 当中调用： 12345678object SuspendFromJavaExample { // 在Java当中如何调用这个方法？ suspend fun getUserInfo(id: Long):String { delay(1000L) return &quot;Kotlin&quot; }} 方法一： 当挂起函数通过 Kotlin 编译器进行 CPS 转换后，对应的挂起函数就被转换成了带 Callback 参数 （Continuation 接口） 的普通函数，只要传入 Continuation 接口的实现就可以了。 方法二： 在Java中的getContext()中可考虑传入EmptyCoroutineContext.INSTANCE #三、深入理解协程基础元素 Kotlin 协程的基础元素大致有这些：Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。 其中的 CoroutineContext、CancellationException 前面已介绍过，另外的 CombinedContext，就是 CoroutineContext 的一个实现类，而 SafeContinuation 则是 Continuation 的实现类。 所以，在整个协程基础元素当中，最需要关心的，其实就是 Continuation 和 intrinsics。在 intrinsics 里，有一个重要的高阶函数 suspendCoroutineUninterceptedOrReturn{}。 #1. Continuation 的两种用法 #1. 实现挂起函数 1234567891011121314151617181920212223// 代码段1suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T = suspendCancellableCoroutine { continuation -&gt; val call = call(object : Callback&lt;T&gt; { override fun onSuccess(data: T) { // 注意这里 continuation.resume(data) } override fun onFail(throwable: Throwable) { // 注意这里 continuation.resumeWithException(throwable) } }) continuation.invokeOnCancellation { println(&quot;Call cancelled!&quot;) call.cancel() } } 如上代码实现了一个具有取消支持的挂起函数。在这段代码中，使用suspendCancellableCoroutine函数创建了一个挂起函数。在onSuccess回调中，使用continuation.resume(data)来恢复挂起的协程并传递数据。在onFail回调中，使用continuation.resumeWithException(throwable)来恢复挂起的协程并传递异常信息。此外，还使用continuation.invokeOnCancellation来注册一个取消回调，以确保在协程取消时取消网络请求。 当想要实现挂起函数的时候，可以使用 suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，在它们的 Lambda 当中，可以使用它暴露出来的 continuation 对象，把程序的执行结果或异常传到外部去。这种方式，往往是用于实现挂起函数内部逻辑的。 #2. 调用挂起函数 用 suspendCoroutine{}写一个更加简单的例子： 1234567891011121314151617181920// 代码段2fun main() = runBlocking { val result = getLengthSuspend(&quot;Kotlin&quot;) println(result)}suspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation-&gt; thread { // 模拟耗时 Thread.sleep(1000L) continuation.resume(text.length) }}/*输出结果：等待1秒6*/ 以上代码里，使用 suspendCoroutine{}实现了挂起函数，然后在它的内部，使用 continuation.resume() 的方式，传出了挂起函数的返回值。 1234567891011121314151617181920212223242526272829303132// 代码段3// 变化在这里fun main() { val func = ::getLengthSuspend as (String, Continuation&lt;Int&gt;) -&gt; Any? func(&quot;Kotlin&quot;, object: Continuation&lt;Int&gt;{ override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result&lt;Int&gt;) { println(result.getOrNull()) } }) // 防止程序提前结束 Thread.sleep(2000L)}suspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation-&gt; thread { // 模拟耗时 Thread.sleep(1000L) continuation.resume(text.length) }}/*输出结果：等待1秒6*/ 这段代码里，把 getLengthSuspend() 这个函数强转成了带有 Continuation 的函数类型，然后通过匿名内部类的方式，创建了一个 Continuation 对象传了进去。最终，程序的执行结果和 代码段 2 是一致的。 挂起函数的本质，就是 Callback! 1234567891011121314151617181920212223242526272829303132// 代码段4// 变化在这里fun main() { func(&quot;Kotlin&quot;, object: Callback&lt;Int&gt;{ override fun resume(result: Int) { println(result) } }) // 防止程序提前结束 Thread.sleep(2000L)}fun func(text: String, callback: Callback&lt;Int&gt;) { thread { // 模拟耗时 Thread.sleep(1000L) callback.resume(text.length) }}interface Callback&lt;T&gt; { fun resume(value: T)}/*输出结果：等待1秒6*/ 上述代码中，当把 Continuation 改成 Callback 以后，整个代码就变成了最熟悉的异步回调代码了。调用方，可以使用匿名内部类创建 Callback 用于接收异步结果；异步函数内部，使用 callback.resume() 将结果传出去。 综上所述，Kotlin 协程当中的 Continuation，作用其实就相当于 Callback，它既可以用于 实现挂起函数，往挂起函数的外部传递结果；也可以用于 调用挂起函数，可以创建 Continuation 的匿名内部类，来接收挂起函数传递出来的结果。 #3. 在 Java 当中调用 Kotlin 挂起函数 12345678910// 代码段5// 需要在Java中调用的Kotlin挂起函数object SuspendFromJavaExample { // 在Java当中如何调用这个方法？ suspend fun getUserInfo(id: Long):String { delay(1000L) return &quot;Kotlin&quot; }} 上面这个函数，可以在 Java 当中调用： 123456789101112131415161718192021222324// 代码段6public static void main(String[] args) throws InterruptedException { SuspendFromJavaExample.INSTANCE.getUserInfo(100L, new Continuation&lt;String&gt;() { @NotNull @Override public CoroutineContext getContext() { return EmptyCoroutineContext.INSTANCE; } @Override public void resumeWith(@NotNull Object o) { System.out.println(o+&quot;&quot;); } }); // 防止程序提前结束 Thread.sleep(2000L);}/*输出结果Kotlin*/ 这段代码演示了 在Java中调用Kotlin的挂起函数。通过创建SuspendFromJavaExample的单例对象，然后调用其getUserInfo方法，传入一个实现了Continuation接口的匿名内部类。在这个内部类中，通过重写resumeWith方法来处理挂起函数的返回结果，在这里将结果打印出来。 可以发现，在实现挂起函数逻辑的时候，总是离不开 suspendCoroutine{}、suspendCancellableCoroutine{}。 #2. suspendCoroutine{} suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数的实现原理是类似的，所以这里就主要探究下 suspendCoroutine{}。 suspendCoroutine{}的源代码，在Continuation.kt文件当中。 #1. suspendCoroutineUninterceptedOrReturn 12345678910111213141516// 代码段7public interface Continuation&lt;in T&gt; { public val context: CoroutineContext public fun resumeWith(result: Result&lt;T&gt;)}public suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T { // 注意这里 return suspendCoroutineUninterceptedOrReturn { c: Continuation&lt;T&gt; -&gt; val safe = SafeContinuation(c.intercepted()) block(safe) safe.getOrThrow() }} 在上面的代码中，高阶函数 suspendCoroutineUninterceptedOrReturn{}其实就是实现 suspendCoroutine{}的关键。除了它之外，其他部分的代码都很好理解： SafeContinuation(c.intercepted()) 这行代码的作用，就是把原本的 Continuation 包裹一遍。 block(safe) 这行代码，其实就是在调用 Lambda 当中的逻辑。 safe.getOrThrow()，就是在取出 block(safe) 的运行结果，Continuation 当中是可以存储 result 的。这个 Result 可能是正确的结果，也可能是异常。 下面重点来看看 suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用。 123456// 代码段8public suspend inline fun &lt;T&gt; suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation&lt;T&gt;) -&gt; Any?): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } throw NotImplementedError(&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;)} 由上suspendCoroutineUninterceptedOrReturn源码可以看到，这个高阶函数的源代码会是抛出了一个异常。异常内容：“Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic.”。理解这句话的关键在于 “intrinsic” 这个单词，它有“固有”“本质”的意思，不过在上面这句话的语境下，这里的 intrinsic 其实是指编译器领域的一个术语，可以把它理解为 “内建”。因此，上面看到的异常提示信息的意思就是：suspendCoroutineUninterceptedOrReturn 是一个编译器内建函数，它是由 Kotlin 编译器来实现的。 Kotlin 编译器当中的逻辑源码：coroutineCodegenUtil.kt #2. suspendCoroutineUninterceptedOrReturn 的功能和作用 suspendCoroutineUninterceptedOrReturn 这个高阶函数，会接收一个 Lambda，类型是(Continuation) -&gt; Any?，这里的 “Any?” 类型，其实就能代表当前这个挂起函数是否真正挂起。 12345678910111213141516// 代码段9fun main() = runBlocking { val result = testNoSuspendCoroutine() println(result)}private suspend fun testNoSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn&lt;String&gt; { continuation -&gt; return@suspendCoroutineUninterceptedOrReturn &quot;Hello!&quot;}/*输出结果：Hello!*/ 在这段代码中，直接使用 suspendCoroutineUninterceptedOrReturn 实现了挂起函数，并且，在它的 Lambda 当中，并没有调用 continuation.resume()，而是直接返回了结果 “Hello!”。根据程序的运行结果，在挂起函数的外部确实也可以接收到这个结果。 上面的代码反编译后的代码如下： 12345678910// 代码段10private static final Object testNoSuspendCoroutine(Continuation $completion) { int var2 = false; if (&quot;Hello!&quot; == IntrinsicsKt.getCOROUTINE_SUSPENDED()) { DebugProbesKt.probeCoroutineSuspended($completion); } return &quot;Hello!&quot;;} 从反编译的结果来看，testNoSuspendCoroutine() 这个函数其实就是一个伪挂起函数，它的内部并不会真正挂起，而是直接返回结果。这样，当从外部调用这个函数的时候，这个函数会立即返回结果 “Hello!”。 真正的挂起函数如下： 1234567891011121314151617181920212223// 代码段11fun main() = runBlocking { val result = testSuspendCoroutine() println(result)}private suspend fun testSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn&lt;String&gt; { continuation -&gt; thread { Thread.sleep(1000L) continuation.resume(&quot;Hello!&quot;) } return@suspendCoroutineUninterceptedOrReturn kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED}/*输出结果：等待1秒Hello!*/ 这一次，并没有使用 return 返回结果，而是使用了 continuation.resume()。通过程序运行结果，可以看到挂起函数的外部也能接收到这个结果。 反编译对应的 Java 代码： 1234567891011121314151617181920212223242526272829303132333435363738// 代码段12private static final Object testSuspendCoroutine(Continuation $completion) { int var2 = false; // 1 ThreadsKt.thread$default(false, false, (ClassLoader)null, (String)null, 0, (Function0)(new CoroutineBasicElementsKt$testSuspendCoroutine$2$1($completion)), 31, (Object)null); // 2 Object var10000 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); if (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) { DebugProbesKt.probeCoroutineSuspended($completion); } // 3 return var10000;}final class CoroutineBasicElementsKt$testSuspendCoroutine$2$1 extends Lambda implements Function0 { final Continuation $it; public Object invoke() { this.invoke(); return Unit.INSTANCE; } public final void invoke() { // 4 Thread.sleep(1000L); Continuation var1 = this.$it; String var2 = &quot;Hello!&quot;; Companion var3 = Result.Companion; var1.resumeWith(Result.constructor-impl(var2)); } CoroutineBasicElementsKt$testSuspendCoroutine$2$1(Continuation var1) { super(0); this.$it = var1; }} 说明： 注释 1、4 ，创建了一个新的线程，执行了 thread{} 当中的代码。 注释 2，将 var10000 赋值为 COROUTINE_SUSPENDED 这个挂起标志位。 注释 3，返回挂起标志位，代表 testSuspendCoroutine() 这个函数会真正挂起。 所以，这两个例子也从侧面证明了一个结论：由于 suspend 修饰的函数，既可能返回 CoroutineSingletons.COROUTINE_SUSPENDED，也可能返回实际结果，甚至可能返回 null，为了适配所有的可能性，CPS 转换后的函数返回值类型就只能是 Any? 了。 那么现在，也就可以总结出 suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用了：它可以将挂起函数当中的 Continuation 以参数的形式暴露出来，在它的 Lambda 当中，可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，也可以返回 COROUTINE_SUSPENDED 这个挂起标志位，然后使用 continuation.resume() 传递结果。 相应的，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，只是对它的一种封装而已。 #3. 小结 Continuation 是整个协程当中最重要的基础元素，可以将其看做是一个 Callback。它主要有两个使用场景: 一种是在实现挂起函数的时候，用于传递挂起函数的执行结果； 另一种是在调用挂起函数的时候，以匿名内部类的方式，用于接收挂起函数的执行结果。 借助这种思路，也完全可以在 Java 当中调用挂起函数。当想要实现挂起函数的时候，需要使用 suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数。它们两个都是对 suspendCoroutineUninterceptedOrReturn{}的封装，这个高阶函数的作用其实就是暴露挂起函数的 Continuation 对象。在它的 Lambda 当中，既可以直接返回执行结果，也可以返回 COROUTINE_SUSPENDED 这个挂起标志位，然后使用 continuation.resume() 传递结果。 #四、深入理解协程的创建与启动–launch、sync #1. 协程启动的基础 API 在Continuation.kt这个文件当中，有两个重要的扩展函数： 123456789101112// 代码段2public fun &lt;T&gt; (suspend () -&gt; T).createCoroutine( completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)public fun &lt;T&gt; (suspend () -&gt; T).startCoroutine( completion: Continuation&lt;T&gt;) { createCoroutineUnintercepted(completion).intercepted().resume(Unit)} 其实，createCoroutine{}、startCoroutine{}这两个函数，就是 Kotlin 协程当中最基础的两个创建协程的 API。 启动协程有三种常见的方式：launch、runBlocking、async。它们其实属于协程中间层提供的 API，而它们的底层都在某种程度上调用了“基础层”的协程 API。也就是说，使用协程的基础层 API，也可以创建协程。 createCoroutine{}、startCoroutine{}，它们都是扩展函数，其扩展接收者类型是一个函数类型：suspend () -&gt; T，代表了“无参数，返回值为 T 的挂起函数或者 Lambda”。而对于函数本身，它们两个都接收一个 Continuation&lt;T&gt; 类型的参数，其中一个函数，还会返回一个 Continuation&lt;Unit&gt; 类型的返回值。 12345678910111213141516171819202122232425262728293031323334// 代码段3fun main() { testStartCoroutine() Thread.sleep(2000L)}val block = suspend { println(&quot;Hello!&quot;) delay(1000L) println(&quot;World!&quot;) &quot;Result&quot;}private fun testStartCoroutine() { val continuation = object : Continuation&lt;String&gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result&lt;String&gt;) { println(&quot;Result is: ${result.getOrNull()}&quot;) } } block.startCoroutine(continuation)}/*输出结果Hello!World!Result is: Result*/ 在这段代码中，定义了一个 Lambda 表达式 block，它的类型就是 suspend () -&gt; T。这样一来，就可以用 block.startCoroutine() 来启动协程了。这里，还创建了一个匿名内部类对象 continuation，作为 startCoroutine() 的参数。 上文中提到过， Continuation 主要有两种用法，一种是在实现挂起函数的时候，用于 传递挂起函数的执行结果；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于 接收挂起函数的执行结果。而 代码段 3 中 Continuation 的作用，则明显属于后者。 从 代码段 3 的执行结果中，可以看出来，startCoroutine() 的作用其实就是创建一个新的协程，并且执行 block 当中的逻辑，等协程执行完毕以后，将结果返回给 Continuation 对象。而这个逻辑，使用 createCoroutine() 这个方法其实也可以实现。 123456789101112131415161718192021222324代码段4private fun testCreateCoroutine() { val continuation = object : Continuation&lt;String&gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result&lt;String&gt;) { println(&quot;Result is: ${result.getOrNull()}&quot;) } } val coroutine = block.createCoroutine(continuation) coroutine.resume(Unit)}/*输出结果Hello!World!Result is: Result*/ 根据以上代码，可以看到，createCoroutine() 的作用其实就是创建一个协程，并暂时先不启动它。等想要启动它的时候，直接调用 resume() 即可。进一步分析 代码段 2 当中的源代码，会发现 createCoroutine()、startCoroutine() 的源代码差别也并不大，只是前者没有调用 resume()，而后者调用了 resume()。 换句话说，startCoroutine() 之所以可以创建并同时启动协程的原因就在于，它在源码中直接调用了 resume(Unit)，所以，在 代码段 3 当中就不需要自己调用 resume() 方法了。 #2. startCoroutine() 实现原理 下面，以 startCoroutine() 为例，来研究下它的实现原理。把 代码段 3 反编译成 Java ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 代码段5public final class LaunchUnderTheHoodKt { // 1 public static final void main() { testStartCoroutine(); Thread.sleep(2000L); } // 2 private static final Function1&lt;Continuation&lt;? super String&gt;, Object&gt; block = new LaunchUnderTheHoodKt$block$1(null); // 3 public static final Function1&lt;Continuation&lt;? super String&gt;, Object&gt; getBlock() { return block; } // 4 static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1&lt;Continuation&lt;? super String&gt;, Object&gt; { int label; LaunchUnderTheHoodKt$block$1(Continuation $completion) { super(1, $completion); } @Nullable public final Object invokeSuspend(@NotNull Object $result) { Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1); System.out .println(&quot;Hello!&quot;); this.label = 1; if (DelayKt.delay(1000L, (Continuation)this) == object) return object; DelayKt.delay(1000L, (Continuation)this); System.out .println(&quot;World!&quot;); return &quot;Result&quot;; case 1: ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1); System.out.println(&quot;World!&quot;); return &quot;Result&quot;; } throw new IllegalStateException(&quot;call to 'resume' before 'invoke' with coroutine&quot;); } @NotNull public final Continuation&lt;Unit&gt; create(@NotNull Continuation&lt;? super LaunchUnderTheHoodKt$block$1&gt; $completion) { return (Continuation&lt;Unit&gt;)new LaunchUnderTheHoodKt$block$1($completion); } @Nullable public final Object invoke(@Nullable Continuation&lt;?&gt; p1) { return ((LaunchUnderTheHoodKt$block$1)create(p1)).invokeSuspend(Unit.INSTANCE); } } // 5 private static final void testStartCoroutine() { LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 continuation = new LaunchUnderTheHoodKt$testStartCoroutine$continuation$1(); ContinuationKt.startCoroutine(block, continuation); } // 6 public static final class LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 implements Continuation&lt;String&gt; { @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { System.out.println(Intrinsics.stringPlus(&quot;Result is: &quot;, Result.isFailure-impl(result) ? null : result)); } }}internal abstract class SuspendLambda( public override val arity: Int, completion: Continuation&lt;Any?&gt;?) : ContinuationImpl(completion), FunctionBase&lt;Any?&gt;, SuspendFunction {} 说明： 注释 1，是 main() 函数。由于它本身只是一个普通的函数，因此反编译之后，逻辑并没有什么变化。 注释 2、3，它们是 Kotlin 为 block 变量生成的静态变量以及方法。 注释 4，LaunchUnderTheHoodKt$block$1，其实就是 block 具体的实现类。这个类继承自 SuspendLambda，而 SuspendLambda 是 ContinuationImpl 的子类，因此它也间接实现了 Continuation 接口。其中的 invokeSuspend()，也就是之前分析过的协程状态机逻辑。除此之外，它还有一个 create() 方法。 注释 5，它对应了 testStartCoroutine() 这个方法，原本的 block.startCoroutine(continuation) 变成了“ContinuationKt.startCoroutine(block, continuation)”，这其实就体现出了扩展函数的原理。 注释 6，其实就是 continuation 变量对应的匿名内部类。 接下来，对照着反编译代码，来分析整个代码的执行流程: 首先，main() 函数会调用 testStartCoroutine() 函数，接着，就会调用 startCoroutine() 方法。 123456789// 代码段6public fun &lt;T&gt; (suspend () -&gt; T).startCoroutine( completion: Continuation&lt;T&gt;) {// 注意这里// ↓createCoroutineUnintercepted(completion).intercepted().resume(Unit)} 从 代码段 6 里，可以看到，在 startCoroutine() 当中，首先会调用 createCoroutineUnintercepted() 方法。它的源代码只存在一个声明，并没有具体实现： 1234567// 代码段7// 注意这里// ↓public expect fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted( completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; 上面代码中的 expect，可以把它理解为一种声明，由于 Kotlin 是面向多个平台的，具体的实现，就需要在特定的平台实现。所以在这里，就需要打开 Kotlin 的源代码，找到 JVM 平台 IntrinsicsJvm 对应的实现： 1234567891011121314151617// 代码段8// 1，注意这里// ↓public actual fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted( completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; { val probeCompletion = probeCoroutineCreated(completion) // 2，注意这里 // ↓ return if (this is BaseContinuationImpl) create(probeCompletion) else createCoroutineFromSuspendFunction(probeCompletion) { (this as Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it) }} 注释 1 ，这个 actual，代表了 createCoroutineUnintercepted() 在 JVM 平台的实现。另外，可以看到，createCoroutineUnintercepted() 仍然还是一个扩展函数， 注释 2 处的 this，其实就代表了前面 代码段 3 当中的 block 变量。结合 代码段 5 反编译出来的 LaunchUnderTheHoodKt$block$1，可以知道 block 其实就是 SuspendLambda 的子类，而 SuspendLambda 则是 ContinuationImpl 的子类。 因此，注释 2 处的 (this is BaseContinuationImpl) 条件一定是为 true 的。这时候，它就会调用 create(probeCompletion)。 然后，查看 create() 的源代码，会看到这样的代码： 12345// 代码段9public open fun create(completion: Continuation&lt;*&gt;): Continuation&lt;Unit&gt; { throw UnsupportedOperationException(&quot;create(Continuation) has not been overridden&quot;)} 可以看到，在默认情况下，这个 create() 方法是会抛出异常的，它的提示信息是：create() 方法没有被重写！潜台词就是，create() 方法应该被重写！如果不被重写，就会抛出异常。 那么，create() 方法是在哪里被重写的呢？答案其实就在 代码段 5 的“LaunchUnderTheHoodKt$block$1”这个 block 的实现类当中。 123456789101112131415161718192021222324252627282930313233343536373839404142// 代码段10static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1&lt;Continuation&lt;? super String&gt;, Object&gt; { int label; LaunchUnderTheHoodKt$block$1(Continuation $completion) { super(1, $completion); } @Nullable public final Object invokeSuspend(@NotNull Object $result) { Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1); System.out .println(&quot;Hello!&quot;); this.label = 1; if (DelayKt.delay(1000L, (Continuation)this) == object) return object; DelayKt.delay(1000L, (Continuation)this); System.out .println(&quot;World!&quot;); return &quot;Result&quot;; case 1: ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1); System.out.println(&quot;World!&quot;); return &quot;Result&quot;; } throw new IllegalStateException(&quot;call to 'resume' before 'invoke' with coroutine&quot;); } // 1，注意这里 public final Continuation&lt;Unit&gt; create(@NotNull Continuation&lt;? super LaunchUnderTheHoodKt$block$1&gt; $completion) { return (Continuation&lt;Unit&gt;)new LaunchUnderTheHoodKt$block$1($completion); } @Nullable public final Object invoke(@Nullable Continuation&lt;?&gt; p1) { return ((LaunchUnderTheHoodKt$block$1)create(p1)).invokeSuspend(Unit.INSTANCE); }} 这里，注意代码里的 注释 1，这个其实就是重写之后的 create() 方法。换句话说，代码段 8 当中的 create(probeCompletion)，最终会调用 代码段 10 的 create() 方法，它最终会返回 “LaunchUnderTheHoodKt$block$1”这个 block 实现类，对应的 Continuation 对象。 这行代码，其实就对应着协程被创建的时刻。 协程创建的逻辑就分析完了，再回到 startCoroutine() 的源码，看看它后续的逻辑。 123456789// 代码段11public fun &lt;T&gt; (suspend () -&gt; T).startCoroutine( completion: Continuation&lt;T&gt;) {// 注意这里// ↓createCoroutineUnintercepted(completion).intercepted().resume(Unit)} 类似的，intercepted() 这个方法的源代码，也需要去 Kotlin 的源代码当中找到对应的 JVM 实现。 1234// 代码段12public actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; = (this as? ContinuationImpl)?.intercepted() ?: this 它是将 Continuation 强转成了 ContinuationImpl，调用了它的 intercepted()。由于 this 的类型是“LaunchUnderTheHoodKt$block$1”，它是 ContinuationImpl 的子类，所以这个类型转换一定可以成功。 接下来，看看 ContinuationImpl 的源代码。 123456789101112131415// 代码段13internal abstract class ContinuationImpl( completion: Continuation&lt;Any?&gt;?, private val _context: CoroutineContext?) : BaseContinuationImpl(completion) { @Transient private var intercepted: Continuation&lt;Any?&gt;? = null public fun intercepted(): Continuation&lt;Any?&gt; = intercepted ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this) .also { intercepted = it }} 这里其实就是通过 ContinuationInterceptor，对 Continuation 进行拦截，从而将程序的执行逻辑派发到特定的线程之上。 再看 startCoroutine() 的源码，看看它的最后一步 resume(Unit)。 123456789// 代码段14public fun &lt;T&gt; (suspend () -&gt; T).startCoroutine( completion: Continuation&lt;T&gt;) {// 注意这里// ↓createCoroutineUnintercepted(completion).intercepted().resume(Unit)} 这里的 resume(Unit)，作用其实就相当于启动了协程。 现在为止 startCoroutine() 这个协程的基础 API 是启动协程的原理已明了。 #3. launch 是如何启动协程的 123456789101112131415161718192021// 代码段15fun main() { testLaunch() Thread.sleep(2000L)}private fun testLaunch() { val scope = CoroutineScope(Job()) scope.launch { println(&quot;Hello!&quot;) delay(1000L) println(&quot;World!&quot;) }}/*输出结果：Hello!World!*/ 反编译后代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 代码段16public final class LaunchUnderTheHoodKt { public static final void main() { testLaunch(); Thread.sleep(2000L); } private static final void testLaunch() { CoroutineScope scope = CoroutineScopeKt.CoroutineScope((CoroutineContext)JobKt.Job$default(null, 1, null)); BuildersKt.launch$default(scope, null, null, new LaunchUnderTheHoodKt$testLaunch$1(null), 3, null); } static final class LaunchUnderTheHoodKt$testLaunch$1 extends SuspendLambda implements Function2&lt;CoroutineScope, Continuation&lt;? super Unit&gt;, Object&gt; { int label; LaunchUnderTheHoodKt$testLaunch$1(Continuation $completion) { super(2, $completion); } @Nullable public final Object invokeSuspend(@NotNull Object $result) { Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1); System.out .println(&quot;Hello!&quot;); this.label = 1; if (DelayKt.delay(1000L, (Continuation)this) == object) return object; DelayKt.delay(1000L, (Continuation)this); System.out .println(&quot;World!&quot;); return Unit.INSTANCE; case 1: ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1); System.out.println(&quot;World!&quot;); return Unit.INSTANCE; } throw new IllegalStateException(&quot;call to 'resume' before 'invoke' with coroutine&quot;); } @NotNull public final Continuation&lt;Unit&gt; create(@Nullable Object value, @NotNull Continuation&lt;? super LaunchUnderTheHoodKt$testLaunch$1&gt; $completion) { return (Continuation&lt;Unit&gt;)new LaunchUnderTheHoodKt$testLaunch$1($completion); } @Nullable public final Object invoke(@NotNull CoroutineScope p1, @Nullable Continuation&lt;?&gt; p2) { return ((LaunchUnderTheHoodKt$testLaunch$1)create(p1, p2)).invokeSuspend(Unit.INSTANCE); } }} “LaunchUnderTheHoodKt$testLaunch$1”这个类，它其实对应的就是 launch 当中的 Lambda。 为了让它们之间的对应关系更加明显，可以换一种写法： 1234567891011// 代码段17private fun testLaunch() { val scope = CoroutineScope(Job()) val block: suspend CoroutineScope.() -&gt; Unit = { println(&quot;Hello!&quot;) delay(1000L) println(&quot;World!&quot;) } scope.launch(block = block)} 这段代码中的 block，其实就对应着“LaunchUnderTheHoodKt$testLaunch$1”这个类。这里的 block， 本质上仍然是一个 Continuation。 接下来，看看 launch{} 的源代码。 12345678910111213141516171819202122@file:JvmMultifileClass@file:JvmName(&quot;BuildersKt&quot;)@file:OptIn(ExperimentalContracts::class)package kotlinx.coroutinespublic fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job { // 1 val newContext = newCoroutineContext(context) // 2 val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) // 3 coroutine.start(start, coroutine, block) return coroutine} 上面的代码一共有三个注释： 注释 1，launch 会根据传入的 CoroutineContext 创建出新的 Context。 注释 2，launch 会根据传入的启动模式来创建对应的协程对象。这里有两种，一种是标准的，一种是懒加载的。 注释 3，尝试启动协程。 跟进 coroutine.start() 这个方法，会进入 AbstractCoroutine 这个抽象类： 123456789101112public abstract class AbstractCoroutine&lt;in T&gt;( parentContext: CoroutineContext, initParentJob: Boolean, active: Boolean) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope { // 省略 public fun &lt;R&gt; start(start: CoroutineStart, receiver: R, block: suspend R.() -&gt; T) { start(block, receiver, this) }} 到这里，其实就能看到，Java 当中有 Thread.java 对应线程的逻辑，而 Kotlin 协程当中，也有 AbstractCoroutine.kt 这个类对应协程的抽象逻辑。AbstractCoroutine 有一个 start() 方法，专门用于启动协程。 继续跟进 start(block, receiver, this)，就会进入 CoroutineStart.invoke()。 123456789public enum class CoroutineStart { public operator fun &lt;T&gt; invoke(block: suspend () -&gt; T, completion: Continuation&lt;T&gt;): Unit = when (this) { DEFAULT -&gt; block.startCoroutineCancellable(completion) ATOMIC -&gt; block.startCoroutine(completion) UNDISPATCHED -&gt; block.startCoroutineUndispatched(completion) LAZY -&gt; Unit // will start lazily }} 在这个 invoke() 方法当中，它会根据 launch 传入的启动模式，以不同的方式启动协程。当启动模式是 ATOMIC 的时候，就会调用 block.startCoroutine(completion)。而这个，其实就是研究过的 startCoroutine() 这个协程基础 API。 而另外两个方法，startCoroutineUndispatched(completion) 和 startCoroutineCancellable(completion)，它们只是在 startCoroutine() 的基础上增加了一些额外的功能而已。前者代表启动协程以后就不会被分发，后者代表启动以后可以响应取消。 然后，对于 代码段 15 的 launch 逻辑而言，由于没有传入特定的启动模式，因此，这里会执行默认的模式，也就是调用“startCoroutineCancellable(completion)”这个方法。 123456789101112131415161718public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) { // 1 createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))}public actual fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted( completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; { val probeCompletion = probeCoroutineCreated(completion) return if (this is BaseContinuationImpl) // 2 create(probeCompletion) else createCoroutineFromSuspendFunction(probeCompletion) { (this as Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it) }} 那么，通过查看 startCoroutineCancellable() 的源代码，可以发现，它最终还是会调用之前分析过的 createCoroutineUnintercepted()，而在它的内部，仍然会像之前分析过的，去调用 create(probeCompletion)，然后最终会调用 代码段 16 当中 “LaunchUnderTheHoodKt$testLaunch$1”的 create() 方法。 至此，launch 启动协程的整个过程，就已经分析完了。其实，launch 这个 API，只是对协程的基础元素 startCoroutine() 等方法进行了一些封装而已。 #五、参考 Continuation coroutineCodegenUtil JVM平台 IntrinsicsJvm launch","link":"/2023/05/30/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/"},{"title":"使用IntDef注解代替ENUM","text":"一、前言 二、依赖 三、实例 四、Retention说明 其中Retention有三种模式： 如何选择合适的注解生命周期 RetentionPolicy源码 #一、前言 在android系统中，不推荐使用ENUM类型，因为他占用内存较大，所以一般使用静态常量来代替枚举，但是有些场景我们只需要某几个固定的或一个范围内的值。此时静态常量就没有办法用来检查我们传递的是不是自己想要的值，这个场景下可以使用这两个注解来完成，它会在编译的时候检查我们的赋值是否符合要求，提前发现错误。 #二、依赖 这两个注解实现需要com.android.support:support-annotations依赖包 #三、实例 StringDef用法与IntDef相同，以下为一个IntDef例子： 123456789101112131415161718192021222324import android.support.annotation.IntDef;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;public class IntDefDemo { public static final int TEST_ONE = 1; public static final int TEST_TWO = 2; public static final int TEST_THREE = 3; @IntDef({TEST_ONE, TEST_TWO, TEST_THREE}) @Retention(RetentionPolicy.SOURCE) public @interface Test{} private @Test int mTestValue; public void setTestValue(@Test int value) { mTestValue = value; } public @Test int getTestValue() { return mTestValue; }} #四、Retention说明 #其中Retention有三种模式： RetentionPolicy.SOURCE：注解只保留在源码文件，当Java文件编译成class文件的时候，注解信息会被丢弃，不会保留在编译好的class文件中。生命周期对应Java源文件(.java文件) RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，默认值。生命周期对应 .class文件 RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，因此可以通过反射机制读取注解的信息。生命周期对应 内存中的字节码dex #如何选择合适的注解生命周期 要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。 一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解 如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解 如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。 #RetentionPolicy源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. * * This code is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 only, as * published by the Free Software Foundation. Oracle designates this * particular file as subject to the &quot;Classpath&quot; exception as provided * by Oracle in the LICENSE file that accompanied this code. * * This code is distributed in the hope that it will be useful, but WITHOUT * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License * version 2 for more details (a copy is included in the LICENSE file that * accompanied this code). * * You should have received a copy of the GNU General Public License version * 2 along with this work; if not, write to the Free Software Foundation, * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. */package java.lang.annotation;/** * Annotation retention policy. The constants of this enumerated type * describe the various policies for retaining annotations. They are used * in conjunction with the {@link Retention} meta-annotation type to specify * how long annotations are to be retained. * * @author Joshua Bloch * @since 1.5 */public enum RetentionPolicy { /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME}","link":"/2020/05/31/%E4%BD%BF%E7%94%A8IntDef%E6%B3%A8%E8%A7%A3%E4%BB%A3%E6%9B%BFENUM/"},{"title":"源码系列三：View被添加到屏幕窗口上的源码流程","text":"一、前言 二、 源码追踪 三、 总结 四、附录 #一、前言 本文主要讲述View被添加到屏幕窗口上的源码流程 源码基于 Android API 28，即Oreo 8.0.0_r4 在线查看源码建议使用：http://androidxref.com/ 官方源码网站：https://android.googlesource.com/ 源码系列文章： 源码系列一：APP的启动过程 源码系列二：ActivityThread的理解 源码系列四：事件分发机制 #二、 源码追踪 我们一般在Activity里的void onCreate(@Nullable Bundle savedInstanceState)方法中使用setContentView()方法添加自己的布局，代码如下： 12345//MyActivity.javaprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.testlayout);} 追踪setContentView()方法到Activity类中，看到如下代码： 123456package android.app;//Activity.javapublic void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar();} 其中getWindow()方法返回一个继承抽象类Window的PhoneWindow对象。 注意：PhoneWindow是抽象类Window的唯一实现类。 继续追踪setContentView()方法到PhoneWindow类中，看到如下代码： 123456789101112131415161718package com.android.internal.policy;//PhoneWindow.javapublic void setContentView(int layoutResID) { if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } ...} 其中重点关注两条代码： installDecor() mLayoutInflater.inflate(layoutResID, mContentParent) 追踪installDecor()方法，看到如下代码： 1234567891011121314151617package com.android.internal.policy;//PhoneWindow.javaprivate void installDecor() { mForceDecorInstall = false; if (mDecor == null) { mDecor = generateDecor(-1); ... } else { mDecor.setWindow(this); } if (mContentParent == null) { mContentParent = generateLayout(mDecor); ... } ...} 其中重点关注两条代码： mDecor = generateDecor(-1) mContentParent = generateLayout(mDecor) 追踪generateDecor()方法，看到如下代码： 12345678910111213141516171819202122package com.android.internal.policy;//PhoneWindow.javaprotected DecorView generateDecor(int featureId) { // System process doesn't have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don't cling to the // activity. Context context; if (mUseDecorContext) { Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) { context = getContext(); } else { context = new DecorContext(applicationContext, getContext()); if (mTheme != -1) { context.setTheme(mTheme); } } } else { context = getContext(); } return new DecorView(context, featureId, this, getAttributes());} 该方法主要返回一个DecorView，DecorView继承了FrameLayout 追踪generateLayout()方法，看到如下代码： 123456789package com.android.internal.policy;//PhoneWindow.javaprotected ViewGroup generateLayout(DecorView decor) { ... mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... return contentParent;} 其中重点关注两条代码： mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); 其中layoutResource值为根据特性返回的不同的布局文件资源 id ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT) 追踪onResourcesLoaded(mLayoutInflater, layoutResource)方法，看到如下代码： 1234567891011121314151617181920package com.android.internal.policy;//DecorView.javavoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) { ... mDecorCaptionView = createDecorCaptionView(inflater); final View root = inflater.inflate(layoutResource, null); if (mDecorCaptionView != null) { if (mDecorCaptionView.getParent() == null) { addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); } mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); } else { // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); } mContentRoot = (ViewGroup) root; ...} 该方法将layoutResources中传递的布局文件解析成名为root的View，然后将该View添加到DecorView中 之后回到第6条中ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT)，这条语句根据固定id获取一个容器，并在generateLayout方法中将该容器返回。该ID值如下： 12345678910package android.view;//Window.javapublic abstract class Window { ... /** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; ...} 该ID是主容器的ID值，且必然存在 接着返回第3条中，经过installDecor方法之后mContentParent即为第8条中获取的容器。之后通过mLayoutInflater.inflate(layoutResID, mContentParent)将layoutResID解析成View再放到mContentParent中。即将开发者所写的布局文件加载到名为ID_ANDROID_CONTENT的容器中。inflate源码如下： 123456789package android.view;public abstract class LayoutInflater { ... public View inflate(XmlPullParser parser, @Nullable ViewGroup root) { return inflate(parser, root, root != null); } ...} #三、 总结 Activity: 每个Activity持有一个PhoneWindow的对象，而一个PhoneWindow对象持有一个DecorView的实例。 Window: 是一个抽象类，提供了绘制窗口的一组通用API，他的唯一实例就是PhoneWindow。 PhoneWindow: 是 Window继承实现类，实现Window各方法，它持有一个DecorView对象，该DecorView对象是所有Activity的根View。Activity可通过getWindow（）方法获取Window对象。 DecorView: 继承自FrameLayout，是PhoneWindow的内部类，当DecorView接受到来自Activity中的setContentView(int resId)传递过来的布局id后通过inflater把布局资源转换为一个View，然后把这个布局View添加到自身中，是所有应用窗口的根View。 层级图如下： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--//device/apps/common/assets/res/layout/screen_simple.xmlThis is an optimized layout for a screen, with the minimum set of features enabled.--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; #四、附录 Activity.java http://androidxref.com/ PhoneWindow.java http://androidxref.com/ DecorView.java http://androidxref.com/ Window.java http://androidxref.com/","link":"/2020/06/11/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B8%89/"},{"title":"小米5sPlus安装原生系统","text":"第一步：先解锁手机 第二步：刷一个第三方recovery 第三步： 获取Root权限 方法一、刷root包 方法二、 MIUI系统中获取 第四步： 获取ROM包 第五步： 安装ROM包 第六步：获取Root权限 方法一、使用Lineageos自带的补丁包 方法二、使用SuperSu 方法三、使用Magisk 遇到问题 手机型号：MI 5s Plus codeName：natrium #第一步：先解锁手机 登录网站http://www.miui.com/unlock/index.html，点击立即解锁。 提交申请成功后，等待审核通过。(一般申请后马上通过) 审核通过后即获解锁资格，然后点击解决工具下载。 将下载好的工具压缩包解压，并点击miflash_unlock.exe运行解锁工具。 然后设置手机进入Bootloader模式（关机后，同时按住开机键和音量下键）。 通过USB连接手机，点击 “解锁”按钮，过程中需要验证小米账号(保证手机登录了有解锁资格的账号) 解锁成功后，点击重启手机。 详细解锁教程可以参考http://www.shuajizhijia.net/news/18550.html #第二步：刷一个第三方recovery 下载Recovery工具包，链接：https://pan.baidu.com/s/1wARkj7nArWUlzrI7iLKPBA 密码：ovkz 手机要进入FastBoot模式，进入的方法：在手机关机状态下，按住音量键-和电源键 保证手机正常连接电脑 然后把上面下载下来的recovery工具包在电脑上进行解压，然后在文件夹里找到【recovery-twrp一键刷入工具.bat】文件直接双击打开运行。 过几秒安装完成后会自动打开recovery界面。 这个版本是3.2.3，可以自动解密data分区 详细刷recovery教程可以参考http://bbs.xiaomi.cn/t-25351609-2-o1#comment_top #第三步： 获取Root权限 #方法一、刷root包 下载root包，链接：https://pan.baidu.com/s/13PogRZX2ZUivdb_wOjuzug 密码：rl7v 将下载下来的压缩包解压，并将Root-Supersu_Pro_2.74.zip放到手机根目录下 进入Recovery界面，点击安装，在根目录下选择压缩包。 安装完成后，点重新启动。 #方法二、 MIUI系统中获取 安全中心–&gt;应用管理–&gt;权限–&gt;Root权限管理 点击获取root权限。 #第四步： 获取ROM包 AospExtended：https://downloads.aospextended.com/ Lineageos：https://download.lineageos.org/ #第五步： 安装ROM包 将下好的ROM包放到手机根目录下 打开手机的Recovery界面，点击安装，选择ROM包。 手机卡在开机界面时，先进入Recovery界面再格式化data即可。 #第六步：获取Root权限 #方法一、使用Lineageos自带的补丁包 Lineageos的Root补丁包地址：https://download.lineageos.org/extras 下载好对应CPU位数及系统版本的Root包后，将压缩包放到手机根目录下 打开手机的Recovery界面，选择安装Root包。 参考网址：https://tieba.baidu.com/p/4961319803?share=9105&amp;fr=share&amp;red_tag=2572190043 结果：失败 #方法二、使用SuperSu SuperSu的卡刷包地址：https://www.lineageosrom.com/2018/09/lineage-os-16-root-android-pie-90-super.html 下载好对应CPU位数及系统版本的Root包后，将压缩包放到手机根目录下 打开手机的Recovery界面，选择安装Root包。 下载SuperSu的app应用并安装。 结果：失败 #方法三、使用Magisk magisk网址：https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445 两种方法： 支持 TWRP ，直接进入Recovery界面，安装Magisk包。 不支持TWRP，使用以下方法： 下载一个magisk manager安装包，并安装。 从你的刷机包中提取当前固件的 boot.img 文件，将它传入到安装了 Magisk Manager 的手机中 进入 Magisk Manager —— 安装（install）—— install —— 修补 boot 镜像文件 然后选择传入的 boot.img 文件进行生成，并将生成后的 Patchedboot.img （姑且这么命名） 传输到电脑上。 随后我们使用 Magisk 应用对 boot.img 进行重新打包： 打开命令行窗口 执行 adb reboot bootloader 进入 Bootloader 界面 执行 fastboot boot Patchedboot.img 来加载生成后的 boot 分区文件获取临时 root 此时进入系统，你会发现你已经成功安装了 Magisk（如果显示没有安装则为获取失败，请检查操作过程重新尝试），但这还不够，我们还得进入 Magisk Manager，选择安装（install）——install——Direct Install（直接安装）才能将临时 root 转换为永久 root。 注意：安装Magisk之前确保没有安装过Super su，否则无法安装成功。若是之前安装过了，需要格式化data并重新刷系统，才能安装成功。 参考网址：https://sspai.com/post/53043 结果：成功 #遇到问题 WIFI显示叉号，提示无法联网，但是可以上网 解决方法： Android 7.0之前版本的系统，执行以下命令： adb shell &quot;settings put global captive_portal_server captive.lineageos.org.cn&quot; Android 7.0之后的版本需要执行下面的两条命令： adb shell &quot;settings put global captive_portal_http_url http://captive.lineageos.org.cn/generate_204&quot;; adb shell &quot;settings put global captive_portal_https_url https://captive.lineageos.org.cn/generate_204&quot; 参考网址：https://www.lineageos.org.cn/thread-118-1-1.html 一定要科学上网，否则网速会让你绝望","link":"/2020/05/31/%E5%B0%8F%E7%B1%B35sPlus%E5%AE%89%E8%A3%85%E5%8E%9F%E7%94%9F%E7%B3%BB%E7%BB%9F/"},{"title":"源码系列二：ActivityThread的理解","text":"一、前言 二、 ActivityThread 1. ActivityThread的初始化 2. MainLooper的初始化 3. 主线程Handler的初始化 4. ApplicationThread及Activity的创建和启动 1. thread.attach(false)相关代码如下： 2. ActivityManagerService相关代码如下： 3. thread.bindApplication： 4. 再回到第2节的 mStackSupervisor.attachApplicationLocked(app)： 三、 附录源码 #一、前言 本文主要讲述：ActivityThread的理解 源码基于 Android API 28，即Oreo 8.0.0_r4 在线查看源码建议使用：http://androidxref.com/ 官方源码网站：https://android.googlesource.com/ 源码系列文章： 源码系列一：App启动过程 源码系列三：View被添加到屏幕窗口上的源码流程 源码系列四：事件分发机制 #二、 ActivityThread ActivityThread就是我们常说的主线程或UI线程，但他并不是一个Thread类。 ActivityThread的main方法是整个APP的入口，它管理应用程序进程中主线程的执行，调度和执行Activity、Broadcasts以及Activity manager请求的其他操作。 Java程序初始类中的main()方法，将作为该程序初始线程的起点，任何其他的线程都是由这个初始线程启动的。这个线程就是程序的主线程。 简略代码如下： 12345678910111213141516171819202122232425/** * This manages the execution of the main thread in an * application process, scheduling and executing activities, * broadcasts, and other operations on it as the activity * manager requests. * {@hide} */public final class ActivityThread { ... final ApplicationThread mAppThread = new ApplicationThread(); final Looper mLooper = Looper.myLooper(); final H mH = new H(); final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;(); final ArrayMap&lt;IBinder, Service&gt; mServices = new ArrayMap&lt;&gt;(); ... private class ApplicationThread extends IApplicationThread.Stub { ... } private class H extends Handler { ... } public static void main(String[] args) { ... }} #1. ActivityThread的初始化 ActivityThread即Android的主线程，也就是UI线程，ActivityThread的main方法是一个APP的真正入口，MainLooper在它的main方法中被创建。 12345678910111213141516package android.app;//ActivityThread.javapublic static void main(String[] args) { ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); //在attach方法中完成Application对象的初始化，然后调用Application的onCreate()方法 thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } ... Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } #2. MainLooper的初始化 在第1节中ActivityThread的main方法中调用Looper.prepareMainLooper()初始化主线程Looper。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package android.os;///frameworks/base/core/java/android/os/Looper.java//一般线程Looper的初始化public static void prepare() { prepare(true);}//主线程Looper的初始化public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); }}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed));}/** * Returns the application's main looper, which lives in the main thread of the application. */public static Looper getMainLooper() { synchronized (Looper.class) { return sMainLooper; }}public void quit() { mQueue.quit(false);}public void quitSafely() { mQueue.quit(true);} 其中一般线程与主线程Looper初始化区别： 主线程Looper 初始化之后，赋值给了成员变量sMainLooper，这个成员变量的作用就是向其他线程提供主线程的Looper 对象。可以通过Looper.getMainLooper()方法能获取主线程的Looper对象 主线程Looper初始化与一般线程Looper初始化时都调用了prepare(boolean quitAllowed)方法，只是一般线程Looper初始化时quitAllowed值传的true，而主线程Looper传入的false。 12345678910package java.lang;//libcore/ojluni/src/main/java/java/lang/ThreadLocal.javapublic void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);} 可以看到prepare(boolean quitAllowed)方法只是创建一个Looper，追踪代码后会发现Looper最终会放到Thread的ThreadLocalMap中。 12345private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();} 追踪代码可以看到quitAllowed参数传入MessageQueue中，而Looper的quit()方法也是调用的MessageQueue的quit()方法，在其quit方法中判断mQuitAllowed，若是主线程Looper则报错。 123456789package android.os;//MessageQueue.javavoid quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;); } ...} #3. 主线程Handler的初始化 在ActivityThread类中的main方法中调用了如下语句： 1234567ActivityThread thread = new ActivityThread();//在attach方法中完成Application对象的初始化，然后调用Application的onCreate()方法thread.attach(false);if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler();} 可以看到，直接获取主线程Handler，相关代码如下： 1234final H mH = new H();final Handler getHandler() { return mH;} 由以上代码可知：主线程的Handler作为ActivityThread的成员变量，是在ActivityThread的main方法被执行时，ActivityThread被创建而初始化。 小结： 主线程（ActivityThread）的初始化是在它的main方法中，主线程的Handler以及MainLooper的初始化时机都是在ActivityThread创建的时候。 #4. ApplicationThread及Activity的创建和启动 在ActivityThread类中的main方法中调用了如下语句： 12ActivityThread thread = new ActivityThread();thread.attach(false); #1. thread.attach(false)相关代码如下： 12345678910111213141516171819package android.app;//ActivityThread.javaprivate void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ... final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } ... } else { ... } ...} #2. ActivityManagerService相关代码如下： 1234567891011121314151617181920212223242526package com.android.server.am;//ActivityManagerService.java@Overridepublic final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); }}private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... if (app.instr != null) { thread.bindApplication(...); } else { thread.bindApplication(...); } ... if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } ...} 在每个ActivityThread（APP）被创建的时候，都需要向ActivityManagerService绑定（或者说是向远程服务AMS注册自己），用于AMS管理ActivityThread中的所有四大组件的生命周期。 #3. thread.bindApplication： 主要用于创建Application，这里的thread对象是ApplicationThread在AMS中的代理对象，所以这里的bindApplication方法最终会调用ApplicationThread.bindApplication()方法，该方法会向ActivityThread的消息对列发送BIND_APPLICATION的消息，消息的处理最终会调用Application.onCreate()方法，这也说明Application.onCreate()方法的执行时机比任何Activity.onCreate()方法都早。 12345//ActivityThread#ApplicationThreadpublic final void bindApplication(...) { ... sendMessage(H.BIND_APPLICATION, data);} 该方法会发送消息给主线程Handler，然后主线程Handler会调用ActivityThread的handleBindApplication()方法。 1234567891011121314151617//ActivityThread.javaprivate void handleBindApplication(AppBindData data) { ... try { Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... try { mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { ... } } finally { ... } ...} data.info为LoadedApk的对象，LoadedApk的makeApplication方法如下： 1234567891011121314151617181920212223242526package android.app;///frameworks/base/core/java/android/app/LoadedApk.javapublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } Application app = null; ... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); ... mApplication = app; if (instrumentation != null) { try { //调用Application的onCreate方法 instrumentation.callApplicationOnCreate(app); } catch (Exception e) { ... } } ... return app;} 然后调用Instrumentation的newApplication方法如下： 12345678package android.app;///frameworks/base/core/java/android/app/Instrumentation.javastatic public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException { Application app = (Application)clazz.newInstance(); app.attach(context); return app;} 再调用Application的attach方法 1234567package android.app;///frameworks/base/core/java/android/app/Application.javafinal void attach(Context context) { attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;} #4. 再回到第2节的 mStackSupervisor.attachApplicationLocked(app)： 该方法用于创建Activity，mStackSupervisor是AMS的成员变量，为Activity堆栈管理辅助类实例。 12345678910111213141516171819202122232425package com.android.server.am;// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.javaboolean attachApplicationLocked(ProcessRecord app) throws RemoteException { boolean didSomething = false; ... try { if (realStartActivityLocked(hr, app, true, true)) { didSomething = true; } } catch (RemoteException e) { ... } ... return didSomething;}final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ... try { app.thread.scheduleLaunchActivity(...); } catch (RemoteException e) { ... } ...} attachApplicationLocked()方法调用了realStartActivityLocked()方法，在realStartActivityLocked()方法内处理启动Activity逻辑。realStartActivityLocked()方法中首先会准备启动Activity的参数信息，准备完毕后调用ApplicationThread的scheduleLaunchActivity方法 1234567891011121314151617181920212223242526272829303132333435//ActivityThread.javapublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);} scheduleLaunchActivity()方法对启动的信息进行准备，然后通过sendMessage()方法发送一个消息，ActivityThread的内部类H即主线程Handler进行接收并处理 123456789101112131415161718//ActivityThread.javaprivate class H extends Handler { public static final int LAUNCH_ACTIVITY = 100; public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { case LAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } break; ... } } 然后调用handleLaunchActivity()方法 12345private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason { ... Activity a = performLaunchActivity(r, customIntent); ...} performLaunchActivity()方法真正处理Activity的具体启动逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } ComponentName component = r.intent.getComponent(); if (component == null) { component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); } if (r.activityInfo.targetActivity != null) { component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); } ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) { config.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } if (!r.activity.mFinished) { activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnPostCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPostCreate()&quot;); } } } r.paused = true; mActivities.put(r.token, r); } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); } } return activity;} mInstrumentation.callActivityOnPostCreate()方法的调用就会执行对Activity的onCreate调用 总结其流程如下图： 参考文章： https://blog.csdn.net/hzwailll/article/details/85339714 #三、 附录源码 Looper.java：androidxref.com；本地 LoadedApk.java：androidxref.com；本地 Application.java：androidxref.com；本地 ThreadLocal.java：androidxref.com；本地 ActivityThread.java：androidxref.com；本地 Instrumentation.java：androidxref.com；本地 ActivityManagerService.java：androidxref.com；本地 ActivityStackSupervisor.java：androidxref.com；本地","link":"/2020/06/15/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%BA%8C/"},{"title":"源码系列四：事件分发机制","text":"一、前言 二、事件概述 1. 定义 2. 常用事件类型 3. 事件序列 4. 事件分发对象 5. 事件分发主要方法 三、源码分析 1. Activity 事件分发 1. 当触摸事件触发时会首先调用Activity的dispatchTouchEvent()方法 2. PhoneWindow#superDispatchTouchEvent() 2. ViewGroup 事件分发 2. View 事件分发 四、总结 五、附录 #一、前言 本文主要讲述事件分发机制 源码基于 Android API 28，即Oreo 8.0.0_r4 在线查看源码建议使用：http://androidxref.com/ 官方源码网站：https://android.googlesource.com/ 源码系列文章： 源码系列一：APP 的启动过程 源码系列二：ActivityThread 的理解 源码系列三：View 被添加到屏幕窗口上的源码流程 #二、事件概述 #1. 定义 当用户触摸屏幕时，产生的触摸行为（Touch 事件） #2. 常用事件类型 MotionEvent.ACTION_DOWN 手指刚接触屏幕 MotionEvent.ACTION_UP 手指从屏幕上松开 MotionEvent.ACTION_MOVE 手指在屏幕上滑动 MotionEvent.ACTION_CANCEL 非人为因素取消 #3. 事件序列 正常情况下，一次手指触摸屏幕的行为会产生一系列触摸事件 点击屏幕后立即松开，事件序列为 DOWN --&gt; UP 点击屏幕滑动一会再松开，事件序列为 DOWN --&gt; MOVE --&gt; … --&gt;MOVE --&gt;UP #4. 事件分发对象 Activity: 控制生命周期 &amp; 处理事件 ViewGroup: 一组 View 的集合（含多个子 View) View: 所有 UI 组件的基类 #5. 事件分发主要方法 dispatchTouchEvent(MotionEvent ev): 用于进行事件分发 onInterceptTouchEvent(MotionEvent ev): 判断是否拦截事件（只存在于 ViewGroup 中） onTouchEvent(MotionEvent ev): 处理点击事件 #三、源码分析 #1. Activity 事件分发 #1. 当触摸事件触发时会首先调用Activity的dispatchTouchEvent()方法 源码如下： 12345678910111213package android.app;// /frameworks/base/core/java/android/app/Activity.javapublic class Activity { public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); }} 判断如果是DOWN事件，则执行一个空实现的onUserInteraction()方法，该方法让子类实现。之后getWindow()方法返回PhoneWindow对象，调用PhoneWindow#superDispatchTouchEvent()方法。 #2. PhoneWindow#superDispatchTouchEvent() 1234567891011package com.android.internal.policy;///frameworks/base/core/java/com/android/internal/policy/PhoneWindow.javapublic class PhoneWindow extends Window implements MenuBuilder.Callback { // This is the top-level view of the window, containing the window decor. private DecorView mDecor; @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); }} 其中，mDecor为DecorView对象。 12345678package com.android.internal.policy;///frameworks/base/core/java/com/android/internal/policy/DecorView.javapublic class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); }} 而DecorView继承自FrameLayout,FrameLayout继承自ViewGroup，所以最后调用ViewGroup#dispatchTouchEvent()方法 由此可知，若ViewGroup#dispatchTouchEvent()方法返回true，则第 1 步中getWindow().superDispatchTouchEvent(ev)返回true, 则Activity#dispatchTouchEvent()返回true，事件结束； 若ViewGroup#dispatchTouchEvent()方法返回false，则getWindow().superDispatchTouchEvent(ev)返回false, 继续执行Activity#onTouchEvent()方法。 123456789public class Activity { public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; }} 当触摸屏事件未被其下的任何视图处理时调用。如果超出当前Window的边界，则关闭当前Activity。如果没有超出，则直接返回 false, 事件件结束。 Activity的事件分发流程如下图所示： #2. ViewGroup 事件分发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package android.view;// /frameworks/base/core/java/android/view/ViewGroup.javapublic abstract class ViewGroup extends View implements ViewParent, ViewManager { @Override public boolean dispatchTouchEvent(MotionEvent ev) { ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } ... final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { ... if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { ... final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); ... if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } ... return handled; } private void cancelAndClearTouchTargets(MotionEvent event) { if (mFirstTouchTarget != null) { ... clearTouchTargets(); ... } } private void resetTouchState() { clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE; } private void clearTouchTargets() { TouchTarget target = mFirstTouchTarget; if (target != null) { do { TouchTarget next = target.next; target.recycle(); target = next; } while (target != null); mFirstTouchTarget = null; } }} 一个完整的触摸事件是由ACTION_DOWN开始，以ACTION_UP结束。则ACTION_DOWN事件是一个新的触摸事件的开始，所以判断如果是ACTION_DOWN事件，则进行初始化： 调用cancelAndClearTouchTargets()方法清空mFirstTouchTarget，该变量用于存储响应该事件的子View的信息； 调用resetTouchState()方法，清除mGroupFlags中存储的FLAG_DISALLOW_INTERCEPT标志，该标志用于判断是否允许拦截事件。 之后判断是否拦截除ACTION_DOWN之外的其它触摸事件。流程如下图： 如果事件为ACTION_DOWN事件或者mFirstTouchTarget不为空，则通过mGroupFlags与标志FLAG_DISALLOW_INTERCEPT做位与操作并将结果存入变量disallowIntercept用于判断是否不允许拦截事件。其中子View可通过ViewGroup#requestDisallowInterceptTouchEvent()方法来设置父容器是否能拦截事件。 判断变量disallowIntercept如果为true，则不允许拦截事件，将标志intercepted置为false。 若disallowIntercept如果为false，标志intercepted值由方法onInterceptTouchEvent方法返回。onInterceptTouchEvent方法默认返回false，即默认不拦截事件。 如果事件没有取消且没有被拦截，则准备将事件交给子 View 处理。 如果是ACTION_DOWN事件，并且事件没有被分发且子 View 数量不为 0，则倒序遍历取出子 View。 通过canViewReceivePointerEvents()方法判断取出的子 View 是否能接收触摸事件（判断条件：View 是可见的或者 View 没有执行动画，则认为是可接收触摸事件) 并且通过isTransformedTouchPointInView()方法判断子 View 是否在触摸范围内，如果不满足条件，则判断下一个子 View。 1234567891011121314151617private static boolean canViewReceivePointerEvents(@NonNull View child) { return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null;}protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) { final float[] point = getTempPoint(); point[0] = x; point[1] = y; transformPointToViewLocal(point, child); final boolean isInView = child.pointInView(point[0], point[1]); if (isInView &amp;&amp; outLocalPoint != null) { outLocalPoint.set(point[0], point[1]); } return isInView;} 如果有满足条件的子 View，则执行方法dispatchTransformedTouchEvent()并将子 View 作为参数传递进去。 12345678910111213141516171819202122232425/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; ... // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } ... return handled;} 如果 child 不为空，则调用child.dispatchTouchEvent(transformedEvent)，将事件交给子 View 处理，并返回一个布尔型，来判断子 view 是否消费了事件。 如果 child 为空，则调用ViewGroup自身的onTouchEvent()方法。 如果dispatchTransformedTouchEvent()方法返回true，则子 View 消费了该事件，接着调用addTouchTarget()方法为newTouchTarget变量赋值并将alreadyDispatchedToNewTouchTarget变量置为true。 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;} 该方法内对变量mFirstTouchTarget进行赋值，将其指向消费事件的子 View。 mFirstTouchTarget不为空表示在ACTION_DOWN事件中找到了子 View 消费事件。 判断如果alreadyDispatchedToNewTouchTarget为true，并且mFirstTouchTarget与newTouchTarget相等，则handled置为true，并退出。表示ACTION_DOWN事件已分发。 如果以上条件不成立，则是除ACTION_DOWN事件以外的其它事件，再通过dispatchTransformedTouchEvent方法，将这些事件交给子 View 去处理。 #2. View 事件分发 123456789101112131415161718192021222324252627282930313233343536373839package android.view;// /frameworks/base/core/java/android/view/View.javapublic class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { public boolean dispatchTouchEvent(MotionEvent event) { ... boolean result = false; if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result; }}ListenerInfo getListenerInfo() { if (mListenerInfo != null) { return mListenerInfo; } mListenerInfo = new ListenerInfo(); return mListenerInfo;}public void setOnTouchListener(OnTouchListener l) { getListenerInfo().mOnTouchListener = l;} 如果View是ENABLED（可见的） 并且设置了setOnTouchListener()监听，且监听的onTouch()返回 true，则结果返回true。 如果设置了mOnTouchListener监听，则只有mOnTouchListener.onTouch返回false，才会执行onTouchEvent()方法。只有onTouchEvent()返回true，结果才会返回true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: ... boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } mHasPerformedLongPress = false; if (!clickable) { checkForLongClick(0, x, y); break; } if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0, x, y); } break; case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; } break; } return true; } return false;} 判断View是否可点击：viewFlags是否有CLICKABLE或LONG_CLICKABLE或CONTEXT_CLICKABLE。将结果存入变量clickable中。 如果View是DISABLED状态，则返回clickable，即 View虽然是不可用的，但是仍然可以消费触摸事件 如果是可点击的，则根据事件类型做不同处理： ACTION_DOWN事件，则将变量mHasPerformedLongPress置为false，该变量用于判断是否处理了长按事件。之后判断是否处于一个滑动的容器内： 如果在一个滑动容器内，则发送一个一百毫秒的延时任务去检测长按事件。 如果不在一个滑动容器内，则通过方法checkForLongClick()直接检测长按事件 12345678910111213private void checkForLongClick(int delayOffset, float x, float y) { if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) { mHasPerformedLongPress = false; if (mPendingCheckForLongPress == null) { mPendingCheckForLongPress = new CheckForLongPress(); } mPendingCheckForLongPress.setAnchor(x, y); mPendingCheckForLongPress.rememberWindowAttachCount(); mPendingCheckForLongPress.rememberPressedState(); postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset); }} 该方法主要发送一个五百毫秒的延时任务去检测长按事件。 123456789101112131415161718192021222324252627282930private final class CheckForLongPress implements Runnable { private int mOriginalWindowAttachCount; private float mX; private float mY; private boolean mOriginalPressedState; @Override public void run() { if ((mOriginalPressedState == isPressed()) &amp;&amp; (mParent != null) &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) { if (performLongClick(mX, mY)) { mHasPerformedLongPress = true; } } }...}public boolean performLongClick() { return performLongClickInternal(mLongClickX, mLongClickY);}public boolean performLongClick(float x, float y) { mLongClickX = x; mLongClickY = y; final boolean handled = performLongClick(); mLongClickX = Float.NaN; mLongClickY = Float.NaN; return handled;} CheckForLongPress类里run()方法调用了performLongClick(float x, float y)方法，之后该方法最终调用performLongClickInternal(float x, float y)方法，在该方法内处理View的长按事件。 12345678910111213141516171819202122private boolean performLongClickInternal(float x, float y) { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED); boolean handled = false; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLongClickListener != null) { handled = li.mOnLongClickListener.onLongClick(View.this); } if (!handled) { final boolean isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y); handled = isAnchored ? showContextMenu(x, y) : showContextMenu(); } if ((mViewFlags &amp; TOOLTIP) == TOOLTIP) { if (!handled) { handled = showLongClickTooltip((int) x, (int) y); } } if (handled) { performHapticFeedback(HapticFeedbackConstants.LONG_PRESS); } return handled;} 该方法内处理长按事件，先判断是否设置mOnLongClickListener监听器，如果设置了监听器，则长按事件处理结果为监听器内onLongClick()方法的返回值。 如果返回true，则performLongClick(float x, float y)方法返回true，则将变量mHasPerformedLongPress置为true ACTION_UP事件，判断mHasPerformedLongPress值。 如果mHasPerformedLongPress值为false, 即没有处理长按事件且没有忽略ACTION_UP事件，则通过removeLongPressCallback()方法，将之前的检测长按事件的延时任务关闭，表示从DOWN事件到UP事件之间少于五百毫秒。之后通过PerformClick类响应点击事件。 1234567891011121314151617181920private final class PerformClick implements Runnable { @Override public void run() { performClick(); }}public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } ... return result;} 在performClick()方法中处理点击事件，先判断是否设置mOnClickListener监听器，如果设置了监听器，则长按事件处理结果为监听器内onClick()方法的返回值。 如果mHasPerformedLongPress值为true, 即如果添加了mOnLongClickListener监听器，且onLongClick()方法返回了true，则不会执行onClick事件。 #四、总结 一个事件序列从手指接触屏幕到手指离开屏幕，在这个过程中产生一系列事件，以DOWN事件开始，中间含有不定数的MOVE事件，以UP事件结束。 正常情况下，一个事件序列只能被一个 View 拦截并且消费。 某个 View 一旦决定拦截，那么这个事件序列都将由它的onTouchEvent处理，并且它的onInterceptTouchEvent不会再调用。 某个 View 一旦开始处理事件，如果它不消费ACTION_DOWN事件 (onTouchEvent事件返回false)，那么同一事件序列中其它事件都不会再交给它处理。并且重新由它的父元素处理（父元素onTouchEvent被调用）。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子 View，通过requestDisallowInterceptTouchEvent方法可以在子 View 中干预父元素的事件分发过程，但ACTION_DOWN除外。 ViewGroup默认不拦截任何事件，即onInterceptTouchEvent默认返回false。View 没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那它的onTouchEvent方法就会被调用。 View 的onTouchEvent默认会消费事件（返回true)，除非它是不可点击的 (clickable和longClickable同时为false)。View 的longClickable默认都为false，clickable 要分情况，比如Button的clickable默认为true,TextView的clickable默认为false。但是设置setOnClickLinstener监听器时View会自动将clickable置为true。 View 的enable属性不影响onTouchEvent的默认返回值。哪怕一个 View 是disable状态，只要它的clickable或longClickable有一个为true，那么它的onTouchEvent就一定返回true。 onClick会响应的前提是当前 View 是可点击的，并且收到了ACTION_DOWN和ACTION_UP的事件，并且受长按事件影响，当长按事件返回true时，onClick不会响应。 onLongClick在ACTION_DOWN里判断是否进行响应，要想执行长按事件该 View 必须是longClickable的并且设置了OnLongCLickListener。 触摸事件整体流程如下图： #五、附录 Activity.java http://androidxref.com/ PhoneWindow.java http://androidxref.com/ DecorView.java http://androidxref.com/ ViewGroup.java：androidxref.com View.java http://androidxref.com/","link":"/2020/11/27/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E5%9B%9B/"},{"title":"kotlin学习系列番外篇","text":"二、协程基本概念 3. kotlin协程的示例 1. 常规网络接口请求处理流程 2. 使用协程改造异步程序 1. 网络请求`API中添加挂起函数 2. 替换call.equeue方法 3. 通过多个用户名获取多个用户的数组 三、 协程的常见实现 1. 协程分类 2. 其它语言的常见协程实现 1. Python的Generator 2. Lua的Coroutine 3. Go的routine 4. async/await关键字 1. JavaScript的使用 2. async/await和suspend的区别 四、Kotlin协程的基本要素 1. 协程的挂起和恢复 1. 相关概念说明 2. 在挂起时线程和协程各自操作 3. 挂起实现原理 4. suspend挂起总结 2. Continuation 1. Continuation部分源码 2. 挂起函数与Continuation关系 3. 将回调转为挂起函数 3. 协程的创建 1. createCoroutine()方法 4. 协程启动 1. resume 2. startCoroutine 5. 协程上下文 1. ContinuationInterceptor 6. Continuation执行示意 1. SuspendLambda 2. SafeContinuation 3. 加入Intetcepted拦截器 4. 协程挂起恢复执行示意 7. 协程的线程调度 五、示例–使用标准库的序列生成器Sequence实现Generator 1. 代码实现 2. 使用sequence实现 六、 示例-- 仿 Lua 协程实现非对称协程 API 七、 示例-- 基于非对称协程API实现对称协程 1. 实现思路 2. 代码实现 八、 示例–仿Go的channel实现协程通信 八、 示例–仿Js实现async await 九、延伸–揭秘 suspend fun main 1. 普通的main函数 2. 可挂起的main函数 十、参考文章 二、示例–仿官方框架实现launch 1. 协程回顾 1. 协程创建 2. 协程启动 #二、协程基本概念 #3. kotlin协程的示例 #1. 常规网络接口请求处理流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//网络接口请求返回数据data class User(val id: String, val name: String, val url: String)//网络请求APIinterface GitHubApi { @GET(&quot;users/{login}&quot;) fun getUserCallback(@Path(&quot;login&quot;) login: String): Call&lt;User&gt;}//构建retrofit网络请求实例val githubApi by lazy { val retrofit = retrofit2.Retrofit.Builder() .client(OkHttpClient.Builder().addInterceptor(Interceptor { it.proceed(it.request()).apply { println(&quot;request: $code&quot;) } }).build()) .baseUrl(&quot;https://api.github.com&quot;) .addConverterFactory(GsonConverterFactory.create()) .build() retrofit.create(GitHubApi::class.java)}//请求结果处理函数fun showUser(user:User) { println(user)}//请求结果处理函数fun showError(t: Throwable) { t.printStackTrace(System.out)}fun main() { val call = githubApi.getUserCallback(&quot;puppet16&quot;) call.enqueue(object : Callback&lt;User&gt; { override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { showError(t) } override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { response.body()?.let(::showUser) ?: showError(NullPointerException()) } })} 说明： 创建了一个名为GitHubApi的网络请求API，其中有一个getUser()方法用于获取GitHub的用户信息，该方法返回一个带泛型User的Call。若要拿到User数据，则有两种方法：一是使用enqueue方法，也就是传进一个Callback回调；二是阻塞的调用，但是在主线程是明显不合适。 通过retrofit创建网络请求API的实例githubApi，其中添加拦截器用于打印网络请求返回码，设置了网络请求地址域名为https://api.github.com，再设置了返回的结果使用Gson解析。 再创建了两个请求结果处理函数showUser()、showError()，用于处理接口请求成功及请求失败的逻辑 最后在main()函数中，通过githubApi获取网络请求返回的Call，再调用Call的equeue方法，传入一个Callback，再在Callback的两个方法中分别调用请求结果处理函数showUser()、showError() call.equeue()方法是个异步方法，该异步方法回调到主流程后会调用showUser()或是调用showError()，如此异步方法将主流程分裂成了两个分支 问题： 如果传入多个GitHub的用户名称，使用forEach方法每个名称调用一次网络请求，可以获取多个对应User的结果，但是传入的是名称的数组，无法将多个User放到一个数组中 #2. 使用协程改造异步程序 #1. 网络请求`API中添加挂起函数 在网络请求API，添加如下方法： 12345interface GitHubApi { @GET(&quot;users/{login}&quot;) suspend fun getUserSuspend(@Path(&quot;login&quot;) login: String): User} 说明： 添加了一个getUserSuspend()方法，该方法使用了关键字 suspend 修饰，表示该方法为 挂起函数 该函数返回结果为User对象 #2. 替换call.equeue方法 123456try { val user = githubApi.getUserSuspend(name) showUser(user)} catch (e: Exception) { showError(e)} 说明： 使用如上方法替换之前的网络请求 githubApi.getUserSuspend()是一个挂起函数，调用到该条语句时该函数会挂起，直到返回结果再回到该线程中。此时已经获得了网络请求的结果，若请求正常返回了user，则直接显示信息，否则显示错误信息 如此网络请求的后的异步操作变成了同步操作 #3. 通过多个用户名获取多个用户的数组 1234val names = arrayOf(&quot;abreslav&quot;,&quot;udalov&quot;, &quot;yole&quot;)val users = names.map { name -&gt; githubApi.getUserSuspend(name)} 说明： 通过map方法，每个用户名都进行一次网络操作，之后将网络操作的结果组合成一个列表返回 #三、 协程的常见实现 #1. 协程分类 按调用栈 有栈协程：每个协程会分配单独的调用栈，类似线程的调用栈，可以在任意函数嵌套中挂起 无栈协程：不会分配单独的调用栈，挂起点状态通过闭包或对象保存，只能在当前函数中挂起，无法嵌套函数实现挂起 按调用关系 对称协程：调度权可以转移给任意协程，协程之间是对等关系 非对称协程：调度权只能转移给调用自己的协程，协程存在父子关系 Kotlin中的是无栈的非对称协程 #2. 其它语言的常见协程实现 协程的关键： 挂起、恢复 #1. Python的Generator 123456def numbers(): i = 0 while True: yield i i += 1 time.sleep(1) 123gen = numbers()print(f&quot;[0]{next(gen)}&quot;)print(f&quot;[1]{next(gen)}&quot;) 打印结果： 12[0]0[1]1 说明： Python因其语法简单，不需要额外配置环境等而号称是最简单的语言 Python通过缩进定义作用域 定义了一个函数numbers()，函数中创建一个死循环，yield函数有挂起的含义，表示不再执行下面的代码，该条语句后面是将i自加1 调用函数numbers()返回的是一个generator，generator有next()方法，在python中next(gen)语句表示调用generator的next()方法，调用这条语句时才会真正执行numbers()里的代码 执行到第一条打印语句时，才会真正开始执行numbers()里的代码：先给i赋值为0，再进入死循环，之后执行到yield i，将这个函数挂起，再将i的值抛给了调用的位置，即next(gen)得到的是i的值，此时i的值为0 之后开始执行第二条打印语句，如此又开始执行numbers()函数里的yield i语句后的代码，将i值加一，因在列循环中，所以再次执行到了yield i，如此第二条打印语句的next(gen)得到了i的值，此时i的值为1 Python的Generator是无栈的非对称协程 #2. Lua的Coroutine 创建协程：coroutine.create(&lt;function&gt;)，传入一个函数 查询协程：coroutine.status(&lt;Coroutine-Object&gt;)，传入一个协程对象 挂起协程：coroutine.yield(&lt;Values-to-Yield&gt;)，可以传入一些值 恢复协程：coroutine.resume(&lt;Coroutine-Object&gt;)，传入协程对象 1234567891011121314151617181920212223function producer() for i = 0,3 do print(&quot;send&quot;..i) coroutine.yield(i) end print(&quot;End Producer&quot;)endfunction consumer(value) repeat print(&quot;receive&quot;..value) value = coroutine.yield() until(not value) print(&quot;EndConsumer&quot;)endproducerCoroutine = coroutine.create(producer)consumerCoroutine = coroutine.create(consumer)repeat status,product = coroutine.resume(producerCoroutine) coroutine.resume(consumerCoroutine,product)until(not status)print(&quot;End Main&quot;) 打印结果： 1234567891011send0receive0send1receive1send2receive2send3receive3End ProducerEndConsumerEnd Main 说明： 定义了函数producer()，其中创建一个循环四次的for循环yeild值i 定义了函数consumer()，该函数接收值value，创建一个条件循环当没有value值时停止循环，循环体内打印该值，然后将协程的yield()携带的值赋值给value 主调用中操作： 先根据那两个函数创建出两个协程：producerCoroutine、consumerCoroutine 创建一个条件循环，直到status为false时停止 循环体内先执行协程producerCoroutine中的函数producer：执行函数producer中的for循环，每次循环都打印信息，再通过coroutine.yield(i)方法将当前协程挂起并将i值丢出去 此时因为协程producerCoroutine还没执行完，所以status为true，而product值是yield出来的i值 之后执行协程consumerCoroutine中的函数consumer，并将product值作为入参传入函数中：进入函数内的循环，打印接收的值，之后将当前协程挂起 此时status值还是true，再次开始主调用循环：即再次执行协程producerCoroutine中的函数producer。走到函数producer中的循环执行完毕，status的值变为false，主调用结束 调用resume时，会将resume的其它参数作为入参传入到协程的函数中 Lua中..有拼接字符串的意思 Lua的协程是 有栈的非对称协程 #3. Go的routine 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决 非对称协程的调度权只能转移给调用自己的协程，而对称协程的调度权可以转移给任意协程。 对称协程是基于非对称协程的实现：在两个非对称协程中添加一个中间层调度中心就可以实现对称协程 Go语言的Coroutine是对称协程，它实现对称协程的中间层channel。 Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯。 Channel的操作符是箭头 &lt;-。该操作符代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据 使用 go 语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间 12ch &lt;- v // 发送值v到Channel ch中v := &lt;-ch // 从Channel ch中接收数据，并将数据赋值给v 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { channel := make(chan int) var readChannel &lt;-chan int = channel var writeChannel chan &lt;- int = channel go func() { for i:= 0; i &lt; 3; i++ { fmt.Println(&quot;write&quot;,i) writeChannel &lt;- i } close(writeChannel) }() go func() { fmt.Println(&quot;wait for read&quot;) for i := range readChannel { fmt.Println(&quot;read&quot;, i) } fmt.Println(&quot;read end&quot;) }() now := time.Now() time.Sleep(5 * time.Second) latency := time.Since(now).Seconds() fmt.Println(latency)} 打印结果： 123456789wait for readwrite 0write 1read 0read 1write 2read 2read end5.000133976 说明： :=是赋值符号。make(chan int)语句创建了一个channel，该channel类型是int，即channel可以传递的元素是int，没有指定方向，这个channel是双向的 声明一个变量readChannel，类型是一个单向的channel，channel只可以发送数据，即只能取到channel里的数据 声明一个变量writeChannel，类型是一个单向的channel，channel只可以接收数据，即只能往channel里放数据 定义了两个函数，并直接使用go语句开启两个新的运行期线程来分别执行这两个函数 第一个函数功能：定义一个for循环，循环体先打印信息，再将i的值放到writeChannel中，最后关闭 第二个函数功能：先打印信息。再定义了一个for循环，循环内打印从writeChannel取出的数据 因为主程序退出的太快了，所以最后添加了一个5秒的延时，否则两个协程的信息打印不出来。 结论： 每个go routine 都是并发或并行执行 无Buffer的Channel写时会挂起，直到读取，反之亦然 go routine 可以认为是一种有栈对称协程的实现 #4. async/await关键字 支持这两个关键字的语言有：JavaScript Es 2016(ES7)、C# 5.0、Python 3.5、Rust 1.39.0等等 #1. JavaScript的使用 12345678910111213141516171819function getUser(name) { return axios.get(`https://api.github.com/users/${name}`)}//正常调用该网络请求function main() { const userPromise = getUser(&quot;Lee&quot;) userPromise.then(user =&gt; { console.log(user); }).catch(e =&gt; { console.error(e) })}//使用这两个关键字调用网络请求async function main() { const user = await getUser(&quot;Lee&quot;) console.log(user)} 说明： 定义一个名为getUser()的函数，入参为name，用于获取GitHub上某用户的公开信息 Axios 是一个基于 promise 的 HTTP 库，返回类型为Promise&lt;AxiosResponse&lt;T&gt;&gt;，类似于Retrofit。官网：http://www.axios-js.com/ 若要正常调用网络请求的函数getUser()，需要使用.then()和.catch()添加回调，这是一个异步的调用 而使用关键字async和await调用网络请求函数getUser()，这是个同步的操作，不需要添加回调 关于async/await的总结： 可以多层嵌套，但必须为async function async/await是一种无线非对称的协程实现 async/await是目前各类语言支持最广泛的特性 #2. async/await和suspend的区别 12345//js中使用async function main() { const user = await getUser(&quot;Lee&quot;) console.log(user)} 123456789//kotlin中使用suspend fun coroutine(){ try { val user = githubApi.getUserSuspend(name) showUser(user) } catch (e: Exception) { showError(e) }} 说明： kotlin中使用修饰于函数上的关键字suspend实现调用网络请求时的同步操作，而sync/await需要两个关键字 #四、Kotlin协程的基本要素 #1. 协程的挂起和恢复 #1. 相关概念说明 挂起函数： 即使用suspend关键字修饰的函数。 suspend 是有暂停的意思，但在协程中应该理解为：当线程执行到协程的 suspend 函数的时候，暂时不继续执行协程代码了。 挂起函数只能在 其他挂起函数 或 协程 中调用 协程在执行到某一个suspend函数的时候，这个协程会被挂起 (即挂起的对象是协程)，也就是说 这个协程从正在执行它的线程上脱离，此时当前线程不再关心协程进行什么操作 挂起函数调用时包含了协程 挂起的语义 挂起函数返回时包含了协程 恢复的语义 挂起函数的类型是在一般函数类型前加一个suspend 函数 类型 suspend fun foo(){} suspend () -&gt; Unit suspend fun bar(a:Int):String { return “Hello”} suspend (Int) -&gt; String 挂起点： 挂起函数的调用处称为挂起点，在Android Studio中，挂起点位置有如下图标显示： 协程： 可以使用 launch 或者 async 函数启动一个协程，协程其实就是这两个函数中 闭包的代码块 #2. 在挂起时线程和协程各自操作 在挂起点时线程操作： 线程执行到了协程的代码块中的 suspend 函数时，就暂时不再执行剩余的协程代码，跳出协程的代码块。 此时若线程是一个后台线程，则跟 Java 线程池里的线程在工作结束之后是完全一样的：回收或者再利用。 若线程是一个Android主线程，那它接下来就会继续执行本职工作：也就是一秒钟60次的界面刷新任务 在挂起点时协程操作： 线程的代码在到达 suspend 函数的时候被掐断，接下来协程会从这个 suspend 函数开始继续往下执行，不过是在 suspend 函数指定的线程中执行。 suspend 函数通过Dispatchers 调度器来指定线程。Dispatchers调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行 常用的 Dispatchers有以下三种 Dispatchers.Main：Android 中的主线程 Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求 Dispatchers.Default：适合 CPU 密集型的任务，比如计算 在 suspend 函数执行完成之后，协程会自动帮我们把线程再切回来 挂起时线程和协程操作流程总结： 我们的协程原本是运行在某线程的。当代码遇到 suspend 函数的时候，会被 suspend 也就是被挂起，而所谓的被挂起，就是线程切换，根据 Dispatchers 切换到其它线程执行suspend函数。当这个suspend函数执行完毕后，协程会重新切换回一开始的线程 切回原线程的操作在 Kotlin 里叫做 恢复 (resume)， 也就是协程会帮我们再 post 一个 Runnable，让协程中剩下的代码继续回到一开始的线程中执行 简单来讲，在 Kotlin 中所谓的 挂起，就是一个稍后会被自动切回来的线程调度操作 挂起之后需要恢复，而 恢复这个功能是协程的，如果你不在协程里面调用，恢复这个功能没法实现，所以挂起函数必须在协程或者另一个挂起函数里被调用 因为一个挂起函数要么在协程里被调用，要么在另一个挂起函数里被调用，所以它其实直接或者间接地，总是会在一个协程里被调用 所以要求 suspend 函数只能在协程里或者另一个 suspend 函数里被调用，是为了要让协程能够在 suspend 函数切换线程之后再切回来，若在一般函数中调用了suspend函数，IDE会报错：Suspend function 'XXX' should be called only from a coroutine or another suspend function 挂想和恢复可以控制执行流程的转移 异步逻辑可以用同步代码的形式写出 同步代码比异步代码更灵活，更容易实现复杂业务 #3. 挂起实现原理 123suspend fun suspendingPrint() = withContext(Dispatchers.IO) { println(&quot;Thread: ${Thread.currentThread().name}&quot;)} 说明： 如上声明了一个挂起函数suspendingPrint()，函数功能是打印当前线程 withContext()函数是一个挂起函数，接收一个 Dispatcher 参数，依赖这个 Dispatcher 参数的指示，协程被挂起，然后切到别的线程 真正挂起协程是 Kotlin 的协程框架帮我们实现的。所以我们想要自己写一个挂起函数，除了加上 suspend 关键字还要函数内部直接或间接地调用到 Kotlin 协程框架自带的 suspend 函数才行 #4. suspend挂起总结 suspend 关键字并不是用来操作挂起的，挂起的操作依赖的是挂起函数里面的实际代码。该关键字其实是函数的创建者对函数的使用者的提醒：这是一个耗时函数，它被创建者用挂起的方式放在后台运行，所以请在协程里调用该函数 若创建了 suspend 函数但它内部不包含真正的挂起逻辑，IDE会给你提示一个警告：redundant suspend modifier (冗余的“redundant”修饰符) suspend 关键字限制函数只能在协程里被调用，如果在非协程的代码中调用，就会编译不通过 创建一个 suspend 函数，为了让它包含真正挂起的逻辑，要在它内部直接或间接调用 Kotlin 自带的 suspend 函数，自定义的 suspend 函数才是有意义的 suspend 函数用于处理比较耗时也就是要等的操作。耗时操作一般分为两类：I/O 操作和 CPU 计算工作。比如文件的读写、网络交互、图片的模糊处理，都是耗时的，通通可以把它们写进 suspend 函数里 suspend 函数的另一个应用场景是操作本身做起来并不慢，但它需要等待，比如 5 秒钟之后再做这个操作 withContext()函数是在挂起函数里功能最简单直接：把线程自动切走和切回 delay()函数等待一段时间后再继续往下执行代码 挂起，就是一个稍后会被自动切回来的线程调度操作 参考文章：kotlin协程的挂起suspend #2. Continuation 因为 Kotlin中的协程是无栈的，没有栈去保存挂起点的状态，而是通过Continuation接口实现了挂起点状态的保存，实现这个接口的类，具有可以暂停和继续的能力。 #1. Continuation部分源码 1234567891011121314151617181920package kotlin.coroutines@SinceKotlin(&quot;1.3&quot;)public interface Continuation&lt;in T&gt; { public val context: CoroutineContext public fun resumeWith(result: Result&lt;T&gt;)}@SinceKotlin(&quot;1.3&quot;)@InlineOnlypublic inline fun &lt;T&gt; Continuation&lt;T&gt;.resume(value: T): Unit = resumeWith(Result.success(value))@SinceKotlin(&quot;1.3&quot;)@InlineOnlypublic inline fun &lt;T&gt; Continuation&lt;T&gt;.resumeWithException(exception: Throwable): Unit = resumeWith(Result.failure(exception)) 说明： Continuation 定义了一个回调方法：resumeWith()：恢复执行相应的协程，将成功或失败的结果传递给挂起点返回值 Continuation接口有两个扩展方法： resume()：恢复执行相应的协程，传递对应值作为挂起点的返回值。 resumeWithException()：恢复执行相应的协程，以便在挂起点之后立即重新抛出错误 resume()与resumeWithException()都调用的resumeWith()方法 该源码是1.3版本之后的 #2. 挂起函数与Continuation关系 每个挂起函数编译后会增加一个 Continuation 类型的参数。每个挂起函数都有一个回调自己的 Continuation 实现类，并且这个类会被传递给这个挂起函数所调用的其它挂起函数，这些子方法可以通过 Continuation 回调父方法以恢复暂停的程序 1234suspend fun foo() {}suspend fun bar(a:Int):String { return &quot;Hello&quot;} 上述代码中的两个函数本质上其内容如下： 1234fun foo(continuation:Continuation&lt;Unit&gt;):Any{}fun bar(a:Int, continuation:Continuation&lt;String&gt;):Any{ return &quot;Hello&quot;} 说明： 一开始两个函数的类型分别为suspend () -&gt; Unit、suspend (Int) -&gt; String 如上挂起函数在编译后会增加一个 Continuation类型的入参，Continuation中的泛型是挂起函数的返回值类型，而挂起函数的返回值类型变为了Any，Any有两层含义： 若该挂起函数没有挂起，跟普通函数没有区别，则Any是承载真正的返回值结果的 若该挂起函数挂起，需要通过回调返回结果，则Any返回的是一个挂起标志：COROUTINE_SUSPENDED 如此调用挂起函数时一定要传入一个Continuation参数，而传递Continuation参数是编译器完成的，所以当前调用挂起函数的位置一定要有一个Continuation参数实例才可被作为参数传入，因此 挂起函数只能在挂起函数或协程中调用 #3. 将回调转为挂起函数 通过将 常规网络接口请求处理流程章节 中的异步网络请求改为同步来直观展示Continuation的使用 12345678910suspend fun getUserSuspend(name: String) = suspendCoroutine&lt;User&gt; { continuation -&gt; githubApi.getUserCallback(name).enqueue(object: Callback&lt;User&gt; { override fun onFailure(call: Call&lt;User&gt;, t: Throwable) = continuation.resumeWithException(t) override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) = response.takeIf { it.isSuccessful }?.body()?.let(continuation::resume) ?: continuation.resumeWithException(HttpException(response)) })} 说明： githubApi.getUserCallback()方法返回的是一个Call&lt;User&gt;，它可以通过equeue方法来实现网络的请求。 getUserSuspend()函数有suspend修饰符，则该函数是有一个Continuation对象的，正常使用是无法使用该Continuation对象，可以借助suspendCoroutine suspendCoroutine函数可以获取当前挂起函数中的Continuation实例，并且在该函数中可以调用Continuation的resume()和resumeWithException()方法 在回调成功的分支中使用Continuation.resume(value)，在回调失败的分支中使用Continuation.resumeWithException(e) 真正的挂起 必须异步调用resume，包括： 切换到其他线程resume 单线程事件循环异步执行 没有真正挂起 的情况：一开始直接return；在suspendCoroutine中直接调用resume。以上两种情况都没有切换线程 而Call&lt;User&gt;的equeue方法会将线程切换到IO线程去请求网络，所以getUserSuspend()函数实现了真正的挂起 #3. 协程的创建 #1. createCoroutine()方法 协程是一段可执行的程序，它的创建通常需要一个函数即挂起函数，且需要使用createCoroutine()来进行创建 12345678fun &lt;T&gt; (suspend () -&gt; T).createCoroutine(completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; {}fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutine(receiver: R, completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; {} 说明： createCoroutine()方法是挂起函数的扩展方法，也就是说只有挂起函数才能创建协程 提供了两个createCoroutine()方法，一个带receiver，一个不带receiver，这取决于调用该方法的挂起函数是否有receiver createCoroutine()方法中传入了一个Continuation类型的参数completion，这个Continuation是作为协程执行完毕后返回的Continuation createCoroutine()方法返回结果是一个Continuation，这个Continuation是协程创建出来的本体，该Continuation中的所有resume()方法执行完毕之后，就会调用入参传入的那个Continuation类型参数completion 一个协程需要两个Continuation： 一个是协程的本体即挂起函数本身执行需要一个Continuation实例在恢复时调用，即createCoroutine()方法中传入的参数completion createCoroutine()方法的返回值Continuation&lt;Unit&gt;，是创建出来的协程的载体，该方法的receiver即挂载函数会被传给该实例作为协程的实际执行体 #4. 协程启动 #1. resume 123456789suspend {}.createCoroutine(object: Continuation&lt;Unit&gt; { override val context = EmptyCoroutineContext override fun resumeWith(result: Result&lt;Unit&gt;) { Log.d(TAG,&quot;Coroutine End with $result&quot;) }}).resume(Unit) 说明： suspend {}创建了一个匿名的挂起函数，该匿名挂起函数又调用了createCoroutine()方法创建一个该匿名挂起函数包装的Continuation 而createCoroutine()方法中传入的Continuation是在协程执行完成后调用 调用resume(Unit)方法启动协程 #2. startCoroutine 1234567fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(completion: Continuation&lt;T&gt;): Unit {}fun &lt;R, T&gt; (suspend R.() -&gt; T).startCoroutine(receiver: R, completion: Continuation&lt;T&gt;): Unit {} 说明： startCoroutine()方法作用是创建协程，并在创建后启动协程，相当于createCoroutine()加上resume(Unit) 如此上一节代码可写为如下样式： 123456789suspend {}.startCoroutine(object: Continuation&lt;Unit&gt;{ override val context = EmptyCoroutineContext override fun resumeWith(result: Result&lt;Unit&gt;) { Log.d(TAG,&quot;Coroutine End with $result&quot;) }}) 协程在启动和执行结束的时候都会调用一次resume方法，协程中如果有N个挂起点，即调用了N个挂起函数且 挂起函数真正实现了挂起 (即切换了线程)，则总共调用了 N + 2 次resume方法 #5. 协程上下文 协程上下文 存放了协程执行过程中需要携带的数据 协程上下文 是一组用于定义协程行为的元素。由如下几项构成： Job: 控制协程的生命周期 CoroutineDispatcher: 调度器如Dispatchers.IO CoroutineName: 协程的名称，调试的时候很有用 CoroutineExceptionHandler: 用于处理未被捕捉的异常 协程上下文 简单来说是一个数据集合，索引是CoroutineContext.Key，元素是CoroutineContext.Element，实现接口CoroutineContext.Element的类，即可存放于协程上下文中，实现该接口的类如下图： #1. ContinuationInterceptor 拦截器ContinuationInterceptor是协程上下文的一类元素，它可以对协程上下文所在协程的Continuation进行拦截、篡改 1234567@SinceKotlin(&quot;1.3&quot;)public interface ContinuationInterceptor : CoroutineContext.Element { companion object Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt; public fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt;} 说明： ContinuationInterceptor接口中的interceptContinuation()方法，传入了一个Continuation，返回了一个Continuation 该拦截器与OkHttp里面addInterceptor的时候在这里面更改Interceptor然后在返回是一样的原理 #6. Continuation执行示意 #1. SuspendLambda 123suspend {...}.startCoroutine(...) 说明： 通过startCoroutine()创建出一个协程，而协程真正执行的逻辑就是该方法的receiver，即匿名挂起函数suspend {...}，这个匿名挂起函数创建成功后会生成一个类SuspendLambda，这是一个Continuation的实现类，如下图： #2. SafeContinuation 123456789suspend { a()}.startCoroutine(...)suspend fun a() = suspendCoroutine&lt;Unit&gt; { thread { it.resume(Unit) }} 说明： 若该匿名挂起函数内有挂起函数的调用，则会用SafeContinuation将SuspendLambda进行包装 只要使用了suspendCoroutine，就会将SuspendLambda包装起来，如下图： suspendCoroutine()函数中有一个参数Continuation，可以用it来表示该参数。而it代表的Continuation是SafeContinuation的一个实例。则it.resume()实际上调用的是SafeContinuation的resume，最终会调到SuspendLambda的resume，如此恢复到匿名挂起函数的执行 SafeContinuation的作用就是确保： SuspendLambda只被调用一次 如果在当前线程调用栈上直接调用则不会挂起 #3. 加入Intetcepted拦截器 123suspend { a()}.startCoroutine(...) 说明： 拦截器其实是将SuspendLambda包装了一次，如下图： SafeContinuation真正调用resume时，会调用了拦截器Intetcepted中返回的Continuation的resume，在拦截器返回的Continuation的resume方法中可以做切换线程操作，切换线程后，再调用SuspendLambda，如此实现了线程切换 拦截器最重要的一个功能就是线程切换 协程体是一个用suspend关键字修饰的一个无参、无返回值的函数类型。 调用顺序注意点： SafeContinuation仅在挂起点时出现 拦截器在每次 (恢复) 执行协程体时调用 SuspendLambda是协程函数体 #4. 协程挂起恢复执行示意 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//javapublic class ContinuationImpl implements Continuation&lt;Object&gt; { private int mLabel = 0; private final Continuation&lt;Unit&gt; mCompletion; public ContinuationImpl(Continuation&lt;Unit&gt; completion) { mCompletion = completion; } @NotNull @Override public CoroutineContext getContext() { return EmptyCoroutineContext.INSTANCE; } @Override public void resumeWith(@NotNull Object o) { try { Object result = o; switch (mLabel) { case 0: { Logger.debug(1); result = ConsoleMainKt.returnSuspend(this); mLabel++; if (isSuspended(result)) return; } case 1: { Logger.debug(result); Logger.debug(2); result = DelayKt.delay(1000, this); mLabel++; if (isSuspended(result)) return; } case 2: { Logger.debug(3); result = ConsoleMainKt.returnImmediately(this); mLabel++; if (isSuspended(result)) return; } case 3: { Logger.debug(result); Logger.debug(4); } } mCompletion.resumeWith(Unit.INSTANCE); } catch (Exception e) { mCompletion.resumeWith(e); } } private boolean isSuspended(Object o) { return o == IntrinsicsKt.getCOROUTINE_SUSPENDED(); }} 12345678//kotlinLogger.debug(1)Logger.debug(returnSuspend())Logger.debug(2)delay(1000)Logger.debug(3)Logger.debug(returnImmediately())Logger.debug(4) 介绍： 如上Java代码是仿照Kotlin中协程的调用逻辑写出的一个类ContinuationImpl，其本质上就是SuspendLambda： ContinuationImpl#resumeWith()方法执行的就是SuspendLambda中Lambda表达式真正传进去的东西 ContinuationImpl#isSuspended()方法用于判断某个对象是否为挂起标记， 如上Kotlin代码是协程启动后挂起函数执行的逻辑即SuspendLambda中Lambda表达式内容，启动的协程就是上述的Java代码类ContinuationImpl，每遇到一个挂起点都会有一个SafeContinuation，而SafeContinuation resume之后，会继续执行挂起函数里后续逻辑 Kotlin代码中有三个挂起点： Logger.debug(returnSuspend()) delay(1000) Logger.debug(returnImmediately()) 假定： 挂起函数returnSuspend()有切换线程的操作 挂起函数returnImmediately()直接在该挂起函数中return、或没有切换线程即没有调用SafeContinuation的resume 执行逻辑说明： 执行Kotlin中第一行代码：Logger.debug(1)，纯打印语句没有执行挂起之类的操作时，就是执行对应到Continu ationImpl#resumeWith()方法，第一次调用resumeWith()时，mLabel为0，所以执行值为0的分支：执行Logger.debug(1) 之后执行第二行代码：Logger.debug(returnSuspend())，因为上一条语句没有挂起之类的操作，所以还是在分支0中： 调用挂起函数ConsoleMainKt.returnSuspend(this)，该挂起函数有切换线程的操作，所以要实现真正的挂起 mLabel自加1 再通过函数isSuspended()判断该挂起函数的返回值result是一个 挂起标记，直接return，这就是非阻塞式的挂起，不卡当前线程。此时 此时等待该挂起函数恢复 当挂起函数returnSuspend()恢复时会再次调用ContinuationImpl#resumeWith()方法，因mLabel之前已经自加，所以此时走到了mLabel值为1的分支中，而恢复时传递回来的真正结果的打印也是在该分支中进行 之后执行第三行代码：Logger.debug(2)，纯打印语句，直接执行 之后执行第四行代码：delay(1000)，是Kotlin提供的挂起函数，功能是延时一秒，此时继续执行mLabel值为1的分支： 执行DelayKt.delay(1000, this) mLabel自加1 通过函数isSuspended()判断该挂起函数的返回值result是一个 挂起标记，直接return 等待延时结束后恢复 当延时恢复后，会再次调用ContinuationImpl#resumeWith()方法，此时mLabel已经自加到了2 之后执行第五行代码：Logger.debug(3)，纯打印语句，直接执行 之后执行第六行代码：Logger.debug(returnImmediately())，继续执行mLabel值为2的分支： 调用挂起函数ConsoleMainKt.returnImmediately(this);，该挂起函数没有切换线程之类的操作，不需要实现真正的挂起 mLabel自加1 通过函数isSuspended()判断该挂起函数的返回值result 不是 挂起标记，此时不会return，而是继续执行下个分支的语句 此时执行mLabel值为3的分支：打印出returnImmediately()函数的返回值 之后执行第七行代码：Logger.debug(4)，纯打印语句，直接执行 如此，创建协程时返回的Contiuation中resume全部执行完毕，此时执行创建协程时传入的Continuation即mCompletion的resumeWith()方法，将Unit传入其中 若是以上流程有错误的话，则会执行catch(Execption e)分支中的mCompletion.resumeWith(e);，即将错误信息返回 如此以Kotlin代码中的几条代码为SuspendLambda中Lambda而创建的协程执行完毕 协程挂起恢复的要点总结： 协程体内的代码都是通过Continuation.resumeWith调用来实现恢复 每调用一次resumeWith则mLabel加1，mLabel表示挂起次数，每个分支是挂起mLabel次后执行的代码，即每一个挂点对应一个case分支 挂起函数返回COROUTINE_SUSPENDED时才是真正的挂起 #7. 协程的线程调度 suspend函数会将整个协程挂起，而不仅仅是这个suspend函数，也就是说一个协程中有多个挂起函数时，它们是顺序执行的。而协程每次resume都会resume一开始的SuspendLambda，如此只要将这个resume拦截就可以进行线程调度 123456suspend {...}.startCoroutine(object: Continuation&lt;Unit&gt;{ override val context = DispatcherContext(HandlerDispatcher) ...}) 12345678910111213141516171819interface Dispatcher { fun dispatch(block: ()-&gt;Unit)}open class DispatcherContext(private val dispatcher: Dispatcher = DefaultDispatcher) : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor { override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; = DispatchedContinuation(continuation, dispatcher)}private class DispatchedContinuation&lt;T&gt;(val delegate: Continuation&lt;T&gt;, val dispatcher: Dispatcher) : Continuation&lt;T&gt;{ override val context = delegate.context override fun resumeWith(result: Result&lt;T&gt;) { dispatcher.dispatch { delegate.resumeWith(result) } }} 说明： 整体实现原理是：添加拦截器，拦截了SuspendLambda并返回了自己的Continuation，在自己的Continuation被调用时先切换线程，再去调用SuspendLambda的resume。如此实现了线程切换。这也是自定义类DispatcherContext实现的功能 #五、示例–使用标准库的序列生成器Sequence实现Generator Generator是Python中的协程特性，Generator的使用请看之前的章节：Pyhton的Generator #1. 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394abstract class GeneratorScope&lt;T&gt; internal constructor(){ protected abstract val parameter: T abstract suspend fun yield(value: T)}sealed class State { class NotReady(val continuation: Continuation&lt;Unit&gt;): State() class Ready&lt;T&gt;(val continuation: Continuation&lt;Unit&gt;, val nextValue: T): State() object Done: State()}interface Generator&lt;T&gt; { operator fun iterator(): Iterator&lt;T&gt;}class GeneratorImpl&lt;T&gt;(private val block: suspend GeneratorScope&lt;T&gt;.(T) -&gt; Unit, private val parameter: T): Generator&lt;T&gt; { override fun iterator(): Iterator&lt;T&gt; { return GeneratorIterator(block, parameter) }}fun &lt;T&gt; generator(block: suspend GeneratorScope&lt;T&gt;.(T) -&gt; Unit): (T) -&gt; Generator&lt;T&gt; { return { parameter: T -&gt; GeneratorImpl(block, parameter) }}class GeneratorIterator&lt;T&gt;(private val block: suspend GeneratorScope&lt;T&gt;.(T) -&gt; Unit, override val parameter: T) : GeneratorScope&lt;T&gt;(), Iterator&lt;T&gt;, Continuation&lt;Any?&gt; { override val context: CoroutineContext = EmptyCoroutineContext private var state: State init { val coroutineBlock: suspend GeneratorScope&lt;T&gt;.() -&gt; Unit = { block(parameter) } val start = coroutineBlock.createCoroutine(this, this) state = State.NotReady(start) } override suspend fun yield(value: T) = suspendCoroutine&lt;Unit&gt; { continuation -&gt; state = when(state) { is State.NotReady -&gt; State.Ready(continuation, value) is State.Ready&lt;*&gt; -&gt; throw IllegalStateException(&quot;Cannot yield a value while ready.&quot;) State.Done -&gt; throw IllegalStateException(&quot;Cannot yield a value while done.&quot;) } } private fun resume() { when(val currentState = state) { is State.NotReady -&gt; currentState.continuation.resume(Unit) } } override fun hasNext(): Boolean { resume() return state != State.Done } override fun next(): T { return when(val currentState = state) { is State.NotReady -&gt; { resume() return next() } is State.Ready&lt;*&gt; -&gt; { state = State.NotReady(currentState.continuation) (currentState as State.Ready&lt;T&gt;).nextValue } State.Done -&gt; throw IndexOutOfBoundsException(&quot;No value left.&quot;) } } override fun resumeWith(result: Result&lt;Any?&gt;) { state = State.Done result.getOrThrow() }}fun main() { val nums = generator { start: Int -&gt; for (i in 0..5) { yield(start + i) } } val seq = nums(10) for (j in seq) { println(j) }} 打印结果： 123456101112131415 代码说明： 定义抽象类GeneratorScope： 将该抽象类的构造函数声明为模块内可见 定义一个泛型T类型的参数parameter 定义一个抽象的挂起函数yield()，接收一个泛型T类型的参数 该抽象类用于限制挂起函数yield()的使用范围：仅限于以该抽象类为receiver的Lambda表达式 定义密封类State，用于标识协程运行情况： 不带值的状态建议使用枚举，带值的状态建议使用密封类 NotReady状态：还没有准备好值，需要一个协程继续执行协程体 Ready状态：已经有值了，此时内部已经yield，所以需要协程挂起，并将值传入 Done状态：协程体已执行完毕不会有新的值了 定义类GeneratorIterator： 主构造器上添加两个类内属性：一个是名为block的挂起函数——该挂起函数的receiver是GeneratorScope类、入参是泛型、返回结果是Unit；另一个是名为parameter的泛型参数 创建一个记录状态的属性state 添加一个初始化代码块： 启动协程时的SuspendLambda是没有参数的，但是该类传入的是一个带参数的挂起函数，所以声明一个名为coroutineBlock的无参挂起函数，在挂起函数体中将该类传入的泛型类型的参数作为入参调用传入的那个挂起函数 通过coroutineBlock创建协程，因不需要马上启动，所以使用createCoroutine()方法创建，该方法需要传入两个参数：第一个参数是receiver，因该类实现了GeneratorScope抽象类，所以写this；第二个参数是协程执行完毕后的回调，因为该类实现了Continuation接口，所以写this 状态初始化为NotReady，并传入上一条语句创建的协程 实现接口Iterator用于迭代： 定义一个resume()方法，用于判断如果当前状态是NotReady，调用一下状态中协程的resume()方法，以此来判断协程是否能yield值 hasNext()方法：用于判断是否有下一个值。先执行一下自定义的resume()方法——若状态是NotReady去调用协程的resume()方法，之后判断若状态为Done，表示协程执行完毕没有值了返回false，其它状态返回true next()方法返回下一次yield()返回的值。将当前状态state赋值给另一个属性currentState，判断currentState： 若currentState是NotReady，则调用一下自定义的resume()方法，看一下是否还有值，之后再调用一下next()方法 若currentState是Ready，先将state切换为NotReady状态，之后将curentState强转为Ready状态，之后调用Ready#nextValue()方法，得到yield()的值 若currentState是Done，抛出异常：下标越界 实现接口Continuation用于协程： 因为本次实现的功能不需要CoroutineContext，所以为CoroutineContext类型的属性context赋值为EmptyCoroutineContext对象 resumeWith()方法会在协程结束时调用，此时将状态置为Done，result.getOrThrow()语句表示若有异常则抛出异常，否则不做操作 继承抽象类GeneratorScope：实现yield()方法，该方法是一个挂起函数，需要通过suspendCoroutine拿到它的Continuation，之后根据当前状态state重新为state赋值: 若当前状态是NotReady，调用了yield()方法表示值已经准备好了，所以将当前置为Ready状态。创建Ready实例时将yield()之后继续执行的Continuation即通过suspendCoroutine拿到的Continuation传入进去，也将yield()方法的入参value传入进去 若当前状态是Ready(判断时Ready后加星投影是因为运行时这个类型不会真正存在)，抛出异常：在Ready状态不能yield值了 若当前状态是Done状态，抛出异常：不能在Done状态yield值 定义接口Generator，该接口中定义了一个重载运算符的函数iterator()、返回一个迭代器 定义实现类GeneratorImpl，它实现了接口Generator： 主构造器上添加两个类内属性：一个是名为block的挂起函数——该挂起函数的receiver是GeneratorScope类、入参是泛型、返回结果是Unit；另一个是名为parameter的泛型参数 在实现iterator()方法中直接返回GeneratorIterator类的对象 定义一个生成器函数generator： 入参是一个挂起函数——该挂起函数的receiver是GeneratorScope类、入参是泛型、返回结果是Unit 返回结果是一个函数——该函数有一个泛型入参、返回结果是接口Generator类型对象 函数体直接return了一个Lambda表达式，入参是泛型T类型的parameter，返回是一个接口Generator的实现类GeneratorImpl的对象 执行流程说明： generator函数创建一个Lambda表达式即创建一个新函数，新函数接收一个参数返回一个GeneratorImpl实例 GeneratorImpl实现了iterator运算符即可以迭代了 每次迭代先通过hasNext()函数判断是否有值，这个值就是yield()函数中的入参，其中若状态是NotReady则 会恢复协程 恢复协程会执行执行yield()函数，若状态是NotReady状态会将状态置为Ready并 将协程挂起 后交给状态对象state 之后执行next()函数取值，若是Ready状态，则将状态置为NotReady并将状态对象中的协程传给NotReady以便于下次该状态下恢复协程，如此实现了协程的挂起和恢复 #2. 使用sequence实现 12345678910111213fun main() { val sequence = sequence { yield(1) yield(2) yield(3) yield(4) yieldAll(listOf(1,2,3,4)) } for(seq in sequence){ println(seq) }} 打印结果： 1234567812341234 说明： 直接使用sequence实现了Python中的Generator功能 每次yield都会挂起，也可以对sequence迭代 但是上一节自定义的代码中可以输入一个初始值，而sequence不行 #六、 示例-- 仿 Lua 协程实现非对称协程 API 非对称协程：非对称协程的调度权只能转移给调用自己的协程，Lua的Coroutine就是非对称协程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139sealed class Status { class Created(val continuation: Continuation&lt;Unit&gt;): Status() class Yielded&lt;P&gt;(val continuation: Continuation&lt;P&gt;): Status() class Resumed&lt;R&gt;(val continuation: Continuation&lt;R&gt;): Status() object Dead: Status()}@RequiresApi(Build.VERSION_CODES.N)class Coroutine&lt;P, R&gt; ( override val context: CoroutineContext = EmptyCoroutineContext, private val block: suspend Coroutine&lt;P, R&gt;.CoroutineBody.(P) -&gt; R): Continuation&lt;R&gt; { companion object { fun &lt;P, R&gt; create( context: CoroutineContext = EmptyCoroutineContext, block: suspend Coroutine&lt;P, R&gt;.CoroutineBody.(P) -&gt; R ): Coroutine&lt;P, R&gt; { return Coroutine(context, block) } } inner class CoroutineBody { var parameter: P? = null suspend fun yield(value: R): P = suspendCoroutine { continuation -&gt; val previousStatus = status.getAndUpdate { when(it) { is Status.Created -&gt; throw IllegalStateException(&quot;Never started!&quot;) is Status.Yielded&lt;*&gt; -&gt; throw IllegalStateException(&quot;Already yielded!&quot;) is Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation) Status.Dead -&gt; throw IllegalStateException(&quot;Already dead!&quot;) } } (previousStatus as? Status.Resumed&lt;R&gt;)?.continuation?.resume(value) } } private val body = CoroutineBody() private val status: AtomicReference&lt;Status&gt; val isActive: Boolean get() = status.get() != Status.Dead init { val coroutineBlock: suspend CoroutineBody.() -&gt; R = { block(parameter!!) } val start = coroutineBlock.createCoroutine(body, this) status = AtomicReference(Status.Created(start)) } override fun resumeWith(result: Result&lt;R&gt;) { val previousStatus = status.getAndUpdate { when(it) { is Status.Created -&gt; throw IllegalStateException(&quot;Never started!&quot;) is Status.Yielded&lt;*&gt; -&gt; throw IllegalStateException(&quot;Already yielded!&quot;) is Status.Resumed&lt;*&gt; -&gt; { Status.Dead } Status.Dead -&gt; throw IllegalStateException(&quot;Already dead!&quot;) } } (previousStatus as? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result) } suspend fun resume(value: P): R = suspendCoroutine { continuation -&gt; val previousStatus = status.getAndUpdate { when(it) { is Status.Created -&gt; { body.parameter = value Status.Resumed(continuation) } is Status.Yielded&lt;*&gt; -&gt; { Status.Resumed(continuation) } is Status.Resumed&lt;*&gt; -&gt; throw IllegalStateException(&quot;Already resumed!&quot;) Status.Dead -&gt; throw IllegalStateException(&quot;Already dead!&quot;) } } when(previousStatus){ is Status.Created -&gt; previousStatus.continuation.resume(Unit) is Status.Yielded&lt;*&gt; -&gt; (previousStatus as Status.Yielded&lt;P&gt;).continuation.resume(value) } } //为了下一章节对称协程调用API时特殊添加 suspend fun &lt;SymT&gt; SymCoroutine&lt;SymT&gt;.yield(value: R): P { return body.yield(value) }}class Dispatcher: ContinuationInterceptor { override val key = ContinuationInterceptor private val executor = Executors.newSingleThreadExecutor() override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; { return DispatcherContinuation(continuation, executor) }}class DispatcherContinuation&lt;T&gt;(val continuation: Continuation&lt;T&gt;, val executor: Executor): Continuation&lt;T&gt; by continuation { override fun resumeWith(result: Result&lt;T&gt;) { executor.execute { continuation.resumeWith(result) } }}@RequiresApi(Build.VERSION_CODES.N)suspend fun main() { val producer = Coroutine.create&lt;Unit, Int&gt;(Dispatcher()) { for(i in 0..3){ log(&quot;send&quot;, i) yield(i) } 200 } val consumer = Coroutine.create&lt;Int, Unit&gt;(Dispatcher()) { param: Int -&gt; log(&quot;start&quot;, param) for(i in 0..3){ val value = yield(Unit) log(&quot;receive&quot;, value) } } while (producer.isActive &amp;&amp; consumer.isActive){ val result = producer.resume(Unit) consumer.resume(result) }}fun log(vararg msg: Any?) = println(&quot;Coroutine: ${msg.joinToString(&quot; &quot;)}&quot;) 打印结果： 123456789Coroutine: send 0Coroutine: start 0Coroutine: send 1Coroutine: receive 1Coroutine: send 2Coroutine: receive 2Coroutine: send 3Coroutine: receive 3Coroutine: receive 200 说明： 创建密封类Status，用于协程的状态： Created：创建状态 Yielded：挂起状态，yield时的值定义为泛型类型&lt;P&gt; Resumed：恢复状态， Dead：销毁状态 创建类Coroutine： 该类有两个泛型参数：P表示需要的参数；R表示返回值，也就是yield时传出的值 创建伴生对象，在伴生对象中创建可静态调用的方法create(),用于创建Coroutine类的对象 创建内部类CoroutineBody，用于约束yield方法只能在该协程lambda中使用： 创建一个泛型P类型的参数parameter，初始值为null 创建一个挂起函数yield，该函数接收的入参为泛型R类型value，返回值为泛型P类型 该类主构造器中有两个参数：一个是带默认参数的CoroutineContext类型的context，若不需要在多线程下运行不传该值直接使用默认值EmptyCoroutineContext；一个是挂起函函数block，该函数必须以CoroutineBody为receiver、以泛型P为入参、以泛型R为返回值 该类实现Continuation的接口，用于监听协程结束，在协程结束后会调用resumeWith()方法，在该方法中更新状态： 创建状态属性previousStatus，调用status的getAndUpdate()方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的it即为当前状态，也就是更新之前的状态 添加when语句进行状态判断 若为Created状态，抛非法异常：从没开始过 若为Yielded状态，抛非法异常：已经yield了 若为Resumed状态，返回Dead状态 若为Dead状态，抛非法异常：已经销毁 切换完状态后，将previousStatus强转为Resumed状态，之后每步都加非空判断，调用该状态的协程的resumeWith()方法将result传入 创建名为body的CoroutineBody对象 创建名为status的Status对象，但是使用了AtomicReference将对象包裹。AtomicReference是可以原子更新的对象引用，以保证线程安全 创建布尔型的属性isActive，用于判断协程是否还在活动，覆写该属性的get()方法，比较status是否是Dead状态 创建初始代码块： 创建名为coroutineBlock的用于创建协程的SuspendLambda，它的类型为以CoroutinBody为receiver的无入参、返回值为泛型R类型的挂起函数，其函数体是将强转为非空的parameter参数为入参调用的挂起函数block 通过coroutineBlock创建名为start的协程，因不需要马上启动，所以使用createCoroutine()方法创建。createCoroutine()方法需要传入两个参数：第一个参数是receiver即SuspendLambda的receiver，所以写CoroutinBody的实例body；第二个参数是协程执行完毕后的回调，因为类Coroutine实现了Continuation接口，所以写this 初始化状态status，为其赋值为Created状态，并将创建的start传入 创建resume()方法，该方法是一个挂起函数，传入泛型P类型的参数，返回泛型R，需要通过suspendCoroutine拿到它的Continuation，然后进行状态的流转: 创建状态属性previousStatus，调用status的getAndUpdate()方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的it即为当前状态，也就是更新之前的状态 添加when语句进行状态判断 若为Created状态，将body中的parameter赋值为value，作为函数调用的第一个参数。之后状态流转为resume,并将控制外部流程的continuation传递进去 若为Yielded状态，状态流转为resume,并将控制外部流程的continuation传递进去 若为Resumed状态，抛非法异常：已经resumed了 若为Dead状态，抛非法异常：已经销毁 切换完状态后，判断previousStatus状态： 若为Created状态，将之前的挂起点执行一下，之所以不在上一条的when语句中执行，是因为getAndUpdate中的lambda可能会执行多次。因此，等状态流转成功后再执行。这是协程刚被创建，第一次执行resume方法的场景，所以resume()方法不需要传进去参数 若为Yielded状态，将previousStatus强转为P泛型的Yielded类型，之后执行它的continuation的resume()方法，并将value值传递进去 创建yield()方法，该方法是一个挂起函数，传入泛型R类型的参数，返回泛型P，需要通过suspendCoroutine拿到它的Continuation，然后进行状态的流转。 创建类DispatcherContinuation，用于进行continuation的分发 其主构造器中传入两个参数，一个是要执行的continuation，一个是要执行continuation的executor 该类实现使用Continuation代理，如果只需要实现需要修改的方法即可，其它与Continuation一致 创建类Dispatcher，实现ContinuationInterceptor接口，用于切换线程： 其中key若是实现协程拦截器，则赋值ContinuationInterceptor 在拦截协程方法中返回分发协程类对象，其中传入的执行器是使用newSingleThreadExecutor()创建的新执行器 创建main()函数验证代码： 创建一个名为producer的Coroutine，其中 第一个形参是CoroutineContext类型，传入的是Dispatcher类实例，该类实现ContinuationInterceptor接口，而该接口继承自CoroutineContext 第二个形参是receiver为CoroutineBody的lambda表达式，该表达式入参为Unit即无入参，返回结果为Int类型。此时lambda表达式功能为执行fori循环，执行四次，从0开始到3结束，每次打印日志发送出去的值，并将i通过yield()方法传递出去 创建名为consumer的Coroutine，其中 第一个形参是CoroutineContext类型，传入的是Dispatcher类实例，该类实现ContinuationInterceptor接口，而该接口继承自CoroutineContext 第二个形参是receiver为CoroutineBody的lambda表达式，该表达式入参为Int类型，返回结果为Unit类型。此时lambda表达式功能为打印传递进来的参数，之后执行fori循环，执行四次，从0开始到3结束，每次通过yield()方法取到生产者发送的值，并打印接收到的值 创建一个循环，如果生产者和消费者都处于活跃状态则执行循环体：通过生产者的resume()方法取到生产的值，将通过消费者的resume()方法将值传递给消费者 问题：使用Executor的newSingleThreadExecutor()方法创建的线程不是幽灵线程，该线程会一直在后台等待execute()方法传递的任务。所以主线程执行完毕后，executor创建的线程还在后台运行，因此不能正常结束 #七、 示例-- 基于非对称协程API实现对称协程 #1. 实现思路 基于非对称协程实现对称协程只需要 添加一个中间层调度中心即可实现。 如上图所示： 若从协程A转到协程B，若是非对称协程直接在协程A中yield()或是resume(coroutineB)即可 而若是对称协程，协程Ayield()之后将调度权转给调度中心，而调度中心再调用resume(coroutineB),如此来通过非对称实现对称。 调度中心可以是单独的一个协程，它只负责分发转移调度权。 而调度协程如何知道调度权转移给谁呢？只需要调用yield()方法时将要转到的协程作为参数传入调度协程即可，如下图所示： #2. 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//sym全拼为symmetricclass SymCoroutine&lt;T&gt;( override val context: CoroutineContext = EmptyCoroutineContext, private val block: suspend SymCoroutine&lt;T&gt;.SymCoroutineBody.(T) -&gt; Unit) : Continuation&lt;T&gt; { companion object { lateinit var main: SymCoroutine&lt;Any?&gt; suspend fun main(block: suspend SymCoroutine&lt;Any?&gt;.SymCoroutineBody.() -&gt; Unit) { SymCoroutine&lt;Any?&gt; { block() }.also { main = it }.start(Unit) } fun &lt;T&gt; create( context: CoroutineContext = EmptyCoroutineContext, block: suspend SymCoroutine&lt;T&gt;.SymCoroutineBody.(T) -&gt; Unit ): SymCoroutine&lt;T&gt; { return SymCoroutine(context, block) } } class Parameter&lt;T&gt;(val coroutine: SymCoroutine&lt;T&gt;, val value: T) val isMain: Boolean get() = this == main private val body = SymCoroutineBody() private val coroutine = Coroutine&lt;T, Parameter&lt;*&gt;&gt;(context) { Parameter(this@SymCoroutine, suspend { block(body, it) if(this@SymCoroutine.isMain) Unit else throw IllegalStateException(&quot;SymCoroutine cannot be dead.&quot;) }() as T) } inner class SymCoroutineBody { private tailrec suspend fun &lt;P&gt; transferInner(symCoroutine: SymCoroutine&lt;P&gt;, value: Any?): T{ if(this@SymCoroutine.isMain){ return if(symCoroutine.isMain){ value as T } else { val parameter = symCoroutine.coroutine.resume(value as P) transferInner(parameter.coroutine, parameter.value) } } else { this@SymCoroutine.coroutine.run { return yield(Parameter(symCoroutine, value as P)) } } } suspend fun &lt;P&gt; transfer(symCoroutine: SymCoroutine&lt;P&gt;, value: P): T { return transferInner(symCoroutine, value) } } override fun resumeWith(result: Result&lt;T&gt;) { throw IllegalStateException(&quot;SymCoroutine cannot be dead!&quot;) } suspend fun start(value: T){ coroutine.resume(value) }}object SymCoroutines { val coroutine0: SymCoroutine&lt;Int&gt; = SymCoroutine.create&lt;Int&gt; { param: Int -&gt; log(&quot;coroutine-0&quot;, param) var result = transfer(coroutine2, 0) log(&quot;coroutine-0 1&quot;, result) result = transfer(SymCoroutine.main, Unit) log(&quot;coroutine-0 1&quot;, result) } val coroutine1: SymCoroutine&lt;Int&gt; = SymCoroutine.create { param: Int -&gt; log(&quot;coroutine-1&quot;, param) val result = transfer(coroutine0, 1) log(&quot;coroutine-1 1&quot;, result) } val coroutine2: SymCoroutine&lt;Int&gt; = SymCoroutine.create { param: Int -&gt; log(&quot;coroutine-2&quot;, param) var result = transfer(coroutine1, 2) log(&quot;coroutine-2 1&quot;, result) result = transfer(coroutine0, 2) log(&quot;coroutine-2 2&quot;, result) }}suspend fun main() { SymCoroutine.main { log(&quot;main&quot;, 0) val result = transfer(SymCoroutines.coroutine2, 3) log(&quot;main end&quot;, result) }} 代码说明： 该章节代码是基于上一章节非对称协程代码开发的 对称协程要求在运行结束后主动将调度权转移，而不是执行完毕。即不允许在不确定的协程里运行结束，以避免意想不到的结果。 创建类SymCoroutine： 该类只有一个泛型参数：T表示需要的参数；因为是对称协程没有返回值的说法 创建伴生对象，在伴生对象中做如下操作： 创建SymCoroutine类型的属性main，用于保存调度中心的协程，以判断当前协程是否为调度中心 创建挂起函数main，该函数入参类型为以SymCoroutinBody为receiver的无入参、返回值为Unit类型的挂起函数，main函数体将传入的挂起函数启动 创建可静态调用的方法create()，用于创建SymCoroutine类的对象 创建类Parameter，用于包含yield()和resume()方法中所有入参，即SymCoroutine类型的协程对象，和该协程对象所需要的类型为泛型T的参数value，也是为了复用上一章节非对称协程代码 创建属性isMain，返回值类型为Boolean，用于判断当前协程是否为调度中心协程即是是否为main协程 创建SymCoroutineBody类型对象body 创建非对称协程对象coroutine，即为上一章节非对称协程代码中的Coroutine类对象，其中需要的参数为泛型T，返回的参数为Parameter。传入真正执行的lambda表达式，该lambda表达式返回一个Parameter实例对象。 parameter对象第一个入参是要转移的目标协程，传当前协程即可 parameter对象另一个参数是目标协程所需要参数，创建一个suspend lambda表达式，在表达式中运行block表达式以得到结果，block表达式中首先传入上一步创建的body对象，再传入泛型参数，因为上一章节非对称协程代码中的Coroutine类对象中的语句private val block: suspend Coroutine&lt;P, R&gt;.CoroutineBody.(P) -&gt; R入参中CoroutineBody有一个入参P,因此可以直接使用it来代指。 执行完block表达式后，判断当前协程是否为main，如果是main协程则返回一个Unit，否则抛出异常：SymCoroutine不能执行完毕 创建内部类SymCoroutineBody，用于约束transfer方法只能在该协程lambda中使用： 创建一个挂起函数transfer： 一个入参类型为SymCoroutine的协程对象，即转移的目标协程，该协程接收一个泛型为P类型的参数 另一个入参类型为泛型P的value值，该值为上一个入参协程对象所需要的参数 返回值为泛型T类型，用于流转到该协程时所要传入参数 创建挂起函数transferInner，用于实现函数transfer的功能： 满足尾递归条件的函数前面加tailrec修饰，编译器会优化该递归成一个快速而高效的基于循环的版本，减少栈消耗。尾递归条件：1. 最后一条语句是函数调用语句；2. 调用的函数是自身 第一个入参类型与transfer()函数一致 第二个入参类型为Any? 先判断当前SymCoroutineBody的SymCoroutine是否为main协程 若是main协程，因为每次转换调度权都会回到main协程中，因此要再判断转移目标协程是否为main协程 若转移目标协程是main协程，直接将value值返回 若转移目标协程不是main协程，即不是转移给main协程的，则需要获取yield()出来的两个参数，通过symCoroutine.coroutine取到非对称协程的对象并调用其resume()方法获取该协程返回的结果，其中resume()方法入参就是该协程需要的参数，即value,将其强转为泛型P。之后再调用transferInner()方法，将转移的目标协程及目标协程需要的参数传递进去 若当前SymCoroutineBody的SymCoroutine不是main协程，即协程A到协程B的过程中，协程A还没有yield,因此需要执行一下协程A的yield()方法，但是this@SymCoroutine.coroutine中只有它的CoroutineBody里才有yield()方法，因此我们需要改造上一章节的代码在Coroutine类中添加如下方法: 123456789101112131415161718192021 suspend fun &lt;SymT&gt; SymCoroutine&lt;SymT&gt;.yield(value: R): P { return body.yield(value) } ```` 之后调用`this@SymCoroutine.coroutine`的`run`方法，并将`symCoroutine`和`value`拼装成`Parameter`对象，再将该对象作为入参调用`yield()`方法 8. 创建方法`start()`，用于启动该调度中心的协程`main`，在该方法体中调用非对称协程的`resume()`方法。该方法在`SymCoroutine`的伴生对象里的`main()`方法中被调用 9. 创建带名伴生对象`SymCoroutines`，在该伴生对象中创建三个对称协程，在各自的函数中调用`transfer()`方法进行协程的切换，并打印日志 10. 创建程序入口`main()`函数，在该函数中调用`SymCoroutine.main()`方法，用于创建并启动调度中心的协程`main`，并在该`main`协程中开始进行协程的切换并打印日志**打印结果：**```kotlinCoroutine: main 0Coroutine: coroutine-2 3Coroutine: coroutine-1 2Coroutine: coroutine-0 1Coroutine: coroutine-2 1 0Coroutine: coroutine-0 1 2Coroutine: main end kotlin.Unit 执行流程说明： 上述例子中协程调用流程如下图所示： 程序开始首先启动调度中心的协程即协程main 打印信息main 0然后再将调度权转给协程2，并传入值3 之后进入协程2，打印信息coroutine-2 3，接着将调度权转移给协程1，并传入值2 之后进入协程1，打印信息coroutine-1 2，接着将调度权转移给协程0，并传入值1 之后进入协程0，打印信息coroutine-0 1，接着将调度权转移给协程2，并传入值0 之后进入协程2，运行调用其第一个挂起函数transfer()之后的语句，打印信息coroutine-2 1 0，接着将调度权转移给协程0，并传入值2 之后进入协程0，打印信息coroutine-0 1 2，接着将调度权转移给了调度中心的协程main，表示要结束协程调度 之后进入协程main，运行调用其挂起函数transfer()之后的语句，打印信息main end kotlin.Unit，程序结束 若第6步，打印信息后，将调度权转移给协程1，即result = transfer(coroutine0, 2)替换为result = transfer(coroutine1, 2)，则会进入协程1，运行调用其挂起函数transfer()之后的语句，打印信息coroutine-1 1 2，之后协程里lambda运行完毕了，并会走到如下语句if(this@SymCoroutine.isMain) Unit else throw IllegalStateException(&quot;SymCoroutine cannot be dead.&quot;)，因为该协程不是协程main，则程序会触发断言，抛出异常。由此将协程切换限制到在协程main开始，最后到协程main里结束 #八、 示例–仿Go的channel实现协程通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109@file:RequiresApi(Build.VERSION_CODES.N)package cn.ltt.projectcollection.kotlin.coroutinesLab.goimport android.os.Buildimport androidx.annotation.RequiresApiimport cn.ltt.projectcollection.kotlin.coroutinesLab.lua.logimport cn.ltt.projectcollection.kotlin.coroutinesLab.primary.dispatcher.DispatcherContextimport java.util.*import java.util.concurrent.atomic.AtomicReferenceimport kotlin.coroutines.*interface Channel&lt;T&gt; { suspend fun send(value: T) suspend fun receive(): T fun close()}class ClosedException(message: String) : Exception(message)class SimpleChannel&lt;T&gt; : Channel&lt;T&gt; { sealed class Element { override fun toString(): String { return this.javaClass.simpleName } object None : Element() class Producer&lt;T&gt;(val value: T, val continuation: Continuation&lt;Unit&gt;) : Element() class Consumer&lt;T&gt;(val continuation: Continuation&lt;T&gt;) : Element() object Closed : Element() } private val state = AtomicReference&lt;Element&gt;(Element.None) override suspend fun send(value: T) = suspendCoroutine&lt;Unit&gt; { continuation -&gt; val prev = state.getAndUpdate { when (it) { Element.None -&gt; Element.Producer(value, continuation) is Element.Producer&lt;*&gt; -&gt; throw IllegalStateException(&quot;Cannot send new element while previous is not consumed.&quot;) is Element.Consumer&lt;*&gt; -&gt; Element.None Element.Closed -&gt; throw IllegalStateException(&quot;Cannot send after closed.&quot;) } } (prev as? Element.Consumer&lt;T&gt;)?.continuation?.resume(value)?.let { continuation.resume(Unit) } } override suspend fun receive(): T = suspendCoroutine&lt;T&gt; { continuation -&gt; val prev = state.getAndUpdate { when (it) { Element.None -&gt; Element.Consumer(continuation) is Element.Producer&lt;*&gt; -&gt; Element.None is Element.Consumer&lt;*&gt; -&gt; throw IllegalStateException(&quot;Cannot receive new element while previous is not provided.&quot;) is Element.Closed -&gt; throw IllegalStateException(&quot;Cannot receive new element after closed.&quot;) } } (prev as? Element.Producer&lt;T&gt;)?.let { it.continuation.resume(Unit) continuation.resume(it.value) } } override fun close() { val prev = state.getAndUpdate { Element.Closed } if (prev is Element.Consumer&lt;*&gt;) { prev.continuation.resumeWithException(ClosedException(&quot;Channel is closed.&quot;)) } else if (prev is Element.Producer&lt;*&gt;) { prev.continuation.resumeWithException(ClosedException(&quot;Channel is closed.&quot;)) } }}fun plainChannelSample() { val channel = SimpleChannel&lt;Int&gt;() go(&quot;producer&quot;){ for (i in 0..6) { log(&quot;send&quot;, i) channel.send(i) } } go(&quot;consumer&quot;, channel::close){ for (i in 0..5) { log(&quot;receive-i:$i&quot;) val got = channel.receive() log(&quot;got&quot;, got) } }}fun go(name: String = &quot;&quot;, completion: () -&gt; Unit = {}, block: suspend () -&gt; Unit){ block.startCoroutine(object : Continuation&lt;Any&gt; { override val context = DispatcherContext() override fun resumeWith(result: Result&lt;Any&gt;) { log(&quot;end $name&quot;, result) completion() } })}fun main() { plainChannelSample() //blockingChannelSample()} 说明： go routine的详细内容可以看前而讲到的Go routine示例 因工程里设置的最小API版本为16，而AtomicReference#getAndUpdate()方法需要的API版本为24， 所以需要添加注解来标识，因此使用**@file** 来为整个文件添加注解而不需要再在每个方法上添加 定义接口Channel，用于规范协程间通信的管道。在接口中定义三个方法： 挂起函数send()方法，用于发送参数 挂起函数receive()方法，用于接收参数 函数close()，用于关闭管道 定义类CosedException，用于显示关闭管道异常信息 定义类SimpleChannel，实现接口channel，该类 不支持队列，只能发送接收，不能发送发送再接收接收： 创建密封类Element，用于规范管道的几种状态： None状态，即没有发送的也没有接收的 Producer状态，即已经发送了，但还没有接收 Consumer状态，即已经开始接收了，但还没有发送 Closed状态，管道关闭 创建状态属性state，类型为AtomicReference类型的Element，初始值为Element.None 实现挂起函数send()，通过suspendCoroutine函数可以获取当前挂起函数中的Continuation实例，并且在该函数中可以调用Continuation方法。 send()方法是发送数据，不需要返回数据，所以suspendCoroutine后的泛型写Unit 创建状态属性prev，调用state的getAndUpdate()方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的it即为当前状态，也就是更新之前的状态 添加when语句进行状态判断 若为None状态，则将state更新为Producer状态，并将传入的value和当前的coroutine作为参数传进去，等接收人将value取走，并调用这个coroutine来将这个协程恢复执行 若为Producer状态，抛非法异常。因为此时已经是发送待接收状态了不能再发送了 若为Consumer状态，意味着已经在等待发送数据，将数据发送出去，再将state更新为None状态 若为Closed状态，抛非法异常，关闭了就不能再发送了 切换完状态后，将prev判空强转为Consumer状态，意味着已经在等待发送数据，之后每步都加非空判断，调用该状态的协程的resume()方法将value发送出去，之后调用continuation的resume()方法恢复当前协程 实现挂起函数receive()，依然是通过通过suspendCoroutine函数获取当前挂起函数中的Continuation实例，并且在该函数中调用Continuation方法。 receive()方法用于接收数据，该方法返回接收到的数据，所以suspendCoroutine后的泛型写T 创建状态属性prev，调用state的getAndUpdate()方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的it即为当前状态，也就是更新之前的状态 添加when语句进行状态判断 若为None状态，则将state更新为Consumer状态，并将当前的coroutine作为参数传进去， 若为Producer状态，意味着已经是发送待接收状态，因此要将数据接收，再将state更新为None状态 若为Consumer状态，抛非法异常。因为此时已经是等待发送状态了，不能接收了。不支持队列 若为Closed状态，抛非法异常，关闭了就不能再发送了 切换完状态后，将prev判空强转为Producer状态，意味着已经发送数据等待接收，之后每步都加非空判断，因为该状态是发送者，不需要返回结果，调用该状态的协程的resume()方法将Unit发送回去，之后调用continuation的resume()方法将发送过来的值传递进去来获取 实现挂起函数close()： 创建状态属性prev，调用state的getAndUpdate()方法，将state切换为closed状态，并将切换之前的状态值赋值给prev 判断切换之前的状态值：如果是Consumer状态或是Producer状态，调用该状态的continuation的resumeWithException()方法。也就是在关闭过程中管道还在发送或是接收数据，抛出异常管道已经关闭啦不要再用啦 定义函数go()，用于模仿go语言中的routine样式， 有三个入参： 第一个参数是一个String类型，默认为空，只做打印日志使用 第二个参数是无入参返回值为Unit的函数completion，默认是空函数 第三个参数是无入参返回值为Unit的挂起函数block 函数体内调用block的startCoroutine()方法来运行挂起函数： 每次运行挂起函数都会创建一个DispatcherContext()，由此实现每个协程都单独运行在自己的线程上。具体实现见协程间的线程调度 在resumeWith()方法中打印信息，并执行传进来的方法completion() 定义函数plainChannelSample()，用于非队列非阻塞式管道示例： 定义属性channel，赋值为SimpleChannel类的实例，泛型传入Int 调用go()函数 第一个参数传入producer 第二个参数不传 第三个参数传入一个挂起函数，挂起函数体为一个fori循环，从0到6执行7次，每次循环都打印信息，并通过调用channel.send()方法将循环下标值传递出去 调用go()函数： 第一个参数传入consumer 第二个参数传入匿名函数，函数中调用channel::close，该方法用于关闭管道，即接收完所有数据后调用该方法关闭管道 第三个参数传入一个挂起函数，挂起函数体为一个fori循环，从0到5执行6次，每次循环打印信息，并通过调用channel.receive()方法获取管道发送的值，之后打印该值 创建main()入口函数，在函数中调用plainChannelSample()方法 打印结果： 12345678910111213141516171819202116:49:16:913 [DefaultDispatcher-worker-1] receive16:49:16:913 [DefaultDispatcher-worker-0] send 016:49:16:946 [DefaultDispatcher-worker-0] send 116:49:16:946 [DefaultDispatcher-worker-2] got 016:49:16:946 [DefaultDispatcher-worker-2] receive16:49:16:946 [DefaultDispatcher-worker-2] got 116:49:16:946 [DefaultDispatcher-worker-3] send 216:49:16:946 [DefaultDispatcher-worker-2] receive16:49:16:946 [DefaultDispatcher-worker-2] got 216:49:16:946 [DefaultDispatcher-worker-2] receive16:49:16:946 [DefaultDispatcher-worker-4] send 316:49:16:947 [DefaultDispatcher-worker-4] send 416:49:16:947 [DefaultDispatcher-worker-5] got 316:49:16:947 [DefaultDispatcher-worker-5] receive16:49:16:947 [DefaultDispatcher-worker-5] got 416:49:16:947 [DefaultDispatcher-worker-5] receive16:49:16:947 [DefaultDispatcher-worker-6] send 516:49:16:947 [DefaultDispatcher-worker-6] send 616:49:16:947 [DefaultDispatcher-worker-7] got 516:49:16:948 [DefaultDispatcher-worker-7] end consumer Success(kotlin.Unit)16:49:16:949 [DefaultDispatcher-worker-8] end producer Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.) 打印结果说明： 最后在go()函数中，协程执行完毕后会打印信息，结果显示consumer协程成功结束，但是producer协程是异常结束，之所以异常是因为consumer只循环了6次，且在最后一次循环后将管道关闭了，而在producer中循环了7次，最后一次循环时管道已经关闭了，抛出异常，因此producer是异常结束 定义使用队列的可阻塞式的管道 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class QueueChannel&lt;T&gt; : Channel&lt;T&gt; { class Producer&lt;T&gt;(val value: T, val continuation: Continuation&lt;Unit&gt;) class Consumer&lt;T&gt;(val continuation: Continuation&lt;T&gt;) sealed class ElementList { object Nil : ElementList() abstract class AbsElementList&lt;T&gt; : ElementList() { private val list = mutableListOf&lt;T&gt;() protected abstract fun new(): AbsElementList&lt;T&gt; fun offer(element: T): ElementList { return new().also { it.list += this.list + element } } open fun take(): ElementList { val newList = this.list - this.list.first() if (newList.isEmpty()) return Nil return new().also { it.list += newList } } fun peek(): T = list.first() fun elements(): List&lt;T&gt; = Collections.unmodifiableList(list) } class ProducerList&lt;T&gt; : AbsElementList&lt;Producer&lt;T&gt;&gt;() { override fun new() = ProducerList&lt;T&gt;() } class ConsumerList&lt;T&gt; : AbsElementList&lt;Consumer&lt;T&gt;&gt;() { override fun new() = ConsumerList&lt;T&gt;() } object Closed : ElementList() } private val state = AtomicReference&lt;ElementList&gt;(ElementList.Nil) override suspend fun send(value: T) = suspendCoroutine&lt;Unit&gt; { continuation -&gt; val prev = state.getAndUpdate { when (it) { ElementList.Nil -&gt; ElementList.ProducerList&lt;T&gt;().offer(Producer(value, continuation)) is ElementList.ProducerList&lt;*&gt; -&gt; { (it as ElementList.ProducerList&lt;T&gt;).offer(Producer(value, continuation)) } is ElementList.ConsumerList&lt;*&gt; -&gt; { (it as ElementList.ConsumerList&lt;T&gt;).take() } ElementList.Closed -&gt; throw IllegalStateException(&quot;Cannot send after closed.&quot;) else -&gt; throw IllegalStateException() } } (prev as? ElementList.ConsumerList&lt;T&gt;)?.peek()?.continuation?.resume(value)?.run { continuation.resume(Unit) } } override suspend fun receive(): T = suspendCoroutine&lt;T&gt; { continuation -&gt; val prev = state.getAndUpdate { when (it) { ElementList.Nil -&gt; ElementList.ConsumerList&lt;T&gt;().offer(Consumer(continuation)) is ElementList.ProducerList&lt;*&gt; -&gt; { (it as ElementList.ProducerList&lt;T&gt;).take() } is ElementList.ConsumerList&lt;*&gt; -&gt; { (it as ElementList.ConsumerList&lt;T&gt;).offer(Consumer(continuation)) } ElementList.Closed -&gt; throw IllegalStateException(&quot;Cannot receive after closed.&quot;) else -&gt; throw IllegalStateException() } } (prev as? ElementList.AbsElementList&lt;Producer&lt;T&gt;&gt;)?.peek()?.let { it.continuation.resume(Unit) continuation.resume(it.value) } } override fun close() { val prev = state.getAndUpdate { ElementList.Closed } if (prev is ElementList.ConsumerList&lt;*&gt;) { prev.elements().forEach { it.continuation.resumeWithException(ClosedException(&quot;Channel is closed.&quot;)) } } else if (prev is ElementList.ProducerList&lt;*&gt;) { prev.elements().forEach { it.continuation.resumeWithException(ClosedException(&quot;Channel is closed.&quot;)) } } }}fun blockingChannelSample() { val channel = QueueChannel&lt;Int&gt;() for (n in 0..5) { go(&quot;producer $n&quot;){ for (i in n..n + 5) { log(&quot;send&quot;, i) channel.send(i) } } } go(&quot;consumer&quot;, channel::close) { for (i in 0..11) { val got = channel.receive() log(&quot;got&quot;, got) } }} 说明： 定义实现接口Channel的实现类QueueChannel，用于实现队列的可阻塞式的管道 定义类Producer，有两个入参 定义类Consumer，有一个入参 定义密封类ElementList，通过列表实现队列功能： 定义Nil状态， 定义抽象类AbsElementList: 定义可变列表属性list 定义抽象方法new()，返回AbsElementList对象 定义方法offer()，入参是泛型T类型的元素，返回结果是一个ElementList对象，函数体中返回的是一个新创建的列表，新列表添加了之前列表的所有内容，并添加了传入的元素 定义开放方法take()，返回一个ElementList对象，函数体操作：先创建属性newList用于存储之前列表去除头部元素后的列表，如果新列表是空的，则返回Nil，否则返回一个新创建的列表，该列表添加了newList中所有元素 定义peek()方法，用于返回当前列表的头部元素 定义elements()方法，用于返回一个只读的元素列表 定义类ProducerList，继承抽象类AbsElementList，重写new()方法，返回一个ProducerList对象 定义类ConsumerList，继承抽象类AbsElementList，重写new()方法，返回一个ConsumerList对象 定义单例类Closed 定义属性state，用于保存管道状态，初始化为Nil状态 重写挂起函数send()方法，通过suspendCoroutine函数可以获取当前挂起函数中的Continuation实例，并且在该函数中可以调用Continuation方法。 send()方法是发送数据，不需要返回数据，所以suspendCoroutine后的泛型写Unit 创建状态属性prev，调用state的getAndUpdate()方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的it即为当前状态，也就是更新之前的状态 添加when语句进行状态判断 若为Nil状态，则将state更新为ProducerList状态，先将传入的value和当前的coroutine组合为对象Producer，再调用密封类ElementList的子类ProducerList的offer()方法，将组合好的对象Producer作为参数传进去 若为ProducerList状态，不切换状态，当前虽然已经处于已发送待接收状态，但因为使用了列表可以继续发送。先强转为ProucerList状态，然后再调用ProducerList的offer()方法，将传入的value和当前的coroutine这两个参数 组合的对象Producer作为参数传进去 若为ConsumerList状态，当前是等待发送状态，需要将生产者列表中的头元素发送出去，因此需要更新消费者列表去掉头元素，若去掉头元素后列表变为空了，则将状态切换为Nil 若为Closed状态，抛非法异常，关闭了就不能再发送了 若为其它状态，则抛非法异常 切换完状态后，将prev判空强转为ConsumerList状态，意味着已经在等待发送数据，之后每步都加非空判断，通过peek()方法取出消费者列表中的第一个消费者，再调用该消费者的协程的resume()方法将value发送出去，之后调用continuation的resume()方法恢复当前协程 重写挂起函数receive()，依然是通过suspendCoroutine函数获取当前挂起函数中的Continuation实例，并且在该函数中调用Continuation方法。 receive()方法用于接收数据，该方法返回接收到的数据，所以suspendCoroutine后的泛型写T 创建状态属性prev，调用state的getAndUpdate()方法，该方法使用给定函数的结果以原子方式更新当前值，并返回先前的值，该方法中的函数里的it即为当前状态，也就是更新之前的状态 添加when语句进行状态判断 若为Nil状态，则将state更新为ConsumerList状态，先以当前的coroutine为参数创建对象Consumer，再调用密封类ElementList的子类ConsumerList的offer()方法，将组合好的对象Consumer作为参数传进去 若为ProducerList状态，当前处于已发送待接收状态，此时可以接收生产者列表中的头元素，然后更新消费者列表去掉头元素，若去掉头元素后列表变为空，则将状态切换为Nil 若为ConsumerList状态，不切换状态，当前虽然是等待发送状态，但还可以继续添加消费者。先强转为ConsumerList状态，然后再调用ConsumerList的offer()方法，将以当前的coroutine为参数创建对象Consumer，再调用offer()方法，将对象Consumer放到消费者列表中 若为Closed状态，抛非法异常，关闭了就不能再接收了 若为其它状态，抛非法异常 切换完状态后，将prev判空强转为以Producer为元素的抽象类AbsElementList的子类列表，此时意味着已经在等待接收数据，之后每步都加非空判断，通过peek()方法取出生产者列表中的第一个生产者，因生产者不需要返回结果，所以调用该生产者的协程的resume()方法时传递的是Unit，之后调用当前continuation的resume()方法将发送过来的值传递进去来获取 重写函数close()： 创建存储状态的属性prev，调用state的getAndUpdate()方法，将state切换为closed状态，并将切换之前的状态值赋值给prev 判断切换之前的状态值：如果是ConsumerList状态或是ProducerList状态，通过prev的elements方法取到该状态中元素列表，使用foreach循环调用每个元素的continuation的resumeWithException()方法。也就是在关闭过程中管道还在发送或是接收数据，抛出异常管道已经关闭啦不要再用啦 定义函数blockingChannelSample()，用于非队列非阻塞式管道示例： 定义属性channel，赋值为QueueChannel类的实例，泛型传入Int 创建一个fori循环，循环下标n从0到5共执行6次，每次循环都会调用go()函数： go()函数第一个参数传入producer加上当前循环下标值 第二个参数不传 第三个参数传入一个挂起函数，挂起函数体为一个fori循环，循环下标i是从外层循环下标当前值n开始，到n+5结束，共执行6次，每次循环都打印信息，并通过调用channel.send()方法将内循环下标i值传递出去 调用go()函数： 第一个参数传入consumer 第二个参数传入匿名函数，函数中调用channel::close，该方法用于关闭管道，即接收完所有数据后调用该方法关闭管道 第三个参数传入一个挂起函数，挂起函数体为一个fori循环，从0到11执行12次，每次循环打印信息，并通过调用channel.receive()方法获取管道发送的值，之后打印该值 最后在main()入口函数中调用blockingChannelSample()方法 打印结果： 1234567891011121314151617181920212223242526272829303132333435363717:39:56:691 [DefaultDispatcher-worker-1] send 117:39:56:691 [DefaultDispatcher-worker-5] send 517:39:56:691 [DefaultDispatcher-worker-3] send 317:39:56:691 [DefaultDispatcher-worker-4] send 417:39:56:691 [DefaultDispatcher-worker-2] send 217:39:56:691 [DefaultDispatcher-worker-0] send 017:39:56:721 [DefaultDispatcher-worker-1] send 217:39:56:721 [DefaultDispatcher-worker-7] got 117:39:56:721 [DefaultDispatcher-worker-5] send 617:39:56:721 [DefaultDispatcher-worker-8] got 517:39:56:721 [DefaultDispatcher-worker-8] got 417:39:56:722 [DefaultDispatcher-worker-9] send 517:39:56:722 [DefaultDispatcher-worker-8] got 317:39:56:722 [DefaultDispatcher-worker-10] send 417:39:56:722 [DefaultDispatcher-worker-8] got 217:39:56:722 [DefaultDispatcher-worker-11] send 317:39:56:722 [DefaultDispatcher-worker-8] got 017:39:56:722 [DefaultDispatcher-worker-12] send 117:39:56:722 [DefaultDispatcher-worker-8] got 217:39:56:722 [DefaultDispatcher-worker-13] send 317:39:56:722 [DefaultDispatcher-worker-8] got 617:39:56:722 [DefaultDispatcher-worker-14] send 717:39:56:723 [DefaultDispatcher-worker-8] got 517:39:56:723 [DefaultDispatcher-worker-15] send 617:39:56:723 [DefaultDispatcher-worker-8] got 417:39:56:723 [DefaultDispatcher-worker-15] send 517:39:56:723 [DefaultDispatcher-worker-8] got 317:39:56:723 [DefaultDispatcher-worker-4] send 417:39:56:723 [DefaultDispatcher-worker-8] got 117:39:56:723 [DefaultDispatcher-worker-4] send 217:39:56:724 [DefaultDispatcher-worker-8] end consumer Success(kotlin.Unit)17:39:56:725 [DefaultDispatcher-worker-7] end producer 2 Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.)17:39:56:725 [DefaultDispatcher-worker-5] end producer 0 Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.)17:39:56:725 [DefaultDispatcher-worker-3] end producer 1 Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.)17:39:56:725 [DefaultDispatcher-worker-0] end producer 5 Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.)17:39:56:725 [DefaultDispatcher-worker-2] end producer 3 Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.)17:39:56:725 [DefaultDispatcher-worker-8] end producer 4 Failure(cn.ltt.projectcollection.kotlin.coroutinesLab.go.ClosedException: Channel is closed.) 打印结果说明： 因是多协程操作，每次运行的打印结果都不一样 最后在go()函数中，协程执行完毕后会打印信息，结果显示consumer协程成功结束，但是5个producer协程都是异常结束，之所以异常是因为consumer只循环了12次，且在最后一次循环后将管道关闭了，而有6个生产者且每个生产者发送了6条数据给consumer，而consumer只循环了12次，不能把各生产者发送的值都接收到，所以抛出异常，因此producer是异常结束，将consumer协程里的循环改为到35结束，即循环36次，将生产者们发送的值都接收到，如此生产者们就不会异常结束了 #八、 示例–仿Js实现async await 1234567891011121314151617181920212223242526272829303132333435363738interface AsyncScopesuspend fun &lt;T&gt; AsyncScope.await(block: () -&gt; Call&lt;T&gt;) = suspendCoroutine&lt;T&gt; { continuation -&gt; val call = block() call.enqueue(object : Callback&lt;T&gt;{ override fun onFailure(call: Call&lt;T&gt;, t: Throwable) { continuation.resumeWithException(t) } override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) { if(response.isSuccessful){ response.body()?.let(continuation::resume) ?: continuation.resumeWithException(NullPointerException()) } else { continuation.resumeWithException(HttpException(response)) } } })}fun async(context: CoroutineContext = EmptyCoroutineContext, block: suspend AsyncScope.() -&gt; Unit) { val completion = AsyncCoroutine(context) block.startCoroutine(completion, completion)}class AsyncCoroutine(override val context: CoroutineContext = EmptyCoroutineContext): Continuation&lt;Unit&gt;, AsyncScope { override fun resumeWith(result: Result&lt;Unit&gt;) { result.getOrThrow() }}fun main() { async() { val user = await { githubApi.getUserCallback(&quot;puppet16&quot;) } log(user) }} 打印结果： 12request: 20019:39:56:395 [OkHttp https://api.github.com/...] User(id=14159272, name=Puppet16, url=https://api.github.com/users/puppet16) 说明： js的async await的详细内容可以看前面讲到的async/await关键字 定义一个接口AsyncScope，用于约束async()、await()这两个函数的使用范围 创建类AsyncCoroutine，实现接口Continuation和接口AsyncScope： 重写ConroutineContext类型的context，默认值为EmptyCoroutinContext 重写resumeWith()方法，在该方法中如果结果有异常则抛出异常 定义函数async()： 第一个入参是CoroutineContext类型的变量context，它的默认值是EmptyCoroutineContext 第二个入参是挂起函数的lambda表达式block，必须是限制必须是AsyncScope的扩展函数 创建名为completion的AsyncCoroutine类的实例，将context传入其中 之后调用startCoroutine()启动block协程，该方法需要的receiver和协程结束时调用的completion都传入上一步创建的completion 定义挂起函数await()，该函数传入一个lambda表达式，该表达式没有入参、出参是一个Call对象。之后通过suspendCoroutine函数获取当前挂起函数中的Continuation实例 创建属性call，用于保存block()返回的结果 调用call的异步请求方法enqueue()，该方法需要有一个Callback类对象，因此使用 object:关键字创建Callback类的匿名内部对象，之后重写该类中方法 在onFailure()方法中通过resumeWithException()方法给协程抛出异常 在onResponse()方法中，先判断网络请求是否成功，若未成功则抛出异常；若成功则取response的body对象，若有body对象则通过函数引用，直接调用协程的resume()方法；若没有body对象则调用resumeWithException()方法抛出空指针异常 由此async本身没有异步的能力，异步是由call的enqueue()方法提供的 #九、延伸–揭秘 suspend fun main #1. 普通的main函数 123fun main(args: Array&lt;String&gt;) { ...} 自Kotlin 1.3之后可省略参数 1234//since kotlin 1.3fun main() { ...} #2. 可挂起的main函数 123suspend fun main() { ...} 挂起main函数看起来函数类型为：suspend () -&gt; Unit。但其实该函数传入了一个Continuation，并且返回了一个Any?，即实际上类型为(Continuation&lt;Unit&gt;) -&gt; Any?，本质上挂起main函数为如下样式： 123fun main(continuation: Continuation&lt;Unit&gt;): Any? { ...} 而定义为如上形式也就不是入口函数了，可以使用runSuspend()方法运行如上形式函数： 1234567fun main1(continuation: Continuation&lt;Unit&gt;): Any? { return Unit;}fun main() { runSuspend(::main1 as suspend () -&gt; Unit)} 123456789101112131415161718192021222324252627282930313233343536373839404142package kotlin.coroutines.jvm.internalimport kotlin.coroutines.Continuationimport kotlin.coroutines.CoroutineContextimport kotlin.coroutines.EmptyCoroutineContextimport kotlin.coroutines.startCoroutine/** * Wrapper for `suspend fun main` and `@Test suspend fun testXXX` functions. */@SinceKotlin(&quot;1.3&quot;)internal fun runSuspend(block: suspend () -&gt; Unit) { val run = RunSuspend() block.startCoroutine(run) run.await()}private class RunSuspend : Continuation&lt;Unit&gt; { override val context: CoroutineContext get() = EmptyCoroutineContext var result: Result&lt;Unit&gt;? = null override fun resumeWith(result: Result&lt;Unit&gt;) = synchronized(this) { this.result = result @Suppress(&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;) (this as Object).notifyAll() } fun await() = synchronized(this) { while (true) { when (val result = this.result) { null -&gt; @Suppress(&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;) (this as Object).wait() else -&gt; { result.getOrThrow() // throw up failure return } } } }} 说明： 在入口main()函数中使用runSuspend()方法运行main1()方法，其中将main1()函数类型引用强转为suspend () -&gt; Unit 函数runSuspend()是标准库中的源码函数，该函数被internal，没办法直接调用，因此直接将该函数代码从源码中提取出来 runSuspend()函数，入参为标准的无参返回值为Unit的挂起函数block，在函数体中创建RunSuspend类的对象run，调用block的startCoroutine()方法开启协程，并将run作为completion传递进去，最后再调用await()方法 RunSuspend类实现接口Continuation: context为EmptyCoroutineContext 定义结果属性result，设置初始值为null，Result作为特殊类型，编译器不允许它作为返回值的类型，而声明为var的属性有getter，所以该行会报错：'kotlin.Result' cannot be used as a return type。 而要解决该报错，只需要在module的build.gradle文件中kotlinOptions中配置如下代码：freeCompilerArgs = [&quot;-Xallow-result-return-type&quot;]，如下图所示： 重写resumeWith()方法，将协程返回的结果赋值给属性result 定义await()方法，添加synchronized关键字保证线程安全，添加一个while死循环，在循环体内判断如果result为null，则调用object的wait()方法继续等待；而如果result不为null，则直接将其取到并返回 wait()、notify/notifyAll()方法延伸： wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁 当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。 也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁 wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒 notify 和wait 的顺序不能错，如果 A 线程先执行notify方法，B 线程在执行wait方法，那么 B 线程是无法被唤醒的 notify 和 notifyAll的区别： notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现 notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法 如果先调用的resumeWith()，再调用的await()，则result值不会为null，则会在await()方法中将result值抛出去；如果先调用await()，再调用resumeWith()，此时result值为null，会调用wait方法，将线程阻塞在这里，直到其它线程调用了resumeWith()方法，并在该方法中调用了notifyAll,将刚才阻塞的线程唤醒，又执行了一次循环，此时result不为null，如此将result值抛出去 #十、参考文章 kotlin协程的挂起suspend Kotlin协程简介 Kotlin协程-协程的内部概念Continuation AtomicReference源码详解 #二、示例–仿官方框架实现launch #1. 协程回顾 #1. 协程创建 协程是一段可执行的程序 协程的创建通常 需要一个函数，即 suspend function 协程的创建也需要一个API，即createCoroutine：只创建不执行、startCoroutine：创建后执行 #2. 协程启动 12345678suspend { ...}.startCoroutine(object:Continuation&lt;Unit&gt;) { override val context = EmptyCoroutineContext override fun resumeWith(result: Result&lt;Unit&gt;) { prinln(&quot;Coroutine End with $result&quot;) }} 说明： 使用startCoroutine协程创建后会被立即执行 suspend function在编译完成之后会被包装成一个continuation，这个continuation即为协程的本体，协程挂起恢复调用resume()时也是调用这个continuation的resume() startCoroutine()方法中传入形参名为completion的continuation, 在协程执行完成后会调用该continuation的resumeWith()方法","link":"/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/"},{"title":"源码系列一：App启动过程","text":"一、前言 二、 Launcher解析 1. Launcher#onClick() 2. Launcher#startAppShortcutOrInfoActivity() 3. Launcher#startActivitySafely() 4. Activity#startActivity() 5. Activity#startActivityForResult() 6. Instrumentation#execStartActivity() 7. ActivityManager#getService() (1). 其中Context.ACTIVITY_SERVICE常量值为activity (2). ServiceManager#getService() (3). ServiceManagerNative#asInterface(IBinder) (4). ServiceManagerProxy#getService() (5). IActivityManager.Stub.asInterface(b) 8. ActivityManagerService#startActivityAsUser() 9. ActivityStarter#startActivityMayWait() 10. ActivityStarter#startActivityUnchecked() 11. ActivityStackSupervisor#resumeFocusedStackTopActivityLocked() 12. ActivityStack#resumeTopActivityUncheckedLocked() 13. ActivityStackSupervisor#startSpecificActivityLocked() 14. ActivityManagerService#startProcessLocked() 15. Process#start() 16. ZygoteProcess#start() 17. ZygoteInit#main() 18. ZygoteServer#runSelectLoop() 19. ZygoteConnection#runOnce() 20. ZygoteConnection#handleChildProc() 21. ZygoteInit#zygoteInit() 22. RuntimeInit.applicationInit() 23. RuntimeInit.Arguments#parseArgs() 附录 #一、前言 本文主要讲述App启动过程 源码基于 Android API 28，即Oreo 8.0.0_r4 在线查看源码建议使用：http://androidxref.com/ 官方源码网站：https://android.googlesource.com/ 源码系列文章： 源码系列二：ActivityThread的理解 源码系列三：View被添加到屏幕窗口上的源码流程 源码系列四：事件分发机制 #二、 Launcher解析 Android手机开机解锁后会进入到桌面，而桌面也是一个App，名为Launcher，用户平常使用的应用都是通过点击这里面的图标打开的。源码位于：/ packages/apps/，该目录下存放一些系统应用，如电话、蓝牙、图库、日历等。如下图： 可以看到Launcher程序有两个：Launcher2和Launcher3。 Launcher 使用版本 Launcher2 Android2.2到Android4.4(含) Launcher3 Android4.4以上 查看Launcher3中的Androidmanifest.xml代码如下： 1234567891011121314151617181920212223&lt;!--/packages/apps/Launcher3/AndroidManifest.xml--&gt;&lt;!--Main launcher activity. When extending only change the name, and keep all the attributes and intent filters the same--&gt;&lt;activity android:name=&quot;com.android.launcher3.Launcher&quot; android:launchMode=&quot;singleTask&quot; android:clearTaskOnLaunch=&quot;true&quot; android:stateNotNeeded=&quot;true&quot; android:windowSoftInputMode=&quot;adjustPan&quot; android:screenOrientation=&quot;nosensor&quot; android:configChanges=&quot;keyboard|keyboardHidden|navigation&quot; android:resizeableActivity=&quot;true&quot; android:resumeWhilePausing=&quot;true&quot; android:taskAffinity=&quot;&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.MONKEY&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER_APP&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; #1. Launcher#onClick() 可以看到主页面是com.android.launcher3.Launcher，这是一个Activity。 1234567891011121314151617181920212223242526272829303132333435// /packages/apps/Launcher3/src/com/android/launcher3/Launcher.javapackage com.android.launcher3;...public class Launcher extends BaseActivity implements ... { ... /** * Launches the intent referred by the clicked shortcut. * @param v The view representing the clicked shortcut. */ public void onClick(View v) { // Make sure that rogue clicks don't get through while allapps is launching, or after the // view has detached (it's possible for this to happen if the view is removed mid touch). if (v.getWindowToken() == null) { return; } ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) { onClickAppShortcut(v); } else if (tag instanceof FolderInfo) { if (v instanceof FolderIcon) { onClickFolderIcon(v); } } else if ((v instanceof PageIndicator) || (v == mAllAppsButton &amp;&amp; mAllAppsButton != null)) { onClickAllAppsButton(v); } else if (tag instanceof AppInfo) { startAppShortcutOrInfoActivity(v); } else if (tag instanceof LauncherAppWidgetInfo) { if (v instanceof PendingAppWidgetHostView) { onClickPendingWidget((PendingAppWidgetHostView) v); } } }} #2. Launcher#startAppShortcutOrInfoActivity() 继续追踪Launcher#startAppShortcutOrInfoActivity(v),其关键代码如下： 1234567891011121314151617181920212223public class Launcher extends BaseActivity implements ... { ... private void startAppShortcutOrInfoActivity(View v) { ItemInfo item = (ItemInfo) v.getTag(); Intent intent; if (item instanceof PromiseAppInfo) { PromiseAppInfo promiseAppInfo = (PromiseAppInfo) item; intent = promiseAppInfo.getMarketIntent(); } else { intent = item.getIntent(); } if (intent == null) { throw new IllegalArgumentException(&quot;Input must have a valid intent&quot;); } boolean success = startActivitySafely(v, intent, item); getUserEventDispatcher().logAppLaunch(v, intent); // TODO for discovered apps b/35802115 if (success &amp;&amp; v instanceof BubbleTextView) { mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); } }} 首先通过view的Tag获取intent，然后调用Launcher#startActivitySafely(v, intent, item)方法， #3. Launcher#startActivitySafely() 代码如下： 12345678910111213141516171819202122232425262728293031public class Launcher extends BaseActivity implements ... { ... public boolean startActivitySafely(View v, Intent intent, ItemInfo item) { ... // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); Bundle optsBundle = useLaunchAnimation ? getActivityLaunchOptions(v) : null; UserHandle user = item == null ? null : item.user; // Prepare intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ... try { if (...) { ... //如果user为空，或者user是Launcher所在的用户 } else if (user == null || user.equals(Process.myUserHandle())) { // Could be launching some bookkeeping activity startActivity(intent, optsBundle); } else { LauncherAppsCompat.getInstance(this).startActivityForProfile( intent.getComponent(), user, intent.getSourceBounds(), optsBundle); } return true; } catch (ActivityNotFoundException|SecurityException e) { ... } return false; }} 其中，处理启动动画，以及对用户的管理，然后给intent添加了一个Intent.FLAG_ACTIVITY_NEW_TASK的flag，然后调用了Activity#startActivity(intent, optsBundle)方法，这时我们就进入了Framework。 #4. Activity#startActivity() 123456789101112131415package android.app;// /frameworks/base/core/java/android/app/Activity.java...public class Activity extends ContextThemeWrapper implements ... { ... public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } }} 接着会调用Activity#startActivityForResult(Intent, int, Bundle) #5. Activity#startActivityForResult() 1234567891011121314151617181920public class Activity extends ContextThemeWrapper implements ... { ... public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } ... } ... }} 其中，有个mInstrumentation成员变量，并调用了它的execStartActivity方法，还有一个mMainThread变量，这应该就是APP的主线程，这两个变量在Activity#attach(...)里初始化，代码如下： 123456789101112131415public class Activity extends ContextThemeWrapper implements ... { ... final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) { ... mMainThread = aThread; mInstrumentation = instr; ... }} 可以看到这几个变量是在调用Activity#attach(...)方法时传入进来的。 Activity#startActivityForResult(Intent, int, Bundle)方法内先获取了一个Instrumentation.ActivityResult实例，并调用了 ActivityThread#sendActivityResult方法。追踪Instrumentation#execStartActivity()方法。 注意： 在Instrumentation类中，execStartActivity函数有两个，其中一个在注释中表示是让Fragment调用的。 #6. Instrumentation#execStartActivity() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package android.app;// /frameworks/base/core/java/android/app/Instrumentation.javapublic class Instrumentation { /** * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)}, * but for starting as a particular user. * ... */ public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String resultWho, Intent intent, int requestCode, Bundle options, UserHandle user) { IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) { result = am.onStartActivity(intent); } if (result != null) { am.mHits++; return result; } else if (am.match(who, null, intent)) { am.mHits++; if (am.isBlocking()) { return requestCode &gt;= 0 ? am.getResult() : null; } break; } } } } try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService() .startActivityAsUser(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, resultWho, requestCode, 0, null, options, user.getIdentifier()); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 其中，mActivityMonitors变量是在Instrumentation中维护一的个列表，在一个Activity已经started，该列表会添加一个ActivityMonitor。真正的启动在下方的try-catch中，接着追踪ActivityManager.getService().startActivityAsUser()方法 #7. ActivityManager#getService() 12345678910111213141516171819202122package android.app;//frameworks/base/core/java/android/app/ActivityManager.java@SystemService(Context.ACTIVITY_SERVICE)public class ActivityManager { ... public static IActivityManager getService() { return IActivityManagerSingleton.get(); } private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; ...} #(1). 其中Context.ACTIVITY_SERVICE常量值为activity 源码如下 12345678910111213141516package android.content;///frameworks/base/core/java/android/content/Context.javapublic abstract class Context { ... /** * Use with {@link #getSystemService} to retrieve a * {@link android.app.ActivityManager} for interacting with the global * system state. * * @see #getSystemService * @see android.app.ActivityManager */ public static final String ACTIVITY_SERVICE = &quot;activity&quot;; ...} #(2). ServiceManager#getService() 1234567891011121314151617181920212223242526272829303132333435package android.os;///frameworks/base/core/java/android/os/ServiceManager.javapublic final class ServiceManager { private static final String TAG = &quot;ServiceManager&quot;; private static IServiceManager sServiceManager; private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;(); private static IServiceManager getIServiceManager() { if (sServiceManager != null) { return sServiceManager; } // Find the service manager sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; } public static IBinder getService(String name) { try { IBinder service = sCache.get(name); if (service != null) { return service; } else { return Binder.allowBlocking(getIServiceManager().getService(name)); } } catch (RemoteException e) { Log.e(TAG, &quot;error in getService&quot;, e); } return null; } ...} 这个ServiceManager就是方便调用和管理实例的，其中sServiceManager的实例化又是通过ServiceManagerNative完成，这里asInterface的参数通过BinderInternal.getContextObject()给出，它是一个native方法，源码如下： 123456789///frameworks/base/core/java/com/android/internal/os/BinderInternal.java /** * Return the global &quot;context object&quot; of the system. This is usually * an implementation of IServiceManager, which you can use to find * other services. */public static final native IBinder getContextObject(); 该方法为native方法，它的作用是用来获取Service的。然后追踪ServiceManagerNative#asInterface(IBinder)方法。 #(3). ServiceManagerNative#asInterface(IBinder) 1234567891011121314151617181920212223package android.os;///frameworks/base/core/java/android/os/ServiceManagerNative.javapublic abstract class ServiceManagerNative extends Binder implements IServiceManager{ /** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */ static public IServiceManager asInterface(IBinder obj) { if (obj == null) { return null; } IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ServiceManagerProxy(obj); } ...} 最后返回的是一个ServiceManagerProxy对象。即第2小节中sServiceManager为ServiceManagerProxy，也就是说 ServiceManager#getService()调用的是ServiceManagerProxy#getService() #(4). ServiceManagerProxy#getService() 1234567891011121314151617181920212223package android.os;///frameworks/base/core/java/android/os/ServiceManagerNative.javaclass ServiceManagerProxy implements IServiceManager { public ServiceManagerProxy(IBinder remote) { mRemote = remote; } public IBinder asBinder() { return mRemote; } public IBinder getService(String name) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; }} 最后返回的是BinderProxy。也就是说第7节中通过ServiceManager.getService(&quot;activity&quot;)得到的就是BinderProxy。接着追踪final IActivityManager am = IActivityManager.Stub.asInterface(b); #(5). IActivityManager.Stub.asInterface(b) IActivityManager在这个版本中写成了一个AIDL文件，源码地址：frameworks/base/core/java/android/app/IActivityManager.aidl asInterface的作用是根据调用是否属于同进程而返回不同的实例对象。 IxxxxService.Stub.asInterface(IBinder obj)语句： 平常可以利用Binder引用作为参数实例化出一个 IxxxxService.Proxy。但如果服务端和客户端都是在同一个进程时不需要利用IPC，直接将IxxxxService当做普通的对象调用就成了。IxxxxService.Stub.asInterface函数对这两种不同的情况进行了统一，也就是不管你是在同一进程还是不同进程，那么在拿到Binder引用后，调用IxxxxService.Stub.asInterface(IBinder obj)即可得到一个IxxxxService实例，然后你只管调用IxxxxService里的函数就可以。 所以，IActivityManager.Stub.asInterface(b)返回了一个 ActivityManagerService 对象 #8. ActivityManagerService#startActivityAsUser() 12345678910111213141516171819202122package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback { ... @Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); // 拿到用户的userId userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null, &quot;startActivityAsUser&quot;); } ...} mActivityStarter是在ActivityManagerService实例化时就被初始化了，继续追踪它的startActivityMayWait方法 #9. ActivityStarter#startActivityMayWait() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityStarter.javaclass ActivityStarter { final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason) { ... synchronized (mService) { ... int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason); ... return res; } } int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason) { ... mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, inTask); ... // Aborted results are treated as successes externally, but we must track them internally. return mLastStartActivityResult != START_ABORTED ? mLastStartActivityResult : START_SUCCESS; } /** DO NOT call this method directly. Use {@link #startActivityLocked} instead. */ private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask) { ... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity); } private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { int result = START_CANCELED; try { mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); } finally { // If we are not able to proceed, disassociate the activity from the task. Leaving an // activity in an incomplete state can lead to issues, such as performing operations // without a window container. if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; mStartActivity.getTask() != null) { mStartActivity.getTask().removeActivity(mStartActivity); } mService.mWindowManager.continueSurfaceLayout(); } postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId, mSourceRecord, mTargetStack); return result; }} 从startActivityMayWait开始，到startActivityLocked，再到startActivity,再到startActivity，最后再调用startActivityUnchecked方法。 #10. ActivityStarter#startActivityUnchecked() 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityStarter.javaclass ActivityStarter { // Note: This method should only be called from {@link startActivity}. private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { ... mIntent.setFlags(mLaunchFlags); ... //处理和ActivityStack相关的操作 mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions); if (mDoResume) { ... if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) { // If the activity is not focusable, we can't resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don't want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. ... } else { // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) { mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); } mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); } } else { mTargetStack.addRecentActivityLocked(mStartActivity); } ... return START_SUCCESS; }} mSupervisor是在ActivityStarter实例化时传入进来的，实例化是在ActivityManagerService中完成。 #11. ActivityStackSupervisor#resumeFocusedStackTopActivityLocked() 12345678910111213package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.javapublic class ActivityStackSupervisor extends ConfigurationContainer implements DisplayListener { boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) { if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) { return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); } ... return false; }} #12. ActivityStack#resumeTopActivityUncheckedLocked() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityStack.javaclass ActivityStack&lt;T extends StackWindowController&gt; extends ConfigurationContainer implements StackWindowListener { boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); } finally { mStackSupervisor.inResumeTopActivity = false; } ... } private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { ... // If the flag RESUME_WHILE_PAUSING is set, then continue to schedule the previous activity // to be paused, while at the same time resuming the new resume activity only if the // previous activity can't go into Pip since we want to give Pip activities a chance to // enter Pip before resuming the next activity. final boolean resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0 &amp;&amp; !lastResumedCanPip; // 在这里，把所有其他的Activity都Pause掉 boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false); ... ActivityStack lastStack = mStackSupervisor.getLastStack(); // 进程已经被创建会走这里 if (next.app != null &amp;&amp; next.app.thread != null) { ... } else { ... mStackSupervisor.startSpecificActivityLocked(next, true, true); } if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true; }} 启动新Activity前，会先将原有的Activity pause 掉，这样做可以释放很多资源。启动Activity的工作交给了mStackSupervisor来处理 #13. ActivityStackSupervisor#startSpecificActivityLocked() 12345678910111213141516171819202122232425262728293031323334353637package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.javapublic class ActivityStackSupervisor extends ConfigurationContainer implements DisplayListener { void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.getStack().setLaunchTime(r); //只有app创建好之后才会走这个if分支 if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) { // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); } //启动Activity，并返回 realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. } // APP还未创建会走这里，通过AMS开启进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); }} 如果APP已经创建好会直接走realStartActivityLocked方法，追踪开启进程方法。 #14. ActivityManagerService#startProcessLocked() 123456789101112131415package com.android.server.am;///frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback { final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); }} startProcessLocked调用多次重载方法，最终会调用如下方法： 1234567891011121314151617181920212223242526272829///frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) { ... // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; + app.processName); checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); ProcessStartResult startResult; if (hostingType.equals(&quot;webview_service&quot;)) { startResult = startWebView(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs); } else { startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs); } checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); ... } 可以看到，通过Process#start方法创建需要的进程,Android所有进程起源于Zygote,Process类只是对Zygote的包装。 #15. Process#start() 12345678910111213141516171819202122package android.os;///frameworks/base/core/java/android/os/Process.javapublic class Process { public static final ZygoteProcess zygoteProcess = new ZygoteProcess(ZYGOTE_SOCKET, SECONDARY_ZYGOTE_SOCKET); ... public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) { return zygoteProcess.start(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs); }} #16. ZygoteProcess#start() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package android.os;///frameworks/base/core/java/android/os/ZygoteProcess.javapublic class ZygoteProcess { public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] extraArgs) throws ZygoteStartFailedEx { ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(&quot;--runtime-args&quot;); argsForZygote.add(&quot;--setuid=&quot; + uid); argsForZygote.add(&quot;--setgid=&quot; + gid); ... argsForZygote.add(processClass); ... synchronized(mLock) { return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); } } private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx { Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;); if (primaryZygoteState == null || primaryZygoteState.isClosed()) { try { primaryZygoteState = ZygoteState.connect(mSocket); } catch (IOException ioe) { throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe); } } if (primaryZygoteState.matches(abi)) { return primaryZygoteState; } // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) { try { secondaryZygoteState = ZygoteState.connect(mSecondarySocket); } catch (IOException ioe) { throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe); } } if (secondaryZygoteState.matches(abi)) { return secondaryZygoteState; } throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi); } private static Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { // Throw early if any of the arguments are malformed. This means we can // avoid writing a partial response to the zygote. int sz = args.size(); for (int i = 0; i &lt; sz; i++) { if (args.get(i).indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;); } } /** * See com.android.internal.os.SystemZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? Process.ProcessStartResult result = new Process.ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } }} zygoteProcess#start调用zygoteProcess#startViaZygote。startViaZygote中通过socket与zygote通信，启动app进程，zygoteSendArgsAndGetResult方法返回app进程的pid。 接下来追踪argsForZygote中的参数在哪里解析，在zygoteSendArgsAndGetResult中注释在com.android.internal.os.SystemZygoteInit.readArgumentList()解析。但是 找不到SystemZygoteInit 这个类！ 其中传递的参数argsForZygote中有固定值runtime-args等，全局搜索后在在 ZygoteInit.java 和 ZygoteConnection.java 中发现了这些参数。 #17. ZygoteInit#main() 1234567891011121314151617181920212223package com.android.internal.os;///frameworks/base/core/java/com/android/internal/os/ZygoteInit.javapublic class ZygoteInit { ... public static void main(String argv[]) { ZygoteServer zygoteServer = new ZygoteServer(); ... try { ... zygoteServer.registerServerSocket(socketName); // The select loop returns early in the child process after a fork and // loops forever in the zygote. caller = zygoteServer.runSelectLoop(abiList); } catch (Throwable ex) { Log.e(TAG, &quot;System zygote died with exception&quot;, ex); throw ex; } finally { zygoteServer.closeServerSocket(); } ... }} ZygoteInit是zygote进程启动类，main方法中创建了ZygoteServer。由ZygoteServer监听Socket请求，并执行相应的命令。 #18. ZygoteServer#runSelectLoop() 12345678910111213141516171819202122232425262728package com.android.internal.os;///frameworks/base/core/java/com/android/internal/os/ZygoteServer.javaclass ZygoteServer { ... void runSelectLoop(String abiList) throws Zygote.MethodAndArgsCaller { ... while (true) { ... for (int i = pollFds.length - 1; i &gt;= 0; --i) { if ((pollFds[i].revents &amp; POLLIN) == 0) { continue; } if (i == 0) { ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); } else { boolean done = peers.get(i).runOnce(this); if (done) { peers.remove(i); fds.remove(i); } } } } }} 当有一个连接时，就会执行else语句，调用ZygoteConnection#runOnce()方法 #19. ZygoteConnection#runOnce() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.android.internal.os;///frameworks/base/core/java/com/android/internal/os/ZygoteConnection.javaclass ZygoteConnection {boolean runOnce(ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller { ... try { args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); } catch (IOException ex) { ... } ... int pid = -1; ... try { ... parsedArgs = new Arguments(args); pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet, parsedArgs.appDataDir); } catch (...) { ... } try { if (pid == 0) { // in child zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw Zygote.MethodAndArgsCaller or exec(). return true; } else { // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); } } finally { IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); } }} 其中，readArgumentList()方法读取参数，创建Arguments对象时，在Arguments#parseArgs方法中解析参数。将解析后的参数传入Zygote#forkAndSpecialize创建子进程。 这里执行完forkAndSpecialize后，在 子进程（pid=0） 中，执行handleChildProc进行子进程初始化。 #20. ZygoteConnection#handleChildProc() 1234567891011121314151617181920package com.android.internal.os;///frameworks/base/core/java/com/android/internal/os/ZygoteConnection.javaclass ZygoteConnection { private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws Zygote.MethodAndArgsCaller { closeSocket(); ... if (parsedArgs.invokeWith != null) { WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); } else { ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); } }} invokeWith是socket参数&quot;--invoke-with&quot;，在ActivityManagerService的startProcessLocked中赋值，只有在debug的情况下才!=null。 #21. ZygoteInit#zygoteInit() 1234567891011121314151617package com.android.internal.os;///frameworks/base/core/java/com/android/internal/os/ZygoteInit.javapublic class ZygoteInit { public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) { if (RuntimeInit.DEBUG) { Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;); } Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;); RuntimeInit.redirectLogStreams(); RuntimeInit.commonInit(); ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); }} zygoteInit中执行RuntimeInit.applicationInit #22. RuntimeInit.applicationInit() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.android.internal.os;///frameworks/base/core/java/com/android/internal/os/RuntimeInit.javapublic class RuntimeInit { protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) { // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true); // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args = new Arguments(argv); // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // Remaining arguments are passed to the start class's static main return findStaticMain(args.startClass, args.startArgs, classLoader); } private static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class&lt;?&gt; cl; try { cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( &quot;Missing class when invoking static main &quot; + className, ex); } Method m; try { m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class }); } catch (NoSuchMethodException ex) { throw new RuntimeException( &quot;Missing static main on &quot; + className, ex); } catch (SecurityException ex) { throw new RuntimeException( &quot;Problem getting static main on &quot; + className, ex); } int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( &quot;Main method is not public and static on &quot; + className); } /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv); } static class MethodAndArgsCaller implements Runnable { /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) { mMethod = method; mArgs = args; } public void run() { try { mMethod.invoke(null, new Object[] { mArgs }); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) { throw (RuntimeException) cause; } else if (cause instanceof Error) { throw (Error) cause; } throw new RuntimeException(ex); } } }} zygoteInit中执行RuntimeInit.applicationInit，applicationInit调用findStaticMain，findStaticMain调用MethodAndArgsCaller，反射执行的main方法。 那么这个main方法是哪个类的呢？我们需要反向查看之前的代码，在RuntimeInit#findStaticMain方法中传入的第一个参数就是className，而这个参数是通过args.startClass获取的，相应的代码在RuntimeInit#applicationInit中。这个args是把传进来的String[] argv转成了Arguments变量，我们看下这个Arguments，它是RuntimeInit的静态内部类。 #23. RuntimeInit.Arguments#parseArgs() 123456789101112131415161718192021222324252627282930313233package com.android.internal.os;public class RuntimeInit { static class Arguments { String startClass; String[] startArgs; Arguments(String args[]) throws IllegalArgumentException { parseArgs(args); } private void parseArgs(String args[]) throws IllegalArgumentException { int curArg = 0; for (; curArg &lt; args.length; curArg++) { String arg = args[curArg]; if (arg.equals(&quot;--&quot;)) { curArg++; break; } else if (!arg.startsWith(&quot;--&quot;)) { break; } } if (curArg == args.length) { throw new IllegalArgumentException(&quot;Missing classname argument to RuntimeInit!&quot;; } startClass = args[curArg++]; startArgs = new String[args.length - curArg]; System.arraycopy(args, curArg, startArgs, 0, startArgs.length); } }} 可以看到startClass是args里最后一个值。而args是在ZygoteProcess#startViaZygote方法中创建，它在添加了一些–xxx的字段之后，最后还通过语句argsForZygote.add(processClass);添加了processClass值，而这个值是作为参数传递了过来。最终追踪到第14节ActivityManagerService#startProcessLocked中有如下代码 12345678910package com.android.server.am;public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback { private final void startProcessLocked(...) { ... if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;; ... }} 由此可见Zygote孵化完成之后，会 invoke ActivityThread#main 方法。接下来进程创建完毕，就该是我们APP的初始化了。 总结其流程如下图： 参考文章： 1. https://www.jianshu.com/p/6885b4558ba2 2. https://juejin.im/post/5c6d0161f265da2dbc598603#heading-4 #附录 Activity.java http://androidxref.com/ ActivityManager.java http://androidxref.com/ Launcher.java http://androidxref.com/ Instrumentation.java：androidxref.com Context.java http://androidxref.com/ ServiceManager.java http://androidxref.com/ ServiceManagerNative.java http://androidxref.com/ ActivityManagerService.java http://androidxref.com/ ActivityStarter.java http://androidxref.com/ ActivityStackSupervisor.java http://androidxref.com/ ActivityStack.java http://androidxref.com/ Process.java http://androidxref.com/ ZygoteProcess.java http://androidxref.com/ ZygoteInit.java http://androidxref.com/ ZygoteServer.java http://androidxref.com/ ZygoteConnection.java http://androidxref.com/ RuntimeInit.java http://androidxref.com/","link":"/2020/06/16/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B8%80/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"FFmpeg","slug":"FFmpeg","link":"/tags/FFmpeg/"},{"name":"JNI","slug":"JNI","link":"/tags/JNI/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"编程规范","slug":"编程规范","link":"/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"name":"Jetpack Compose","slug":"Jetpack-Compose","link":"/tags/Jetpack-Compose/"},{"name":"Effect","slug":"Effect","link":"/tags/Effect/"},{"name":"Animation","slug":"Animation","link":"/tags/Animation/"},{"name":"State","slug":"State","link":"/tags/State/"},{"name":"状态订阅","slug":"状态订阅","link":"/tags/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85/"},{"name":"自动更新","slug":"自动更新","link":"/tags/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"传统 View 迁移","slug":"传统-View-迁移","link":"/tags/%E4%BC%A0%E7%BB%9F-View-%E8%BF%81%E7%A7%BB/"},{"name":"MediaPlayer","slug":"MediaPlayer","link":"/tags/MediaPlayer/"},{"name":"MotionLayout","slug":"MotionLayout","link":"/tags/MotionLayout/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","link":"/tags/ConstraintLayout/"},{"name":"Animate","slug":"Animate","link":"/tags/Animate/"},{"name":"Android Library","slug":"Android-Library","link":"/tags/Android-Library/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"类型","slug":"类型","link":"/tags/%E7%B1%BB%E5%9E%8B/"},{"name":"协程","slug":"协程","link":"/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"},{"name":"表达式","slug":"表达式","link":"/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"集合操作符","slug":"集合操作符","link":"/tags/%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"name":"协程源码结构","slug":"协程源码结构","link":"/tags/%E5%8D%8F%E7%A8%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"},{"name":"Channel","slug":"Channel","link":"/tags/Channel/"},{"name":"Flow","slug":"Flow","link":"/tags/Flow/"},{"name":"Job","slug":"Job","link":"/tags/Job/"},{"name":"Deferred","slug":"Deferred","link":"/tags/Deferred/"},{"name":"CoroutineContext","slug":"CoroutineContext","link":"/tags/CoroutineContext/"},{"name":"Dispatchers","slug":"Dispatchers","link":"/tags/Dispatchers/"},{"name":"CoroutineScope","slug":"CoroutineScope","link":"/tags/CoroutineScope/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"异常原因及处理","slug":"异常原因及处理","link":"/tags/%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%A4%84%E7%90%86/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"挂起函数","slug":"挂起函数","link":"/tags/%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0/"},{"name":"launch","slug":"launch","link":"/tags/launch/"},{"name":"协程基础元素","slug":"协程基础元素","link":"/tags/%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%85%83%E7%B4%A0/"},{"name":"PhoneWindow","slug":"PhoneWindow","link":"/tags/PhoneWindow/"},{"name":"小米","slug":"小米","link":"/tags/%E5%B0%8F%E7%B1%B3/"},{"name":"Lineageos","slug":"Lineageos","link":"/tags/Lineageos/"},{"name":"ActivityThread","slug":"ActivityThread","link":"/tags/ActivityThread/"},{"name":"ViewGroup","slug":"ViewGroup","link":"/tags/ViewGroup/"},{"name":"MotionEvent","slug":"MotionEvent","link":"/tags/MotionEvent/"},{"name":"dispatch","slug":"dispatch","link":"/tags/dispatch/"},{"name":"Launcher","slug":"Launcher","link":"/tags/Launcher/"}],"categories":[]}