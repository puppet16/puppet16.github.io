<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>Kotlin学习系列四：函数进阶 · Puppet</title><meta name="description" content="一、前言
二、高阶函数

1. 高阶函数定义
2. 常见的高阶函数

1. forEach函数
2. map函数


3. 高阶函数调用

1. 传递函数引用
2. 使用表达式
3. 高阶函数示例




三、内联函数

1. 定义
2. 高阶函数更适合定义为内联函数
3. 内联高阶函数的retur"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Kotlin学习系列四：函数进阶</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">二、高阶函数</a>
<ul>
<li><a href="#1-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">1. 高阶函数定义</a></li>
<li><a href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">2. 常见的高阶函数</a>
<ul>
<li><a href="#1-foreach%E5%87%BD%E6%95%B0">1. <code>forEach</code>函数</a></li>
<li><a href="#2-map%E5%87%BD%E6%95%B0">2. <code>map</code>函数</a></li>
</ul>
</li>
<li><a href="#3-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">3. 高阶函数调用</a>
<ul>
<li><a href="#1-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8">1. 传递函数引用</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">2. 使用表达式</a></li>
<li><a href="#3-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B">3. 高阶函数示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">三、内联函数</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89">1. 定义</a></li>
<li><a href="#2-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">2. 高阶函数更适合定义为内联函数</a></li>
<li><a href="#3-%E5%86%85%E8%81%94%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84return">3. 内联高阶函数的<code>return</code></a>
<ul>
<li><a href="#1-local-return">1. local return</a></li>
<li><a href="#2-non-local-return">2. non-local return</a></li>
<li><a href="#3-%E4%B8%8D%E5%85%81%E8%AE%B8non-local-return">3. 不允许<code>non-local return</code></a></li>
</ul>
</li>
<li><a href="#4-%E5%86%85%E8%81%94%E5%B1%9E%E6%80%A7">4. 内联属性</a></li>
<li><a href="#5-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6">5. 内联函数的限制</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%87%A0%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0">四、几个实用的函数</a>
<ul>
<li><a href="#1-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E">1. 函数简单说明</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">2. 函数的实现</a>
<ul>
<li><a href="#1-let%E5%87%BD%E6%95%B0">1. <code>let</code>函数</a></li>
<li><a href="#2-run%E5%87%BD%E6%95%B0">2. <code>run</code>函数</a></li>
<li><a href="#3-also%E5%87%BD%E6%95%B0">3. <code>also</code>函数</a></li>
<li><a href="#4-apply%E5%87%BD%E6%95%B0">4. <code>apply</code>函数</a></li>
<li><a href="#5-use%E5%87%BD%E6%95%B0">5. <code>use</code>函数</a></li>
<li><a href="#6-with%E5%87%BD%E6%95%B0">6. <code>with</code>函数</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E4%BE%8B">实例</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E9%9B%86%E5%90%88%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%BA%8F%E5%88%97">五、集合变换与序列</a>
<ul>
<li><a href="#1-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF">1. 遍历集合通常使用循环</a>
<ul>
<li><a href="#1-for-i">1. for i …</a></li>
<li><a href="#2-for-each">2. for each …</a></li>
<li><a href="#3-foreach">3. forEach …</a></li>
</ul>
</li>
<li><a href="#2-%E9%9B%86%E5%90%88%E7%9A%84%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C">2. 集合的映射操作</a>
<ul>
<li><a href="#1-filter-%E6%93%8D%E4%BD%9C">1. filter 操作</a></li>
</ul>
</li>
<li><a href="#3-map-%E6%93%8D%E4%BD%9C">3. map 操作</a>
<ul>
<li><a href="#java%E4%B8%ADsteam%E5%92%8Ckotlin%E4%B8%AD%E7%9A%84assequence%E5%AF%B9%E6%AF%94"><strong><code>java</code>中<code>steam()</code>和<code>kotlin</code>中的<code>asSequence()</code>对比：</strong></a>
<ul>
<li><a href="#1-java-%E4%B8%AD-steam-%E5%90%8E%E5%86%8D%E5%8F%98%E6%8D%A2%E9%9B%86%E5%90%88">1. java 中 steam() 后再变换集合</a></li>
<li><a href="#2-kotlin-%E4%B8%AD-assequence-%E5%90%8E%E5%86%8D%E5%8F%98%E6%8D%A2%E9%9B%86%E5%90%88">2. kotlin 中 asSequence() 后再变换集合</a></li>
<li><a href="#3-kotlin%E4%B8%AD%E7%9B%B4%E6%8E%A5%E5%AF%B9%E9%9B%86%E5%90%88%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2">3. <code>kotlin</code>中直接对集合进行变换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-flatmap-%E5%8F%98%E6%8D%A2">3. flatMap 变换</a></li>
<li><a href="#3-kotlin%E4%B8%AD%E9%9B%86%E5%90%88%E7%9A%84%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C">3. <code>kotlin</code>中集合的聚合操作</a>
<ul>
<li><a href="#1-fold-%E6%93%8D%E4%BD%9C">1. fold 操作</a></li>
<li><a href="#2-zip-%E6%93%8D%E4%BD%9C">2. zip 操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD-sam-%E8%BD%AC%E6%8D%A2-single-abstract-method">六、SAM 转换 (Single Abstract Method)</a>
<ul>
<li><a href="#1-java-%E7%9A%84-sam">1. java 的 SAM</a></li>
<li><a href="#2-kotlin-%E7%9A%84-sam">2. kotlin 的 SAM</a>
<ul>
<li><a href="#1-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E8%BD%AC%E6%8D%A2%E4%B8%BAlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">1. 匿名内部类转换为<code>lambda</code>表达式</a></li>
<li><a href="#2-kotlin-%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95">2. kotlin 中的匿名内部类写法</a></li>
</ul>
</li>
<li><a href="#3-java-%E5%92%8C-kotlin-%E7%9A%84-sam-%E8%BD%AC%E6%8D%A2%E5%AF%B9%E6%AF%94">3. java 和 kotlin 的 SAM 转换对比</a>
<ul>
<li><a href="#1-java-%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A6%81%E6%B1%82">1. java 的转换要求</a></li>
<li><a href="#2-kotlin-%E8%BD%AC%E6%8D%A2%E8%A6%81%E6%B1%82">2. kotlin 转换要求</a></li>
<li><a href="#3-%E6%80%BB%E7%BB%93">3. 总结</a></li>
</ul>
</li>
<li><a href="#4-sam-%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98">4. SAM 转换的问题</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E7%A4%BA%E4%BE%8B">七、示例</a>
<ul>
<li><a href="#1-%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0">1. 统计字符个数</a></li>
<li><a href="#2-html-dsl%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80">2. HTML DSL(领域特定语言)</a></li>
<li><a href="#3-%E4%BD%93%E9%AA%8Cgradle-kotlin-dsl">3. 体验<code>Gradle Kotlin DSL</code></a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E5%B0%8F%E6%8A%80%E5%B7%A7">八、 小技巧</a>
<ul>
<li><a href="#1-%E9%9A%90%E8%97%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E7%9A%84%E4%BB%A3%E7%A0%81">1. 隐藏不需要显示的代码</a></li>
<li><a href="#2-%E6%9F%A5%E7%9C%8Bkotlin%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E6%BA%90%E7%A0%81">2. 查看<code>kotlin</code>编译后的源码</a>
<ul>
<li><a href="#1-%E7%9B%B4%E6%8E%A5%E5%9C%A8android-studio%E4%B8%AD%E6%9F%A5%E7%9C%8B">1. 直接在<code>Android Studio</code>中查看</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4javap%E5%8F%8D%E7%BC%96%E8%AF%91">2. 使用命令<code>javap</code>反编译</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 函数进阶</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://github.com/enbandari">Bennyhuo老师</a>讲解的<code>Kotlin</code>系列视频的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程初解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程进阶</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程应用</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-高阶函数" class="header-anchor">#</a><span id="二-高阶函数">二、高阶函数</span></h1>
<h2><a href="#1-高阶函数定义" class="header-anchor">#</a><span id="1-高阶函数定义">1. 高阶函数定义</span></h2>
<p><strong>高阶函数：</strong> <strong>参数类型</strong>包含函数类型或<strong>返回值类型</strong>为函数类型的函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数类型包含函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">needsFunction</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值类型是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnFunctions</span><span class="params">()</span></span>: () -&gt;<span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;System.currentTimeMillis()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-常见的高阶函数" class="header-anchor">#</a><span id="2-常见的高阶函数">2. 常见的高阶函数</span></h2>
<h3><a href="#1-foreach函数" class="header-anchor">#</a><span id="1-foreach函数">1. <code>forEach</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">forEach</span><span class="params">(action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forEach()</code>函数作用是迭代集合，把每个元素取出来<strong>进行了某些操作</strong>。</p>
<p><code>forEach()</code>作为<code>IntArray</code>类的扩展方法，该方法接收一个函数<code>action</code>作为参数，这个函数入参是一个<code>Int</code>, 返回<code>Unit</code>。在<code>forEach()</code>里直接调用函数<code>action</code>的<code>invoke()</code>方法。</p>
<h3><a href="#2-map函数" class="header-anchor">#</a><span id="2-map函数">2. <code>map</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> IntArray.<span class="title">map</span><span class="params">(transform: (<span class="type">Int</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> mapTo(ArrayList&lt;R&gt;(size), transform)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map()</code>函数作用是迭代集合，把每个元素取出来但是<strong>把元素转为另外的元素，并组成一个<code>List</code></strong></p>
<p><code>map()</code>函数作为<code>IntArray</code>类的扩展方法，该方法接收一个函数<code>transform</code>作为参数，这个函数入参是一个<code>Int</code>类型，返回一个<code>R</code> <em>(R 为泛型）</em> 类型。在<code>map()</code>里将函数<code>transform</code>作为一个参数传入另一个高阶函数<code>mapTo()</code></p>
<h2><a href="#3-高阶函数调用" class="header-anchor">#</a><span id="3-高阶函数调用">3. 高阶函数调用</span></h2>
<h3><a href="#1-传递函数引用" class="header-anchor">#</a><span id="1-传递函数引用">1. 传递函数引用</span></h3>
<p>在<code>kotlin</code>中，函数也是普通的类型，与<code>Int</code>、<code>String</code>等没什么区别</p>
<p>作为入参的函数可以直接传递函数引用，而不一定要传<code>lambda</code>表达式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : IntArray = IntArray(<span class="number">3</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">a.forEach(::println)</span><br></pre></td></tr></table></figure>
<p>如上，将函数<code>println</code>的引用传入，因<code>forEach()</code>函数入参类型为<code>(Int) -&gt; Unit</code>而<code>println</code>函数有一个重载方法类型为<code>(Int) -&gt; Unit</code>，所以这样写完全可以。</p>
<h3><a href="#2-使用表达式" class="header-anchor">#</a><span id="2-使用表达式">2. 使用表达式</span></h3>
<p>按高阶函数的声明来看，应该在入参位置放一个函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.forEach(&#123; println(<span class="string">&quot;element <span class="variable">$it</span>&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>若高阶函数的入参函数只有一个或最后一个入参是高阶函数，则可将<code>lambda</code>表达式移到小括号外面。</strong><br>
<strong>只有一个<code>lambda</code>表达式作为参数时可省略小括号</strong><br>
<strong>只有一个参数的<code>lambda</code>表达式的形参默认是<code>it</code></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将lambda表达式外移</span></span><br><span class="line">a.forEach() &#123; println(<span class="string">&quot;element <span class="variable">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略小括号</span></span><br><span class="line">a.forEach &#123; println(<span class="string">&quot;element <span class="variable">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#3-高阶函数示例" class="header-anchor">#</a><span id="3-高阶函数示例">3. 高阶函数示例</span></h3>
<p><strong>统计指印斐波那契数列的时间</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//region + 统计取斐波那契数列前11位所需时间</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cost &#123;</span><br><span class="line">        <span class="keyword">val</span> fibonacciNext = fibonacci()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>. <span class="number">10</span>) &#123;</span><br><span class="line">            println(fibonacciNext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现斐波那契数列求值，</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fibonacci</span><span class="params">()</span></span>: () -&gt; <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> first = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">var</span> second = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> next = first + second</span><br><span class="line">        <span class="keyword">val</span> current = first</span><br><span class="line">        first = second</span><br><span class="line">        second = next</span><br><span class="line">        current</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//endregion</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">3</span> ms</span><br></pre></td></tr></table></figure>
<p>打印出斐波那契数列前 11 项，耗时 3ms。</p>
<p>说明：</p>
<ol>
<li>
<p><code>cost</code>函数作用是统计函数<code>block</code>运行所需时间，<code>cost</code>入参为函数<code>block</code>，<code>block</code>函数不需要入参，且返回值为<code>Unit</code></p>
</li>
<li>
<p><code>fibonacci()</code>函数实现了斐波那契数列取值，它返回一个<code>lambda</code>表达式，该表达式不需要入参，但返回了一具<code>Long</code>类型数值</p>
</li>
</ol>
<h1><a href="#三-内联函数" class="header-anchor">#</a><span id="三-内联函数">三、内联函数</span></h1>
<h2><a href="#1-定义" class="header-anchor">#</a><span id="1-定义">1. 定义</span></h2>
<p>使用关键字 <strong><code>inlin</code></strong> 修饰的函数即为内联函数<br>
<strong>编译时会将内联函数内定义的函数直接内联到真正的调用处</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">forEach</span><span class="params">(action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，调用内联函数<code>forEach</code>其实是将函数<code>forEach</code>内定义的函数内联到调用处，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> ints) &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-高阶函数更适合定义为内联函数" class="header-anchor">#</a><span id="2-高阶函数更适合定义为内联函数">2. 高阶函数更适合定义为内联函数</span></h2>
<p>内联函数的作用：<strong>减少了函数调用</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cost &#123;</span><br><span class="line">        println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上定义了一个以<code>lambda</code>表达式为入参的高阶函数<code>cost</code>, 而<code>lambda</code>是匿名函数的语法糖，每次调用函数<code>cost</code>时都会创建他的入参函数<code>block</code>，所以可以为高阶函数<code>cost</code>添加关键字<code>inline</code>修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cost &#123;</span><br><span class="line">        println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    block()</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在编译时会将函数<code>cost</code>内联到原始调用处，如下所示编译后<code>class</code>文件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KotlinLabKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void cost(<span class="meta">@NotNull</span> Function0 block) &#123;</span><br><span class="line">      long start = System.currentTimeMillis();</span><br><span class="line">      block.invoke();</span><br><span class="line">      String var4 = System.currentTimeMillis() - start + <span class="string">&quot; ms&quot;</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">      long start$iv = System.currentTimeMillis();</span><br><span class="line">      String var4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(var4);</span><br><span class="line">      String var6 = System.currentTimeMillis() - start$iv + <span class="string">&quot; ms&quot;</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(var6);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如此，没有了调用函数<code>cost</code>的开销，也没有了创建<code>lambda</code>表达式的开销。</p>
<h2><a href="#3-内联高阶函数的return" class="header-anchor">#</a><span id="3-内联高阶函数的return">3. 内联高阶函数的<code>return</code></span></h2>
<h3><a href="#1-local-return" class="header-anchor">#</a><span id="1-local-return">1. local return</span></h3>
<p><code>kotlin</code>会给<code>lambda</code>表达式加一个<strong>默认的标签</strong>，标签名就是 <strong>@加上调用<code>lambda</code>表达式的高阶函数名一致</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        println(<span class="string">&quot;element: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element: <span class="number">1</span></span><br><span class="line">element: <span class="number">2</span></span><br><span class="line">element: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如上所示，先定义了一个有四个元素的<code>Int</code>数组，之后遍历数组，在元素为 3 时不执行打印语句。即<code>return@forEach</code>只起一次作用，类似于<code>continue</code>语句，它等价于如下语句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> ints) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="number">3</span>) <span class="keyword">continue</span></span><br><span class="line">        println(<span class="string">&quot;element: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-non-local-return" class="header-anchor">#</a><span id="2-non-local-return">2. non-local return</span></h3>
<p>若<code>return</code>不加标签，且在高阶函数的入参表达式中<code>return</code>了，则是直接退出了调用高阶函数所在的外部函数<br>
如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    ints.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        println(<span class="string">&quot;element: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> ints) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="number">3</span>) <span class="keyword">continue</span></span><br><span class="line">        println(<span class="string">&quot;element: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">element: <span class="number">1</span></span><br><span class="line">element: <span class="number">2</span></span><br><span class="line">element: <span class="number">4</span></span><br><span class="line">element: <span class="number">1</span></span><br><span class="line">element: <span class="number">2</span></span><br><span class="line">element: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>但是，若去掉标签<code>@forEach</code>，只留<code>return</code>语句，则打印结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element: <span class="number">1</span></span><br><span class="line">element: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>即<code>return</code>直接作用到了函数<code>main()</code>上，从函数<code>main()</code>上返回</p>
<h3><a href="#3-不允许non-local-return" class="header-anchor">#</a><span id="3-不允许non-local-return">3. 不允许<code>non-local return</code></span></h3>
<p>若高阶函数的入参表达式的调用处与定义处不在同一个调用上下文，有可能存在不合法的<code>non-local return</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Runnable</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义如上代码时，在语句<code>block()</code>处报错<code>Can't inline 'block' here: it may contain non-local returns. Add 'crossinline' modifier to parameter declaration 'block</code>，即此处不允许出现<code>non-local return</code>。</p>
<p>关键字<code>crossinline</code>，表示表达式禁止<code>nono-local return</code>，但是表达式还可以内联，但要在声明的形参表达式前加上该关键字。<br>
关键字<code>noinline</code>，表示禁止形参表达式被内联</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Runnable</span><span class="params">(corssinline block: () -&gt; <span class="type">Unit</span>)</span></span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Runnable</span><span class="params">(<span class="keyword">noinline</span> block: () -&gt; <span class="type">Unit</span>)</span></span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#4-内联属性" class="header-anchor">#</a><span id="4-内联属性">4. 内联属性</span></h2>
<p>没有<code>backing-field</code>的属性的<code>getting/setting</code>可以被内联</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pocket: <span class="built_in">Double</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">var</span> monkey: <span class="built_in">Double</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">get</span>() = pocket</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        pocket = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    monkey = <span class="number">5.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> pocket;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="title function_">getPocket</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pocket;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPocket</span><span class="params">(<span class="type">double</span> var0)</span> &#123;</span><br><span class="line">      pocket = var0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="title function_">getMonkey</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getPocket();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setMonkey</span><span class="params">(<span class="type">double</span> value)</span> &#123;</span><br><span class="line">      setPocket(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">double</span> <span class="variable">value$iv</span> <span class="operator">=</span> <span class="number">5.0D</span>;</span><br><span class="line">      setPocket(value$iv);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到执行语句<code>monkey = 5.0</code>时直接调用了方法<code>setPocket()</code>，而不是调用<code>monkey</code>的<code>setMonkey</code>方法</p>
<h2><a href="#5-内联函数的限制" class="header-anchor">#</a><span id="5-内联函数的限制">5. 内联函数的限制</span></h2>
<ol>
<li><code>public/protected</code>的内联方法只能访问对应类的<code>public</code>成员</li>
<li>内联函数的内联函数参数不能被存储（赋值给变量）</li>
<li>内联函数的内联函数参数只能传递给其它内联函数参数</li>
</ol>
<p>即：</p>
<ol>
<li><code>public</code>只能访问<code>public</code></li>
<li>内联只能访问内联</li>
<li>内联函数作为参数不能被存</li>
</ol>
<h1><a href="#四-几个实用的函数" class="header-anchor">#</a><span id="四-几个实用的函数">四、几个实用的函数</span></h1>
<h2><a href="#1-函数简单说明" class="header-anchor">#</a><span id="1-函数简单说明">1. 函数简单说明</span></h2>
<table>
<thead>
<tr>
<th>高阶函数名</th>
<th>介绍</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>let</td>
<td>val r = X.let{x -&gt;R}</td>
<td>将 receiver 作为参数调用指定的函数 [block] 并返回其结果</td>
</tr>
<tr>
<td>run</td>
<td>val r = X.run{this: X -&gt;R}</td>
<td>以 receiver 作为接收者调用指定的函数 [block] 并返回其结果</td>
</tr>
<tr>
<td>also</td>
<td>val x = X.also{x -&gt; Unit}</td>
<td>将 receiver 作为参数调用指定的函数 [block] 并返回 receiver</td>
</tr>
<tr>
<td>apply</td>
<td>val x = X.apply{this: x -&gt; Unit}</td>
<td>将 receiver 作为接收者调用指定的函数 [block]，并返回 receiver</td>
</tr>
<tr>
<td>use</td>
<td>val r = Closeable.use{c -&gt; R}</td>
<td>在 Closeable 资源上执行给定的 [block] 函数，然后无论是否引发异常，都正确地将其关闭。</td>
</tr>
<tr>
<td>with</td>
<td>with(X, X.() -&gt; R)</td>
<td>以给定的 [receiver] 作为接收者调用指定的函数 [block]，并返回其结果</td>
</tr>
</tbody>
</table>
<h2><a href="#2-函数的实现" class="header-anchor">#</a><span id="2-函数的实现">2. 函数的实现</span></h2>
<h3><a href="#1-let函数" class="header-anchor">#</a><span id="1-let函数">1. <code>let</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-run函数" class="header-anchor">#</a><span id="2-run函数">2. <code>run</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#3-also函数" class="header-anchor">#</a><span id="3-also函数">3. <code>also</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#4-apply函数" class="header-anchor">#</a><span id="4-apply函数">4. <code>apply</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#5-use函数" class="header-anchor">#</a><span id="5-use函数">5. <code>use</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="meta">@RequireKotlin(<span class="string">&quot;1.2&quot;</span>, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = <span class="string">&quot;Requires newer compiler version to be inlined correctly.&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Closeable?, R&gt;</span> T.<span class="title">use</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> exception: Throwable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        exception = e</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            apiVersionIsAtLeast(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) -&gt; <span class="keyword">this</span>.closeFinally(exception)</span><br><span class="line">            <span class="keyword">this</span> == <span class="literal">null</span> -&gt; &#123;&#125;</span><br><span class="line">            exception == <span class="literal">null</span> -&gt; close()</span><br><span class="line">            <span class="keyword">else</span> -&gt;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    close()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (closeException: Throwable) &#123;</span><br><span class="line">                    <span class="comment">// cause.addSuppressed(closeException) // ignored here</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#6-with函数" class="header-anchor">#</a><span id="6-with函数">6. <code>with</code>函数</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>with</code>函数可以让我们创建一个以变量作为上下文的代码块，这样就不需要每次使用它时重复它的名字。<br>
<code>with</code>可以简单理解为“有了”，“有了变量 X”。这样代码也显得简洁。</p>
<h2><a href="#实例" class="header-anchor">#</a><span id="实例">实例</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    person.let(::println)</span><br><span class="line">    person.run(::println)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> person2 = person.also &#123;</span><br><span class="line">        it.name = <span class="string">&quot;Lee2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> person3 = person.apply &#123;</span><br><span class="line">        name = <span class="string">&quot;Lee3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(person) &#123;</span><br><span class="line">        name = <span class="string">&quot;Lee4&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File(<span class="string">&quot;build.gradle&quot;</span>).inputStream().reader().buffered()</span><br><span class="line">            .use &#123;</span><br><span class="line">                println(it.readLines())</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><a href="#五-集合变换与序列" class="header-anchor">#</a><span id="五-集合变换与序列">五、集合变换与序列</span></h1>
<h2><a href="#1-遍历集合通常使用循环" class="header-anchor">#</a><span id="1-遍历集合通常使用循环">1. 遍历集合通常使用循环</span></h2>
<h3><a href="#1-for-i" class="header-anchor">#</a><span id="1-for-i">1. for i …</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>. <span class="number">10</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-for-each" class="header-anchor">#</a><span id="2-for-each">2. for each …</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (e <span class="keyword">in</span> ints) &#123;</span><br><span class="line">    println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#3-foreach" class="header-anchor">#</a><span id="3-foreach">3. forEach …</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ints.forEach &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：该方式不能<code>continue</code>或者<code>break</code></p>
<h2><a href="#2-集合的映射操作" class="header-anchor">#</a><span id="2-集合的映射操作">2. 集合的映射操作</span></h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter</td>
<td>保留满足条件的元素</td>
</tr>
<tr>
<td>map</td>
<td>集合中的所有元素一一映射到其它元素构成新集合</td>
</tr>
<tr>
<td>flatMap</td>
<td>集合中的所有元素一一映射到新集合并合并这些集合得到新集合</td>
</tr>
</tbody>
</table>
<h3><a href="#1-filter-操作" class="header-anchor">#</a><span id="1-filter-操作">1. filter 操作</span></h3>
<p><strong>功能：</strong> 将集合 a 内所有满足条件的元素生成一个新集合 b</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_filter.png" alt="filter操作图"></p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">println(list.joinToString())</span><br><span class="line">println(list2.joinToString())</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><code>java 8</code>中有类似的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;Integer&gt; list2 = list.stream().filter( e -&gt; e % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>filter</code>操作不会操作原来的集合而是创建一个新的集合</p>
</li>
<li>
<p><code>java</code>中是先将<code>list</code>转为<code>stream</code>流，再进行<code>filter</code>筛选操作</p>
</li>
<li>
<p><code>kotlin</code>中也有与<code>java</code>类似的先转换再筛选的操作：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.asSequence().filter&#123;it % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>先将集合转换为懒序列再将序列进行<code>filter</code>筛选操作</li>
<li>与将集合直接进行<code>filter</code>操作的区别只在于是<em>懒汉式</em>还是<em>饿汉式</em></li>
</ol>
</li>
</ol>
<p><strong>ArrayList 的 filter 操作源码：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> filterTo(ArrayList&lt;T&gt;(), predicate)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, C : MutableCollection&lt;in T&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filterTo</span><span class="params">(destination: <span class="type">C</span>, predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">if</span> (predicate(element)) destination.add(element)</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-map-操作" class="header-anchor">#</a><span id="3-map-操作">3. map 操作</span></h2>
<p><strong>功能：</strong> 将集合 a 内的所有元素进行一个操作得到新的元素集合</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_map.png" alt="map操作示意图"></p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">println(list.joinToString())</span><br><span class="line">println(list2.joinToString())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><code>java</code>中若要使用<code>map</code>操作，要先将集合转为流 <em>(stream)</em>，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;Integer&gt; list2 = list.stream().map( e -&gt; e % <span class="number">2</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>map</code>操作也是创建一个 ussr 的集合，集合中的元素是原集合元素进行一个操作映射出来的</p>
</li>
<li>
<p><code>kotlin</code>中也有与<code>java</code>类似的先转换再映射的操作：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.asSequence().map&#123;it % <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>先将集合转换为懒序列再将序列进行<code>map</code>筛选操作</li>
<li>与将集合直接进行<code>map</code>操作的区别只在于是<em>懒汉式</em>还是<em>饿汉式</em></li>
</ol>
</li>
</ol>
<p><strong>ArrayList 的 map 操作源码：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(<span class="number">10</span>)), transform)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R, C : MutableCollection&lt;in R&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">mapTo</span><span class="params">(destination: <span class="type">C</span>, transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#java中steam和kotlin中的assequence对比" class="header-anchor">#</a><span id="java中steam和kotlin中的assequence对比"><strong><code>java</code>中<code>steam()</code>和<code>kotlin</code>中的<code>asSequence()</code>对比：</strong></span></h3>
<h4><a href="#1-java-中-steam-后再变换集合" class="header-anchor">#</a><span id="1-java-中-steam-后再变换集合">1. java 中 steam() 后再变换集合</span></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">list.stream()</span><br><span class="line">        .filter(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filter:&quot;</span> + e);</span><br><span class="line">            <span class="keyword">return</span> e % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;map:&quot;</span> + e);</span><br><span class="line">            <span class="keyword">return</span> e * <span class="number">2</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .forEach(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;forEach:&quot;</span> + e);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter:<span class="number">1</span></span><br><span class="line">filter:<span class="number">2</span></span><br><span class="line">map:<span class="number">2</span></span><br><span class="line">forEach:<span class="number">4</span></span><br><span class="line">filter:<span class="number">3</span></span><br><span class="line">filter:<span class="number">4</span></span><br><span class="line">map:<span class="number">4</span></span><br><span class="line">forEach:<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>先定义一个只有四个元素的整型列表，之后将列表转为流，再筛选出偶数，再通过乘以 2 映射成一个新集合，最后打印新集合元素</li>
<li>从打印结果可以看出，会先通过<code>filter</code>判断元素是否为偶数：奇数不会再往下执行；若是偶数，则该元素会一直往下执行，最后打印出来，然后再判断下一个元素是否为偶数</li>
<li><code>java</code>中的<code>steam()</code>是懒序列</li>
</ol>
<h4><a href="#2-kotlin-中-assequence-后再变换集合" class="header-anchor">#</a><span id="2-kotlin-中-assequence-后再变换集合">2. kotlin 中 asSequence() 后再变换集合</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">list.asSequence()</span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        &#125;.map &#123;</span><br><span class="line">            println(<span class="string">&quot;map:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it * <span class="number">2</span></span><br><span class="line">        &#125;.forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;forEach:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter:<span class="number">1</span></span><br><span class="line">filter:<span class="number">2</span></span><br><span class="line">map:<span class="number">2</span></span><br><span class="line">forEach:<span class="number">4</span></span><br><span class="line">filter:<span class="number">3</span></span><br><span class="line">filter:<span class="number">4</span></span><br><span class="line">map:<span class="number">4</span></span><br><span class="line">forEach:<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义一个只有四个元素的整数集合，之后将列表转为<code>sequence()</code>，再筛选出偶数，再通过乘以 2 映射成一个新集合，最后打印新集合元素</li>
<li>打印结果与<code>java</code>中的<code>steam()</code>结果完全一致，执行逻辑也一致。</li>
<li><strong><code>kotlin</code>中的<code>asSequence()</code>也是懒序列，只有在需要时才会执行变换，如果不需要则只是个公式，不会执行。若把<code>forEach()</code>操作去掉，则不会有打印信息</strong></li>
</ol>
<h4><a href="#3-kotlin中直接对集合进行变换" class="header-anchor">#</a><span id="3-kotlin中直接对集合进行变换">3. <code>kotlin</code>中直接对集合进行变换</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list.filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        println(<span class="string">&quot;map:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it * <span class="number">2</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(<span class="string">&quot;forEach:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter:<span class="number">1</span></span><br><span class="line">filter:<span class="number">2</span></span><br><span class="line">filter:<span class="number">3</span></span><br><span class="line">filter:<span class="number">4</span></span><br><span class="line">map:<span class="number">2</span></span><br><span class="line">map:<span class="number">4</span></span><br><span class="line">forEach:<span class="number">4</span></span><br><span class="line">forEach:<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>该段代码对集合<code>list</code>进行了三个操作<code>filter</code>、<code>map</code>、<code>forEach</code>，只有<strong>当列表里所有元素都执行完一个操作之后，才会执行下一个操作</strong>。</li>
<li><strong><code>kotlin</code>中直接对集合进行变换是饿汉式的，不管需要不需要都会执行变换，若把<code>forEach()</code>操作去掉，也会有打印信息</strong>。</li>
<li><code>RxJava</code>中的<code>Obserable</code>是<em>懒汉式的</em></li>
</ol>
<h2><a href="#3-flatmap-变换" class="header-anchor">#</a><span id="3-flatmap-变换">3. flatMap 变换</span></h2>
<p><strong>功能：</strong> 将一个集合 a 内的每个元素通过某个操作得到一个集合，最后将每个元素映射的集合拼接成一个新集合</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_flatmap.png" alt="flatMap操作示意图"></p>
<p>如图所示：转换操作是创建一个长度为原集合对应元素值大小的<code>Int</code>数组，该数组元素由<code>index * 2</code>构成</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.flatMap &#123;</span><br><span class="line">        <span class="number">0</span> until it</span><br><span class="line">    &#125;.joinToString().let(::println)</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>map</code>操作是将集合里每个元素映射成一个新元素，而<code>flatMap</code>操作是<strong>将集合里的每个元素映射成一个新集合</strong></li>
<li><code>flatMap</code>操作需要是的<code>Iterable</code>类型的数据，而<code>0 until it</code>生成的一个<code>IntRange</code>，该类型实现了<code>Iterable</code></li>
</ol>
<p><strong>ArrayList 的 flatMap 操作源码：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">flatMap</span><span class="params">(transform: (<span class="type">T</span>) -&gt; <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> flatMapTo(ArrayList&lt;R&gt;(), transform)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R, C : MutableCollection&lt;in R&gt;</span>&gt; Iterable<span class="type">&lt;T&gt;</span>.<span class="title">flatMapTo</span><span class="params">(destination: <span class="type">C</span>, transform: (<span class="type">T</span>) -&gt; <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: C &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> list = transform(element)</span><br><span class="line">        destination.addAll(list)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-kotlin中集合的聚合操作" class="header-anchor">#</a><span id="3-kotlin中集合的聚合操作">3. <code>kotlin</code>中集合的聚合操作</span></h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>所有元素求和</td>
</tr>
<tr>
<td>reduce</td>
<td>将元素依次按规则聚合，结果与元素类型一致</td>
</tr>
<tr>
<td>fold</td>
<td>给定初始化值，将元素按规则聚合，结果与初始化值类型一致</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ol>
<li>聚合操作是将所有元素进行运算</li>
<li><code>reduce</code>操作可以看作<code>fold</code>操作的简化版</li>
</ol>
<h3><a href="#1-fold-操作" class="header-anchor">#</a><span id="1-fold-操作">1. fold 操作</span></h3>
<p><strong>功能：</strong> 给定一个初始值，将元素进行某个操作，返回一个和初始值相同类型的结果</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_fold.png" alt="fold操作示意图"></p>
<p>如上图所示，<code>fold</code>里的操作是初始值都与元素相加，<strong>而每次操作时的初始值都是上次的操作结果。</strong></p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(list.fold(<span class="number">2</span>) &#123;</span><br><span class="line">    acc, i -&gt;</span><br><span class="line">    println(<span class="string">&quot;acc:<span class="variable">$acc</span>, i:<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    acc + i</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acc:<span class="number">2</span>, i:<span class="number">1</span></span><br><span class="line">acc:<span class="number">3</span>, i:<span class="number">2</span></span><br><span class="line">acc:<span class="number">5</span>, i:<span class="number">3</span></span><br><span class="line">acc:<span class="number">8</span>, i:<span class="number">4</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>acc</code>是初始值，<code>i</code>是原集合中的每个元素，所做的操作是将初始值与元素值相加</li>
<li>给<code>fold</code>操作一个初始值 2 即<code>acc</code>为 2，然后取第一个元素 1，两者相加为 3，然后 3 是取下一个元素时的初始值，如此往复，最后结果是初始值加上元素的累加结果，即 12</li>
</ol>
<p><strong>ArrayList 的 fold 操作源码：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">acc</span>: <span class="type">R</span>, <span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> accumulator = initial</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) accumulator = operation(accumulator, element)</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-zip-操作" class="header-anchor">#</a><span id="2-zip-操作">2. zip 操作</span></h3>
<p><strong>功能：</strong> 将两个集合中对应下标的元素进行某个操作返回操作结果，最后将操作结果拼接成一个新集合</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_zip.png" alt="zip操作示意图"></p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayListOf&lt;String&gt;(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">list.zip(array)&#123;</span><br><span class="line">    a, b -&gt;</span><br><span class="line">    println(<span class="string">&quot;a:<span class="variable">$a</span>, b:<span class="variable">$b</span>&quot;</span>)</span><br><span class="line">    arrayListOf(a, b)</span><br><span class="line">&#125;.joinToString().let(::println)</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span>, b:x</span><br><span class="line">a:<span class="number">2</span>, b:y</span><br><span class="line">[<span class="number">1</span>, x], [<span class="number">2</span>, y]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>a</code>是原集合的元素，<code>b</code>是<code>zip</code>操作传入的集合的元素，所进行的操作是创建一个新集合，新集合元素是<code>a</code>和<code>b</code></li>
<li>最后的结果是一新的集合，新集合的每个元素都是一个小集合</li>
</ol>
<p><strong>Collection 的 zip 操作源码：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">zip</span><span class="params">(other: <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: List&lt;Pair&lt;T, R&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> zip(other) &#123; t1, t2 -&gt; t1 to t2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R, V&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">zip</span><span class="params">(other: <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;, transform: (<span class="type">a</span>: <span class="type">T</span>, <span class="type">b</span>: <span class="type">R</span>) -&gt; <span class="type">V</span>)</span></span>: List&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> first = iterator()</span><br><span class="line">    <span class="keyword">val</span> second = other.iterator()</span><br><span class="line">    <span class="keyword">val</span> list = ArrayList&lt;V&gt;(minOf(collectionSizeOrDefault(<span class="number">10</span>), other.collectionSizeOrDefault(<span class="number">10</span>)))</span><br><span class="line">    <span class="keyword">while</span> (first.hasNext() &amp;&amp; second.hasNext()) &#123;</span><br><span class="line">        list.add(transform(first.next(), second.next()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>操作的执行次数是由最小的集合的元素个数决定的</li>
<li>进行操作的对象是两个集合中相同位置的元素</li>
<li><code>zip</code>的默认操作是返回一个<code>Pair</code></li>
</ol>
<h1><a href="#六-sam-转换-single-abstract-method" class="header-anchor">#</a><span id="六-sam-转换-single-abstract-method">六、SAM 转换 (Single Abstract Method)</span></h1>
<h2><a href="#1-java-的-sam" class="header-anchor">#</a><span id="1-java-的-sam">1. java 的 SAM</span></h2>
<p><code>Java</code>中的<code>lambda</code>表达式没有自己的类型，必须有一个 <strong>单一方法的接口</strong> 来接收它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">executor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run in Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">executor.submit(() -&gt; System.out.println(<span class="string">&quot;run in Runnable&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2><a href="#2-kotlin-的-sam" class="header-anchor">#</a><span id="2-kotlin-的-sam">2. kotlin 的 SAM</span></h2>
<h3><a href="#1-匿名内部类转换为lambda表达式" class="header-anchor">#</a><span id="1-匿名内部类转换为lambda表达式">1. 匿名内部类转换为<code>lambda</code>表达式</span></h3>
<p><code>kotlin</code>中的<code>lambda</code>表达式即为匿名函数的语法糖，它是有自己类型的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> executor = Executors.newCachedThreadPool()</span><br><span class="line">executor.submit(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;run in runnable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>Runnable</code>是一个匿名内部类，它转换成<code>lambda</code>表达式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.submit &#123; println(<span class="string">&quot;run in runnable&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说<code>()-&gt;Unit</code>类型的<code>lambda</code>转换为了<code>Runnable</code>，但转换过程并非直接转换，实际上是创建了一个<code>Runnable</code>，然后在它的<code>run</code>方法中添加了<code>lambda</code>表达式，又因<code>lambda</code>表达式可以内联，所以可以把<code>lambda</code>表达式里的内容直接放到<code>run</code>方法中。</p>
<h3><a href="#2-kotlin-中的匿名内部类写法" class="header-anchor">#</a><span id="2-kotlin-中的匿名内部类写法">2. kotlin 中的匿名内部类写法</span></h3>
<p>如上一节所示传统的匿名内部类如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;run in runnable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匿名内部类的简写：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable&#123; println(<span class="string">&quot;run in runnable&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法完全等价，编译器都会生成如下函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Runnable</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span>: Runnable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;run in runnable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-java-和-kotlin-的-sam-转换对比" class="header-anchor">#</a><span id="3-java-和-kotlin-的-sam-转换对比">3. java 和 kotlin 的 SAM 转换对比</span></h2>
<h3><a href="#1-java-的转换要求" class="header-anchor">#</a><span id="1-java-的转换要求">1. java 的转换要求</span></h3>
<p><code>java 8</code>一个参数类型为<strong>只有一个方法的接口</strong>的方法，调用时可用<code>lambda</code>表达式做转换作为参数</p>
<p>即假设有一个方法，它只接收一个<code>java</code>接口，且这个接口只有一个方法，此时可将那个接口转换为<code>lambda</code>表达式</p>
<h3><a href="#2-kotlin-转换要求" class="header-anchor">#</a><span id="2-kotlin-转换要求">2. kotlin 转换要求</span></h3>
<p>一个参数类型为<strong>只有一个方法的 Java 接口</strong> 的<code>java</code>方法，调用时可用<code>lambda</code>表达式做转换作为参数</p>
<p><code>kotlin</code>的需要与<code>java</code>一致，甚至更加严格。即只能是<code>java</code>的接口，若在<code>kotlin</code>中自定义的接口，即使只有一个函数也不能进行转换。</p>
<h3><a href="#3-总结" class="header-anchor">#</a><span id="3-总结">3. 总结</span></h3>
<table>
<thead>
<tr>
<th></th>
<th>Java</th>
<th>Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java 接口</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Kotlin 接口</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Java 方法</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Kotlin 函数</td>
<td>支持</td>
<td>不支持，kotlin1.3 起，添加编译器参数也可以支持</td>
</tr>
<tr>
<td>抽象类</td>
<td>不支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p><strong><code>Java</code>的<code>lambda</code>是假的，没有自己的类型，本质就是<code>SAM</code>, 转换为了<code>java</code>的接口</strong><br>
<strong><code>Kotlin</code>的<code>lambda</code>是真的，有自己的函数类型，只是支持<code>SAM</code></strong></p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//报错</span></span><br><span class="line">    submit &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常</span></span><br><span class="line">    submit2 &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常</span></span><br><span class="line">    submitRunnable &#123; println(<span class="string">&quot;ok&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">submitRunnable</span><span class="params">(runnable: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">    runnable.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">submit</span><span class="params">(invokable: <span class="type">Invokable</span>)</span></span> &#123;</span><br><span class="line">    invokable.invoke()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">submit2</span><span class="params">(lambda: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    lambda()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> FunctionX = () -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">submit3</span><span class="params">(lambda: <span class="type">FunctionX</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Invokable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>自定义了一个只有方法<code>invoke</code>的接口<code>Invokable</code>，又定义了一个要以接口<code>Invokable</code>为入参的方法<code>submit</code>，接着定义了一个接口<code>java</code>接口<code>Runnable</code>做为参数的方法<code>submitRunnable</code>。</li>
<li>此时若调用方法<code>submit</code>时写成<code>submit&#123;&#125;</code>，编辑器会报错：<em>Type mismatch.      Required:     Invokable     Found:      () → Unit</em>，原因是参数需要<code>Invokable</code>接口而传进去了一个<code>lambda</code>表达式</li>
<li>调用函数<code>submitRunnable()</code>时将<code>lambda</code>表达传递进去是可以的，并未报错。这个是在<code>Kotlin</code>1.3 版本之后支持的</li>
<li>若需要在<code>kotlin</code>中支持入参是<code>lambda</code>，只需要入参定义为函数类型即接收一个函数，例如函数<code>submit2</code>和<code>submit3</code></li>
</ol>
<h2><a href="#4-sam-转换的问题" class="header-anchor">#</a><span id="4-sam-转换的问题">4. SAM 转换的问题</span></h2>
<p>若需要保存接口，且在增删接口时使用 lambda 表达，则增删时的<code>lambda</code>表达式肯定不是同一个接口，此时不能删除之前添加的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallbackManager</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">ViewCallback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="type">int</span> viewId)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCallback</span><span class="params">(ViewCallback callback)</span> &#123;</span><br><span class="line">        mCallbacks.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterCallback</span><span class="params">(ViewCallback callback)</span> &#123;</span><br><span class="line">        mCallbacks.remove(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;ViewCallback&gt; mCallbacks = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上<code>java</code>定义了一个管理<code>Callback</code>的管理类，管理类提供了增删<code>ViewCallback</code>接口的功能</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> manager = CallbackManager()</span><br><span class="line">    manager.registerCallback &#123;</span><br><span class="line">        println(<span class="string">&quot;onChanged<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，<code>kotlin</code>中使用该类，但传递进去的是一个<code>lambda</code>表达式，编译器转换后如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">manager.registerCallback(<span class="keyword">object</span>: CallbackManager.ViewCallback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCallback</span><span class="params">(viewId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;onChanged<span class="variable">$viewId</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时，因为传递进去的是一个匿名函数，无法标识该函数所以<code>CallbackManager</code>无法删除该接口了。</p>
<p><strong>为<code>lambda</code>表达式关联一个变量，增删时使用这个变量</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> manager = CallbackManager()</span><br><span class="line">    <span class="keyword">val</span> onCallback = &#123;viewId: <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;onChanged<span class="variable">$viewId</span>&quot;</span>)&#125;</span><br><span class="line">    manager.registerCallback(onCallback)</span><br><span class="line">    <span class="comment">//编译器转换后的代码</span></span><br><span class="line">    manager.registerCallback(<span class="keyword">object</span>: CallbackManager.ViewCallback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCallback</span><span class="params">(viewId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            onCallback.invoke(viewId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    manager.unregisterCallback(onCallback)</span><br><span class="line">    <span class="comment">//编译器转换后的代码</span></span><br><span class="line">    manager.unregisterCallback(<span class="keyword">object</span>: CallbackManager.ViewCallback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCallback</span><span class="params">(viewId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            onCallback(viewId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如上所示：</strong></p>
<ol>
<li>将<code>lambda</code>表达式赋值给变量<code>onCallback</code>，此时调用管理类<code>CallbackManager</code>的<code>registerCallback</code>方法和<code>unregisterCallback</code>方法皆不会报错。</li>
<li>但是，可以看到编译器转换后的代码，不管理是在<code>registerCallback</code>方法和<code>unregisterCallback</code>方法中，都是重新创建<code>onCallback</code>，所以也不可能删除。</li>
</ol>
<p><strong>原因：</strong> 变量<code>onCallback</code>的类型并非是之前定义的接口<code>ViewCallback</code>类型，而是<code>() -&gt; Unit</code>，编译器会重新创建接口</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>
<p>为变量<code>onCallback</code>关联接口，而非<code>lambda</code>表达式，此时变量<code>onCallback</code>类型为<code>ViewCallback</code>接口类型，在添加和删除时就不会进行转换。例：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> onCallback = CallbackManager.ViewCallback &#123;viewId: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    println(<span class="string">&quot;onChanged<span class="variable">$viewId</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">manager.registerCallback(onCallback)</span><br><span class="line">manager.unregisterCallback(onCallback)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用匿名内部类的方式为变量<code>onCallback</code>赋值，就是第一种方案里的<code>lambda</code>展示形式。例：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> onCallback = <span class="keyword">object</span> : CallbackManager.ViewCallback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCallback</span><span class="params">(viewId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;onChanged<span class="variable">$viewId</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1><a href="#七-示例" class="header-anchor">#</a><span id="七-示例">七、示例</span></h1>
<h2><a href="#1-统计字符个数" class="header-anchor">#</a><span id="1-统计字符个数">1. 统计字符个数</span></h2>
<p><strong>实现效果：</strong> 给定一个文件统计所有非空字符的出现次数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    File(<span class="string">&quot;build.gradle&quot;</span>).readText()<span class="comment">//读文件，返回一个String</span></span><br><span class="line">            .toCharArray()<span class="comment">//将String 转为char[]</span></span><br><span class="line">            .filterNot &#123; it.isWhitespace() &#125;<span class="comment">//过滤空格</span></span><br><span class="line">            .groupBy &#123; it &#125;<span class="comment">//按每个char字符分组</span></span><br><span class="line">            .map &#123;</span><br><span class="line">                it.key to it.value.size</span><br><span class="line">            &#125;.let(::println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<pre><code>[(/, 7), (T, 2), (o, 40), (p, 16), (-, 4), (l, 35), (e, 50), (v, 4), (b, 8), (u, 13), (i, 33), (d, 21), (f, 3), (w, 1), (h, 6), (r, 24), (y, 4), (c, 17), (a, 20), (n, 26), (g, 11), (t, 29), (s, 22), (m, 5), (j, 6), (., 13), (&#123;, 6), (x, 1), (k, 5), (_, 2), (=, 1), (', 2), (1, 1), (4, 2), (2, 1), (0, 3), ((, 5), (), 5), (&#125;, 6), (&quot;, 4), (:, 6), ($, 1), (N, 1), (O, 1), (E, 1), (D, 3), (;, 1), (P, 1)]
</code></pre>
<p><strong>说明：</strong></p>
<ol>
<li>函数<code>fitlerNot()</code>作用是将满足条件的元素过滤掉不参与之后操作</li>
<li>函数<code>groupBy()</code>作用是按<code>lambda</code>表达式返回结果作为依据进行分组，返回结果是一个<code>map</code>，<code>key</code>为 lambda 表达式返回结果，<code>value</code>为<code>list</code>，<code>list</code>元素为对应<code>lambda</code>结果的入参。</li>
<li>获取工程根目录下的<code>build.gradle</code>文件内的所有字符串，然后转为字符数组，接着过滤空格，再接字符分组，最后通过<code>map</code>函数得到对应字符及字符数量的<code>Pair</code>的<code>list</code></li>
</ol>
<h2><a href="#2-html-dsl领域特定语言" class="header-anchor">#</a><span id="2-html-dsl领域特定语言">2. HTML DSL(领域特定语言)</span></h2>
<p><strong>定义：</strong> 领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。</p>
<p><code>SQL</code>是典型的<code>DSL</code>,而<code>Gradle</code>也是基于编程语言<code>Groovy</code>的<code>DSL</code></p>
<p>手动简单编写<code>kotlin</code>中支持<code>HTML DSL</code>，可查看官方的实现库：<a target="_blank" rel="noopener" href="https://github.com/kotlin/kotlinx.html">https://github.com/kotlin/kotlinx.html</a></p>
<p>示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> htmlContent = html &#123;</span><br><span class="line">        head &#123;</span><br><span class="line">            <span class="string">&quot;meta&quot;</span> &#123; <span class="string">&quot;charset&quot;</span>(<span class="string">&quot;UTF-8&quot;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        body &#123;</span><br><span class="line">            <span class="string">&quot;div&quot;</span> &#123;</span><br><span class="line">                <span class="string">&quot;style&quot;</span>(</span><br><span class="line">                        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    width: 200px; </span></span><br><span class="line"><span class="string">                    height: 200px; </span></span><br><span class="line"><span class="string">                    line-height: 200px; </span></span><br><span class="line"><span class="string">                    background-color: #C9394A;</span></span><br><span class="line"><span class="string">                    text-align: center</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">                )</span><br><span class="line">                <span class="string">&quot;span&quot;</span> &#123;</span><br><span class="line">                    <span class="string">&quot;style&quot;</span>(</span><br><span class="line">                            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                        color: white;</span></span><br><span class="line"><span class="string">                        font-family: Microsoft YaHei</span></span><br><span class="line"><span class="string">                        &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">                    )</span><br><span class="line">                    +<span class="string">&quot;Hello HTML DSL!!&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.render()</span><br><span class="line"></span><br><span class="line">    File(<span class="string">&quot;Kotlin_html_DSL.html&quot;</span>).writeText(htmlContent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringNode</span>(<span class="keyword">val</span> content: String) : Node &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockNode</span>(<span class="keyword">val</span> name: String) : Node &#123;</span><br><span class="line">    <span class="comment">//节点的子节点</span></span><br><span class="line">    <span class="keyword">val</span> children = ArrayList&lt;Node&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的属性</span></span><br><span class="line">    <span class="keyword">val</span> properties = HashMap&lt;String, Any&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="comment">//&lt;html props&gt;XXX&lt;/html&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &lt;<span class="variable">$name</span> <span class="subst">$&#123;properties.map &#123; <span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span>=&#x27;<span class="subst">$&#123;it.value&#125;</span>&#x27;&quot;</span> &#125;</span>.joinToString(&quot; &quot;)&#125;&gt;</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;children.joinToString(<span class="string">&quot;&quot;</span>)&#123;it.render()&#125;</span>&#125;</span></span><br><span class="line"><span class="string">            &lt;/<span class="variable">$name</span>&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为这个函数需要两个receiver:String,和BlockNode，将其定义到BlockNode类里就自动有了该receiver</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">invoke</span><span class="params">(block: <span class="type">BlockNode</span>.() -&gt; <span class="type">Unit</span>)</span></span>: BlockNode &#123;</span><br><span class="line">        <span class="keyword">val</span> node = BlockNode(<span class="keyword">this</span>)</span><br><span class="line">        node.block()</span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@BlockNode</span>.children += node</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">invoke</span><span class="params">(value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@BlockNode</span>.properties[<span class="keyword">this</span>] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">unaryPlus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@BlockNode</span>.children += StringNode(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">(block: <span class="type">BlockNode</span>.() -&gt; <span class="type">Unit</span>)</span></span>: BlockNode &#123;</span><br><span class="line">    <span class="keyword">val</span> html = BlockNode(<span class="string">&quot;html&quot;</span>)</span><br><span class="line">    html.block()</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为顶级函数head添加一个receiver,使之成为扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> BlockNode.<span class="title">head</span><span class="params">(block: <span class="type">BlockNode</span>.() -&gt; <span class="type">Unit</span>)</span></span>: BlockNode &#123;</span><br><span class="line">    <span class="keyword">val</span> head = BlockNode(<span class="string">&quot;head&quot;</span>)</span><br><span class="line">    head.block()</span><br><span class="line">    <span class="keyword">this</span>.children += head</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> BlockNode.<span class="title">body</span><span class="params">(block: <span class="type">BlockNode</span>.() -&gt; <span class="type">Unit</span>)</span></span>: BlockNode &#123;</span><br><span class="line">    <span class="keyword">val</span> body = BlockNode(<span class="string">&quot;body&quot;</span>)</span><br><span class="line">    body.block()</span><br><span class="line">    <span class="keyword">this</span>.children += body</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成的<em>Kotlin_html_DSL.html</em>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            &lt;html &gt;</span><br><span class="line">                            &lt;head &gt;</span><br><span class="line">                &lt;meta charset=&#x27;UTF-8&#x27;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/meta&gt;</span><br><span class="line">            &lt;/head&gt;            &lt;body &gt;</span><br><span class="line">                            &lt;div style=&#x27;width: 200px; </span><br><span class="line">height: 200px; </span><br><span class="line">line-height: 200px; </span><br><span class="line">background-color: #C9394A;</span><br><span class="line">text-align: center&#x27;&gt;</span><br><span class="line">                            &lt;span style=&#x27;color: white;</span><br><span class="line">font-family: Microsoft YaHei&#x27;&gt;</span><br><span class="line">                Hello HTML DSL!!</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;/body&gt;</span><br><span class="line">            &lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-体验gradle-kotlin-dsl" class="header-anchor">#</a><span id="3-体验gradle-kotlin-dsl">3. 体验<code>Gradle Kotlin DSL</code></span></h2>
<p><code>Gradle DSL</code>在<strong>5.0</strong>之前版本是<code>Groovy DSL</code>，在<strong>5.0</strong>版本之后引入了<code>Kotlin DSL</code></p>
<p><code>Groovy</code>是动态语言，<code>Kotlin</code>是静态语言，<code>IDE</code>可以提示静态语言，体验更友好。</p>
<p><strong>官网：</strong> <a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/using-gradle.html">https://www.kotlincn.net/docs/reference/using-gradle.html</a></p>
<p>简单示例如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setting.gradle</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span></span><br><span class="line">rootProject.name = <span class="string">&quot;ProjectCollection&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;30.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;cn.ltt.projectcollection&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">        targetSdkVersion <span class="number">30</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&quot;libs&quot;</span>, <span class="attr">include:</span> [<span class="string">&quot;*.jar&quot;</span>])</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.0.2&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gson</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.code.gson:gson:2.8.6&#x27;</span></span><br><span class="line">    <span class="comment">//EventBus</span></span><br><span class="line">    implementation <span class="string">&#x27;org.greenrobot:eventbus:3.1.1&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;com.jakewharton:butterknife:10.2.3&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;com.jakewharton:butterknife-compiler:10.2.3&#x27;</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.core:core-ktx:+&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;com.squareup.retrofit2:retrofit:2.6.2&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;com.squareup.retrofit2:converter-gson:2.6.2&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;com.google.code.gson:gson:2.8.1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为<code>kotlin DSL</code>如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setting.gradle</span></span><br><span class="line">include(<span class="string">&quot;:app&quot;</span>)</span><br><span class="line">rootProject.name = <span class="string">&quot;ProjectCollection&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.config.KotlinCompilerVersion</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id (<span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">    id (<span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(<span class="number">30</span>)</span><br><span class="line">    buildToolsVersion(<span class="string">&quot;30.0.1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId = <span class="string">&quot;cn.ltt.projectcollection&quot;</span></span><br><span class="line">        minSdkVersion(<span class="number">16</span>)</span><br><span class="line">        targetSdkVersion(<span class="number">30</span>)</span><br><span class="line">        versionCode = <span class="number">1</span></span><br><span class="line">        versionName = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner = <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        getByName(<span class="string">&quot;release&quot;</span>) &#123;</span><br><span class="line">            isMinifyEnabled = <span class="literal">true</span></span><br><span class="line">            proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android-optimize.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(fileTree(mapOf(<span class="string">&quot;dir&quot;</span> to <span class="string">&quot;libs&quot;</span>, <span class="string">&quot;include&quot;</span> to listOf(<span class="string">&quot;*.jar&quot;</span>))))</span><br><span class="line">    implementation(<span class="string">&quot;androidx.appcompat:appcompat:1.2.0&quot;</span>)</span><br><span class="line">    implementation( <span class="string">&quot;androidx.constraintlayout:constraintlayout:2.0.2&quot;</span>)</span><br><span class="line">    testImplementation( <span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">    androidTestImplementation( <span class="string">&quot;androidx.test.ext:junit:1.1.2&quot;</span>)</span><br><span class="line">    androidTestImplementation( <span class="string">&quot;androidx.test.espresso:espresso-core:3.3.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gson</span></span><br><span class="line">    implementation (<span class="string">&quot;com.google.code.gson:gson:2.8.6&quot;</span>)</span><br><span class="line">    <span class="comment">//EventBus</span></span><br><span class="line">    implementation (<span class="string">&quot;org.greenrobot:eventbus:3.1.1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    implementation (<span class="string">&quot;com.jakewharton:butterknife:10.2.3&quot;</span>)</span><br><span class="line">    annotationProcessor( <span class="string">&quot;com.jakewharton:butterknife-compiler:10.2.3&quot;</span>)</span><br><span class="line">    implementation( <span class="string">&quot;androidx.core:core-ktx:+&quot;</span>)</span><br><span class="line">    implementation(kotlin(<span class="string">&quot;stdlib-jdk7&quot;</span>, KotlinCompilerVersion.VERSION))</span><br><span class="line">    implementation(<span class="string">&quot;com.squareup.retrofit2:retrofit:2.6.2&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;com.squareup.retrofit2:converter-gson:2.6.2&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;com.google.code.gson:gson:2.8.1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>示例中<code>Android Studio</code>版本为<code>4.1.2</code>,<code>Gradle</code>版本为<code>gradle-6.5-all</code>,<code>Gradle</code>支持<code>Android Studio</code>的插件版本为<code>4.1.1</code></li>
<li>将<code>Groovy DSL</code>改为<code>kotlin DSL</code>时，先将文件名添加一个后缀<code>kts</code>,例：<code>settings.gradle.kts</code></li>
<li>不再支持ext的全局变量定义</li>
<li>参考示例： <a target="_blank" rel="noopener" href="https://github.com/gradle/kotlin-dsl-samples/tree/master/samples/hello-android">https://github.com/gradle/kotlin-dsl-samples/tree/master/samples/hello-android</a></li>
</ol>
<h1><a href="#八-小技巧" class="header-anchor">#</a><span id="八-小技巧">八、 小技巧</span></h1>
<h2><a href="#1-隐藏不需要显示的代码" class="header-anchor">#</a><span id="1-隐藏不需要显示的代码">1. 隐藏不需要显示的代码</span></h2>
<p>在需要折叠的代码块开始位置添加 <code>//region + 说明</code>, 在结束位置添加<code>//endregion</code>，之后使用快捷键<code>ctrl  -</code>来将代码块折叠</p>
<p>在编辑器中添加如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//region + 演示折叠效果</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//endregion</span></span><br></pre></td></tr></table></figure>
<p>显示如下图：</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin3.png" alt="折叠前效果显示"></p>
<p>再使用快捷键<code>ctrl  -</code>，显示效果如下图：<br>
<img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_2.png" alt="折叠效果显示"></p>
<h2><a href="#2-查看kotlin编译后的源码" class="header-anchor">#</a><span id="2-查看kotlin编译后的源码">2. 查看<code>kotlin</code>编译后的源码</span></h2>
<h3><a href="#1-直接在android-studio中查看" class="header-anchor">#</a><span id="1-直接在android-studio中查看">1. 直接在<code>Android Studio</code>中查看</span></h3>
<p>步骤：</p>
<ol>
<li>
<p>选择要查看的<code>kotlin</code>文件，然后点击<strong>Tools–&gt;Kotlin–&gt;Show Kotlin Bytecode</strong>, 如下图所示：</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_loopup_class.png" alt="按钮位置"></p>
 <br>
<p>此时会打开<code>Kotlin Bytecode</code>窗口，如下所示：</p>
 <br>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_loopup_class2.png" alt="Kotlin Bytecode"></p>
 <br>
</li>
<li>
<p>点击<code>Kotlin Bytecode</code>窗口内左上角的 <strong><code>DECOMPILE</code></strong> 按钮就会打开一个新窗口显示出反编译后的的<code>class</code>源码，如下所示：</p>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_loopup_class3.png" alt="源码文件"></p>
</li>
</ol>
<h3><a href="#2-使用命令javap反编译" class="header-anchor">#</a><span id="2-使用命令javap反编译">2. 使用命令<code>javap</code>反编译</span></h3>
<p>步骤：</p>
<ol>
<li>
<p>先在目录 <strong>app–&gt;build–&gt;tmp–&gt;kotlin-classes–&gt;debug–&gt;自己的包名 --&gt;kotlin</strong>下找到<code>class</code>源文件，如下图所示：</p>
<br>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_lookup_class4.png" alt="class文件目录"></p>
</li>
<li>
<p>在命令行中进入到源文件所在目录，之后输入<code>javap</code>命令，结果如下所示：</p>
 <br>
<p><img src="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/kotlin_lookup_class5.png" alt="class文件"></p>
</li>
</ol>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-01-22</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/函数/" title="函数">函数 </a><span class="leancloud_visitors"></span><span>大约8348个字, 27分钟49秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2021/01/22/kotlin学习系列四/,Puppet,Kotlin学习系列四：函数进阶,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><!-- Mermaid diagrams support--><script src="https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  mermaid.initialize({
    startOnLoad: true,
    securityLevel: 'loose',
    flowchart: { htmlLabels: true, useMaxWidth: true },
    classDiagram: {
      layout: 'elk',
      elk: {
        'elk.spacing.nodeNodeBetweenLayers': 200,
        'elk.spacing.nodeNode': 80
      }
    },
    theme: 'default',
    logLevel: 1
  });
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>