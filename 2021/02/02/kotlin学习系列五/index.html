<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>Kotlin学习系列五：类型进阶 · Puppet</title><meta name="description" content="一、前言
二、 类的构造器

1. 基本写法
2. 类的继承
3. 副构造器
4. 构造同名的工厂函数


三、 类与成员的可见性

1. 可见性对比
2. 修饰对象
3. internal与default的对比
4. 构造器的可见性
5. 属性的可见性
6. 顶级声明的可见性


四、 类属性的延"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Kotlin学习系列五：类型进阶</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">二、 类的构造器</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95">1. 基本写法</a></li>
<li><a href="#2-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">2. 类的继承</a></li>
<li><a href="#3-%E5%89%AF%E6%9E%84%E9%80%A0%E5%99%A8">3. 副构造器</a></li>
<li><a href="#4-%E6%9E%84%E9%80%A0%E5%90%8C%E5%90%8D%E7%9A%84%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0">4. 构造同名的工厂函数</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E7%B1%BB%E4%B8%8E%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7">三、 类与成员的可见性</a>
<ul>
<li><a href="#1-%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AF%B9%E6%AF%94">1. 可见性对比</a></li>
<li><a href="#2-%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1">2. 修饰对象</a></li>
<li><a href="#3-internal%E4%B8%8Edefault%E7%9A%84%E5%AF%B9%E6%AF%94">3. <code>internal</code>与<code>default</code>的对比</a></li>
<li><a href="#4-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7">4. 构造器的可见性</a></li>
<li><a href="#5-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7">5. 属性的可见性</a></li>
<li><a href="#6-%E9%A1%B6%E7%BA%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7">6. 顶级声明的可见性</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96">四、 类属性的延迟初始化</a>
<ul>
<li><a href="#1-%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E5%9B%A0">1. 延迟初始化原因</a></li>
<li><a href="#2-%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E7%8E%B0">2. 延迟初始化实现</a>
<ul>
<li><a href="#1-%E4%B8%BA%E9%9C%80%E8%A6%81%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%88%90%E5%91%98%E8%B5%8B%E7%A9%BA%E5%80%BC">1. 为需要延迟初始化的成员赋空值</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97lateinit">2. 使用关键字<code>lateinit</code></a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8lazy">3. 使用<code>lazy</code></a></li>
<li><a href="#4-%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">4. 方案对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E4%BB%A3%E7%90%86%E5%A7%94%E6%89%98-delegate">五、 代理(委托) Delegate</a>
<ul>
<li><a href="#1-%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86">1. 接口代理</a></li>
<li><a href="#2-%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86%E5%A7%94%E6%89%98">2. 属性代理(委托)</a>
<ul>
<li><a href="#1-%E7%9B%B4%E6%8E%A5%E5%A7%94%E6%89%98">1. 直接委托</a></li>
<li><a href="#2-lazy-%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A7%94%E6%89%98">2. <code>lazy</code> 懒加载委托</a></li>
<li><a href="#3-delegatesobservable-%E8%A7%82%E5%AF%9F%E8%80%85%E5%A7%94%E6%89%98">3. <code>Delegates.observable</code> 观察者委托</a></li>
<li><a href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86%E7%B1%BB">4. 自定义属性代理类</a></li>
<li><a href="#5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86">5. 自定义属性代理</a></li>
<li><a href="#6-%E5%A7%94%E6%89%98%E6%A1%88%E4%BE%8B-1%E5%B1%9E%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%B0%81%E8%A3%85">6. 委托案例-1：属性可见性封装</a></li>
<li><a href="#7-%E5%A7%94%E6%89%98%E6%A1%88%E4%BE%8B-2%E6%95%B0%E6%8D%AE%E4%B8%8E-view-%E7%9A%84%E7%BB%91%E5%AE%9A">7. 委托案例-2：数据与 View 的绑定</a></li>
<li><a href="#8-%E5%A7%94%E6%89%98%E6%A1%88%E4%BE%8B-3viewmodel-%E5%A7%94%E6%89%98">8. 委托案例-3：ViewModel 委托</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%8D%95%E4%BE%8B-object">六、 单例 <code>object</code></a>
<ul>
<li><a href="#1-%E5%8D%95%E4%BE%8B%E5%AE%9A%E4%B9%89">1. 单例定义</a></li>
<li><a href="#2-%E8%AE%BF%E9%97%AEobject%E7%9A%84%E6%88%90%E5%91%98">2. 访问<code>object</code>的成员</a></li>
<li><a href="#3-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98jvmstatic">3. 静态成员<code>@JvmStatic</code></a>
<ul>
<li><a href="#1-%E5%9C%A8%E5%8D%95%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8jvmstatic">1. 在单例中使用<code>@JvmStatic</code></a></li>
<li><a href="#2-%E5%9C%A8%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8jvmstatic">2. 在普通类中使用<code>@JvmStatic</code></a></li>
</ul>
</li>
<li><a href="#4-jvmfield">4. <code>@JvmField</code></a>
<ul>
<li><a href="#1-%E5%9C%A8%E5%8D%95%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8jvmfield">1. 在单例中使用<code>@JvmField</code></a></li>
<li><a href="#2-%E5%9C%A8%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8jvmfield">2. 在普通类中使用<code>@JvmField</code></a></li>
</ul>
</li>
<li><a href="#5-object%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">5. <code>object</code>的构造器</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%86%85%E9%83%A8%E7%B1%BBinner-class">七、内部类<code>inner class</code></a>
<ul>
<li><a href="#1-%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9A%E4%B9%89">1. 内部类定义</a></li>
<li><a href="#2-%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96">2. 内部类实例化</a></li>
<li><a href="#3-%E5%8D%95%E4%BE%8Bobject%E7%9A%84%E5%86%85%E9%83%A8object">3. 单例<code>object</code>的内部<code>object</code></a></li>
<li><a href="#4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">4. 匿名内部类</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E6%95%B0%E6%8D%AE%E7%B1%BBdata-class">八、数据类<code>data class</code></a>
<ul>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%AE%9A%E4%B9%89">1. 数据类定义</a></li>
<li><a href="#2-component">2. component</a></li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E8%A7%A3%E6%9E%84">3. 数据类解构</a></li>
<li><a href="#4-javabean-%E4%B8%8E-data-class-%E5%8C%BA%E5%88%AB">4. JavaBean 与 data class 区别</a></li>
<li><a href="#5-data-class-%E6%80%BB%E7%BB%93">5. data class 总结</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D-%E6%9E%9A%E4%B8%BE%E7%B1%BBenum-class">九、枚举类<code>enum class</code></a>
<ul>
<li><a href="#1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9A%E4%B9%89">1. 枚举类定义</a></li>
<li><a href="#2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%B1%9E%E6%80%A7">2. 枚举类属性</a></li>
<li><a href="#3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8">3. 枚举类构造器</a></li>
<li><a href="#4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">4. 枚举类实现接口</a>
<ul>
<li><a href="#1-%E7%BB%9F%E4%B8%80%E5%AE%9E%E7%8E%B0">1. 统一实现</a></li>
<li><a href="#2-%E5%90%84%E8%87%AA%E5%AE%9E%E7%8E%B0">2. 各自实现</a></li>
</ul>
</li>
<li><a href="#5-%E4%B8%BA%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95">5. 为枚举定义扩展</a></li>
<li><a href="#6-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF">6. 枚举类条件分支</a></li>
<li><a href="#7-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F">7. 枚举类比较大小</a></li>
<li><a href="#8-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%8C%BA%E9%97%B4">8. 枚举类区间</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81-%E5%AF%86%E5%B0%81%E7%B1%BBsealed-class">十、密封类<code>sealed class</code></a>
<ul>
<li><a href="#1-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%A6%82%E5%BF%B5">1. 密封类概念</a></li>
<li><a href="#2-%E5%AF%86%E5%B0%81%E7%B1%BB%E5%AE%9A%E4%B9%89">2. 密封类定义</a></li>
<li><a href="#3-%E5%AF%86%E5%B0%81%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB">3. 密封类的子类</a></li>
<li><a href="#4-%E5%AF%86%E5%B0%81%E7%B1%BB%E5%AD%90%E7%B1%BB%E5%88%86%E6%94%AF">4. 密封类子类分支</a></li>
<li><a href="#5-%E5%AF%86%E5%B0%81%E7%B1%BB%E4%BD%BF%E7%94%A8">5. 密封类使用</a></li>
<li><a href="#6-%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AF%B9%E6%AF%94">6. 密封类和枚举类对比</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%86%85%E8%81%94%E7%B1%BBinline-class">十一、内联类<code>inline class</code></a>
<ul>
<li><a href="#1-%E5%86%85%E8%81%94%E7%B1%BB%E6%A6%82%E5%BF%B5">1. 内联类概念</a></li>
<li><a href="#2-%E5%86%85%E8%81%94%E7%B1%BB%E5%AE%9A%E4%B9%89">2. 内联类定义</a></li>
<li><a href="#3-%E5%86%85%E8%81%94%E7%B1%BB%E6%96%B9%E6%B3%95">3. 内联类方法</a></li>
<li><a href="#4-%E5%86%85%E8%81%94%E7%B1%BB%E5%B1%9E%E6%80%A7">4. 内联类属性</a></li>
<li><a href="#5-%E5%86%85%E8%81%94%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">5. 内联类继承关系</a></li>
<li><a href="#6-%E5%86%85%E8%81%94%E7%B1%BB%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96">6. 内联类编译优化</a></li>
<li><a href="#7-%E5%86%85%E8%81%94%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">7. 内联类使用场景</a>
<ul>
<li><a href="#1-%E5%86%85%E8%81%94%E7%B1%BB%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90">1. 内联类官方例子</a></li>
<li><a href="#2-%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E7%B1%BB%E6%A8%A1%E6%8B%9F%E6%9E%9A%E4%B8%BE">2. 使用内联类模拟枚举</a></li>
</ul>
</li>
<li><a href="#8-%E5%86%85%E8%81%94%E7%B1%BB%E7%9A%84%E9%99%90%E5%88%B6">8. 内联类的限制</a></li>
<li><a href="#9-%E5%88%AB%E5%90%8D-typealias-%E4%B8%8E%E5%86%85%E8%81%94%E7%B1%BB-inline-class-%E5%8C%BA%E5%88%AB">9. 别名 <em>(<code>typealias</code>)</em> 与内联类 <em>(<code>inline class</code>)</em> 区别</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%8C-%E7%A4%BA%E4%BE%8B-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%BA%8F%E5%88%97%E5%8C%96">十二、示例 - 数据类序列化</a>
<ul>
<li><a href="#1-%E5%BC%95%E5%85%A5%E5%B7%A5%E5%85%B7">1. 引入工具</a>
<ul>
<li><a href="#1-gson">1. Gson</a></li>
<li><a href="#2-moshi">2. Moshi</a></li>
<li><a href="#3-kotlinxserialization">3. Kotlinx.serialization</a></li>
</ul>
</li>
<li><a href="#2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">2. 示例代码</a>
<ul>
<li><a href="#1-%E7%AE%80%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96json">1. 简单序列化json</a></li>
<li><a href="#2-%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84json%E5%BA%8F%E5%88%97%E5%8C%96">2. 带默认参数的json序列化</a>
<ul>
<li><a href="#1-gson%E5%A4%84%E7%90%86%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">1. Gson处理默认参数</a></li>
<li><a href="#2-moshi%E5%A4%84%E7%90%86%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">2. Moshi处理默认参数</a></li>
<li><a href="#3-ks%E5%A4%84%E7%90%86%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">3. K.S处理默认参数</a></li>
</ul>
</li>
<li><a href="#3-%E5%B8%A6init%E5%9D%97%E6%88%96%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%BA%8F%E5%88%97%E5%8C%96">3. 带init块或成员初始化的数据类序列化</a>
<ul>
<li><a href="#1-gson%E5%BA%8F%E5%88%97%E5%8C%96%E5%B8%A6init%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB">1. Gson序列化带init块的数据类</a></li>
<li><a href="#2-moshi%E5%BA%8F%E5%88%97%E5%8C%96%E5%B8%A6init%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB">2. Moshi序列化带init块的数据类</a></li>
<li><a href="#3-ks%E5%BA%8F%E5%88%97%E5%8C%96%E5%B8%A6init%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB">3. K.S序列化带init块的数据类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94">3. 框架对比</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89-%E7%A4%BA%E4%BE%8B-%E9%80%92%E5%BD%92%E6%95%B4%E5%9E%8B%E5%88%97%E8%A1%A8">十三、示例 -  递归整型列表</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">十四、参考文章</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 类型进阶</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://github.com/enbandari">Bennyhuo老师</a>讲解的<code>Kotlin</code>系列视频的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程初解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程进阶</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程应用</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-类的构造器" class="header-anchor">#</a><span id="二-类的构造器">二、 类的构造器</span></h1>
<h2><a href="#1-基本写法" class="header-anchor">#</a><span id="1-基本写法">1. 基本写法</span></h2>
<p>将构造器写到类的定义上</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>, name:String) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上定义一个类<code>Person</code>，其中关键字<code>constructor</code>可省略</li>
<li>同时定义了类内的属性<code>age</code>, 类内全局可见</li>
<li>同时定义了一个形参<code>name</code>，构造器内可见 (init 块，属性初始化）</li>
</ol>
<p><strong>init 块：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>, name:String) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> firstName = name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;firstName:<span class="variable">$firstName</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>init</code>块类似于<strong>主构造器</strong> 的方法体，<code>init</code>块可以有多个</p>
</li>
<li>
<p>多个<code>init</code>块会按<strong>从上到下</strong> 的顺序合并执行，上面示例执行顺序如下：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> age: <span class="built_in">Int</span>, name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> firstName: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        firstName = name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>Java</code>中有类似功能，名为构造块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person-构造块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person-静态构造块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>java</code>中执行顺序为：静态构造块 --&gt;构造块 --&gt;构造方法</li>
<li>构造块访问不到构造方法内的形参</li>
</ol>
<h2><a href="#2-类的继承" class="header-anchor">#</a><span id="2-类的继承">2. 类的继承</span></h2>
<p><code>Kotlin</code>中类的继承需要在子类后而加<code>:父类构造器</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> age: <span class="built_in">Int</span>,name: String) :Animal()&#123;</span><br><span class="line">    <span class="keyword">var</span> personName: String</span><br><span class="line">    <span class="keyword">var</span> firstName: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.personName = name</span><br><span class="line">        firstName = name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><a href="#3-副构造器" class="header-anchor">#</a><span id="3-副构造器">3. 副构造器</span></h2>
<p>定义了主构造器后，在类内部再定义的构造器都被称为<strong>副构造器</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> age: <span class="built_in">Int</span>,name: String)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="number">20</span>, <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>副构造器必须调用主构造器</p>
</li>
<li>
<p>若子类没有主构造器，则不必在继承父类时调用构造器，可在<strong>副构造器时调用父类的构造器</strong></p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> :<span class="type">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> personName: String</span><br><span class="line">    <span class="keyword">constructor</span>(personName: String): <span class="keyword">super</span>(<span class="string">&quot;unknown&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.personName = personName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>建议创建类时采用<strong>主构造器 + 默认参数</strong>的方式，这样构造路径较少，减少复杂度</p>
</li>
</ol>
<p><strong>@JvmOverloads</strong>注解</p>
<p><strong>作用：</strong> 主构造器的<strong>默认参数</strong> 在<code>Java</code>代码中可以以重载的形式调用，即可省略</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span>,name: String)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>():<span class="keyword">this</span>(<span class="number">20</span>, <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lee&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如上，若<code>kotlin</code>中主构造器前不加<code>@JvmOverloads</code>注解，则<code>java</code>中的调用语句会报错。</p>
<h2><a href="#4-构造同名的工厂函数" class="header-anchor">#</a><span id="4-构造同名的工厂函数">4. 构造同名的工厂函数</span></h2>
<p>在<code>Kotlin</code>中，定义了一个类情况下，还可以定义同名的函数，该同名函数一般用于构建同名类对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = String()</span><br><span class="line"><span class="keyword">val</span> str1 = String(charArrayOf(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>如上，第一个语句调用的是类<code>String</code>的构造器来创建一个<code>String</code>对象，第二条语句是调用的函数<code>String()</code>来创建一个<code>String</code>对象，该函数入参为<code>CharArray</code>。还可以自定义同名的函数，如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">String</span><span class="params">(ints: <span class="type">IntArray</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> ints.contentToString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><a href="#三-类与成员的可见性" class="header-anchor">#</a><span id="三-类与成员的可见性">三、 类与成员的可见性</span></h1>
<h2><a href="#1-可见性对比" class="header-anchor">#</a><span id="1-可见性对比">1. 可见性对比</span></h2>
<table>
<thead>
<tr>
<th>可见性类型</th>
<th>Java</th>
<th>Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>公开</td>
<td>与 java 相同，默认类型</td>
</tr>
<tr>
<td>internal</td>
<td>X</td>
<td>模块内可见</td>
</tr>
<tr>
<td>default</td>
<td>包内可见，默认</td>
<td>X</td>
</tr>
<tr>
<td>protected</td>
<td>包内及子类可见</td>
<td>类内及子类可见</td>
</tr>
<tr>
<td>private</td>
<td>类内可见</td>
<td>类或文件内可见</td>
</tr>
</tbody>
</table>
<h2><a href="#2-修饰对象" class="header-anchor">#</a><span id="2-修饰对象">2. 修饰对象</span></h2>
<table>
<thead>
<tr>
<th>可见性类型</th>
<th>顶级声明</th>
<th>类</th>
<th>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>internal</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>protected</td>
<td>不可</td>
<td>不可</td>
<td>可以</td>
</tr>
<tr>
<td>private</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ol>
<li><code>internal</code>虽然所有都可以修饰，但是被修饰的对象是模块内可见</li>
<li><code>private</code>虽然所有都可以修饰，但是修饰顶级声明和类时，只是文件内可见；修饰成员的话只是类内可见</li>
</ol>
<p><strong>模块</strong>：在一次调用命令<code>kotlinc</code>的文件当中，<code>internal</code>可见，直观的讲，大致可认为一个<code>Jar</code>包、一个<code>aar</code></p>
<h2><a href="#3-internal与default的对比" class="header-anchor">#</a><span id="3-internal与default的对比">3. <code>internal</code>与<code>default</code>的对比</span></h2>
<ol>
<li>
<p>一般由 SDK 或公共组件开发者用于隐藏模块内部细节实现</p>
</li>
<li>
<p><code>default</code>可通过外部创建相同包名来访问，访问控制非常弱</p>
</li>
<li>
<p><code>default</code>会导致不同抽象层次的类聚集到相同包之下</p>
</li>
<li>
<p><code>internal</code>可方便处理内外隔离，提升模块代码内聚、减少接口暴露</p>
</li>
<li>
<p><code>internal</code>修饰的<code>Kotlin</code>类或成员在<code>Java</code>当中可直接访问，此时若想<code>Java</code>不能调用，需要借助注解<code>@JvmName()</code>为将类或成员添加一个<code>Java</code>识别的<strong>不符合 java 命名规范的名称</strong></p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String = <span class="string">&quot;Lee&quot;</span>, <span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">printPerson</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Person&#123;name=<span class="variable">$name</span>, age=<span class="variable">$age</span>&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.printPerson$ProjectCollection_app();</span><br></pre></td></tr></table></figure>
<p>如上所示，在<code>kotlin</code>中声明了一个<code>internal</code>的类<code>Person</code>，其中有一个用于打印信息的函数<code>printPerson()</code>，正常情况下，在<code>Java</code>文件中，创建<code>Person</code>对象后，可直接调用该函数，在<code>java</code>中该函数名字是<em>方法名 $ 模块名</em><br>
<br></p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String = <span class="string">&quot;Lee&quot;</span>, <span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="meta">@JvmName(<span class="string">&quot;123&quot;</span>)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">printPerson</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Person&#123;name=<span class="variable">$name</span>, age=<span class="variable">$age</span>&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person<span class="number">.123</span>();</span><br></pre></td></tr></table></figure>
<p>如上所示，为函数<code>printPerson()</code>添加了注解<code>@JvmName</code>, 让<code>java</code>识别该函数名为<code>123</code>, 但因<code>Java</code>不支持该命名方式，所以不可以调用该函数</p>
</li>
</ol>
<h2><a href="#4-构造器的可见性" class="header-anchor">#</a><span id="4-构造器的可见性">4. 构造器的可见性</span></h2>
<p>在声明类时若要为声明的主构造器限制作用域，则不可以省略关键字<code>constructor</code><br>
比如说要将该类写成一个单例或写成工厂，则应该将构造器私有化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> name:String)</span><br></pre></td></tr></table></figure>
<h2><a href="#5-属性的可见性" class="header-anchor">#</a><span id="5-属性的可见性">5. 属性的可见性</span></h2>
<p>可在声明属性时直接加可见性关键字进行修饰</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">private</span> <span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> name:String)</span><br></pre></td></tr></table></figure>
<p>如上所示，将属性<code>age</code>私有化，则创建对象<code>person</code>后，无法访问<code>age</code>属性。</p>
<p>还可以为属性的<code>setter</code>添加可见性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">private</span> <span class="keyword">var</span> age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> firstName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>不可以设置<code>getter</code>的可见性，因为<code>getter</code>可见性要与属性保持一致</li>
<li><code>setter</code>的可见性不得大于属性的可见性</li>
</ol>
<h2><a href="#6-顶级声明的可见性" class="header-anchor">#</a><span id="6-顶级声明的可见性">6. 顶级声明的可见性</span></h2>
<ol>
<li>顶级声明批文件内直接定义的属性、函数、类等</li>
<li>顶级声明不支持<code>projected</code>，在<code>kotlin</code>中只有子类可见的含义</li>
<li>顶级声明被<code>private</code>修饰表示文件内部可见</li>
</ol>
<h1><a href="#四-类属性的延迟初始化" class="header-anchor">#</a><span id="四-类属性的延迟初始化">四、 类属性的延迟初始化</span></h1>
<h2><a href="#1-延迟初始化原因" class="header-anchor">#</a><span id="1-延迟初始化原因">1. 延迟初始化原因</span></h2>
<ol>
<li>类属性必须在构造时初始化</li>
<li>某些成员只有在类构造之后才会被初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TextView mTvName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_test);</span><br><span class="line">    mTvName = findViewById(R.id.tv_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，<code>Android</code>中创建了一个名为<code>mTvName</code>的<code>TextView</code>，并在<code>onCreate()</code>方法中为其赋值。但是转换为<code>Kotlin</code>代码时却会在声明变量时报错，因为没有初始化，此时可将变量先定义为可空，然后赋空，再在<code>onCreate()</code>方法中为其赋正确的值。</p>
<h2><a href="#2-延迟初始化实现" class="header-anchor">#</a><span id="2-延迟初始化实现">2. 延迟初始化实现</span></h2>
<h3><a href="#1-为需要延迟初始化的成员赋空值" class="header-anchor">#</a><span id="1-为需要延迟初始化的成员赋空值">1. 为需要延迟初始化的成员赋空值</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mTvName: TextView? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_test)</span><br><span class="line">    mTvName = findViewById(R.id.tv_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，将变量<code>mTvName</code>初始化为了<code>null</code>，再在<code>onCreate()</code>方法中为其赋正确的值，虽然解决了要延后初始化的问题，但每次使用<code>mTvName</code>的属性时都要将其做判空处理或进行类型强转。为解决以上问题可使用关ß键字<code>lateinit</code></p>
<h3><a href="#2-使用关键字lateinit" class="header-anchor">#</a><span id="2-使用关键字lateinit">2. 使用关键字<code>lateinit</code></span></h3>
<p>可在需要延迟初始化的成员声明前加上关键字<code>lateinit</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mTvName: TextView</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_test)</span><br><span class="line">    mTvName = findViewById(R.id.tv_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>使用关键字<code>lateinit</code>修饰的属性必须定义为<code>var</code>，允许再次赋值</li>
<li>关键字<code>lateinit</code>会让编译器忽略变量的初始化，不支持<code>Int</code>等基本类型，只能修饰<strong>非基本类型</strong></li>
<li>在<code>Kotlin</code>的 1.2 版本之后，为属性添加了扩展方法<code>isInitialized</code>，可使用该方法来判断被<code>lateinit</code>修饰的属性是否被初始化，已初始化返回<code>true</code></li>
<li>必须在能够完全确定变量值的生命周期下使用<code>lateinit</code></li>
<li>不要在复杂的逻辑中使用<code>lateinit</code>，否则可读性会很差，不能很清晰的知道在哪里初始化</li>
</ol>
<h3><a href="#3-使用lazy" class="header-anchor">#</a><span id="3-使用lazy">3. 使用<code>lazy</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mTvName <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    findViewById&lt;TextView&gt;(R.id.tv_name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码使用的是属性代理，<code>lazy</code>本身是属性代理的实现，只有<code>mTvName</code>首次被访问时才会执行<code>lambda</code>表达式内代码</li>
<li>如上将声明和初始化放到了一起，可读性较强</li>
</ol>
<h3><a href="#4-方案对比" class="header-anchor">#</a><span id="4-方案对比">4. 方案对比</span></h3>
<table>
<thead>
<tr>
<th>方案名称</th>
<th>优缺点</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>可空类型</td>
<td>增代码复杂度；初始化与声明分离；调用处需要做判空处理</td>
<td>不推荐</td>
</tr>
<tr>
<td>lateinit</td>
<td>初始化与声明分离；调用处虽无需判空处理，但潜在的初始化问题可能被掩盖</td>
<td>一般</td>
</tr>
<tr>
<td>lazy</td>
<td>初始化与声明内聚；无需声明可空类型</td>
<td>推荐</td>
</tr>
</tbody>
</table>
<h1><a href="#五-代理委托-delegate" class="header-anchor">#</a><span id="五-代理委托-delegate">五、 代理(委托) Delegate</span></h1>
<p><strong>接口代理：</strong> 某对象代替某个类实现某个接口<br>
<strong>属性代理：</strong> 某对象代替某属性实现<code>getter/setter</code>方法</p>
<p>代理模式主要由三部分组成：<br>
1. 协议：用来指定代理双方可以做什么，必须做什么。<br>
2. 代理：根据指定的协议，完成委托方要实现的功能。<br>
3. 委托：根据指定的协议，指定代理去完成什么功能。</p>
<h2><a href="#1-接口代理" class="header-anchor">#</a><span id="1-接口代理">1. 接口代理</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TextWatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上声明一个接口<code>TextWatcher</code>，其中三个方法，用于监听文本改变之前，文本改变时，文本改变之后三个状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextWatcherImpl</span> : <span class="type">TextWatcher</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;beforeTextChanged&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;onTextChanged&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;afterTextChanged&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，正常的一个类实现接口时，需要将接口的所有方法全部实现。此时若有一个业务场景：需要在<code>afterTextChanged()</code>方法内做一些其它逻辑，其它两个方法还沿用之前的逻辑，此时应创建一个<code>wrapper</code>类，包装一下<code>TextWathcerImpl</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextWatcherImplWrapper</span>(<span class="keyword">val</span> watcher: TextWatcher) : TextWatcher &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        watcher.beforeTextChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        watcher.onTextChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        watcher.afterTextChanged()</span><br><span class="line">        println(<span class="string">&quot;wrapper&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示，创建一个类<code>TextWatcherImplWrapper</code>除了继承<code>TextWatcherImpl</code>类的功能外，在<code>afterTextChanged()</code>方法里又做了其它操作，相较于<code>TextWatcherImpl</code>类，除了在<code>afterTextChanged()</code>方法做了修改，另外两个方法没有修改，但是还必须创建出来</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextWatcherImplWrapper</span>(<span class="keyword">val</span> watcher: TextWatcher) : TextWatcher <span class="keyword">by</span> watcher &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">        watcher.afterTextChanged()</span><br><span class="line">        println(<span class="string">&quot;wrapper&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>by</code>关键字可以看作是委托，将某操作委托给某对象</p>
</li>
<li>
<p><code>by watcher</code>作用是使对象<code>watcher</code>代替类<code>TextWatcherImplWrapper</code>实现接口<code>TextWatcher</code>，而<code>watcher</code>是作为一个参数传入的</p>
</li>
<li>
<p><code>TextWatcherImplWrapper</code>相当于一个壳，它虽然实现了<code>TextWatcher</code>接口，但并不关心它怎么实现，具体的实现由传入的<code>watcher</code>对象实现</p>
</li>
<li>
<p>对于对象<code>watcher</code>的唯一要求是实现了被代理的接口也就是<code>TextWatcher</code></p>
</li>
<li>
<p>使用此方法后，只需要在包装类内实现需要修改的方法即可，编译器会在编译时将其它方法添加到该类内，编译后的<code>TextWatcherImplWrapper</code>代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TextWatcherImplWrapper</span> <span class="keyword">implements</span> <span class="title class_">TextWatcher</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TextWatcher watcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TextWatcherImplWrapper</span><span class="params">(<span class="meta">@NotNull</span> TextWatcher watcher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.watcher = watcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> TextWatcher <span class="title function_">getWatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.watcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeTextChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.watcher.beforeTextChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTextChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.watcher.onTextChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterTextChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.watcher.afterTextChanged();</span><br><span class="line">        <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="string">&quot;wrapper&quot;</span>;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>说明：</strong></p>
<ol>
<li>以上代码显示， <code>TextWatcher</code> 接口的三个方法的实现委托给了传入的对象<code>watcher</code>。</li>
<li><code>Kotlin</code>的委托类提供了 <strong>语法层面的委托模式</strong>。</li>
<li>通过 <code>by</code> 关键字，就可以自动将接口里的方法委托给一个对象，从而可以帮我们省略很多接口方法适配的模板代码。</li>
</ol>
<h2><a href="#2-属性代理委托" class="header-anchor">#</a><span id="2-属性代理委托">2. 属性代理(委托)</span></h2>
<p><strong><code>Kotlin</code> “代理类”代理的是接口方法，而“代理属性”委托的，则是属性的 <code>getter</code>、<code>setter</code>。</strong> 我们知道 <code>val</code> 定义的属性，它只有 <code>get()</code> 方法；而 <code>var</code> 定义的属性，既有 <code>get()</code> 方法，也有 <code>set()</code> 方法。<code>Kotlin</code> 提供了好几种标准委托，其中包括两个属性之间的直接委托、<code>by lazy</code> 懒加载委托、<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/delegated-properties.html#observable-properties"><code>Delegates.observable</code> 观察者委托</a>，以及 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/delegated-properties.html#storing-properties-in-a-map"><code>by map</code> 映射委托</a>。前面两个的使用频率比较高，后面两个频率比较低。</p>
<h3><a href="#1-直接委托" class="header-anchor">#</a><span id="1-直接委托">1. 直接委托</span></h3>
<p>直接委托即将属性A 委托给属性B，从<code>Kotlin</code>1.4开始，我们可以直接在语法层面将 “属性A”委托给“属性B”，就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> total: <span class="built_in">Int</span> <span class="keyword">by</span> ::count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>以上代码定义了两个变量，<code>count</code> 和 <code>total</code>，其中 <code>total</code> 的值与 <code>count</code> 完全一致，因为我们把 <code>total</code> 这个属性的 <code>getter</code> 和 <code>setter</code> 都委托给了 <code>count</code>。</li>
<li>使用<code>by</code>关键字，代表 <code>total</code> 属性的 <code>getter</code>、<code>setter</code> 会被委托出去。</li>
<li><code>::count</code> 代表 <code>total</code> 被委托给了 <code>count</code>。这里的 <code>“::count”</code> 是属性的引用，它跟我们前面学过的函数引用是一样的概念。</li>
<li><code>total</code> 和 <code>count</code> 两者之间的委托关系一旦建立，就代表了它们两者的 <code>getter</code> 和 <code>setter</code> 会完全绑定在一起，反编译后代码如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> int count;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> KMutableProperty0 total$delegate = new Item$total$<span class="number">2</span>((Item)<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> int getCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setCount(int var1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.count = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> int getTotal() &#123;</span><br><span class="line">      KProperty0 var1 = (KProperty0)<span class="keyword">this</span>.total$delegate;</span><br><span class="line">      Object var3 = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> ((Number)var1.<span class="keyword">get</span>()).intValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setTotal(int var1) &#123;</span><br><span class="line">      KMutableProperty0 var2 = <span class="keyword">this</span>.total$delegate;</span><br><span class="line">      Object var4 = <span class="literal">null</span>;</span><br><span class="line">      Integer var5 = var1;</span><br><span class="line">      var2.<span class="keyword">set</span>(var5);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item$total$2.java</span></span><br><span class="line"><span class="keyword">package</span> cn.xdf.pad.launchtasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.Metadata;</span><br><span class="line"><span class="keyword">import</span> kotlin.jvm.<span class="keyword">internal</span>.MutablePropertyReference0Impl;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Item</span>$<span class="title">total</span>$2 <span class="title">extends</span> <span class="title">MutablePropertyReference0Impl</span> &#123;</span><br><span class="line">   Item$total$<span class="number">2</span>(Item var1) &#123;</span><br><span class="line">      <span class="keyword">super</span>(var1, Item.<span class="keyword">class</span>, <span class="string">&quot;count&quot;</span>, <span class="string">&quot;getCount()I&quot;</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Item)<span class="keyword">this</span>.receiver).getCount();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> void <span class="keyword">set</span>(<span class="meta">@Nullable</span> Object value) &#123;</span><br><span class="line">      ((Item)<span class="keyword">this</span>.receiver).setCount(((Number)value).intValue());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>底层生成一个名为<code>Item$total$2</code>的<code>delegate</code>来实现代理关系</li>
<li>调用 <code>total</code>的<code>setter</code>方法及<code>getter</code>方法时会通过生成的<code>delegate</code>来调用<code>count</code>的<code>setter</code>方法及<code>getter</code>方法</li>
<li>因为 <code>total</code>被委托了<code>setter</code>及<code>getter</code>，所以<code>total</code>不需要存值，没有<code>field</code></li>
</ol>
<p><strong>总结：</strong></p>
<p>直接委托特性，其实对我们 <strong>软件版本之间的兼容</strong> 很有帮助。假设 <code>Item</code> 是服务端接口的返回数据，1.0 版本的时候，我们的 <code>Item</code> 当中只 <code>count</code> 这一个变量而到了 2.0 版本的时候，我们需要将 <code>count</code> 修改成 <code>total</code>，这时候问题就出现了，如果我们直接将 <code>count</code> 修改成 <code>total</code>，我们的老用户就无法正常使用了。但如果我们借助委托，就可以很方便地实现这种兼容。我们可以定义一个新的变量 <code>total</code>，然后将其委托给 <code>count</code>，这样的话，2.0 的用户访问 <code>total</code>，而 1.0 的用户访问原来的 <code>count</code>，由于它们是委托关系，也不必担心数值不一致的问题。</p>
<h3><a href="#2-lazy-懒加载委托" class="header-anchor">#</a><span id="2-lazy-懒加载委托">2. <code>lazy</code> 懒加载委托</span></h3>
<p>懒加载，就是对于一些需要消耗计算机资源的操作，我们希望它在被访问的时候才去触发，从而避免不必要的资源开销。</p>
<p><strong>lazy 的源码如下：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:kotlin</span>.jvm.JvmName(<span class="string">&quot;LazyKt&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</span><br><span class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line">    <span class="comment">// final field is required to enable safe publication of constructed instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> _v1 = _value</span><br><span class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">val</span> _v2 = _value</span><br><span class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (_v2 <span class="keyword">as</span> T)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> typedValue = initializer!!()</span><br><span class="line">                    _value = typedValue</span><br><span class="line">                    initializer = <span class="literal">null</span></span><br><span class="line">                    typedValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = _value !== UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (isInitialized()) value.toString() <span class="keyword">else</span> <span class="string">&quot;Lazy value not initialized yet.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeReplace</span><span class="params">()</span></span>: Any = InitializedLazyImpl(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Lazy<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>lazy</code>实际上是一个函数，它接收了一个函数，即<code>lazy</code>为高阶函数</li>
<li><code>lazy</code>函数返回一个<code>lazy</code>对象，该对象代理了<strong>某个对象的实例的某属性的<code>getter</code></strong></li>
<li><code>lazy</code>只能代理只读属性 <em>（即用<code>val</code>修饰的属性）</em> 的<code>getter</code></li>
<li>其<code>lazy</code>的扩展函数<code>getValue()</code>, 其中入参<code>thisRef: Any?</code>表示属性所在类的实例；<code>property: KProperty&lt;*&gt;</code>表示所代理的属性的引用</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> firstName <span class="keyword">by</span> lazy &#123; name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，接口<code>lazy</code>的实例代理了类<code>Person</code>的实例的属性<code>firstName</code>的<code>getter</code>方法，每次访问<code>firstName</code>时都会将<code>lazy</code>内的值返回出来，只有第一次调用时会计算，之后会存储起来。经过编译器编译后如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Lazy firstName$delegate;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> List getFirstName() &#123;</span><br><span class="line">      Lazy var1 = <span class="keyword">this</span>.firstName$delegate;</span><br><span class="line">      <span class="keyword">return</span> (List)var1.getValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Person(<span class="meta">@NotNull</span> String name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.firstName$delegate = LazyKt.lazy((Function0)(new Function0() &#123;</span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> Object invoke() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invoke();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> List invoke() &#123;</span><br><span class="line">            <span class="keyword">return</span> StringsKt.split$default((CharSequence)Person.<span class="keyword">this</span>.getName(), new char[]&#123;<span class="string">&quot; &quot;</span>.charAt(<span class="number">0</span>)&#125;, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">6</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#3-delegatesobservable-观察者委托" class="header-anchor">#</a><span id="3-delegatesobservable-观察者委托">3. <code>Delegates.observable</code> 观察者委托</span></h3>
<p><code>Delegates.observable</code>源码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin.properties</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> Delegates &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">observable</span><span class="params">(initialValue: <span class="type">T</span>, <span class="keyword">crossinline</span> onChange: (<span class="type">property</span>: <span class="type">KProperty</span>&lt;*&gt;, <span class="type">oldValue</span>: <span class="type">T</span>, <span class="type">newValue</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>:</span><br><span class="line">        ReadWriteProperty&lt;Any?, T&gt; =</span><br><span class="line">    <span class="keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">T</span>, newValue: <span class="type">T</span>)</span></span> = onChange(property, oldValue, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin.properties</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ObservableProperty</span>&lt;<span class="type">V</span>&gt;(initialValue: V) : ReadWriteProperty&lt;Any?, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = initialValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">V</span>, newValue: <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">V</span>, newValue: <span class="type">V</span>)</span></span>: <span class="built_in">Unit</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">if</span> (!beforeChange(property, oldValue, value)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        afterChange(property, oldValue, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin.properties</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in T, V</span>&gt; : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">T, V</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Delegates.observable</code>返回了一个对象<code>ObservableProperty</code>, 该对象实现了接口<code>ReadWriteProperty</code>，因此有<code>getValue()</code>方法和<code>setValue()</code>方法，因此所代理的属性应为<strong>可读写属性</strong> <em>（即用 var 声明的属性）</em></li>
<li>接口<code>ReadWriteProperty</code>的<code>getValue()</code>方法和<code>setValue()</code>方法第一个参数为该属性所在类，第二个参数为所要代理的属性</li>
<li><code>ObservableProperty</code>的实例代理了属性的<code>getter</code>和<code>setter</code></li>
<li>在<code>setValue()</code>方法中会执行<code>afterChange()</code>函数，<code>afterChange()</code>函数包含三个入参<code>property</code>表示当前属性，<code>oldValue</code>表示改变之前的值，<code>value</code>表示改变之后的值</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">    <span class="comment">//代理getter</span></span><br><span class="line">    <span class="keyword">val</span> firstName <span class="keyword">by</span> lazy &#123; name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> secondName: String <span class="keyword">by</span> Delegates.observable(name.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;value changed from <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义属性时使用关键字<code>by</code>定义要代理属性的对象</li>
<li><code>Delegates.observable</code>对象后跟的<code>lambda</code>表达式即为上面提到的<code>afterChange()</code>函数，它可以获取当前属性、改变之前的值、改变之后的值</li>
</ol>
<h3><a href="#4-自定义属性代理类" class="header-anchor">#</a><span id="4-自定义属性代理类">4. 自定义属性代理类</span></h3>
<p>经过看<code>lazy</code>和<code>observale</code>源码可以发现，他们之所以可以代理属性，是因为实现了<code>getVaue()</code>、<code>setValue()</code>这两个运算符，所以只要实现了这两个运算符可即代理属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str:String <span class="keyword">by</span> ProxyX(<span class="string">&quot;321&quot;</span>)</span><br><span class="line">    println(str)</span><br><span class="line">    str = <span class="string">&quot;123&quot;</span></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyX</span>(<span class="keyword">private</span> <span class="keyword">var</span> initialValue: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = initialValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$value</span>-Proxy&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value + value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">321</span>-Proxy</span><br><span class="line"><span class="number">321123</span>-Proxy</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>声明了一个代理类<code>ProxyX</code>，代理可读写属性，传入一个初始值，实现<code>getValue()</code>方法和<code>setValue()</code>方法</p>
</li>
<li>
<p><code>getValue()</code>方法功能为：取值时返回一个字符串，该字符串是值加一个常量</p>
</li>
<li>
<p><code>setValue()</code>方法功能为：将新添加的值拼接到原值的后面</p>
</li>
<li>
<p>对于<code>var</code>修饰的属性，我们必须要有 <code>getValue</code>、<code>setValue</code> 这两个方法，同时，这两个方法必须有 <code>operator</code> 关键字修饰。</p>
</li>
<li>
<p>由于我们的 <code>str</code> 属性是 <code>String</code> 类型的，为了实现对它的委托，<code>getValue</code> 的返回值类型，以及 <code>setValue</code> 的参数类型，都必须是 <code>String</code> 类型或者是它的父类。大部分情况下，这三处的类型都应该是一致的。</p>
</li>
<li>
<p>而如果你觉得这样的写法实在很繁琐，也可以借助 <code>Kotlin</code> 提供的 <code>ReadWriteProperty</code>、<code>ReadOnlyProperty</code> 这两个接口，来自定义委托。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> ReadOnlyProperty<span class="type">&lt;in T, out V&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in T, V</span>&gt; : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">T, V</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3><a href="#5-自定义属性代理" class="header-anchor">#</a><span id="5-自定义属性代理">5. 自定义属性代理</span></h3>
<p><strong>实现效果：</strong> 将<code>.properties</code>文件中的内容以变量的方式展示，以方便用户读写，文件中包含<code>author</code>、<code>version</code>、<code>desc</code>等信息</p>
<p>在工程里的<code>resources</code>文件夹下创建<code>Config.properties</code>文件，如下图所示：</p>
<p><img src="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/kotlin_proxy_properties_1.png" alt></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PropertiesDelegate</span>(<span class="keyword">private</span> <span class="keyword">val</span> path: String, <span class="keyword">private</span> <span class="keyword">val</span> defaultValue: String = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> url: URL</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> properties: Properties <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">val</span> prop = Properties()</span><br><span class="line">        url = <span class="keyword">try</span> &#123;</span><br><span class="line">            javaClass.getResourceAsStream(path).use &#123;</span><br><span class="line">                prop.load(it)</span><br><span class="line">            &#125;</span><br><span class="line">            javaClass.getResource(path)!!</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassLoader.getSystemClassLoader().getResourceAsStream(path).use &#123;</span><br><span class="line">                    prop.load(it)</span><br><span class="line">                &#125;</span><br><span class="line">                ClassLoader.getSystemClassLoader().getResource(path)!!</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                FileInputStream(path).use &#123;</span><br><span class="line">                    prop.load(it)</span><br><span class="line">                &#125;</span><br><span class="line">                URL(<span class="string">&quot;file://<span class="subst">$&#123;File(path).canonicalPath&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(property.name, defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        properties.setProperty(property.name, value)</span><br><span class="line">        File(url.toURI()).outputStream().use &#123;</span><br><span class="line">            properties.store(it, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsProperties</span>(path: String) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> prop = PropertiesDelegate(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>: <span class="type">AbsProperties</span>(<span class="string">&quot;Config.properties&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> author <span class="keyword">by</span> prop</span><br><span class="line">    <span class="keyword">var</span> version <span class="keyword">by</span> prop</span><br><span class="line">    <span class="keyword">var</span> desc <span class="keyword">by</span> prop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> config = Config()</span><br><span class="line">    println(config.author)</span><br><span class="line">    println(config.version)</span><br><span class="line">    config.version = <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line">    println(config.desc)</span><br><span class="line">    println(config.version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>resources</code>文件夹下内容编译完成后会被复制到<code>classpath</code>下，所以使用<code>ClassLoader</code>可以读取到文件</p>
</li>
<li>
<p><code>resources</code>文件夹内容编译后位置如下图所示：</p>
<p><img src="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/kotlin_proxy_properties_2.png" alt></p>
</li>
<li>
<p>上述代码创建一个<code>Properties</code>的代理类<code>PropertiesDelegate</code>，入参为一个地址，功能为：获取该地址文件里的所有属性值。</p>
</li>
<li>
<p>注意创建的变量名要与<code>Config.properties</code>文件中的键值对里的键名一致，否则无法读取出属性</p>
</li>
<li>
<p>代理类<code>PropertiesDelegate</code>也可以重新设置属性值，设置的属性值保存在编译后的文件内，并没有改变源文件，在修改时会自动添加所写的<code>comments</code>即<code>Hello</code>，并且自动添加了修改时间，效果上看上去就像是一个提交纪录</p>
<p><img src="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/kotlin_proxy_properties_3.png" alt></p>
</li>
</ol>
<h3><a href="#6-委托案例-1属性可见性封装" class="header-anchor">#</a><span id="6-委托案例-1属性可见性封装">6. 委托案例-1：属性可见性封装</span></h3>
<p>在软件设计当中，我们会遇到这样的需求：对于某个成员变量 <code>data</code>，我们希望类的外部可以访问它的值，但不允许类的外部修改它的值。因此我们经常会写出类似这样的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span>: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 网络请求</span></span><br><span class="line">        <span class="keyword">data</span> = <span class="string">&quot;请求结果&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
我们将 <code>data</code> 属性的 <code>set</code> 方法声明为 <code>private</code> 的，这时候，<code>data</code> 属性的 <code>set</code> 方法只能从类的内部访问，这就意味着类的外部无法修改 <code>data</code> 的值了，但类的外部仍然可以访问 <code>data</code> 的值。这样的代码模式很常见，我们在 <code>Java</code> 当中也经常使用，不过当我们的 <code>data</code> 类型从 <code>String</code> 变成集合以后就不行了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 网络请求</span></span><br><span class="line">        <span class="keyword">data</span>.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> model = Model()</span><br><span class="line">    <span class="comment">// 类的外部仍然可以修改data</span></span><br><span class="line">    model.<span class="keyword">data</span>.add(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
对于集合而言，即使我们将其定义为只读变量 <code>val</code>，类的外部一旦获取到 <code>data</code> 的实例，它仍然可以调用集合的 <code>add()</code> 方法修改它的值。这个问题在 <code>Java</code> 当中几乎没有优雅的解法。只要你暴露了集合的实例给外部，外部就可以随意修改集合的值。这往往也是 <code>Bug</code> 的来源，这样的 <code>Bug</code> 还非常难排查。</p>
<p><em>小知识：</em><br>
<em>1. 使用<code>val</code>修饰的变量是只读变量，指该变量没有<code>setter</code>方法，只有<code>getter</code>方法，也就是说该 变量无法被重新赋值</em><br>
<em>2. <code>mutable</code>集合指集合可变，也就是说集合元素可以变化，因此使用<code>val</code>修饰<code>mutableList</code>类型的变量<code>data</code>指的是<code>data</code>不会被重新赋一个其它的集合，但是<code>data</code>可以修改它的元素</em></p>
<p>上述提到的问题可以使用 <strong>两个属性之间的委托</strong> 的方法来解决</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt; <span class="keyword">by</span> ::_data</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _data: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _data.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
在上面的代码中，我们定义了两个变量，一个变量是公开的“<code>data</code>”，它的类型是 <code>List</code>，这是 <code>Kotlin</code> 当中不可修改的 <code>List</code>，它是没有 <code>add</code>、<code>remove</code> 等方法的。接着，我们通过委托语法，将 <code>data</code> 的 <code>getter</code> 委托给了 <code>_data</code> 这个属性。而 <code>_data</code> 这个属性的类型是 <code>MutableList</code>，这是 <code>Kotlin</code> 当中的可变集合，它是有 <code>add</code>、<code>remove</code> 方法的。由于它是 <code>private</code> 修饰的，类的外部无法直接访问，通过这种方式，我们就成功地将修改权保留在了类的内部，而类的外部访问是不可变的 <code>List</code>，因此类的外部只能访问数据。</p>
<h3><a href="#7-委托案例-2数据与-view-的绑定" class="header-anchor">#</a><span id="7-委托案例-2数据与-view-的绑定">7. 委托案例-2：数据与 View 的绑定</span></h3>
<p>在 <code>Android</code> 当中，如果我们要对“数据”与“<code>View</code>”进行绑定，我们可以用 <code>DataBinding</code>，不过 <code>DataBinding</code> 太重了，也会影响编译速度。其实，除了 <code>DataBinding</code> 以外，我们还可以借助 <code>Kotlin</code> 的自定义委托属性来实现类似的功能。这种方式不一定完美，但也是一个有趣的思路。这里我们以 <code>TextView</code> 为例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> TextView.<span class="title">provideDelegate</span><span class="params">(value: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">object</span> : ReadWriteProperty&lt;Any?, String?&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String? = text</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        text = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
以上的代码，我们为 <code>TextView</code> 定义了一个扩展函数 <code>TextView.provideDelegate</code>，而这个扩展函数的返回值类型是 <code>ReadWriteProperty</code>。通过这样的方式，我们的 <code>TextView</code> 就相当于支持了 <code>String</code> 属性的委托，并且将<code>String</code>值与<code>TextView</code>的<code>text</code>绑定到一起。<br>
它的使用方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> textView = findViewById&lt;textView&gt;(R.id.textView)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message: String? <span class="keyword">by</span> textView</span><br><span class="line"></span><br><span class="line">textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">println(message)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;World&quot;</span></span><br><span class="line">println(textView.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>我们通过委托的方式，将 <code>message</code> 委托给了 <code>textView</code>。这意味着，<code>message</code> 的 <code>getter</code> 和 <code>setter</code> 都将与 <code>TextView</code> 关联到一起。</li>
<li>当我们修改 <code>textView</code> 的 <code>text</code> 属性，由于我们的 <code>message</code> 也委托给了 <code>textView</code>，因此这时候，<code>println(message)</code> 的结果也会变成“<code>Hello</code>”。</li>
<li>当我们修改 <code>message</code> 的值，由于 <code>message</code> 的 <code>setter</code> 也委托给了 <code>textView</code>，因此这时候，<code>println(textView.text)</code> 的结果会跟着变成“<code>World</code>”。</li>
</ol>
<h3><a href="#8-委托案例-3viewmodel-委托" class="header-anchor">#</a><span id="8-委托案例-3viewmodel-委托">8. 委托案例-3：ViewModel 委托</span></h3>
<p>在 <code>Android</code> 当中，我们会经常用到 <code>ViewModel</code> 来存储界面数据。同时，我们不会直接创建 <code>ViewModel</code> 的实例，而对应的，我们会使用委托的方式来实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainViewModel: MainViewModel <span class="keyword">by</span> viewModels()</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
如上所示通过<code>viewModels()</code>方法实现<code>mainViewModel</code>的委托</p>
<p>我们先来看看 <code>viewModels()</code> 是如何实现的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> VM : ViewModel&gt;</span> ComponentActivity.<span class="title">viewModels</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> factoryProducer: (() -&gt; <span class="type">Factory</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Lazy&lt;VM&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> factoryPromise = factoryProducer ?: &#123;</span><br><span class="line">        defaultViewModelProviderFactory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ViewModelLazy(VM::<span class="keyword">class</span>, &#123; viewModelStore &#125;, factoryPromise)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lazy</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>如上代码所示，<code>viewModels()</code> 是 <code>Activity</code> 的一个扩展函数。也是因为这个原因，我们才可以直接在 <code>Activity</code> 当中直接调用 <code>viewModels()</code> 这个方法。另外，我们注意到，<code>viewModels()</code> 这个方法的返回值类型是 <code>Lazy</code>，那么，它是如何实现委托功能的呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Lazy<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = value</span><br></pre></td></tr></table></figure>
<p>实际上，<code>Lazy</code> 类在外部还定义了一个扩展函数 <code>getValue()</code>，这样，我们的只读属性的委托就实现了。而 <code>Android</code> 官方这样的代码设计，就再一次体现了职责划分、关注点分离的原则。<code>Lazy</code> 类只包含核心的成员，其他附属功能，以扩展的形式在 <code>Lazy</code> 外部提供。</p>
<h1><a href="#六-单例-object" class="header-anchor">#</a><span id="六-单例-object">六、 单例 <code>object</code></span></h1>
<h2><a href="#1-单例定义" class="header-anchor">#</a><span id="1-单例定义">1. 单例定义</span></h2>
<p><code>Kotlin</code>中使用关键字<code>object</code>来定义<strong>饿汉式单例</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，只需要关键字<code>object</code>后加一个类名即可创建一个饿汉式单例，它等价于<code>Java</code>中如下所示的单例定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-访问object的成员" class="header-anchor">#</a><span id="2-访问object的成员">2. 访问<code>object</code>的成员</span></h2>
<p><code>object</code>定义的单例可以当做类一样去添加成员属性，成员函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span> = <span class="number">26</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.plus()</span><br><span class="line">    println(<span class="string">&quot;value<span class="subst">$&#123;Singleton.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.INSTANCE.plus();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span>+ Singleton.INSTANCE.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，在<code>kotlin</code>定义了一个单例<code>Singleton</code>，在<code>kotlin</code>中调用时直接使用单例的名字即可调用，但是在<code>java</code>调用时需要加一个<code>INSTANCE</code>，上述定义单例代码经过编译反后的<code>class</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">      value = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">plus</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">var10000</span> <span class="operator">=</span> value++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      value = <span class="number">26</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-静态成员jvmstatic" class="header-anchor">#</a><span id="3-静态成员jvmstatic">3. 静态成员<code>@JvmStatic</code></span></h2>
<p>因<code>kotlin</code>是跨平台语言，其中<code>C</code>语言、<code>JavaScript</code>等都没有静态成员概念，所在<code>kotlin</code>没有静态成员的概念，但可以使用注解<code>JvmStatic</code>来模拟。</p>
<h3><a href="#1-在单例中使用jvmstatic" class="header-anchor">#</a><span id="1-在单例中使用jvmstatic">1. 在单例中使用<code>@JvmStatic</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span> <span class="keyword">var</span> value: <span class="built_in">Int</span> = <span class="number">26</span></span><br><span class="line">    <span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.plus()</span><br><span class="line">    println(<span class="string">&quot;value<span class="subst">$&#123;Singleton.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.plus();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span>+ Singleton.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，在<code>kotlin</code>中定义单例时为其成员添加了注解<code>@JvmStatic</code>。</li>
<li>在<code>kotlin</code>中调用单例成员时没有任何变化</li>
<li>在<code>java</code>中调用单例成员时可省略<code>INSTANCE</code>，可直接视同其调用静态成员</li>
</ol>
<p>上述定义添加注解的单例代码经过反编译后的<code>class</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">      value = var0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">plus</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">var10000</span> <span class="operator">=</span> value++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      value = <span class="number">26</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-在普通类中使用jvmstatic" class="header-anchor">#</a><span id="2-在普通类中使用jvmstatic">2. 在普通类中使用<code>@JvmStatic</code></span></h3>
<p><strong>注解<code>JvmStatic</code>只能使用在单例或普通类的伴生对象里的成员上</strong><br>
<strong>伴生对象 <em>(companion objects)</em>：</strong> 是一个类的伴生对象，定义一个类时可以同时在类内定义定义一个<code>object</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmField</span> <span class="keyword">var</span> value:String = <span class="string">&quot;Test&quot;</span></span><br><span class="line">        <span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">y</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Foo.y()</span><br><span class="line">    println(<span class="string">&quot;value:<span class="subst">$&#123;Foo.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Foo.y();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span>+ Foo.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，在<code>kotlin</code>中定义伴生对象时使用<code>companion object</code></li>
<li>在<code>kotlin</code>中调用类的伴生对象中的静态成员时，直接使用类名即可</li>
<li>在<code>java</code>中调用类的伴生对象中的静态成员时，直接使用类名即可</li>
</ol>
<p>上述定义伴生对象的类代码经过反编译后的<code>class</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">   <span class="meta">@JvmField</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Foo.<span class="type">Companion</span> <span class="variable">Companion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>.Companion((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">      Companion.y();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Companion</span> &#123;</span><br><span class="line">      <span class="meta">@JvmStatic</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">         System.out.println(var1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Companion</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Companion</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#4-jvmfield" class="header-anchor">#</a><span id="4-jvmfield">4. <code>@JvmField</code></span></h2>
<p><strong>注解<code>@JvmField</code>作用：</strong> 不生成<code>getter/setter</code>，但不会给所修饰的属性添加静态属性，只是该属性变成<code>public</code></p>
<h3><a href="#1-在单例中使用jvmfield" class="header-anchor">#</a><span id="1-在单例中使用jvmfield">1. 在单例中使用<code>@JvmField</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> value: <span class="built_in">Int</span> = <span class="number">26</span></span><br><span class="line">    <span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.plus()</span><br><span class="line">    println(<span class="string">&quot;value<span class="subst">$&#123;Singleton.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.plus();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span>+ Singleton.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，为单例中的属性<code>value</code>添加注解<code>@JvmField</code></li>
<li><code>kotlin</code>中调用并没有改变</li>
<li><code>java</code>中调用时直接使用该变量名，它成为了一个全局静态变量</li>
</ol>
<p>上述定义添加注解的单例代码经过反编译后的<code>class</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="meta">@JvmField</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">plus</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">var10000</span> <span class="operator">=</span> value++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      value = <span class="number">26</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-在普通类中使用jvmfield" class="header-anchor">#</a><span id="2-在普通类中使用jvmfield">2. 在普通类中使用<code>@JvmField</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> foo = Foo()</span><br><span class="line">    println(foo.x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    System.out.println(foo.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，在普通类中使用注解<code>@JvmField</code>修饰一个属性</li>
<li>注解<code>@JvmField</code>并没有给属性静态属性，所以必须要声明一个对象再调用它</li>
</ol>
<p>上述定义添加注解的普通类经过反编译后的<code>class</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">   <span class="meta">@JvmField</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#5-object的构造器" class="header-anchor">#</a><span id="5-object的构造器">5. <code>object</code>的构造器</span></h2>
<p><code>kotlin</code>中使用<code>object</code>定义的单例不能自定义构造器，系统会自动生成一个无参构造器，但是可以自定义若干个<code>init</code>块</p>
<p><code>kotlin</code>中单例可以与普通类一样继承或实现其它的类或接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> value: <span class="built_in">Int</span> = <span class="number">26</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        value *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码经过反编译后的<code>class</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="meta">@JvmField</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      value = <span class="number">26</span>;</span><br><span class="line">      value *= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><a href="#七-内部类inner-class" class="header-anchor">#</a><span id="七-内部类inner-class">七、内部类<code>inner class</code></span></h1>
<h2><a href="#1-内部类定义" class="header-anchor">#</a><span id="1-内部类定义">1. 内部类定义</span></h2>
<p>在<code>Java</code>中定义内部类，只需在一个类内再定义一个类，类内的类即为内部类，内部类分为一般内部类、静态内部类。一般内部类持有外部类的引用，所以有可能引起内存泄露，静态内部类没有外部类的引用，所以不能直接调用外部的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kotlin</code>中定义<strong>非静态内部类</strong> 使用关键字<code>inner</code>，而不加关键字的类内类是<strong>静态内部类</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StaticInner</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-内部类实例化" class="header-anchor">#</a><span id="2-内部类实例化">2. 内部类实例化</span></h2>
<p>对于内部类的实例化，<code>java</code>和<code>kotlin</code>操作相同。<br>
初始化非静态内部类时需要<strong>先构造外部类对象</strong> ，然后再拿对象去初始化内部类<br>
初始化静态内部类时，只引用了<strong>外部类的类名</strong> ，不需要初始化外部类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin --非静态内部类</span></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">inner</span> = Outer().Inner()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java --非静态内部类</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin --静态内部类</span></span><br><span class="line"><span class="keyword">val</span> staticInner = Outer.StaticInner()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java --静态内部类</span></span><br><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br></pre></td></tr></table></figure>
<h2><a href="#3-单例object的内部object" class="header-anchor">#</a><span id="3-单例object的内部object">3. 单例<code>object</code>的内部<code>object</code></span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> OuterObject &#123;</span><br><span class="line">    <span class="keyword">object</span> InnerObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>object</code>一旦定义完成后即会被实例化，不存在非静态的情况，故不可用<code>inner</code>修饰</p>
<h2><a href="#4-匿名内部类" class="header-anchor">#</a><span id="4-匿名内部类">4. 匿名内部类</span></h2>
<p><code>java</code>中的匿名内部类表现形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>kotlin</code>中的匿名内部类形式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> btn: Button = Button(context)</span><br><span class="line">btn.post &#123; <span class="keyword">object</span>: Runnable, Closeable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>匿名内部类如果定义在非静态区域内就会持有外部引用，容易造成内存泄漏。</li>
<li><strong>静态区域</strong> 即静态方法、静态类。在<code>kotlin</code>中如果定义在伴生对象中或顶级函数内都不会持有外部引用</li>
<li>如上所示，<code>kotlin</code>中定义匿名内部类只是省略了名字，并且可以<strong>继承父类或实现多个接口</strong></li>
<li>实现多个接口的匿名内部类的类型为 <em><strong>交叉类型</strong></em>，如上代码<code>Buttn</code>的<code>post</code>方法里的匿名内部类类型为<code>Cloneable &amp; Runnable</code></li>
<li>若<code>java</code>中要实现<code>kotlin</code>中匿名内部类的可以继承父类或实现多个接口的效果，可以使用<strong>本地类</strong></li>
</ol>
<p><strong>本地类</strong></p>
<p>本地类又称为局部内部类，理解为有名字的匿名类。它是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于<strong>局部内部类的访问仅限于方法内或者该作用域内</strong>。局部内部类就像是方法里面的一个局部变量一样，是不能有 <code>public</code>、<code>protected</code>、<code>private</code> 以及 <code>static</code> 修饰符的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PreOperation</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Closeable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PreOperation</span> <span class="variable">preOperation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreOperation</span>();</span><br><span class="line">    preOperation.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><a href="#八-数据类data-class" class="header-anchor">#</a><span id="八-数据类data-class">八、数据类<code>data class</code></span></h1>
<h2><a href="#1-数据类定义" class="header-anchor">#</a><span id="1-数据类定义">1. 数据类定义</span></h2>
<p>只需要在普通类前面加关键字<code>data</code>即为数据类。<br>
数据类对标<code>java</code>中的<code>bean</code>类，但两者并不相等<br>
<strong>数据类必须至少有一个主构造函数参数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Book</span>(<span class="keyword">val</span> id: <span class="built_in">Long</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> brand:Person)</span><br></pre></td></tr></table></figure>
<h2><a href="#2-component" class="header-anchor">#</a><span id="2-component">2. component</span></h2>
<p>定义在主构造器中的属性又称之为 <em><strong>component</strong></em>，数据类所有的东西都基于<code>component</code>实现，如下所示为上述代码反编译<code>class</code>文件后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> id;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Person brand;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Person <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.brand;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(<span class="type">long</span> id, <span class="meta">@NotNull</span> String name, <span class="meta">@NotNull</span> Person brand)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.brand = brand;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">component1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">component2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Person <span class="title function_">component3</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.brand;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Computer <span class="title function_">copy</span><span class="params">(<span class="type">long</span> id, <span class="meta">@NotNull</span> String name, <span class="meta">@NotNull</span> Person brand)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(id, name, brand);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Computer(id=&quot;</span> + <span class="built_in">this</span>.id + <span class="string">&quot;, name=&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;, brand=&quot;</span> + <span class="built_in">this</span>.brand + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.id;</span><br><span class="line">      <span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> (<span class="type">int</span>)(var10000 ^ var10000 &gt;&gt;&gt; <span class="number">32</span>) * <span class="number">31</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.name;</span><br><span class="line">      var1 = (var1 + (var10001 != <span class="literal">null</span> ? var10001.hashCode() : <span class="number">0</span>)) * <span class="number">31</span>;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.brand;</span><br><span class="line">      <span class="keyword">return</span> var1 + (var2 != <span class="literal">null</span> ? var2.hashCode() : <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != var1) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Computer) &#123;</span><br><span class="line">            <span class="type">Computer</span> <span class="variable">var2</span> <span class="operator">=</span> (Computer)var1;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.id == var2.id &amp;&amp; Intrinsics.areEqual(<span class="built_in">this</span>.name, var2.name) &amp;&amp; Intrinsics.areEqual(<span class="built_in">this</span>.brand, var2.brand)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Computer copy$<span class="keyword">default</span>(Computer var0, <span class="type">long</span> var1, String var3, Person var4, <span class="type">int</span> var5, Object var6) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var1 = var0.id;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var3 = var0.name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var4 = var0.brand;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>数据类会自动生成<code>N</code>个<code>component</code>，序号顺序即为主构造器中参数顺序</p>
</li>
<li>
<p>可以根据<code>component</code>方法获取数据类的属性值</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> computer = Computer(<span class="number">1001L</span>, <span class="string">&quot;mackBook Pro&quot;</span>, Person(<span class="string">&quot;Apple&quot;</span>, <span class="number">45</span>))</span><br><span class="line"><span class="keyword">val</span> id = computer.component1()</span><br><span class="line"><span class="keyword">val</span> name = computer.component2()</span><br><span class="line"><span class="keyword">val</span> brand = computer.component3()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>相较于普通类，数据类还自动创建了<code>copy()</code>、<code>toString()</code>、<code>hashCode()</code>、<code>equals()</code>等方法</p>
</li>
</ol>
<h2><a href="#3-数据类解构" class="header-anchor">#</a><span id="3-数据类解构">3. 数据类解构</span></h2>
<p>数据类解构就是将一个数据类解构 <em>(destructure)</em> 为多个变量，也就是意味着一个解构声明会一次性创建多个变量</p>
<p><code>Pair</code>的源码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pair类源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">out A, out B</span>&gt;(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> first: A,</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> second: B</span><br><span class="line">) : Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;(<span class="variable">$first</span>, <span class="variable">$second</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = <span class="string">&quot;Hello&quot;</span> to <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">val</span>(hello, world) = pair</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>如上所示，先声明一个<code>Pair</code>类型的属性<code>pair</code>，之后将<code>pair</code>解构成变量<code>hello</code>和<code>world</code></p>
</li>
<li>
<p><code>Pair</code>类是一个数据类，有两个<code>component</code></p>
</li>
<li>
<p>上述代码反编译<code>class</code>文件后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> TuplesKt.to(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)pair.component1();</span><br><span class="line"><span class="type">String</span> <span class="variable">world</span> <span class="operator">=</span> (String)pair.component2();</span><br></pre></td></tr></table></figure>
<p>由此可见<strong>数据类解构是借助<code>component</code>实现的</strong></p>
</li>
</ol>
<p>上一节中定义的<code>Computer</code>实现类可以使用如下代码解构：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> computer = Computer(<span class="number">31L</span>, <span class="string">&quot;mackBook Pro&quot;</span>, Person(<span class="string">&quot;Apple&quot;</span>, <span class="number">45</span>))</span><br><span class="line">    <span class="keyword">val</span>(id, name, brand) = computer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#4-javabean-与-data-class-区别" class="header-anchor">#</a><span id="4-javabean-与-data-class-区别">4. JavaBean 与 data class 区别</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>JavaBean</th>
<th>data class</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造方法</td>
<td>默认无参构造</td>
<td>属性作为参数</td>
</tr>
<tr>
<td>字段</td>
<td>字段私有，Getter/Setter 公开</td>
<td>属性</td>
</tr>
<tr>
<td>继承性</td>
<td>可继承也可被继承</td>
<td>不可被继承</td>
</tr>
<tr>
<td>component</td>
<td>无</td>
<td>相等性、解析等</td>
</tr>
</tbody>
</table>
<p>数据类不可被继承原因：<strong>违反相等性的对称性和传递性</strong></p>
<p>假设定义一个数据基类<code>BaseClass</code>内含一个属性<code>name</code>，之后再定义一个数据子类<code>ChildClass</code>继承了<code>BaseClass</code>，并在其基础上又扩展了一个属性<code>age</code>。之后再创建如下三个实例</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>name 值</th>
<th>age 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>基类<code>BaseClass</code>的实例：a</td>
<td>Lee</td>
<td>无</td>
</tr>
<tr>
<td>子类<code>BaseClass</code>的实例：b</td>
<td>Lee</td>
<td>18</td>
</tr>
<tr>
<td>子类<code>BaseClass</code>的实例：c</td>
<td>Lee</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>则：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>a == b</td>
<td>true</td>
<td>双等号其实是调用的类实例 a 的<code>equals</code>方法，由反编译的代码可知<code>equals</code>方法只比较本类有的属性，而两个实例的<code>name</code>属性值相同，故相等</td>
</tr>
<tr>
<td>b == a</td>
<td>false</td>
<td>实例 b 的<code>equals</code>方法，要比较<code>name</code>和<code>age</code>两个属性，而实例<code>a</code>没有<code>age</code>属性，故不相等</td>
</tr>
<tr>
<td>a == c</td>
<td>true</td>
<td>同第一条原因</td>
</tr>
<tr>
<td>c == a</td>
<td>false</td>
<td>同第二条原因</td>
</tr>
<tr>
<td>b == c</td>
<td>false</td>
<td>虽然实例<code>b</code>和实例<code>c</code>都有<code>name</code>和<code>age</code>两个属性，但是<code>age</code>属性值不同，故不相等</td>
</tr>
</tbody>
</table>
<p>由上表可知：</p>
<p><code>a == b</code> 但是 <code>b != a</code>违反了相等性的<strong>对称性</strong><br>
<code>a == b</code> 并且 <code>a == c</code> 但<code>b != c</code>违反了相等性的<strong>传递性</strong></p>
<h2><a href="#5-data-class-总结" class="header-anchor">#</a><span id="5-data-class-总结">5. data class 总结</span></h2>
<ol>
<li>提供了<code>JavaBean</code>的功能</li>
<li>被<code>final</code>字段修饰不可被继承</li>
<li>核心的<code>Component</code>，它导致必须有有参数的主构造器，并决定了数据类的相等性，还可解构数据类</li>
<li>定义一个数据类应该将其当作一个纯数据结构来使用，大多数情况下不需要额外实现，即一般省略<code>&#123;&#125;</code></li>
<li>数据类的属性类型最好为基本类型、String、其它数据类等，以此保证不会有逻辑，保证数据类是纯数据</li>
<li><code>Component</code>不可以自定义<code>Getter/Setter</code>，以保证数据特性不会被篡改</li>
<li>数据类的属性最好使用<code>val</code>修饰，使属性不可变，以保证其同一个对象的<code>hashcode</code>和<code>equals</code>结果前后一样</li>
</ol>
<p><strong>将<code>data class</code>当作<code>JavaBean</code>使用</strong></p>
<p><strong>问题：</strong> 必须有有参数的主构造器；被 final 修饰不可被继承。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>使用<span id="jumpNoArg"><code>NoArg</code>插件</span>，给数据类加一个注解，使用数据类在编译时生成一个无参构造器，但无法在代码里直接访问该构造器，只能通过反射拿到。</li>
<li>使用<code>AllOpen</code>插件，去掉<code>final</code>修饰，以保证数据类可以被继承</li>
</ol>
<p><strong>实例：</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build.gradle.kts</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    id (<span class="string">&quot;org.jetbrains.kotlin.plugin.allopen&quot;</span>) version <span class="string">&quot;1.4.21&quot;</span></span><br><span class="line">    id (<span class="string">&quot;org.jetbrains.kotlin.plugin.noarg&quot;</span>) version <span class="string">&quot;1.4.21&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noArg &#123;</span><br><span class="line">    invokeInitializers = <span class="literal">true</span></span><br><span class="line">    annotations(<span class="string">&quot;cn.ltt.projectcollection.kotlin.DataClassAnnotation&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allOpen &#123;</span><br><span class="line">    annotations(<span class="string">&quot;cn.ltt.projectcollection.kotlin.DataClassAnnotation&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ltt.projectcollection.kotlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataClassAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>插件需要添加到<code>module</code>模块下的<code>build.gradle.kts</code>中</li>
<li>如上所示，将注解<code>DataClassAnnotation</code>会导致被标注的类生成无参构造函数且类本身及其所有成员会变为开放</li>
<li><code>invokeInitializers</code>为<code>false</code>时，只会调用被标注的类的父类的构造方法；为<code>true</code>时会调用被标注类的<code>init</code>块，默认为<code>false</code>。</li>
<li>参考文章：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/compiler-plugins.html">https://www.kotlincn.net/docs/reference/compiler-plugins.html</a></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataClassAnnotation</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Computer</span>(<span class="keyword">val</span> id: <span class="built_in">Long</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> brand:Person) &#123;</span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> computer = Computer::<span class="keyword">class</span>.java.newInstance()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将注解添加到类<code>Computer</code>上，并通过反射生成一个<code>Computer</code>的实例<br>
反编译<code>Computer</code>类的<code>class</code>文件后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> id;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Person brand;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> Person <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.brand;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(<span class="type">long</span> id, <span class="meta">@NotNull</span> String name, <span class="meta">@NotNull</span> Person brand)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">      Intrinsics.checkNotNullParameter(brand, <span class="string">&quot;brand&quot;</span>);</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.brand = brand;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.getName();</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">component1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getId();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">component2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Person <span class="title function_">component3</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getBrand();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Computer <span class="title function_">copy</span><span class="params">(<span class="type">long</span> id, <span class="meta">@NotNull</span> String name, <span class="meta">@NotNull</span> Person brand)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">      Intrinsics.checkNotNullParameter(brand, <span class="string">&quot;brand&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(id, name, brand);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Computer copy$<span class="keyword">default</span>(Computer var0, <span class="type">long</span> var1, String var3, Person var4, <span class="type">int</span> var5, Object var6) &#123;</span><br><span class="line">      <span class="keyword">if</span> (var6 != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Super calls with default arguments not supported in this target, function: copy&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            var1 = var0.getId();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            var3 = var0.getName();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            var4 = var0.getBrand();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Computer(id=&quot;</span> + <span class="built_in">this</span>.getId() + <span class="string">&quot;, name=&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;, brand=&quot;</span> + <span class="built_in">this</span>.getBrand() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.getId();</span><br><span class="line">      <span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> (<span class="type">int</span>)(var10000 ^ var10000 &gt;&gt;&gt; <span class="number">32</span>) * <span class="number">31</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.getName();</span><br><span class="line">      var1 = (var1 + (var10001 != <span class="literal">null</span> ? var10001.hashCode() : <span class="number">0</span>)) * <span class="number">31</span>;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.getBrand();</span><br><span class="line">      <span class="keyword">return</span> var1 + (var2 != <span class="literal">null</span> ? var2.hashCode() : <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != var1) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Computer) &#123;</span><br><span class="line">            <span class="type">Computer</span> <span class="variable">var2</span> <span class="operator">=</span> (Computer)var1;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getId() == var2.getId() &amp;&amp; Intrinsics.areEqual(<span class="built_in">this</span>.getName(), var2.getName()) &amp;&amp; Intrinsics.areEqual(<span class="built_in">this</span>.getBrand(), var2.getBrand())) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>可以看到类<code>computer</code>已经没有<code>final</code>修饰了，它可以被继承，且<code>computer</code>里的属性的<code>Getter/Setter</code>也没有了<code>final</code>修饰</li>
<li>相较于之前的反编译后的代码，现在在最后的位置多了一个无参的构造器</li>
<li>虽然在插件<code>noarg</code>里将<code>invokeInitializers</code>置为了<code>true</code>，但是<code>IntelliJ</code>在反编译时没有识别到该属性，所以在无参构造器中没有<code>init</code>块中的代码，但是<code>gradle</code>可以识别到该属性，所以在运行时会执行<code>init</code>块中代码，会打印出<code>computer</code>类实例的<code>name</code>值</li>
</ol>
<h1><a href="#九-枚举类enum-class" class="header-anchor">#</a><span id="九-枚举类enum-class">九、枚举类<code>enum class</code></span></h1>
<h2><a href="#1-枚举类定义" class="header-anchor">#</a><span id="1-枚举类定义">1. 枚举类定义</span></h2>
<p>使用关键字 <strong><code>enum</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    START, FINISHED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    START, FINISHED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-枚举类属性" class="header-anchor">#</a><span id="2-枚举类属性">2. 枚举类属性</span></h2>
<p><strong>Java:</strong></p>
<ol>
<li>可以通过枚举项的<code>name()</code>方法，获取枚举项的名称</li>
<li>可以通过枚举项的<code>ordinal()</code>方法，获取枚举项的在枚举声明里的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(State.START.name());</span><br><span class="line">System.out.println(State.START.ordinal());</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin:</strong></p>
<ol>
<li>枚举项有属性<code>name</code>，持有枚举项的名称</li>
<li>枚举项有属性<code>ordinal</code>，持有枚举项在枚举声明中的位置</li>
<li>枚举有方法<code>values</code>，该方法返回枚举项列表</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(State.START.name)</span><br><span class="line">println(State.START.ordinal)</span><br></pre></td></tr></table></figure>
<h2><a href="#3-枚举类构造器" class="header-anchor">#</a><span id="3-枚举类构造器">3. 枚举类构造器</span></h2>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    START(<span class="number">0</span>), FINISHED(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    State(<span class="type">int</span> id) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">State</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    START(<span class="number">0</span>), FINISHED(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>声明构造器后，每个枚举项都要调用构造器。只有通过这种方式来创建有构造器的枚举项。</li>
</ol>
<h2><a href="#4-枚举类实现接口" class="header-anchor">#</a><span id="4-枚举类实现接口">4. 枚举类实现接口</span></h2>
<h3><a href="#1-统一实现" class="header-anchor">#</a><span id="1-统一实现">1. 统一实现</span></h3>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    START, FINISHED;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;For every state&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">State</span> : <span class="type">Runnable</span> &#123;</span><br><span class="line">    START, FINISHED;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;For every state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，每个枚举项的<code>run</code>方法实现都是同样的</li>
<li>其中<code>Kotlin</code>中最后一个枚举项后必须加上分号，否则报错：<code>Expecting ';' after the last enum entry or '&#125;' to close enum class body</code></li>
</ol>
<h3><a href="#2-各自实现" class="header-anchor">#</a><span id="2-各自实现">2. 各自实现</span></h3>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    START &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;For START&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, FINISHED &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;For FINISHED&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">State</span> : <span class="type">Runnable</span> &#123;</span><br><span class="line">    START &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;For START&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    FINISHED &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;For FINISHED&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>每个实例单独实现<code>run</code>方法，这样各个枚举项就只调用自己的<code>run</code>方法</li>
<li>枚举的父类是<code>Enum</code>，所以不能继承其它类</li>
</ol>
<h2><a href="#5-为枚举定义扩展" class="header-anchor">#</a><span id="5-为枚举定义扩展">5. 为枚举定义扩展</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> State.<span class="title">next</span><span class="params">()</span></span>: State &#123;</span><br><span class="line">    <span class="keyword">return</span> State.values().let &#123; </span><br><span class="line">        <span class="keyword">val</span> nextOrdinal = (ordinal + <span class="number">1</span>) % it.size</span><br><span class="line">        it[nextOrdinal]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>枚举也是一个类，可以为其定义扩展方法</li>
<li>如上代码为枚举类<code>State</code>定义了一个扩展方法<code>next()</code>，该方法可以获取某个枚举项的下一个枚举，且是循环的</li>
</ol>
<h2><a href="#6-枚举类条件分支" class="header-anchor">#</a><span id="6-枚举类条件分支">6. 枚举类条件分支</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> state = State.START</span><br><span class="line"><span class="keyword">val</span> value = <span class="keyword">when</span>(state) &#123;</span><br><span class="line">    State.START -&gt; &#123;<span class="number">0</span>&#125;</span><br><span class="line">    State.FINISHED -&gt; &#123;<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>枚举是有限个数的，所以可以将其作为条件分支</li>
</ol>
<h2><a href="#7-枚举类比较大小" class="header-anchor">#</a><span id="7-枚举类比较大小">7. 枚举类比较大小</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> state = State.START</span><br><span class="line"><span class="keyword">if</span> (state &lt;= State.FINISHED) &#123;</span><br><span class="line">    println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>同一个枚举类下的枚举项之间可以比较大小</li>
<li>枚举项之间比较的是<code>ordinal</code></li>
</ol>
<h2><a href="#8-枚举类区间" class="header-anchor">#</a><span id="8-枚举类区间">8. 枚举类区间</span></h2>
<p>枚举是有顺序的，可以创建枚举区间</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    NEW, RUNNABLE, RUNNING, BLOCKED, DEAD</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> statusRange = Status.NEW .. Status.BLOCKED</span><br><span class="line">    <span class="keyword">val</span> status = Status.RUNNING</span><br><span class="line">    println(status <span class="keyword">in</span> statusRange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，先创建了一个线程状态的枚举类，之后又创建了一个枚举项的区间</li>
<li>判断某个状态是否在某几个状态之内，这时使用区间会很方便</li>
</ol>
<h1><a href="#十-密封类sealed-class" class="header-anchor">#</a><span id="十-密封类sealed-class">十、密封类<code>sealed class</code></span></h1>
<h2><a href="#1-密封类概念" class="header-anchor">#</a><span id="1-密封类概念">1. 密封类概念</span></h2>
<ol>
<li>密封类是一种特殊的抽象类，它首先是一个抽象类，其次才是密封类，即密封类可以被继承</li>
<li>密封类的子类定义只能在与自身相同的文件中，即其子类只在一个有限范围内</li>
<li>密封类的子类的个数是有限的</li>
</ol>
<h2><a href="#2-密封类定义" class="header-anchor">#</a><span id="2-密封类定义">2. 密封类定义</span></h2>
<p>使用关键字<code>sealed</code>来定义密封类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">constructor</span>()</span><br><span class="line">    <span class="keyword">constructor</span>(id:<span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">PlayerState</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">PlayerState</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>密封类是一个抽象类</li>
<li>密封类的构造方法是私有的</li>
</ol>
<h2><a href="#3-密封类的子类" class="header-anchor">#</a><span id="3-密封类的子类">3. 密封类的子类</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Idle : PlayerState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Playing</span>(<span class="keyword">val</span> song: String): PlayerState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> errorInfo: String):PlayerState()</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Idle</code>是一个普通单例对象</li>
<li><code>Playing</code>类的实例每次播放的歌曲不同，所以它每次的实例不一样</li>
<li><code>Error</code>类的实例每次错误信息不同，所以它每次的实例也不一样</li>
<li>但是<code>Idle</code>、<code>Playing</code>、 <code>Error</code>的类型是一样的</li>
<li>继承密封类的时候要调用父类的构造器</li>
</ol>
<h2><a href="#4-密封类子类分支" class="header-anchor">#</a><span id="4-密封类子类分支">4. 密封类子类分支</span></h2>
<p>密封类的子类是可数的，分支就可完备，就可以使用<code>when</code>分支语句</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> state : PlayerState = Idle</span><br><span class="line"><span class="keyword">when</span>(state) &#123;</span><br><span class="line">    Idle -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Idle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">is</span> Playing -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Playing&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">is</span> Error -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#5-密封类使用" class="header-anchor">#</a><span id="5-密封类使用">5. 密封类使用</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> player = Player()</span><br><span class="line">    player.play(<span class="string">&quot;The Nights&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Idle : PlayerState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Playing</span>(<span class="keyword">val</span> song: String): PlayerState() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> errorInfo: String):PlayerState() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> state: PlayerState = Idle</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(song: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">when</span>(<span class="keyword">val</span> state = <span class="keyword">this</span>.state) &#123;</span><br><span class="line">            Idle -&gt; &#123;</span><br><span class="line">                Playing(song).also(Playing::start)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> Playing -&gt; &#123;</span><br><span class="line">                state.stop()</span><br><span class="line">                Playing(song).also(Playing::start)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> Error -&gt; &#123;</span><br><span class="line">                state.recover()</span><br><span class="line">                Playing(song).also(Playing::start)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义一个播放状态的密封类<code>PlayerState</code>，然后三个类实现密封类：<code>Idle</code>初始化状态类、<code>Playing</code>播放状态类、<code>Error</code>错误状态类</li>
<li>创建一个播放器类<code>Player</code>，该类中的方法<code>play()</code>通过<code>when</code>语句判断不同的状态采用不同的处理方案：如果是<code>Idle</code>状态直接播放；如果是<code>Playing</code>状态则先将停止播放再播放新歌曲；如果是<code>Error</code>状态则先复位再播放新歌曲。</li>
<li>其中<code>Playing</code>和<code>Error</code>状态的判断还进行了智能类型转换，以方便调用各自状态类中的方法。</li>
<li>其中的<code>also</code>方法会将<code>receiver</code>返回，所以实现了状态机<code>state</code>的流转。</li>
<li><code>when</code>语句在<code>kotlin1.3</code>以后可以在其中创建一个新变量</li>
</ol>
<h2><a href="#6-密封类和枚举类对比" class="header-anchor">#</a><span id="6-密封类和枚举类对比">6. 密封类和枚举类对比</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>密封类</th>
<th>枚举类</th>
</tr>
</thead>
<tbody>
<tr>
<td>状态实现</td>
<td>子类继承</td>
<td>类实例化</td>
</tr>
<tr>
<td>状态可数</td>
<td>子类可数</td>
<td>实例可数</td>
</tr>
<tr>
<td>状态差异</td>
<td>类型差异</td>
<td>值差异</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ol>
<li>密封类可以让子类继承子类可以是<code>object</code>类，而枚举类内的枚举对象都是枚举类的实例</li>
</ol>
<h1><a href="#十一-内联类inline-class" class="header-anchor">#</a><span id="十一-内联类inline-class">十一、内联类<code>inline class</code></span></h1>
<h2><a href="#1-内联类概念" class="header-anchor">#</a><span id="1-内联类概念">1. 内联类概念</span></h2>
<ol>
<li>内联类是对某一个类型的包装</li>
<li>内联类是类似于<code>java</code>装箱类型 <em>(Float, Double等)</em> 的一种类型</li>
<li>编译器会尽可能使用被包装的类型进行优化</li>
<li>内联类在<code>Kotlin 1.3</code>版本中处于公测阶段，谨慎使用</li>
</ol>
<h2><a href="#2-内联类定义" class="header-anchor">#</a><span id="2-内联类定义">2. 内联类定义</span></h2>
<p>使用关键字<code>inline</code>来定义内联类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">BoxInt</span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码所示，定义内联类<code>BoxInt</code>是对类型<code>Int</code>的包装</li>
<li>被包装的类型只能定义在主构造器内</li>
<li>主构造器只能是<code>public</code></li>
<li>主构造器只能有一个参数即被包装的类型，</li>
<li>主构造器里的参数只能用<code>val</code>修饰</li>
</ol>
<h2><a href="#3-内联类方法" class="header-anchor">#</a><span id="3-内联类方法">3. 内联类方法</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">BoxInt</span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span>:BoxInt &#123;</span><br><span class="line">        <span class="keyword">return</span> BoxInt(value + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>内联类可以定义方法，如上代码所示，定义了一个重载运算符的函数<code>inc()</code>,如此可以执行运行符<code>++</code></li>
</ol>
<h2><a href="#4-内联类属性" class="header-anchor">#</a><span id="4-内联类属性">4. 内联类属性</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">BoxInt</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;BoxInt(<span class="variable">$value</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><em>Inline class cannot have properties with backing fields</em></li>
<li>内联类可以定义只有<code>getter</code>的属性，即内联类只能定义方法</li>
</ol>
<h2><a href="#5-内联类继承关系" class="header-anchor">#</a><span id="5-内联类继承关系">5. 内联类继承关系</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">BoxInt</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Comparable&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.compareTo(other)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> boxInt = BoxInt(<span class="number">5</span>)</span><br><span class="line">    println(boxInt &gt; <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码内联类<code>BoxInt</code>实现了接口<code>Comparable</code>，则<code>BoxInt</code>类型的对象可以与<code>Int</code>类型比较大小</li>
<li>内联类可以实现接口</li>
<li>内联类不能继承父类，也不能被继承</li>
</ol>
<h2><a href="#6-内联类编译优化" class="header-anchor">#</a><span id="6-内联类编译优化">6. 内联类编译优化</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> boxInt = BoxInt(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">val</span> newValue = boxInt.value * <span class="number">200</span></span><br><span class="line">    println(newValue)</span><br><span class="line">    boxInt++</span><br><span class="line">    println(boxInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将如上代码反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BoxInt</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> compareTo-impl(<span class="built_in">this</span>.value, var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="comment">// $FF: bridge method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.compareTo(((Number)var1).intValue());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">BoxInt</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> inc_xSVgFbQ<span class="comment">/* $FF was: inc-xSVgFbQ*/</span>(<span class="type">int</span> $<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> constructor-impl($<span class="built_in">this</span> + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> compareTo_impl<span class="comment">/* $FF was: compareTo-impl*/</span>(<span class="type">int</span> $<span class="built_in">this</span>, <span class="type">int</span> other) &#123;</span><br><span class="line">      <span class="keyword">return</span> Intrinsics.compare($<span class="built_in">this</span>, other);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> constructor_impl<span class="comment">/* $FF was: constructor-impl*/</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxInt box_impl<span class="comment">/* $FF was: box-impl*/</span>(<span class="type">int</span> v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BoxInt</span>(v);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String toString_impl<span class="comment">/* $FF was: toString-impl*/</span>(<span class="type">int</span> var0) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;BoxInt(value=&quot;</span> + var0 + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> hashCode_impl<span class="comment">/* $FF was: hashCode-impl*/</span>(<span class="type">int</span> var0) &#123;</span><br><span class="line">      <span class="keyword">return</span> var0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> equals_impl<span class="comment">/* $FF was: equals-impl*/</span>(<span class="type">int</span> var0, Object var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> BoxInt) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> ((BoxInt)var1).unbox-impl();</span><br><span class="line">         <span class="keyword">if</span> (var0 == var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> equals_impl0<span class="comment">/* $FF was: equals-impl0*/</span>(<span class="type">int</span> p1, <span class="type">int</span> p2) &#123;</span><br><span class="line">      <span class="keyword">return</span> p1 == p2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> unbox_impl<span class="comment">/* $FF was: unbox-impl*/</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> toString-impl(<span class="built_in">this</span>.value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> hashCode-impl(<span class="built_in">this</span>.value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> equals-impl(<span class="built_in">this</span>.value, var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">boxInt</span> <span class="operator">=</span> BoxInt.constructor-impl(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> boxInt * <span class="number">200</span>;</span><br><span class="line">    System.out.println(newValue);</span><br><span class="line">    boxInt = BoxInt.inc-xSVgFbQ(boxInt);</span><br><span class="line">    <span class="type">BoxInt</span> <span class="variable">var4</span> <span class="operator">=</span> BoxInt.box-impl(boxInt);</span><br><span class="line">    System.out.println(var4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>编译优化说明：</strong></p>
<ol>
<li>调用类<code>BoxInt</code>的<code>constructor-impl</code>方法为属性<code>boxInt</code>赋值，而<code>constructor-impl</code>方法只是将形参返回，即第一条语句优化为：<code>var boxInt: Int = 5</code></li>
<li>第二条语句直接使用类型为被封闭类型的<code>boxInt</code>属性：<code>val newValue = boxInt * 200</code></li>
<li>打印语句只是将属性打印</li>
<li>第四条作为为自加一的语句调用类<code>BoxInt</code>的<code>inc-xSVgFbQ</code>方法，而该方法又调用了<code>contructor-impl</code>方法，只是入参传入的是其本身的值加一</li>
<li>而最后一条语句是打印类<code>BoxInt</code>的实例，即调用该类的<code>toString()</code>方法，所以将之前的<code>boxInt</code>属性再装箱。调用<code>BoxInt</code>类的<code>box-impl</code>方法，创建一个<code>BoxInt</code>的实例，之后打印该实例</li>
<li>综上所述，只有在必要的时候才使用包装类型，大多数情况下优化为被包装的类型</li>
</ol>
<h2><a href="#7-内联类使用场景" class="header-anchor">#</a><span id="7-内联类使用场景">7. 内联类使用场景</span></h2>
<h3><a href="#1-内联类官方例子" class="header-anchor">#</a><span id="1-内联类官方例子">1. 内联类官方例子</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">UInt</span> <span class="meta">@PublishedApi</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(<span class="meta">@PublishedApi</span> <span class="keyword">internal</span> <span class="keyword">val</span> <span class="keyword">data</span>: <span class="built_in">Int</span>) : Comparable&lt;UInt&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示无符号整型是有符号整形的包装</li>
<li>所有的无符号类型都是对应有符号类型的包装</li>
</ol>
<h3><a href="#2-使用内联类模拟枚举" class="header-anchor">#</a><span id="2-使用内联类模拟枚举">2. 使用内联类模拟枚举</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">State</span>(<span class="keyword">val</span> ordinal:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> Start = State(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> Running = State(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> Finished = State(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">values</span><span class="params">()</span></span> = arrayOf(Start, Finished)</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (ordinal) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    <span class="string">&quot;Start&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                    <span class="string">&quot;Running&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    <span class="string">&quot;Finished&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="string">&quot;other&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    setState(State.Running)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setState</span><span class="params">(state:<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;setState-State:<span class="variable">$state</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>枚举的内存开销大</li>
<li>如上所示，创建一个内联类<code>State</code>模拟枚举，该类提供了<code>values</code>函数和只有<code>getter</code>的<code>name</code>属性，<code>State</code>类的单例中创建了三个内联对象</li>
<li>在<code>java</code>中使用注解<code>IntDef</code>、<code>StingDef</code>等来模拟枚举类，虽然<code>IDE</code>会报错但是可以编译通过。但是在<code>kotlin</code>中该注解不会起到规定范围的作用</li>
<li>内联类虽然在<code>companion object</code>中定义了几个对象，但编译器会将其优化为整型，如此相较于枚举内存开销更小</li>
<li>在某函数中设置该内联类类型时，只能传该内联类单例中定义的对象</li>
<li>两种语言模拟枚举类的区别：在<code>java</code>中使用注解<code>IntDef</code>、<code>StingDef</code>等，虽然<code>IDE</code>会报错但是可以编译通过，而<code>kotlin</code>中的使用内联类，<code>IDE</code>会报错且不会编译通过</li>
</ol>
<h2><a href="#8-内联类的限制" class="header-anchor">#</a><span id="8-内联类的限制">8. 内联类的限制</span></h2>
<ol>
<li>主构造器必须有且仅有一个只读属性 <em>(被包装的类型)</em></li>
<li>不能定义有<code>backing-field</code>的其它属性</li>
<li>被包装类型必须不能是泛型类型，必须是一个确定的类型</li>
<li>不能继承父类也不能被继承</li>
<li>内联类不能定义为其他类的内部类</li>
<li>以上的限制是为了编译器优化类型</li>
</ol>
<h2><a href="#9-别名-typealias-与内联类-inline-class-区别" class="header-anchor">#</a><span id="9-别名-typealias-与内联类-inline-class-区别">9. 别名 <em>(<code>typealias</code>)</em> 与内联类 <em>(<code>inline class</code>)</em> 区别</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>typealias</th>
<th>inline class</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>没有新类型</td>
<td>有包装类型产生</td>
</tr>
<tr>
<td>实例</td>
<td>与原类型一致</td>
<td>必要时使用包装类型</td>
</tr>
<tr>
<td>场景</td>
<td>类型更直观</td>
<td>优化包装类型性能</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ol>
<li><code>typealias</code>是为某类型定义了一个别名，而内联类是将某类型进行包装</li>
<li><code>typealias</code>是为程序员看的更直观，而内联类是为编译器优化类型的</li>
</ol>
<h1><a href="#十二-示例-数据类序列化" class="header-anchor">#</a><span id="十二-示例-数据类序列化">十二、示例 - 数据类序列化</span></h1>
<p>常用的三个<code>Kotlin</code>中的<code>Json</code>序列化工具：</p>
<ol>
<li><code>Gson</code>框架是<code>Google</code>的。官网：<a target="_blank" rel="noopener" href="https://github.com/google/gson">https://github.com/google/gson</a></li>
<li><code>Moshi</code>是大神<code>JakeWharton</code>等人写的。官网：<a target="_blank" rel="noopener" href="https://github.com/square/moshi">https://github.com/square/moshi</a></li>
<li><code>Kotlinx.serialization</code>是<code>Kotlin</code>官方提供的。官网：<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.serialization">https://github.com/Kotlin/kotlinx.serialization</a></li>
</ol>
<h2><a href="#1-引入工具" class="header-anchor">#</a><span id="1-引入工具">1. 引入工具</span></h2>
<h3><a href="#1-gson" class="header-anchor">#</a><span id="1-gson">1. Gson</span></h3>
<p>直接在在模块下的<code>build.gradle</code>文件里的<code>dependences</code>块添加依赖即可</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app/src/build.gradle.kts</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//Gson</span></span><br><span class="line">    implementation (<span class="string">&quot;com.google.code.gson:gson:2.8.6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#2-moshi" class="header-anchor">#</a><span id="2-moshi">2. Moshi</span></h3>
<p>要先添加一下插件，再添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app/src/build.gradle.kts</span></span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;kapt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;com.squareup.moshi:moshi:1.11.0&quot;</span>)</span><br><span class="line">    implementation( <span class="string">&quot;com.squareup.moshi:moshi-kotlin:1.8.0&quot;</span>) <span class="comment">// for KotlinJsonAdapterFactory</span></span><br><span class="line">    kapt( <span class="string">&quot;com.squareup.moshi:moshi-kotlin-codegen:1.11.0&quot;</span>) <span class="comment">// for generated Json Adapter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="#3-kotlinxserialization" class="header-anchor">#</a><span id="3-kotlinxserialization">3. Kotlinx.serialization</span></h3>
<p>要先添加一下插件，再添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app/src/build.gradle.kts</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    kotlin(<span class="string">&quot;plugin.serialization&quot;</span>) version <span class="string">&quot;1.4.30&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.1.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-示例代码" class="header-anchor">#</a><span id="2-示例代码">2. 示例代码</span></h2>
<p><strong>Kotlin版本：</strong> <code>Kotlin version 1.4.20-release-308 (JRE 1.8.0_251-b08) </code><br>
<strong>Kotlin Plugin版本：</strong> <code>1.4.31</code></p>
<h3><a href="#1-简单序列化json" class="header-anchor">#</a><span id="1-简单序列化json">1. 简单序列化json</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonStr = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;Lee&quot;,&quot;age&quot;:20&#125;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gson</span></span><br><span class="line">    println(<span class="string">&quot;Gson&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    println(gson.toJson(person))</span><br><span class="line">    println(gson.fromJson(jsonStr, Person::<span class="keyword">class</span>.java))</span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Moshi</span></span><br><span class="line">    println(<span class="string">&quot;Moshi&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> moshi = Moshi.Builder()</span><br><span class="line">            .add(KotlinJsonAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line">    <span class="keyword">val</span> jsonAdapter = moshi.adapter(Person::<span class="keyword">class</span>.java)</span><br><span class="line">    println(jsonAdapter.toJson(person))</span><br><span class="line">    println(jsonAdapter.fromJson(jsonStr))</span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Kotlinx.serialization&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = PersonForSerialize(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    println(Json.encodeToString(PersonForSerialize.serializer(),<span class="keyword">data</span>))</span><br><span class="line">    println(Json.decodeFromString(PersonForSerialize.serializer(),jsonStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonForrSerialize</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gson</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">Person(name=Lee, age=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Moshi</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">Person(name=Lee, age=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Kotlinx.serialization</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonFroSerialize(name=Lee, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>Gson</th>
<th>Moshi</th>
<th>Kotlinx.serialization</th>
</tr>
</thead>
<tbody>
<tr>
<td>对Json对象的需求</td>
<td>无</td>
<td>无</td>
<td>需要Json对象的类添加注解<code>@Serializable</code></td>
</tr>
<tr>
<td>需要创建工具类对象</td>
<td>需要</td>
<td>需要，且还要再创建对应<code>json</code>对象的<code>adapter</code></td>
<td>不需要</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>Moshi</code>在使用<code>Builder</code>模式创建对象时还要添加<code>KotlinJsonAdapterFactory</code>以支持<code>kotlin</code></p>
</li>
<li>
<p><code>Kotlinx.serialization</code>使用方法<code>encodeToString</code>和<code>decodeFromString</code>序列化<code>json</code>是，第一个参数要传递对应<code>json</code>的数据类的<code>serizlizer</code>对象</p>
</li>
<li>
<p>注解<code>@Serializable</code>会将添加该注解的类的序列化工具生成到对应类的伴生对象中，添加该注解的类<code>PersonForSerizlize</code>反编译后的关键代码如下：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PersonFroSerialize</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> PersonFroSerialize.Companion Companion = new PersonFroSerialize.Companion((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Companion</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Companion() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $FF: synthetic method</span></span><br><span class="line">    <span class="keyword">public</span> Companion(DefaultConstructorMarker $constructor_marker) &#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> KSerializer serializer() &#123;</span><br><span class="line">        <span class="keyword">return</span> (KSerializer)PersonFroSerialize.$serializer.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="keyword">class</span> $serializer implements GeneratedSerializer &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> PersonFroSerialize.$serializer INSTANCE;</span><br><span class="line">    <span class="comment">// $FF: synthetic field</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> SerialDescriptor $$serialDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $serializer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3><a href="#2-带默认参数的json序列化" class="header-anchor">#</a><span id="2-带默认参数的json序列化">2. 带默认参数的json序列化</span></h3>
<h4><a href="#1-gson处理默认参数" class="header-anchor">#</a><span id="1-gson处理默认参数">1. Gson处理默认参数</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Gson</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonStr = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;Lee&quot;&#125;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> person = PersonWithDefaults(<span class="string">&quot;Lee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gson</span></span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    println(gson.toJson(person))</span><br><span class="line">    println(gson.fromJson(jsonStr, PersonWithDefaults::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithDefaults</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithDefaults(name=Lee, age=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Gson</code>在将带有默认参数的数据类序列化时会将默认参数带上</li>
<li><code>Gson</code>在反序列化时会通过反射来判断有没有默认无参的构造方法，如果没有的话会通过<code>UnSafe</code>类直接创建对象，所以反序列化时数据类的默认参数不会起作用</li>
</ol>
<h4><a href="#2-moshi处理默认参数" class="header-anchor">#</a><span id="2-moshi处理默认参数">2. Moshi处理默认参数</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Moshi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonStr = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;Lee&quot;&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">     <span class="keyword">val</span> moshi = Moshi.Builder()</span><br><span class="line"><span class="comment">//            .add(KotlinJsonAdapterFactory())</span></span><br><span class="line">            .build()</span><br><span class="line">    <span class="keyword">val</span> jsonAdapter = moshi.adapter(PersonWithDefaultsAnnotation::<span class="keyword">class</span>.java)</span><br><span class="line">    println(jsonAdapter.toJson(PersonWithDefaultsAnnotation(<span class="string">&quot;Lee&quot;</span>)))</span><br><span class="line">    println(jsonAdapter.fromJson(jsonStr))</span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="keyword">val</span> moshi = Moshi.Builder()</span><br><span class="line">            .add(KotlinJsonAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line">    <span class="keyword">val</span> jsonAdapter = moshi.adapter(PersonWithDefaults::<span class="keyword">class</span>.java)</span><br><span class="line">    println(jsonAdapter.toJson(person))</span><br><span class="line">    println(jsonAdapter.fromJson(jsonStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonClass(generateAdapter = true)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithDefaultsAnnotation</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithDefaults</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithDefaults(name=Lee, age=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithDefaults(name=Lee, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>由打印结果可以看出，<code>Moshi</code>序列化和反序列化都可以支持默认值</li>
<li>方法一需要使用注解处理器，还需要添加远程依赖包：<code>com.squareup.moshi:moshi-kotlin-codegen:1.11.0</code></li>
<li>注解<code>@JsonClass(generateAdapter = true)</code>会在路径：<code>build/generated/source/kapt/debug/注解文件所在包名/</code>下生成<code>JsonAdapter</code>，用以对被注解的类进行序列化与反序列化，路径如下图所示：<br>
<img src="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/kotlin_moshi_generated_path.png" alt></li>
<li>方法二不需要添加注解，但是需要远程依赖包：<code>com.squareup.moshi:moshi-kotlin:1.11.0</code>，之后在创建<code>Moshi</code>对象时添加<code>KotlinJsonAdapterFactory</code>对象</li>
</ol>
<h4><a href="#3-ks处理默认参数" class="header-anchor">#</a><span id="3-ks处理默认参数">3. K.S处理默认参数</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlinx.serialization</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonStr = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;Lee&quot;&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    println(Json.encodeToString(PersonWithDefaults.serializer(),PersonWithDefaults(<span class="string">&quot;Lee&quot;</span>)))</span><br><span class="line">    println(Json.decodeFromString(PersonWithDefaults.serializer(),jsonStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithDefaults</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>&#125;</span><br><span class="line">PersonWithDefaults(name=Lee, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>由打印结果可以看出，<code>kotlinx.serialization</code>在序列化时忽略了默认参数，反序列化时支持默认参数</li>
<li>注解<code>@Serializable</code>会在数据类的伴生对象中创建序列化和反序列化的工具</li>
</ol>
<h3><a href="#3-带init块或成员初始化的数据类序列化" class="header-anchor">#</a><span id="3-带init块或成员初始化的数据类序列化">3. 带init块或成员初始化的数据类序列化</span></h3>
<h4><a href="#1-gson序列化带init块的数据类" class="header-anchor">#</a><span id="1-gson序列化带init块的数据类">1. Gson序列化带init块的数据类</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    println(gson.toJson(PersonWithInits(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)))</span><br><span class="line">    <span class="keyword">val</span> person = gson.fromJson(jsonStr, PersonWithInits::<span class="keyword">class</span>.java)</span><br><span class="line">    println(person)</span><br><span class="line">    println(person.firstName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DataClassAnnotation</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithInits</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;PersonWithInits#init()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> firstName <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PersonWithInits#init()</span><br><span class="line">&#123;<span class="string">&quot;firstName$delegate&quot;</span>:&#123;<span class="string">&quot;initializer&quot;</span>:&#123;&#125;,<span class="string">&quot;_value&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithInits#init()</span><br><span class="line">PersonWithInits(name=Lee, age=<span class="number">18</span>)</span><br><span class="line">Lee</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Gson</code>每次构造数据类时会检查数据类有没有默认无参构造器，若没有的话，则会通过<code>UnSafe</code>类创建数据类实例。通过<code>UnSafe</code>创建的实例不会调用<code>init</code>块和成员初始化代码</li>
<li>数据类默认是没有无参构造器的，可以使用前面数据类章节中提到的<a href="#jumpNoArg"><code>NoArg</code>插件</a></li>
<li>如上代码所示，数据类添加了使用<code>NoArg</code>插件的注解<code>@DataClassAnnotation</code>使用该数据类有了无参构造方法</li>
<li>如上打印结果所示，数据类有了无参构造方法，则<code>Gson</code>可以执行数据类中的<code>init</code>块的代码</li>
</ol>
<h4><a href="#2-moshi序列化带init块的数据类" class="header-anchor">#</a><span id="2-moshi序列化带init块的数据类">2. Moshi序列化带init块的数据类</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonStr = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;Lee&quot;, &quot;age&quot;:18&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="keyword">val</span> moshi = Moshi.Builder()</span><br><span class="line"><span class="comment">//            .add(KotlinJsonAdapterFactory())</span></span><br><span class="line">            .build()</span><br><span class="line">    <span class="keyword">val</span> jsonAdapter = moshi.adapter(PersonWithInitsAnnotation::<span class="keyword">class</span>.java)</span><br><span class="line">    println(jsonAdapter.toJson(PersonWithInitsAnnotation(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)))</span><br><span class="line">    <span class="keyword">val</span> person = jsonAdapter.fromJson(jsonStr)</span><br><span class="line">    println(person)</span><br><span class="line">    println(person?.firstName)</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="keyword">val</span> moshi2 = Moshi.Builder()</span><br><span class="line">            .add(KotlinJsonAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line">    <span class="keyword">val</span> jsonAdapter2 = moshi2.adapter(PersonWithInits::<span class="keyword">class</span>.java)</span><br><span class="line">    println(jsonAdapter2.toJson(PersonWithInits(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> person2 = jsonAdapter2.fromJson(jsonStr)</span><br><span class="line">    println(person2)</span><br><span class="line">    println(person2?.firstName)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonClass(generateAdapter = true)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithInitsAnnotation</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;PersonWithInits#init()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> firstName <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithInits</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;PersonWithInits#init()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> firstName <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PersonWithInits#init()</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithInits#init()</span><br><span class="line">PersonWithInitsAnnotation(name=Lee, age=<span class="number">18</span>)</span><br><span class="line">Lee</span><br><span class="line">PersonWithInits#init()</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithInits#init()</span><br><span class="line">PersonWithInits(name=Lee, age=<span class="number">18</span>)</span><br><span class="line">Lee</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>使用注解<code>@JsonClass</code>和使用反射<code>KotlinJsonAdapterFactory</code>这两种方式都会执行<code>init</code>块和成员变量的初始化</li>
<li><code>Moshi</code>反序列化时会调用数据类的构造器生成数据类对象</li>
</ol>
<h4><a href="#3-ks序列化带init块的数据类" class="header-anchor">#</a><span id="3-ks序列化带init块的数据类">3. K.S序列化带init块的数据类</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonStr = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;Lee&quot;, &quot;age&quot;:18&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    println(Json.encodeToString(PersonWithInits.serializer(), PersonWithInits(<span class="string">&quot;Lee&quot;</span>, <span class="number">18</span>)))</span><br><span class="line">    <span class="keyword">val</span> person = Json.decodeFromString(PersonWithInits.serializer(), jsonStr)</span><br><span class="line">    println(person)</span><br><span class="line">    println(person.firstName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PersonWithInits</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;PersonWithInits#init()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> firstName <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PersonWithInits#init()</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Lee&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">PersonWithInits#init()</span><br><span class="line">PersonWithInits(name=Lee, age=<span class="number">18</span>)</span><br><span class="line">Lee</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>kotlinx.serialization</code>会执行<code>init</code>块和成员变量的初始化</li>
<li>注解<code>@Serializable</code>会在数据类的伴生对象中生成序列化和反序列化的工具</li>
</ol>
<h2><a href="#3-框架对比" class="header-anchor">#</a><span id="3-框架对比">3. 框架对比</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>Gson</th>
<th>Moshi</th>
<th>K.S</th>
</tr>
</thead>
<tbody>
<tr>
<td>空类型</td>
<td>否</td>
<td>反射、注解</td>
<td>是</td>
</tr>
<tr>
<td>默认值</td>
<td>否</td>
<td>反射、注解</td>
<td>否</td>
</tr>
<tr>
<td>init块</td>
<td>NoArg插件</td>
<td>反射、注解</td>
<td>是</td>
</tr>
<tr>
<td>java类</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ol>
<li>如果使用的纯<code>java</code>工程，建议使用<code>Gson</code>和<code>Moshi</code></li>
<li>如果使用的<code>java</code>和<code>kotlin</code>混合工程，建议使用<code>Moshi</code></li>
<li>如果使用的纯<code>kotlin</code>工程，建议使用<code>K.S</code></li>
</ol>
<h1><a href="#十三-示例-递归整型列表" class="header-anchor">#</a><span id="十三-示例-递归整型列表">十三、示例 -  递归整型列表</span></h1>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//[0,1,2,3]</span></span><br><span class="line">    <span class="comment">//实现方式一</span></span><br><span class="line"><span class="comment">//    val list = IntList.Cons(0, IntList.Cons(1, IntList.Cons(2, IntList.Cons(3, IntList.Nil))))</span></span><br><span class="line">    <span class="keyword">val</span> list = intListOf(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    println(list)</span><br><span class="line">    println(list.joinToString(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    println(list.sum())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> (first, second, third) = list</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$first</span>, <span class="variable">$second</span>, <span class="variable">$third</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现嵌套列表</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">intListOf</span><span class="params">(<span class="keyword">vararg</span> ints: <span class="type">Int</span>)</span></span>: IntList &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(ints.size) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; IntList.Nil</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            IntList.Cons(</span><br><span class="line">                    ints[<span class="number">0</span>],</span><br><span class="line">                    intListOf(*(ints.slice(<span class="number">1</span> until ints.size).toIntArray()))</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展方法--求和</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> IntList.<span class="title">sum</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        IntList.Nil -&gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">is</span> IntList.Cons -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> head + tail.sum()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> IntList.<span class="title">component1</span><span class="params">()</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        IntList.Nil -&gt; <span class="literal">null</span></span><br><span class="line">        <span class="keyword">is</span> IntList.Cons -&gt; &#123;</span><br><span class="line">            head</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> IntList.<span class="title">component2</span><span class="params">()</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        IntList.Nil -&gt; <span class="literal">null</span></span><br><span class="line">        <span class="keyword">is</span> IntList.Cons -&gt; &#123;</span><br><span class="line">            tail.component1()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> IntList.<span class="title">component3</span><span class="params">()</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        IntList.Nil -&gt; <span class="literal">null</span></span><br><span class="line">        <span class="keyword">is</span> IntList.Cons -&gt; &#123;</span><br><span class="line">            tail.component2()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="comment">//链的最后一个</span></span><br><span class="line">    <span class="keyword">object</span>  Nil: IntList() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Nil&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>(<span class="keyword">val</span> head: <span class="built_in">Int</span>, <span class="keyword">val</span> tail:IntList): IntList() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>, <span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(sep: <span class="type">Char</span> = <span class="string">&#x27;,&#x27;</span>)</span></span>:String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Nil -&gt; &#123;</span><br><span class="line">                <span class="string">&quot;Nil&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> Cons -&gt; &#123;</span><br><span class="line">                <span class="string">&quot;<span class="subst">$&#123;head&#125;</span><span class="variable">$sep</span><span class="subst">$&#123;tail.joinToString(sep)&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, Nil</span><br><span class="line"><span class="number">0</span>-<span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span>-Nil</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在一个数组前加星号，表示将该数组元素变成一个个的参数传递给变长参数 <em>(vararg)</em></li>
<li>因为密封类的子类有限，所以可以使用<code>when</code>语句判断密封类</li>
<li>密封类中的<code>joinToString()</code>方法、它的扩展方法<code>sum()</code>和数据类<code>Cons</code>的<code>toString()</code>方法都使用了递归操作</li>
<li>只要有<code>component()</code>方法就可以解构,列表定义了几个<code>component</code>方法，就可以解构几个元素</li>
</ol>
<h1><a href="#十四-参考文章" class="header-anchor">#</a><span id="十四-参考文章">十四、参考文章</span></h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/java-inner-class-intro.html">https://www.runoob.com/w3cnote/java-inner-class-intro.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/compiler-plugins.html">https://www.kotlincn.net/docs/reference/compiler-plugins.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/compiler-plugins.html">https://www.kotlincn.net/docs/reference/compiler-plugins.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/kapt.html">https://www.kotlincn.net/docs/reference/kapt.html</a></li>
</ol>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-02-02</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/类型/" title="类型">类型 </a><span class="leancloud_visitors"></span><span>大约17689个字, 58分钟57秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2021/02/02/kotlin学习系列五/,Puppet,Kotlin学习系列五：类型进阶,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>