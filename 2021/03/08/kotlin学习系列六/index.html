<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列六：泛型 · Puppet</title><meta name="description" content="一、前言
二、泛型的基本概念

1. 基本声明

1. 函数声明泛型
2. 类声明泛型
3. 使用
4. Nothing




三、泛型约束

1. 添加泛型约束
2. 添加多个约束
3. 多个泛型参数


四、泛型型变

1. 不变
2. 协变

1. 实现协变
2. 协变点
3. 协变-Lis"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列六：泛型</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">二、泛型的基本概念</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%A3%B0%E6%98%8E">1. 基本声明</a>
<ul>
<li><a href="#1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B">1. 函数声明泛型</a></li>
<li><a href="#2-%E7%B1%BB%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B">2. 类声明泛型</a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8">3. 使用</a></li>
<li><a href="#4-nothing">4. Nothing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F">三、泛型约束</a>
<ul>
<li><a href="#1-%E6%B7%BB%E5%8A%A0%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F">1. 添加泛型约束</a></li>
<li><a href="#2-%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E7%BA%A6%E6%9D%9F">2. 添加多个约束</a></li>
<li><a href="#3-%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">3. 多个泛型参数</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B3%9B%E5%9E%8B%E5%9E%8B%E5%8F%98">四、泛型型变</a>
<ul>
<li><a href="#1-%E4%B8%8D%E5%8F%98">1. 不变</a></li>
<li><a href="#2-%E5%8D%8F%E5%8F%98">2. 协变</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E5%8D%8F%E5%8F%98">1. 实现协变</a></li>
<li><a href="#2-%E5%8D%8F%E5%8F%98%E7%82%B9">2. 协变点</a></li>
<li><a href="#3-%E5%8D%8F%E5%8F%98-listout-e%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">3. 协变-List<out e>的源码分析</out></a></li>
</ul>
</li>
<li><a href="#3-%E9%80%86%E5%8F%98">3. 逆变</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E9%80%86%E5%8F%98">1. 实现逆变</a></li>
<li><a href="#2-%E9%80%86%E5%8F%98%E7%82%B9">2. 逆变点</a></li>
<li><a href="#3-%E9%80%86%E5%8F%98-comparablein-t%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">3. 逆变-Comparable<in t>的源码分析</in></a></li>
</ul>
</li>
<li><a href="#4-unsafevariance%E6%B3%A8%E8%A7%A3">4. <code>UnsafeVariance</code>注解</a></li>
<li><a href="#5-%E5%9E%8B%E5%8F%98%E6%80%BB%E7%BB%93">5. 型变总结</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%98%9F%E6%8A%95%E5%BD%B1">五、 星投影</a>
<ul>
<li><a href="#1-%E6%98%9F%E6%8A%95%E5%BD%B1%E5%AE%9A%E4%B9%89">1. 星投影定义</a>
<ul>
<li><a href="#1-%E5%8D%8F%E5%8F%98%E7%82%B9%E7%A4%BA%E4%BE%8B">1. 协变点示例</a></li>
<li><a href="#2-%E9%80%86%E5%8F%98%E7%82%B9%E7%A4%BA%E4%BE%8B">2. 逆变点示例</a></li>
</ul>
</li>
<li><a href="#2-%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4">2. 适用范围</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%8D%8F%E5%8F%98-%E9%80%86%E5%8F%98-%E4%B8%8D%E5%8F%98%E7%9A%84%E8%A7%84%E5%88%99%E6%80%9D%E8%80%83">六、协变、逆变、不变的规则思考</a></li>
<li><a href="#%E4%B8%83-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%86%85%E8%81%94%E7%89%B9%E5%8C%96">七、泛型实现原理及内联特化</a>
<ul>
<li><a href="#1-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1. 泛型实现原理</a>
<ul>
<li><a href="#1-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4">1. 泛型擦除</a></li>
<li><a href="#2-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94">2. 泛型实现对比</a></li>
</ul>
</li>
<li><a href="#2-%E5%86%85%E8%81%94%E7%89%B9%E5%8C%96">2. 内联特化</a>
<ul>
<li><a href="#1-%E5%86%85%E8%81%94%E7%89%B9%E5%8C%96%E6%A6%82%E5%BF%B5">1. 内联特化概念</a></li>
<li><a href="#2-%E5%86%85%E8%81%94%E7%89%B9%E5%8C%96%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">2. 内联特化实际应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E7%A4%BA%E4%BE%8B">八、 示例</a>
<ul>
<li><a href="#1-%E6%A8%A1%E6%8B%9F-self-type">1. 模拟 <code>Self Type</code></a>
<ul>
<li><a href="#1-builder%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98">1. <code>Builder</code>模式中的类型继承问题</a></li>
<li><a href="#2-scala%E7%9A%84self-type">2. <code>Scala</code>的<code>Self Type</code></a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%A8%A1%E6%8B%9Fself-type">3. 使用泛型模拟<code>Self Type</code></a></li>
</ul>
</li>
<li><a href="#2-%E5%9F%BA%E4%BA%8E%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0model%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%B3%A8%E5%85%A5">2. 基于泛型实现<code>Model</code>实例的注入</a>
<ul>
<li><a href="#1-%E4%BD%BF%E7%94%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E5%9C%B0%E6%96%B9">1. 使用注入的地方</a></li>
<li><a href="#2-%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%85%A5">2. 通过代理方式实现注入</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%80">1. 实现方式一</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BA%8C">实现方式二</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%9D-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">九、参考文章</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 泛型</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://github.com/enbandari">Bennyhuo老师</a>讲解的<code>Kotlin</code>系列视频的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程初解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程进阶</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程应用</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-泛型的基本概念" class="header-anchor">#</a><span id="二-泛型的基本概念">二、泛型的基本概念</span></h1>
<ol>
<li>泛型是一种类型层面的抽象</li>
<li>泛型通过泛型参数实现构造更加通用的类型的能力</li>
<li>泛型可以让符合继承关系的类型批量实现某些能力</li>
</ol>
<h2><a href="#1-基本声明" class="header-anchor">#</a><span id="1-基本声明">1. 基本声明</span></h2>
<p>使用泛型前要先用尖括号声明泛型</p>
<h3><a href="#1-函数声明泛型" class="header-anchor">#</a><span id="1-函数声明泛型">1. 函数声明泛型</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> kotlin.comparisons</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">maxOf</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt;= b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>函数声明泛型，泛型的声明要放到函数名之前</li>
<li>如上代码是比较大小的源码，比较两个泛型对象大小，返回较大的对象</li>
<li>上述代码声明了一个泛型<code>T</code>该泛型代表的类型要实现<code>Comparable</code>接口，以确保可以比较大小</li>
</ol>
<h3><a href="#2-类声明泛型" class="header-anchor">#</a><span id="2-类声明泛型">2. 类声明泛型</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span>  Nil: List&lt;<span class="built_in">Nothing</span>&gt;() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">E</span>&gt; (<span class="keyword">val</span> head: E, <span class="keyword">val</span> tail:List&lt;E&gt;): List&lt;E&gt;() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在类上声明泛型时，泛型声明位于类名后</li>
<li><code>Nothing</code>类是所有类型的子类</li>
<li>数据类<code>Cons</code>的泛型声明，是声明了一个泛型形参，而它实现<code>List</code>类时将这个形参作为一个实参传递给了密封类<code>List</code></li>
</ol>
<h3><a href="#3-使用" class="header-anchor">#</a><span id="3-使用">3. 使用</span></h3>
<p>声明泛型时只是声明了泛型形参，而调用时传递进去一个具体类型的实参</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = maxOf(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">println(max)</span><br><span class="line"><span class="comment">//val list = List.Cons&lt;Double&gt;(1.0, List.Nil)</span></span><br></pre></td></tr></table></figure>
<h3><a href="#4-nothing" class="header-anchor">#</a><span id="4-nothing">4. Nothing</span></h3>
<p><img src="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/kotlin_type_construct.png" alt></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nothing</span> <span class="keyword">private</span> <span class="keyword">constructor</span>()</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Kotlin</code> 里所有东西都有类型，而且有明显的层级关系如上图所示</li>
<li><code>Kotlin</code>类型层次结构的最底层就是类型 <code>Nothing</code> ，最顶层是类型<code>Any?</code>，即<code>Nothing</code>类是所有类型的子类，<code>Any?</code>类是所有类型的父类</li>
<li><code>Nothing</code>类型的表达式计算结果是永远不会返回的 <em>（跟<code>Java</code> 中的 <code>void</code> 相同）</em></li>
<li><code>Nothing</code>的构造方法私有的，所以是没有实例的。可以使用<code>Nothing</code>来表示“一个不存在的值”</li>
<li><code>Nothing?</code>可以只包含一个值：<code>null</code></li>
<li><a target="_blank" rel="noopener" href="https://www.kancloud.cn/alex_wsc/android_kotlin/1053641">参考文章1</a>   <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/exceptions.html#java-interoperability">参考文章2</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26890263">参考文章3</a></li>
<li><em>图中线条颜色无实际意义，只为了方便查看</em></li>
</ol>
<h1><a href="#三-泛型约束" class="header-anchor">#</a><span id="三-泛型约束">三、泛型约束</span></h1>
<h2><a href="#1-添加泛型约束" class="header-anchor">#</a><span id="1-添加泛型约束">1. 添加泛型约束</span></h2>
<p><strong>在声明泛型时通过继承父类或实现接口的方式为泛型添加约束</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin.comparisons</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">maxOf</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt;= b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">maxOf</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.compareTo(b) &gt; <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码所示，方法<code>maxOf()</code>比较两个泛型类型的大小</li>
<li><code> : Comparable&lt;T&gt;</code>强制要求传入的泛型参数，必须是 <code>Comparable</code> 或者是它的子类。这叫做泛型的上界。</li>
<li><code>Java</code>中也是通过继承父类或实现接口的方式为泛型添加约束</li>
</ol>
<h2><a href="#2-添加多个约束" class="header-anchor">#</a><span id="2-添加多个约束">2. 添加多个约束</span></h2>
<p>实现目标：比较两个类大小，并调用较大类的<code>invoke()</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">callMax</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T : Comparable&lt;T&gt;, T : () -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) a() <span class="keyword">else</span> b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>通过<code>where</code>语句为泛型添加多个约束</li>
<li>如上代码所示，泛型<code>T</code>必须实现接口<code>Comparable</code>能比较大小，而且是一个返回值是<code>Unit</code>的函数支持<code>invoke()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt; &amp; Supplier&lt;R&gt;, R <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; R <span class="title function_">callMax</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.compareTo(b) &gt; <span class="number">0</span>) <span class="keyword">return</span> a.get();</span><br><span class="line">    <span class="keyword">return</span> b.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示，在声明泛型<code>T</code>时为它添加了约束, 它必须是<code>Comparable</code>和<code>Supplier</code>的，并且返回结果必须是数值型的</li>
</ol>
<h2><a href="#3-多个泛型参数" class="header-anchor">#</a><span id="3-多个泛型参数">3. 多个泛型参数</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> <span class="title">callMax</span><span class="params">(a:<span class="type">T</span>, b:<span class="type">T</span>)</span></span> <span class="keyword">where</span> T: Comparable&lt;T&gt;, T:()-&gt;R, R: Number &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) a() <span class="keyword">else</span> b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码所示，声明了两个泛型：<code>T</code>代表要比较的类，<code>R</code>代表比较类的返回值是<code>R</code></li>
<li>要比较的类型<code>T</code>必须实现接口<code>Comparable</code>，而且是一个返回值是数值类型的<code>R</code>的函数</li>
</ol>
<h1><a href="#四-泛型型变" class="header-anchor">#</a><span id="四-泛型型变">四、泛型型变</span></h1>
<blockquote>
<p>任何时候期望A类型的值时，可以使用B类型的值,则B就是A的 <strong>子类型</strong><br>
超类型是子类型的反义词。如果B是A的子类型，那么反过来A就是B的 <strong>超类型</strong></p>
</blockquote>
<p>首先，型变是什么呢？简单来说，它就是为了解决 <strong>泛型的不变性问题</strong>。事实上，型变讨论的是：在已知 经 <code>Cat</code> 是 <code>Animal</code> 的子类的情况下，<code>MutableList&lt;Cat&gt;</code> 与 <code>MutableList&lt;Animal&gt;</code> 之间是什么关系。<br>
在正常情况下，编译器会认为它们两者是没有任何关系的。换句话，也就是说，<strong>泛型是不变的</strong>。<code>Kotlin</code> 编译器会这样处理的原因也很简单，这里我们可以先来假设一下：如果编译器不阻止我们用<code>MutableList&lt;Cat&gt;</code> 替代 <code>MutableList&lt;Animal&gt;</code>，当程序需要 <code>Animal</code> 的集合时，如果我们传入的是 <code>Cat</code> 的集合，我们就可以往 <code>Cat</code>集合 里添加其他类型的动物，比如 <code>Dog</code>。然而，<code>Dog</code> 是无法存入 <code>Cat</code> 的集合的。<br>
那如果反过来，当需要子类集合传入父类集合的时候，我们在函数体内部存储的行为是不会受到影响的，存储 <code>Cat</code>、<code>Animal</code> 类型都没问题。可是，一旦我们想从集合当中取出 <code>Cat</code> 对象的时候，会发现取出来的是 <code>Animal</code> 对象，这时候又错了。<br>
这就造成了类型不一致的可能性，无法确保类型安全，违背了泛型引入的初衷 —— <strong>确保类型安全。</strong> 所以，在默认情况下，编译器会认为 <code>MutableList&lt;Cat&gt;</code> 与 <code>MutableList&lt;Animal&gt;</code> 之间不存在任何继承关系，它们也无法互相替代，这样就不会出现前面提到的两种问题。这就是 <strong>泛型的不变性</strong>。</p>
<p>而<code>Java</code>提供了 <strong>有限制的通配符</strong> 来确保类型安全，允许泛型类构建相应的子类型化关系，提高代码的通用性(灵活性)。与之对应的，便是<code>Kotlin</code>的型变。<code>Kotlin</code>中存在协变和逆变两种概念</p>
<p>泛型型变有三类：不变、协变、逆变</p>
<h2><a href="#1-不变" class="header-anchor">#</a><span id="1-不变">1. 不变</span></h2>
<p>泛型形参没有继承关系，泛型实参也没有继承关系</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Nil:List&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">E</span>&gt; (<span class="keyword">val</span> head: E, <span class="keyword">val</span> tail:List&lt;E&gt;): List&lt;E&gt;() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = List.Cons(<span class="number">1.0</span>, List.Nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>声明的泛型<code>T</code>之前 <strong>没有任何修饰词</strong> ，表示泛型型变不变，即泛型没有任何继承关系</li>
<li><code>List&lt;Nothing&gt;</code>不是<code>List&lt;T&gt;</code>的子类，<code>List.Nil</code>也不是<code>List&lt;T&gt;</code>的子类</li>
<li><code>List.Nil</code>不能满足<code>List&lt;T&gt;</code>，所以<code>list</code>的赋值语句会报错</li>
</ol>
<p>不变型就是没有子类型化关系，所以它会有一个局限性就是如果以它作为函数形参类型，外部传入只能是和它相同的类型，因为它根本就不存在子类型化关系说法，那也就是没有任何类型值能够替换它，除了它自己本身的类型 例如<code>MutableList&lt;String&gt;</code>和<code>MutableList&lt;String?&gt;</code>是完全两种不一样的类型，尽管<code>String</code>是<code>String?</code>子类型，但是基础泛型<code>MutableList&lt;E&gt;</code>是不变型的，所以<code>MutableList&lt;String&gt;</code>和<code>MutableList&lt;String?&gt;</code>根本没关系。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MutableList</span>&lt;<span class="type">E</span>&gt;&#123;<span class="comment">//没有in和out修饰</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">E</span>)</span></span><span class="comment">//E可以作为函数形参类型处于逆变点，输入消费E</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">subList</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span>: MutableList&lt;E&gt;<span class="comment">//E又可以作为函数返回值类型处于协变点，生产输出E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#2-协变" class="header-anchor">#</a><span id="2-协变">2. 协变</span></h2>
<h3><a href="#1-实现协变" class="header-anchor">#</a><span id="1-实现协变">1. 实现协变</span></h3>
<p>泛型形参的继承关系与泛型实参的继承关系一致</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Book</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EduBook</span>: <span class="type">Book</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getBook</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        TODO()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buyBook</span><span class="params">(store: <span class="type">BookStore</span>&lt;<span class="type">Book</span>&gt;)</span></span> &#123;</span><br><span class="line">    store.getBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//声明了一家教育类书店</span></span><br><span class="line">    <span class="keyword">val</span> edu = BookStore&lt;EduBook&gt;()</span><br><span class="line">    <span class="comment">//需要普通类型书店，传入了教育类书店，编译器报错</span></span><br><span class="line">    buyBook(edu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上声明了几个类：<code>Book</code>、<code>Book</code>的子类<code>EduBook</code>以及书店类 <code>BookStore</code></li>
<li>在书店类<code>BookStore</code>的泛型参数处，可以传入不同的书的类型，就代表不同类型的书店</li>
<li>之后又定义了买书方法<code>buyBook()</code>方法，该方法传入一个书店然后购买该书店的图书</li>
<li>最后在<code>main()</code>方法中声明了一家教育类型书店<code>edu</code>，然后将该书店作为参数传入<code>buyBook()</code>方法，结果编译器报错：<code>Type mismatch. Required: BookStore&lt;Book&gt;   Found: BookStore&lt;EduBook&gt;</code>，因为<code>buyBook()</code>需要<code>BookStore&lt;Book&gt;</code>，而传入了<code>BookStore&lt;EduBook&gt;</code>，类型不匹配</li>
</ol>
<p>所有书店都应该可以购买图书，由于编译器认死理，我们必须额外提供一些信息给编译器，让它知道我们是在特殊场景使用泛型。具体的做法有两种。<br>
第一种做法，修改泛型参数的使用处，也就是 <strong>使用处型变</strong>。具体的做法就是修改 <code>buyBook()</code> 函数的声明，在 <code>Book</code> 的前面增加一个 <code>out</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buyBook</span><span class="params">(store: <span class="type">BookStore</span>&lt;<span class="type">out</span> <span class="type">Book</span>&gt;)</span></span> &#123;</span><br><span class="line">    store.getBook()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种做法，是修改 <code>BookStore</code> 的源代码，也就是<strong>声明处型变</strong>。具体做法就是，在它泛型形参 <code>T</code> 的前面增加一个关键字 <code>out</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getBook</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        TODO()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
在做完以上任意一种修改以后，代码就可以通过编译了。这也就意味着，在这种情况下，我们可以使用<code>BookStore&lt;EduBook&gt;</code>替代<code>BookStore&lt;Book&gt;</code>，也就意味着<code>BookStore&lt;EduBook&gt;</code>可以看作是<code>BookStore&lt;Book&gt;</code>的子类。</p>
<p><img src="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/kotlin_covariation_relation.png" alt></p>
<p>由上图可知，图书与书店它们之间的父子关系一致了。这种现象，我们称之为 <strong>“泛型的协变”</strong> 。也可以说两个具有相同的基础类型的泛型协变类型，如果类型实参具有子类型化关系，那么这个泛型类型具有一致方向的子类型化关系。上面两种修改的方式，就分别叫做 <strong>使用处协变</strong> 和 <strong>声明处协变</strong> 。<code>kotlin</code>中泛型的协变<code>out</code>对应<code>Java</code>中的<code>? extend </code>操作</p>
<h3><a href="#2-协变点" class="header-anchor">#</a><span id="2-协变点">2. 协变点</span></h3>
<p><code>Kotlin</code> 中规定一个泛型协变类，在泛型形参前面加上<code>out</code>修饰后，那么修饰这个泛型形参在函数内部使用范围将受到限制只能作为函数的返回值或者修饰只读权限的属性。</p>
<p><strong>协变点：</strong> 在一个类里的函数的返回值为我们定义的泛型参数，则该函数返回的泛型参数为协变点</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123;<span class="comment">//在泛型类型形参前面指定out修饰符</span></span><br><span class="line">   <span class="keyword">val</span> something: T<span class="comment">//T作为只读属性的类型，这里T的位置也是out协变点</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T<span class="comment">//T作为函数的返回值输出给外部,这里T的位置就是out协变点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上协变点都是标准的T类型，实际上以下这种方式其实也是协变点,请注意体会协变点含义:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> something: List&lt;T&gt;<span class="comment">//即使T不是单个的类型，但是它作为一个泛型类型修饰只读属性，所以它所处位置还是out协变点</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: List&lt;Map&lt;String,T&gt;&gt;<span class="comment">//即使T不是单个的类型，但是它作为泛型类型的类型实参修饰返回值，所以它所处位置还是out协变点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>协变点基本特征:</strong>  如果一个泛型类声明成协变的，用<code>out</code>修饰的那个类型形参，在函数内部出现的位置只能在只读属性的类型或者函数的返回值类型。相对于外部而言协变是生产泛型参数的角色，生产者向外输出<code>out</code></p>
<h3><a href="#3-协变-list的源码分析" class="header-anchor">#</a><span id="3-协变-list的源码分析">3. 协变-List<out e>的源码分析</out></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过泛型类定义可以看出使用out修饰符 修饰泛型类型形参E</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span><span class="comment">//咦! 咦! 咦! 和说的不一样啊，为什么还能出现在这个位置，还出来了个@UnsafeVariance 这个是什么鬼？ 告诉你，稳住，先不要急，请听我在后面慢慢说来，先暂时保留神秘感</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;E&gt;<span class="comment">//这里明显能看出来E处于out协变点位置，而且还是泛型类型Iterator&lt;E&gt;出现的，正好验证我们上述所说的协变的变种类型(E为类型实参的泛型类型)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;@<span class="type">UnsafeVariance</span> <span class="type">E</span>&gt;)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: E<span class="comment">//函数返回值的类型E，这里明显能看出来E处于out协变点位置，正好验证我们上述所说的协变的标准类型(E直接为返回值的类型)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">indexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">lastIndexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">listIterator</span><span class="params">()</span></span>: ListIterator&lt;E&gt;<span class="comment">//(E为类型实参的泛型类型),为out协变点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">listIterator</span><span class="params">(index: <span class="type">Int</span>)</span></span>: ListIterator&lt;E&gt;<span class="comment">//(E为类型实参的泛型类型),为out协变点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">subList</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span>: List&lt;E&gt;<span class="comment">//(E为类型实参的泛型类型),为out协变点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#3-逆变" class="header-anchor">#</a><span id="3-逆变">3. 逆变</span></h2>
<h3><a href="#1-实现逆变" class="header-anchor">#</a><span id="1-实现逆变">1. 实现逆变</span></h3>
<p>泛型形参的继承关系与泛型实参的继承关系相反</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaWeiTV</span>: <span class="type">TV</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>声明了两个类：父类电视类<code>TV</code>，子类华为电视类<code>HuaWeiTV</code>，它们两者是继承关系。由于它们是父子的关系，当函数的参数需要 <code>TV</code> 这个父类的时候，我们是可以传入子类<code>HuaWeiTV</code>作为参数的。</li>
<li>声明了遥控器类<code>Controller</code>，它有一个<code>turnOn()</code>方法用于打开电视</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                      需要一个华为电视的遥控器</span></span><br><span class="line"><span class="comment">//                                ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buy</span><span class="params">(controller: <span class="type">Controller</span>&lt;<span class="type">HuaWeiTV</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> huaWeiTV = HuaWeiTV()</span><br><span class="line">    <span class="comment">// 打开华为电视</span></span><br><span class="line">    controller.turnOn(huaWeiTV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们的<code>buy()</code>函数需要一个“华为电视的遥控器”，在函数的内部，我们需要打开华为电视。那么，当我们需要打开一台华为电视机的时候，我们是否可以用一个“万能的遥控器”呢？当然可以！所以，我们可以写出下面这样的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//                             实参</span></span><br><span class="line"><span class="comment">//                              ↓</span></span><br><span class="line">    <span class="keyword">val</span> controller = Controller&lt;TV&gt;()</span><br><span class="line">    <span class="comment">// 传入万能遥控器，报错</span></span><br><span class="line">    buy(controller)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，由于我们传入的泛型实参是 <code>TV</code>，它是所有电视机的父类。因此，<code>Controller</code> 内部将会处理所有电视机型号的开机、关机。这时候，它就相当于一个万能遥控器，万能遥控器当然也可以打开华为电视。从道理上来讲，我们的推理是没有错的，不过 <code>Kotlin</code> 编译器会报错，报错的内容是说“类型不匹配”，需要的是华为遥控器<code>Controller&lt;HuaWeiTV&gt;</code>，你却买了个万能遥控器<code>Controller&lt;TV&gt;</code>。</p>
<p>所以，为了让我们的代码通过编译，我们需要主动告诉编译器一些额外的信息，具体的做法有两种。</p>
<p>第一种做法，是修改泛型参数的使用处代码，它叫做<strong>使用处型变</strong>。具体做法就是修改 <code>buy</code> 函数的声明，在 <code>HuaWeiTV</code> 的前面增加一个 <code>in</code> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                      需要一个华为电视的遥控器</span></span><br><span class="line"><span class="comment">//                                ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buy</span><span class="params">(controller: <span class="type">Controller</span>&lt;<span class="type">in</span> <span class="type">HuaWeiTV</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> huaWeiTV = HuaWeiTV()</span><br><span class="line">    <span class="comment">// 打开华为电视</span></span><br><span class="line">    controller.turnOn(huaWeiTV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种做法，是修改 <code>Controller</code> 的源代码，这叫<strong>声明处型变</strong>。具体做法就是，在泛型形参 <code>T</code> 的前面增加一个关键字 <code>in</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//            变化在这里</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用以上任意一种方式修改后，代码就能够通过 <code>Kotlin</code> 编译了。这样修改之后，我们就可以使用<code>Controller&lt;TV&gt;</code>来替代<code>Controller&lt;HuaWeiTV&gt;</code>，也就是说，<code>Controller&lt;TV&gt;</code>是<code>Controller&lt;HuaWeiTV&gt;</code>的子类。</p>
<p><img src="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/kotlin_contravariant_relation.png" alt></p>
<p>在这个场景下，遥控器与电视机之间的父子关系颠倒了。“华为电视”是“电视”的子类，但是，“万能遥控”成了“华为遥控”的子类。这种父子关系颠倒的现象，我们就叫做 <strong>“泛型的逆变”</strong>。也可以说两个具有相同的基础类型的泛型逆变类型，如果类型实参具有子类型化关系，那么这个泛型类型具有相反方向的子类型化关系。上面这两种修改方式，就分别叫做<strong>使用处逆变</strong>和<strong>声明处逆变</strong>。</p>
<h3><a href="#2-逆变点" class="header-anchor">#</a><span id="2-逆变点">2. 逆变点</span></h3>
<p><code>Kotlin</code>中规定一个泛型协变类，在泛型形参前面加上<code>out</code>修饰后，那么修饰这个泛型形参在函数内部使用范围将受到限制只能作为函数的返回值或者修饰只读权限的属性。</p>
<p><strong>逆变点：</strong> 在一个类里的函数的入参为我们定义的泛型参数，则该函数形参的泛型参数为逆变点</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;<span class="type">in T</span>&gt;&#123;<span class="comment">//在泛型类型形参前面指定in修饰符</span></span><br><span class="line">   <span class="keyword">var</span> something: T <span class="comment">//T作为可变属性的类型，这里T的位置也是in逆变点</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(value: <span class="type">T</span>)</span></span><span class="comment">//T作为函数形参类型，这里T的位置也就是in逆变点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和协变类似，逆变也存在那种泛型类型处于逆变点的位置，这些我们都可以把当做逆变点:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;<span class="type">in T</span>&gt;&#123;</span><br><span class="line">   <span class="keyword">var</span> something: B&lt;T&gt;<span class="comment">//这里虽然是泛型类型但是T所在位置依然是修饰可变属性类型，所以仍处于逆变点</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(value: <span class="type">A</span>&lt;<span class="type">T</span>&gt;)</span></span><span class="comment">//这里虽然是泛型类型但是T所在位置依然是函数形参类型，所以仍处于逆变点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逆变点基本特征:</strong> 如果一个泛型类声明成逆变的，用in修饰泛型类的类型形参，在函数内部出现的位置只能是作为可变属性的类型或者函数的形参类型。相对于外部而言逆变是消费泛型参数的角色，消费者请求外部输入in</p>
<h3><a href="#3-逆变-comparable的源码分析" class="header-anchor">#</a><span id="3-逆变-comparable的源码分析">3. 逆变-Comparable<in t>的源码分析</in></span></h3>
<p>在<code>Kotlin</code>中其实最简单的泛型逆变的例子就是<code>Comparable&lt;in T&gt;</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;<span class="comment">//泛型逆变使用in关键字修饰</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object with the specified object for order. Returns zero if this object is equal</span></span><br><span class="line"><span class="comment">     * to the specified [other] object, a negative number if it&#x27;s less than [other], or a positive number</span></span><br><span class="line"><span class="comment">     * if it&#x27;s greater than [other].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span><span class="comment">//因为是逆变的，所以T在函数内部出现的位置作为compareTo函数的形参类型，可以看出它是属于消费泛型参数的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><a href="#4-unsafevariance注解" class="header-anchor">#</a><span id="4-unsafevariance注解">4. <code>UnsafeVariance</code>注解</span></h2>
<ul>
<li>
<p>型变点与泛型参数定义不一致时可以使用注解<code>UnsafeVariance</code>来使编译器停止警告。</p>
</li>
<li>
<p>即：只要函数内部能保证不会对泛型参数存在写操作的行为，可以使用<code>UnSafeVariance</code>注解使编译器停止警告，就可以将其放在<code>in</code>位置。<code>out</code>关键字修饰的泛型参数也是同理。</p>
</li>
<li>
<p>示例：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin.collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">expect</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;<span class="type">E</span>&gt; : <span class="type">MutableList</span>&lt;<span class="type">E</span>&gt;, <span class="type">RandomAccess</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;@<span class="type">UnsafeVariance</span> <span class="type">E</span>&gt;)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: E</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">indexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">lastIndexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示<code>Kotlin</code>的<code>ArrayList</code>中<code>contains</code>等函数，就是应用<code>UnSafeVariance</code>注解使泛型参数存在于<code>in</code>位置，其内部没有写操作。</p>
</li>
</ul>
<h2><a href="#5-型变总结" class="header-anchor">#</a><span id="5-型变总结">5. 型变总结</span></h2>
<table>
<thead>
<tr>
<th>协变</th>
<th>逆变</th>
<th>不变</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构</td>
<td>Producer<out t></out></td>
<td>Consumer<in t></in></td>
</tr>
<tr>
<td>Java实现</td>
<td>Producer&lt;? extends T&gt;</td>
<td>Consumer&lt;? super T&gt;</td>
</tr>
<tr>
<td>子类型化关系</td>
<td>保留子类型化关系</td>
<td>逆转子类型化关系</td>
</tr>
<tr>
<td>位置</td>
<td>out位置</td>
<td>in位置</td>
</tr>
<tr>
<td>角色</td>
<td>生产者</td>
<td>消费者</td>
</tr>
<tr>
<td>表现</td>
<td>只读</td>
<td>只写，读取受限</td>
</tr>
</tbody>
</table>
<p><strong>使用泛型时，选择型变类型：</strong></p>
<ul>
<li>
<p>首先需要考虑泛型形参的位置：只读操作(协变或不变)、只写读操作(逆变或不变)、又读又写操作（不变）。<br>
例如：<code>Array</code>中存在又读又写的操作，如果为其指定协变或逆变，都会造成类型不安全：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> size: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T &#123; …… &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后判断是否需要子类型化关系，子类型化关系主要用于提高<code>API</code>的灵活度。<br>
如果需要子类型化关系，则只读操作(协变或不变)选择协变，否则不变;只写读操作(逆变或不变),选择逆变，否则不变。</p>
</li>
</ul>
<h1><a href="#五-星投影" class="header-anchor">#</a><span id="五-星投影">五、 星投影</span></h1>
<h2><a href="#1-星投影定义" class="header-anchor">#</a><span id="1-星投影定义">1. 星投影定义</span></h2>
<p>所谓的星投影，其实就是用 <strong>“星号”</strong> 作为泛型的实参。那么，什么情况下，我们需要用星号作为泛型实参呢？答案其实也很简单，当我们不关心实参到底是什么的时候。举个例子，我们现在需要开发一个“找饭店”的功能，借助泛型，我们可以写出这样的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">findRestaurant</span><span class="params">()</span></span>: Restaurant&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不过，如果我们并不关心找到的饭店到底是什么类型，不管它是肯德基还是麦当劳的话，那么，我们就完全可以把“星号”作为泛型的实参，比如这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                        把星号作为泛型实参</span></span><br><span class="line"><span class="comment">//                               ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findRestaurant</span><span class="params">()</span></span>: Restaurant&lt;*&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> restaurant = findRestaurant()</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">val</span> food: Any? = restaurant.orderFood() <span class="comment">// 返回值可能是：任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码当中，我们没有传递任何具体的类型给 <code>Restaurant</code>，而是使用了“星号”作为 <code>Restaurant</code> 的泛型实参，因此，我们就无法知道饭店到底是什么类型。相应的，当我们调用 <code>restaurant.orderFood()</code> 的时候，就无法确定它返回的值到底是什么类型。这时候，变量 <code>food</code> 的实际类型可能是任意的，比如 <code>String</code>、<code>Int</code>、<code>Food</code>、<code>KFC</code>，甚至可能是 <code>null</code>，因此，在这里我们只能将其看作是“<code>Any?</code>”类型。那么，对于上面的这种 <code>food</code> 可能是任意类型的情况，我们有没有办法让 <code>food</code> 的类型更加精确一些呢？当然是有的。如果我们为 <code>Restaurant</code> 的泛型类型加上边界的话，<code>food</code> 的类型就可以更精确一些。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                   区别在这里</span></span><br><span class="line"><span class="comment">//                       ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T: Food</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findRestaurant</span><span class="params">()</span></span>: Restaurant&lt;*&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> restaurant = findRestaurant()</span><br><span class="line">    <span class="comment">//       注意这里</span></span><br><span class="line">    <span class="comment">//          ↓</span></span><br><span class="line">    <span class="keyword">val</span> food: Food = restaurant.orderFood() <span class="comment">// 返回值是：Food或其子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子我们能看到，当我们为 <code>Restaurant</code> 泛型类型增加了上界 <code>Food</code> 以后，即使我们使用了“星投影”，也仍然可以通过调用 <code>restaurant.orderFood()</code>，来拿到 <code>Food</code> 类型的变量。在这里，<code>food</code> 的实际类型肯定是 <code>Food</code> 或者是 <code>Food</code> 的子类，因此我们可以将其看作是 <code>Food</code> 类型。泛型虽然很抽象，但它存在的目的，仍然是为了解决我们生活的实际问题。所以，当我们将泛型应用到实际的生活场景时，它就显得不是那么抽象了。</p>
<p><code>*</code>所替换的类型在：</p>
<ul>
<li>协变点返回泛型参数上限类型</li>
<li>逆变点接收泛型参数下限类型</li>
</ul>
<h3><a href="#1-协变点示例" class="header-anchor">#</a><span id="1-协变点示例">1. 协变点示例</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queryMap: QueryMap&lt;*, *&gt; = QueryMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    queryMap.getKey()</span><br><span class="line">    queryMap.getValue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueryMap</span>&lt;<span class="type">out K: CharSequence, out V : Any</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getKey</span><span class="params">()</span></span>: K = TODO()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: V = TODO()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>声明了一个类<code>QueryMap</code>，接收两个泛型：协变泛型<code>K</code>，约束上界为<code>CharSequence</code>; 协变泛型<code>V</code>, 约束上界为<code>Any</code></li>
<li>声明变量<code>queryMap</code>时类型为<code>QueeryMap</code>，但是传入的两个泛型为星号。</li>
<li>变量<code>queryMap</code>的<code>getKey()</code>方法返回值的类型就是泛型<code>K</code>的上界，即<code>CharSequence</code></li>
<li>变量<code>queryMap</code>的<code>getValue()</code>方法返回值的类型就是泛型<code>V</code>的上界，即<code>Any</code></li>
</ol>
<h3><a href="#2-逆变点示例" class="header-anchor">#</a><span id="2-逆变点示例">2. 逆变点示例</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: Function&lt;*,*&gt; = Function&lt;Number, Any&gt;()</span><br><span class="line">    f.invoke()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Function</span>&lt;<span class="type">in P1, in P2</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>, p2: <span class="type">P2</span>)</span></span> = <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>声明了一个类<code>Function</code>，接收两个泛型：逆变泛型<code>P1</code>、逆变泛型<code>P2</code></li>
<li>声明变量<code>f</code>时类型为<code>Function</code>，但是传入的两个泛型为星号</li>
<li>调用变量<code>f</code>的<code>invoke()</code>方法，时传入的两个参数的类型取泛型的下限</li>
<li>定义泛型时没办法添加下限约束，所以是<code>Nothing</code></li>
<li>因为<code>Nothing</code>没有实例，所以变量<code>f</code>的<code>invoke()</code>方法无法调用</li>
</ol>
<h2><a href="#2-适用范围" class="header-anchor">#</a><span id="2-适用范围">2. 适用范围</span></h2>
<p><strong><code>*</code>不能直接或间接应用在属性或函数上，即不能将<code>*</code>作为一个类型传递给泛型</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryMap&lt;Sting,*&gt;()</span><br><span class="line">maxOf&lt;*&gt;(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上两种<code>*</code>的使用方式都是 <strong>不正确的</strong>，不能将<code>*</code>作为一个类型传递给泛型</li>
<li>第一条语句将<code>*</code>间接作用到属性上</li>
<li>第二条语句将<code>*</code>直接作用到函数上</li>
</ol>
<p><strong><code>*</code>适用于作为类型描述的场景</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> queryMap:QueryMap&lt;*, *&gt;</span><br><span class="line"><span class="keyword">if</span>(f <span class="keyword">is</span> Function&lt;*, *&gt;)&#123;&#125;</span><br><span class="line">HashMap&lt;String, List&lt;*&gt;&gt;()</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>类型实例化时或真正使用时可以使用<code>*</code></li>
<li>第一条语句：定义一个<code>queryMap</code>变量时，该变量类型是<code>QueryMap</code>类，<code>QueryMap</code>类传入的两个泛型使用<code>*</code> 描述，之后会根据<code>QueryMap</code>类里定义泛型时是协变还是逆变，来取上限还是下限</li>
<li>第二条语句：使用操作符<code>is</code>来判断变量是什么类型时，<code>is</code>后的类型可以使用<code>*</code>，因其也是类型描述</li>
<li>第三条语句：是一个<code>HashMap</code>的类型构造，本来是不允许使用<code>*</code>，但是<code>HashMap</code>有两个泛型参数<code>K</code>、<code>V</code>, 这两个泛型参数传的都是具体的类型：<code>K</code>对应<code>String</code>,<code>V</code>对应<code>List&lt;*&gt;</code>，其中<code>List</code>可以传递一个泛型参数，这个泛型参数可以使用<code>*</code>。因为<code>List&lt;*&gt;</code>在这个位置作为参数实际上是一个描述。<br>
<strong>总结：直接的类型构造是不能用<code>*</code>，但参数里还有泛型，则该参数里的泛型可以使用<code>*</code></strong></li>
</ol>
<h1><a href="#六-协变-逆变-不变的规则思考" class="header-anchor">#</a><span id="六-协变-逆变-不变的规则思考">六、协变、逆变、不变的规则思考</span></h1>
<p>在学完型变以后，也许你会有点迷惑：到底什么时候用逆变，什么时候用协变？如果你看过 <code>Kotlin</code> 的官方文档，你会看到一句这样的话：<br>
<code>Consumer in, Producer out !</code><br>
直译的话，大概意思就是：<br>
<strong>消费者 <code>in</code>，生产者 <code>out</code></strong>。不过，这个对我们中国人的说话语境而言，不是那么好理解。让我们继续根据前面的场景，来做个说明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//              逆变</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                 ①</span></span><br><span class="line"><span class="comment">//                 ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span><span class="params">(tv: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//               协变</span></span><br><span class="line"><span class="comment">//                ↓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                   ②</span></span><br><span class="line"><span class="comment">//                   ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderFood</span><span class="params">()</span></span>: T &#123; <span class="comment">/*..*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这段代码中，分别是我们前面提到的逆变、协变的例子。把它们两个放到一起后，你应该就能很容易地发现它们两个的差别了。需要特别留意的地方，我都在注释当中标记出来了，让我来解释给你听：对于逆变的情况，我们模拟的是买遥控器的场景。请注意注释①的地方，我们的泛型 T，它最终会以函数的参数的形式，被传入函数的里面，这往往是一种写入行为，这时候，我们使用关键字 <code>in</code>。对于协变的情况，我们模拟的是点外卖的场景。请注意注释②的地方，我们的泛型 <code>T</code>，它最终会以返回值的形式，被传出函数的外面，这往往是一种读取行为，这时候，我们使用关键字 <code>out</code>。所以，如果要以更加通俗的语言来解释逆变与协变的使用场景的话，我们可以将其总结为：<strong>传入 <code>in</code>，传出 <code>out</code></strong>。或者，我们也可以说：泛型作为参数的时候，用 <code>in</code>，泛型作为返回值的时候，用 <code>out</code>。我们再来看一下 <code>Kotlin</code> 源码当中型变的应用。首先，是逆变的应用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                          逆变</span></span><br><span class="line"><span class="comment">//                           ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                                   泛型作为参数</span></span><br><span class="line"><span class="comment">//                                       ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，由于泛型是作为了 <code>compareTo</code> 方法的参数传入的，因此，对于 <code>Comparable</code> 的泛型 <code>T</code>，我们应该使用 <code>in</code> 来修饰，这就是逆变的实际应用。我们再来看看协变在 <code>Kotlin</code> 源码当中的应用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                        协变</span></span><br><span class="line"><span class="comment">//                         ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                         泛型作为返回值</span></span><br><span class="line"><span class="comment">//                              ↓    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码里我们可以看到，由于泛型是作为 <code>next</code> 方法的返回值的，因此，对于 <code>Iterator</code> 的泛型 <code>T</code>，我们应该使用 <code>out</code> 来修饰，这就是协变的应用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                     协变    ①</span></span><br><span class="line"><span class="comment">//                      ↓      ↓</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">val</span> <span class="keyword">data</span>: T, <span class="keyword">val</span> message: String = <span class="string">&quot;&quot;</span>) : Result&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Loading</span>(<span class="keyword">val</span> time: <span class="built_in">Long</span> = System.currentTimeMillis()) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码定义了密封类，我们对 <code>Success</code> 这个数据类的泛型参数使用了 <code>out</code> 来修饰，这就代表了协变。看到这里，如果你足够细心，就会觉得奇怪：这里为什么可以使用协变呢？前面我们不是说过：“泛型作为参数，用 <code>in</code>；泛型作为返回值，用 <code>out</code>”吗？这里并没有任何函数参数或者返回值啊？其实，这里就又体现出了我们对 <code>Kotlin</code> 底层理解的重要性了。请注意我在上面标记的注释①，<code>val</code> 在 <code>Kotlin</code> 当中，代表不可变的变量，当它修饰类成员属性的时候，代表它只有 <code>getter</code>，没有 <code>setter</code>。当我们看到这样的代码时，我们要能自动脑补出 <code>Success</code> 反编译后的 <code>Java</code> 结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Success</span> <span class="keyword">extends</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object data;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Success 这个类当中，是会有getter方法的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们可以用 <code>out</code> 修饰 <code>Success</code> 泛型的原因，是因为 <code>data</code> 的 <code>getter</code> 方法，它本质上是一个返回 <code>T</code> 类型的方法。这时候，如果我们将注释①处的 <code>val</code> 改为 <code>var</code>，那么代码就会立马报错。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                 改为var后，编译器就会立马报错</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Success</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">var</span> <span class="keyword">data</span>: T, <span class="keyword">val</span> message: String = <span class="string">&quot;&quot;</span>) : Result&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Loading</span>(<span class="keyword">val</span> time: <span class="built_in">Long</span> = System.currentTimeMillis()) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，有了前面的铺垫，我想你应该很快就能反应过来，编译器报错的原因是由于 <code>var</code> 修饰的成员属性，<code>Kotlin</code> 编译器会在背后生成对应 <code>getter</code> 和 <code>setter</code>，这个时候泛型参数既是“参数”也是“返回值”。所以，如果此时我们还用 <code>out</code> 修饰泛型 <code>T</code>，编译器就会报错了。也就是说，如果泛型的 <code>T</code>，既是函数的参数类型，又是函数的返回值类型，那么，我们就无法直接使用 <code>in</code> 或者 <code>out</code> 来修饰泛型 <code>T</code>。不过，<strong>函数传入参数的时候，并不一定就意味着写入</strong>，这时候，即使泛型 <code>T</code> 是作为参数类型，我们也仍然要想一些办法来用 <code>out</code> 修饰泛型。让我们拿一段官方源码来举例说明一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                   协变    </span></span><br><span class="line"><span class="comment">//                    ↓      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                                泛型作为返回值</span></span><br><span class="line"><span class="comment">//                                       ↓    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: E</span><br><span class="line"><span class="comment">//                                           泛型作为参数</span></span><br><span class="line"><span class="comment">//                                                 ↓    </span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"><span class="comment">//                                        泛型作为参数</span></span><br><span class="line"><span class="comment">//                                              ↓   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">indexOf</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Kotlin</code> 官方源码当中的 <code>List</code>，也就是这里的泛型 <code>E</code>，它既作为了返回值类型，又作为了参数类型。在正常情况下，如果我们用 <code>out</code> 修饰 <code>E</code>，那编译器是会报错的。但我们其实很清楚，对于 <code>contains</code>、<code>indexOf</code> 这样的方法，它们虽然以 <code>E</code> 作为参数类型，但本质上并没有产生写入的行为。所以，我们用 <code>out</code> 修饰 <code>E</code> 并不会带来实际的问题。所以这个时候，我们就可以通过 <code>@UnsafeVariance</code> 这样的注解，来让编译器忽略这个型变冲突的问题。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                           逆变   协变</span></span><br><span class="line"><span class="comment">//                            ↓     ↓</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSingleton</span>&lt;<span class="type">in P, out T</span>&gt; &#123;</span><br><span class="line"><span class="comment">//                        ①</span></span><br><span class="line">    <span class="meta">@Volatile</span><span class="comment">//           ↓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> instance: T? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//                              参数  返回值</span></span><br><span class="line">    <span class="comment">//                               ↓    ↓</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> creator: (P)-&gt; T</span><br><span class="line"></span><br><span class="line">    <span class="comment">//                    参数 返回值</span></span><br><span class="line">    <span class="comment">//                     ↓   ↓</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(param: <span class="type">P</span>)</span></span>: T =</span><br><span class="line">        instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: creator(param).also &#123; instance = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个单例模板的例子当中，<code>P</code> 一直作为参数，而 <code>T</code> 则是作为返回值。因此我们用 <code>in</code> 来修饰 <code>P</code>，这就是逆变；对应的我们用 <code>out</code> 修饰 <code>T</code>，这就是协变。不过，如果你足够细心的话，会发现注释①处还有一个 <code>instance</code> 是用泛型 <code>T</code> 修饰的。而它是 <code>var</code> 定义的成员变量，这就意味着，它既有 <code>getter</code>，又有 <code>setter</code>。那它为什么可以用协变的泛型 <code>T</code> 呢？其实，这是因为它是 <code>private</code> 的，如果你把 <code>private</code> 关键字删掉的话，上面的代码就会报错了。</p>
<h1><a href="#七-泛型实现原理及内联特化" class="header-anchor">#</a><span id="七-泛型实现原理及内联特化">七、泛型实现原理及内联特化</span></h1>
<h2><a href="#1-泛型实现原理" class="header-anchor">#</a><span id="1-泛型实现原理">1. 泛型实现原理</span></h2>
<h3><a href="#1-泛型擦除" class="header-anchor">#</a><span id="1-泛型擦除">1. 泛型擦除</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">maxOf</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> Comparable maxOf(<span class="meta">@NotNull</span> Comparable a, <span class="meta">@NotNull</span> Comparable b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如下代码所示，写了一个函数<code>maxOf()</code>比较两个约束为<code>Comparable</code>的泛型形参的大小</li>
<li>编译后泛型<code>T</code>直接取的它的上限<code>Comparable</code>，此为<strong>类型擦除</strong></li>
</ol>
<h3><a href="#2-泛型实现对比" class="header-anchor">#</a><span id="2-泛型实现对比">2. 泛型实现对比</span></h3>
<ul>
<li><strong>伪泛型：</strong> 编译时擦除类型，运行时无实际类型生成。如<code>Java</code>、<code>Kotlin</code></li>
<li><strong>真泛型：</strong> 编译时生成真实类型，运行时也存在该类。如<code>C#</code>、<code>C++</code></li>
</ul>
<p><img src="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/kotlin_genericity_comparison.png" alt></p>
<p><strong>说明：</strong></p>
<ol>
<li>在<code>C#</code>语言中，基本类型可以直接作为泛型参数，而在<code>Java</code>中不可以，只能使用基本类型的装箱类型</li>
<li><code>IR</code> 是<code>intermediate representation</code><em>（中间表示)</em> 的缩写</li>
<li><code>Java</code>字节码中会将泛型类型擦除<code>List&lt;String&gt;</code> 、<code>List&lt;Double&gt;</code>只会有一个<code>List</code>。而在<code>C#.Net</code>的字节码中会真正生成<code>List&lt;string</code>、<code>List&lt;double&gt;</code>两个类</li>
<li>运行时，<code>Java</code>中内存也只会加载一个<code>List</code>，而在<code>C#</code>中内存会加载两个</li>
<li>类型擦除会使内存占用减少，但是类型问题在运行时处理进行类型强转，增加了开销</li>
</ol>
<p><strong>泛型类型无法当做真实类型</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">genericMethod</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t = T()<span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">val</span> ts = Array&lt;T&gt;(<span class="number">3</span>)&#123;TODO()&#125;<span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">val</span> jclass = T::<span class="keyword">class</span>.java<span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">val</span> list = ArrayList&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义一个函数<code>genericMethod()</code>，传入一个泛型参数</li>
<li>第一行代码会 <strong>报错：</strong> 因为无法确定泛型<code>T</code>是否有一个默认无参构造器</li>
<li>第二行代码会 <strong>报错：</strong> <code>Array</code>虽然写成了泛型的形式，但并不是泛型，编译后也不会将泛型擦除，因为它有固定的类型<code>Unit</code>，所以泛型<code>T</code>无法作为数组的元素类型</li>
<li>第三行代码 <strong>报错：</strong> 因为泛型无法作为一个真正在类型，编译时会将泛型擦除，所以无法获取泛型<code>T</code>的<code>class</code>文件</li>
<li>第四行代码 <strong>正确：</strong> 因为<code>ArrayList</code>中的泛型会在编译时被擦除，所以传啥都可以</li>
<li>而在<code>C#</code>中，以上语句都是正确的</li>
</ol>
<h2><a href="#2-内联特化" class="header-anchor">#</a><span id="2-内联特化">2. 内联特化</span></h2>
<h3><a href="#1-内联特化概念" class="header-anchor">#</a><span id="1-内联特化概念">1. 内联特化概念</span></h3>
<p><code>Kotlin</code>独有，<code>Java</code>没有。<br>
如果一个函数是内联函数，则会将内联函数内容替换到调用内联函数的位置，一旦替换过去，则内联函数的泛型也就能确定类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline fun&lt;reified T&gt; genericMethod(t: T) &#123;</span><br><span class="line">    val t = T()//报错</span><br><span class="line">    val ts = Array&lt;T&gt;(3)&#123;TODO()&#125;</span><br><span class="line">    val jclass = T::class.java</span><br><span class="line">    val list = ArrayList&lt;T&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    genericMethod(&quot;str&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码，声明了一个内联函数<code>genericMethod()</code>。且该函数接收的泛型<code>T</code>前加 <strong>关键字<code>reified</code>修饰</strong>，表示该泛型可被具体化 <em>(reified)</em></li>
<li>因内联类具体化的特性，调用<code>genericMethod()</code>时会将该函数体放到调用位置，此时该函数的泛型<code>T</code>也能确定类型，即<code>T</code>此时特化成一个具体类型。</li>
<li>调用<code>genericMethod()</code>时, 传入一个<code>String</code>，则内联函数的泛型<code>T</code>特化为了<code>String</code>类型</li>
<li>第一条语句错误：虽然<code>T</code>特化为了<code>String</code>类型，但还是无法确定该类型是否有一个默认无参构造器。<em>但是<code>C#</code>可以添加构造器的约束</em></li>
<li>第二条语句正确：因<code>T</code>特化为了<code>String</code>类型，所以是创建了一个<code>String</code>类型的数组</li>
<li>第三条语句正确：因<code>T</code>特化为了<code>String</code>类型，所以获取了<code>String</code>类型的<code>class</code>类</li>
</ol>
<h3><a href="#2-内联特化实际应用" class="header-anchor">#</a><span id="2-内联特化实际应用">2. 内联特化实际应用</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.gson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上所示代码为<code>Gson</code>框架中的一个反序列化的一个方法</li>
<li><code>fromJson()</code>方法接收一个泛型<code>T</code>参数，并返回一个该类型的结果，同时还接收了该泛型<code>T</code>类型的<code>class</code></li>
<li>反序列化操作步骤：构造对象 --&gt; 填充数据 --&gt; 返回对象</li>
<li>而构造对象一般通过反射构造，这就必须知道该对象的<code>class</code></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gson = Gson()</span><br><span class="line">    <span class="keyword">val</span> garen : Person = gson.fromJson(<span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;盖伦&quot;, &quot;age&quot;:20&#125;&quot;&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ashe = gson.fromJson&lt;Person&gt;(<span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;:&quot;艾希&quot;, &quot;age&quot;:18&#125;&quot;&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> age:<span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json:<span class="type">String</span>)</span></span>: T = fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上代码所示，创建一个<code>Gson</code>类的扩展函数，该函数为内联函数，且只需要传入一个反序列化的字符串，不需要返回值类型的<code>class</code></li>
<li>该函数直接内联到调用处，所以泛型<code>T</code>也就特化为一个具体的类型，也就可以获取该泛型的<code>class</code></li>
<li><code>main()</code>函数中声明了变量<code>garen</code>及其类型为<code>Person</code>，并调用扩展的内联函数<code>fromJson()</code>为其赋值，虽然没有为<code>fromJson()</code>中传入泛型的具体类型，但通过 <strong>类型推导</strong>的形式，将泛型参数的类型推导出来，进而将泛型<code>T</code>特化</li>
<li><code>main()</code>函数中声明了变量<code>ashe</code>，并调用扩展的内联函数<code>fromJson()</code>为其赋值，为<code>fromJson()</code>中传入泛型的具体类型<code>Person</code>，直接将泛型<code>T</code>特化</li>
</ol>
<h1><a href="#八-示例" class="header-anchor">#</a><span id="八-示例">八、 示例</span></h1>
<h2><a href="#1-模拟-self-type" class="header-anchor">#</a><span id="1-模拟-self-type">1. 模拟 <code>Self Type</code></span></h2>
<h3><a href="#1-builder模式中的类型继承问题" class="header-anchor">#</a><span id="1-builder模式中的类型继承问题">1. <code>Builder</code>模式中的类型继承问题</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> OnConfirm = () -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="keyword">typealias</span> OnCancel = () -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> EmptyFunction = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Dialog</span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> content: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfirmDialog</span>(title: String, content: String,</span><br><span class="line">                    <span class="keyword">val</span> onConfirm: OnConfirm,</span><br><span class="line">                    <span class="keyword">val</span> onCancel: OnCancel) : Dialog(title, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">DialogBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> title = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> content = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">title</span><span class="params">(title: <span class="type">String</span>)</span></span>: DialogBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">content</span><span class="params">(content: <span class="type">String</span>)</span></span>: DialogBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = Dialog(<span class="keyword">this</span>.title, <span class="keyword">this</span>.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfirmDialogBuilder</span> : <span class="type">DialogBuilder</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onConfirm: OnConfirm = EmptyFunction</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onCancel: OnCancel = EmptyFunction</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onConfirm</span><span class="params">(onConfirm: <span class="type">OnConfirm</span>)</span></span>: ConfirmDialogBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.onConfirm = onConfirm</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">(onCancel: <span class="type">OnCancel</span>)</span></span>: ConfirmDialogBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.onCancel = onCancel</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = ConfirmDialog(title, content, onConfirm, onCancel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> confirmDialog = ConfirmDialogBuilder()</span><br><span class="line">            .title(<span class="string">&quot;提交弹窗&quot;</span>)</span><br><span class="line">            .onCancel &#123; <span class="comment">//这行开始报错</span></span><br><span class="line">                println(<span class="string">&quot;点击取消&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .content(<span class="string">&quot;确定提交吗？&quot;</span>)</span><br><span class="line">            .onConfirm &#123;</span><br><span class="line">                println(<span class="string">&quot;点击确定&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .build()</span><br><span class="line">    </span><br><span class="line">    confirmDialog.onConfirm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>声明了一个弹窗基类<code>Dialog</code>，该类提供了标题<code>title</code>和内容<code>content</code>两个属性</li>
<li>声明了一个继承弹窗基类的子类提交弹窗类<code>ConfirmDialog</code>，该类除了基类的两个属性外又添加了两个属性：确定点击事件<code>onConfirm()</code>、取消点击事件<code>onCancel</code></li>
<li>声明了一个<code>Builder</code>模式的基类<code>DialogBuilder</code>，用以构造<code>Dialog</code>，基类中的方法返回基类类型</li>
<li>声明了一个继承基类<code>DialogBuilder</code>的子类<code>ConfirmDialogBuilder</code>，用以构造<code>ConfirmDialog</code></li>
<li><strong>问题：</strong> 子类 <code>Builder</code> 中的函数返回的类型是基类 <code>Builder</code> 的类型，所以使用子类<code>Builder</code>创建出来的子类对象<code>ConfirmDialog</code>无法使用其独有的函数，即在<code>main()</code>方法中在<code>onCancel</code>处的代码会错：<code>Unresolved reference: onCancel</code></li>
</ol>
<h3><a href="#2-scala的self-type" class="header-anchor">#</a><span id="2-scala的self-type">2. <code>Scala</code>的<code>Self Type</code></span></h3>
<p><code>Scala</code>语言的<code>Self Type</code>可以解决<code>Builder</code>类继承后类型错误问题</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">OnConfirm</span> </span>= () =&gt; <span class="type">Unit</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">OnCancel</span> </span>= () =&gt; <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">val</span> <span class="type">EmptyFunction</span> = () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dialog</span>(<span class="params">val title: <span class="type">String</span>, val content: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConfirmDialog</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">                        title: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        content: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        val onConfirm: <span class="type">OnConfirm</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        val onCancel: <span class="type">OnCancel</span></span></span></span><br><span class="line"><span class="params"><span class="class">                    </span>) <span class="keyword">extends</span> <span class="title">Dialog</span>(<span class="params">title, content</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DialogBuilder</span> </span>&#123;</span><br><span class="line">        self =&gt;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">var</span> title: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">var</span> content: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">title</span></span>(title: <span class="type">String</span>): self.<span class="keyword">type</span> = &#123;</span><br><span class="line">            <span class="keyword">this</span>.title = title</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">content</span></span>(content: <span class="type">String</span>): self.<span class="keyword">type</span> = &#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build</span></span>() = <span class="keyword">new</span> <span class="type">Dialog</span>(<span class="keyword">this</span>.title, <span class="keyword">this</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConfirmDialogBuilder</span> <span class="keyword">extends</span> <span class="title">DialogBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> onConfirm: <span class="type">OnConfirm</span> = <span class="type">EmptyFunction</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> onCancel: <span class="type">OnCancel</span> = <span class="type">EmptyFunction</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">onConfirm</span></span>(onConfirm: =&gt; <span class="type">Unit</span>): <span class="type">ConfirmDialogBuilder</span> = &#123;</span><br><span class="line">            <span class="keyword">this</span>.onConfirm = () =&gt; &#123;</span><br><span class="line">                onConfirm</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">onCancel</span></span>(onCancel: =&gt; <span class="type">Unit</span>): <span class="type">ConfirmDialogBuilder</span> = &#123;</span><br><span class="line">            <span class="keyword">this</span>.onCancel = () =&gt; &#123;</span><br><span class="line">                onCancel</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">build</span></span>() = <span class="keyword">new</span> <span class="type">ConfirmDialog</span>(title, content, onConfirm, onCancel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ConfirmDialogBuilder</span>()</span><br><span class="line">            .title(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            .onCancel &#123;</span><br><span class="line">                println(<span class="string">&quot;onCancel&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .content(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">            .onConfirm &#123;</span><br><span class="line">                println(<span class="string">&quot;onConfirm&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .build()</span><br><span class="line">            .onConfirm()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>如上为<code>Scala</code>语言代码，其中<code>def</code>相当于<code>kotlin</code>的<code>fun</code>，该函数返回类型为 <code>self.type</code>。其中 <code>self</code>在类后添加了声明，表示该类在使用过程中真实的类型，如果是子类的话，就是子类类型。</li>
<li>在<code>Kotlin</code>中可以使用泛型来实现<code>Self Type</code></li>
</ol>
<h3><a href="#3-使用泛型模拟self-type" class="header-anchor">#</a><span id="3-使用泛型模拟self-type">3. 使用泛型模拟<code>Self Type</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> OnConfirm = () -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="keyword">typealias</span> OnCancel = () -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> EmptyFunction = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Dialog</span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> content: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfirmDialog</span>(title: String, content: String,</span><br><span class="line">                    <span class="keyword">val</span> onConfirm: OnConfirm,</span><br><span class="line">                    <span class="keyword">val</span> onCancel: OnCancel) : Dialog(title, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SelfType</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> self: Self</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="keyword">as</span> Self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">DialogBuilder</span>&lt;<span class="type">Self : DialogBuilder&lt;Self</span>&gt;&gt; : <span class="type">SelfType</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> title = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> content = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">title</span><span class="params">(title: <span class="type">String</span>)</span></span>: Self &#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">content</span><span class="params">(content: <span class="type">String</span>)</span></span>: Self &#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = Dialog(<span class="keyword">this</span>.title, <span class="keyword">this</span>.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfirmDialogBuilder</span> : <span class="type">DialogBuilder</span>&lt;<span class="type">ConfirmDialogBuilder</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onConfirm: OnConfirm = EmptyFunction</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onCancel: OnCancel = EmptyFunction</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onConfirm</span><span class="params">(onConfirm: <span class="type">OnConfirm</span>)</span></span>: ConfirmDialogBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.onConfirm = onConfirm</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">(onCancel: <span class="type">OnCancel</span>)</span></span>: ConfirmDialogBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.onCancel = onCancel</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = ConfirmDialog(title, content, onConfirm, onCancel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> confirmDialog = ConfirmDialogBuilder()</span><br><span class="line">            .title(<span class="string">&quot;提交弹窗&quot;</span>)</span><br><span class="line">            .onCancel &#123;</span><br><span class="line">                println(<span class="string">&quot;点击取消&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .content(<span class="string">&quot;确定提交吗？&quot;</span>)</span><br><span class="line">            .onConfirm &#123;</span><br><span class="line">                println(<span class="string">&quot;点击确定&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    confirmDialog.onConfirm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击确定</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义了一个接口<code>SelfType</code>，接收一个泛型<code>Self</code>，该接口内定义了一个成员<code>self</code>，类型就是传入的泛型类型，设置该成员的<code>getter</code>方法中将该成员强转为<code>Self</code></li>
<li>基类<code>DialogBuilder</code>实现接口<code>SelfType</code>，接口传入的泛型在声明时添加了约束：该泛型上界为<code>DialogBuilder</code>类，该类中的函数返回类型改为泛型<code>Self</code></li>
<li>子类<code>ConfirmDialogBuilder</code>，继承基类<code>DialogBuilder</code>时传入的泛型实参使用子类<code>ConfirmDialogBuilder</code>，如此使用子类<code>ConfirmDialogBuilder</code>中函数返回的就是<code>ConfirmDialogBuilder</code>，则子类创建出来的子类<code>ConfirmDialog</code> 就可以使用子类<code>ConfirmDialog</code>独有的函数</li>
</ol>
<h2><a href="#2-基于泛型实现model实例的注入" class="header-anchor">#</a><span id="2-基于泛型实现model实例的注入">2. 基于泛型实现<code>Model</code>实例的注入</span></h2>
<h3><a href="#1-使用注入的地方" class="header-anchor">#</a><span id="1-使用注入的地方">1. 使用注入的地方</span></h3>
<ol>
<li><code>ViewModel</code>在<code>MVVM</code>中持有<code>View</code>中的数据结构，同时要跟<code>Model</code>进行通信，所以<code>ViewModel</code>持有<code>Model</code>。</li>
<li>但是当有多个<code>Model</code>时，最好通过一个三方的类去管理<code>Model</code>实例，并转发给<code>ViewModel</code>。</li>
<li>其<code>Model</code>的获取通常使用注入方法来实现。</li>
<li>注入方法有：
<ul>
<li>添加注解。注解处理器在编译时将<code>Model</code>注入；</li>
<li>反射。通过读取注解在运行时实现注入；</li>
<li>代理。通过代理类实现<code>Model</code>注入；</li>
</ul>
</li>
</ol>
<h3><a href="#2-通过代理方式实现注入" class="header-anchor">#</a><span id="2-通过代理方式实现注入">2. 通过代理方式实现注入</span></h3>
<h4><a href="#1-实现方式一" class="header-anchor">#</a><span id="1-实现方式一">1. 实现方式一</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsModel</span> &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        Models.run &#123; register() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseModel</span>: <span class="type">AbsModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(sql: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkModel</span>: <span class="type">AbsModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(url:<span class="type">String</span>)</span></span> = <span class="string">&quot;&quot;&quot;&#123;&quot;code&quot;:0&#125;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Models &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> modelMap = ConcurrentHashMap&lt;Class&lt;<span class="keyword">out</span> AbsModel&gt;, AbsModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: AbsModel&gt;</span> KClass<span class="type">&lt;T&gt;</span>.<span class="title">get</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> modelMap[<span class="keyword">this</span>.java] <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> AbsModel.<span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">        modelMap[<span class="keyword">this</span>.javaClass] = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: AbsModel&gt;</span> <span class="title">modelOf</span><span class="params">()</span></span>: ModelDelegate&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ModelDelegate(T::<span class="keyword">class</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelDelegate</span>&lt;<span class="type">T: AbsModel</span>&gt;(<span class="keyword">val</span> kClass:KClass&lt;T&gt;): ReadOnlyProperty&lt;Any, T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Models.run &#123; kClass.<span class="keyword">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> databaseModel <span class="keyword">by</span> modelOf&lt;DatabaseModel&gt;()</span><br><span class="line">    <span class="keyword">val</span> networkModel <span class="keyword">by</span> modelOf&lt;NetworkModel&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initModels</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DatabaseModel()</span><br><span class="line">    NetworkModel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    initModels()</span><br><span class="line">    <span class="keyword">val</span> mainViewModel = MainViewModel()</span><br><span class="line">    mainViewModel.databaseModel.query(<span class="string">&quot;select * from usertable&quot;</span>).let(::println)</span><br><span class="line">    mainViewModel.networkModel.<span class="keyword">get</span>(<span class="string">&quot;https://puppet16.github.io/&quot;</span>).let(::println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>定义了抽象类<code>AbsModel</code>,其为所有<code>Model</code>的父类，子类创建时一定会调用父类的构造器，所以父类的<code>init</code>块一定会执行，<code>init</code>块中调用了单例<code>Modules</code>的<code>register()</code>方法</li>
<li>定义了单例<code>Models</code>类：
<ul>
<li>该类中定义了一个抽象类<code>AbsModel</code>的扩展方法<code>register()</code>，该方法是将<code>AbsModel</code>的子类实例放到<code>modeMap</code>中，<code>Key</code>是子类的<code>javaClass</code>即<code>java</code>中的<code>class</code>类。如此只要是继承了<code>AbsModel</code>的子类都会将实例存入<code>modeMap</code>中；</li>
<li>该类中还定义了一个<code>Kotlin</code>的<code>class</code>的扩展方法<code>get()</code>，该方法是获取子类的实例，返回值一定是继承<code>AbsModel</code>的子类</li>
<li>注意：定义的以上两扩展方法作用域只是在单例<code>Models</code>中</li>
</ul>
</li>
<li>定义了基于抽象类<code>AbsModel</code>的子类<code>DatabaseModel</code>、<code>NetworkModel</code></li>
<li>定义了代理类<code>ModelDelegate</code>，主构造器中定义一个属性<code>kClass</code>，类型为<code>KClass&lt;T&gt;</code>，其中泛型<code>T</code>添加了约束上界为<code>AbsModel</code>。实现接口<code>ReadOnlyProperty</code>的方法<code>getValue()</code>，通过<code>kClass</code>的<code>get()</code>方法取得子类实例</li>
<li>定义了非必须的函数<code>modelOf()</code>，该方法接收一个泛型<code>T</code>，添加了约束上界为<code>AbsModel</code>，返回结果是一个<code>ModelDelegate</code>类的实例</li>
<li>定义类<code>MainViewModel</code>，该类中有两个属性：<code>databaseModel</code>、<code>networkModel</code>，这两个属性通过代理的方式赋值</li>
<li>定义类<code>initModels</code>，该类初始化了子类<code>DatabaseModel</code>、<code>NetworkModel</code></li>
<li>最后在<code>main()</code>方法中先初始化两个<code>AbsModel</code>子类，再创建属性<code>mainViewModel</code>,之后通过属性<code>mainViewModel</code>获取不同的<code>AbsModel</code>子类实例，调用实例的方法</li>
</ol>
<h4><a href="#实现方式二" class="header-anchor">#</a><span id="实现方式二">实现方式二</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsModel</span> &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        Models.run &#123; register() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseModel</span>: <span class="type">AbsModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(sql: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkModel</span>: <span class="type">AbsModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(url:<span class="type">String</span>)</span></span> = <span class="string">&quot;&quot;&quot;&#123;&quot;code&quot;:0&#125;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageModel</span>: <span class="type">AbsModel</span>() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        Models.run &#123; register(<span class="string">&quot;PageModel2&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;enter Next Page&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Models &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> modelMap = ConcurrentHashMap&lt;String, AbsModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: AbsModel&gt;</span> String.<span class="title">get</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> modelMap[<span class="keyword">this</span>] <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> AbsModel.<span class="title">register</span><span class="params">(name: <span class="type">String</span> = this.javaClass.simpleName)</span></span> &#123;</span><br><span class="line">        modelMap[name] = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">        println(modelMap.values.joinToString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ModelDelegate&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: AbsModel&gt;</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Models.run &#123; property.name.capitalize().<span class="keyword">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> databaseModel: DatabaseModel <span class="keyword">by</span> ModelDelegate</span><br><span class="line">    <span class="keyword">val</span> networkModel: NetworkModel <span class="keyword">by</span> ModelDelegate</span><br><span class="line">    <span class="keyword">val</span> pageModel: PageModel <span class="keyword">by</span> ModelDelegate</span><br><span class="line">    <span class="keyword">val</span> pageModel2: PageModel <span class="keyword">by</span> ModelDelegate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initModels</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DatabaseModel()</span><br><span class="line">    NetworkModel()</span><br><span class="line">    PageModel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    initModels()</span><br><span class="line">    <span class="keyword">val</span> mainViewModel = MainViewModel()</span><br><span class="line">    mainViewModel.databaseModel.query(<span class="string">&quot;select * from mysql.user&quot;</span>).let(::println)</span><br><span class="line">    mainViewModel.networkModel.<span class="keyword">get</span>(<span class="string">&quot;https://www.imooc.com&quot;</span>).let(::println)</span><br><span class="line">    mainViewModel.pageModel.enter()</span><br><span class="line">    mainViewModel.pageModel2.enter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>方式二是方式一的优化，即将泛型参数省略。</li>
<li>单例<code>Models</code>的<code>register()</code>方法有一个<code>String</code>类型的入参，默认值为子类的简单类名，该入参作为<code>modelMap</code>的<code>Key</code>值。子类<code>DatabaseModel</code>的简单类名为<code>DatabaseModel</code>。单例<code>Models</code>的<code>get()</code>方法就成为了<code>String</code>的扩展方法</li>
<li>类<code>ModelDelegate</code>也不需要泛型区别<code>Model</code>，对于不同属性没有了区别，所以定义为了单例。其中获取子类实例的方法<code>getValue()</code>中使用了被代理的属性的名字获取子类实例，所以 <strong>定义的属性名字要与子类名字相同。</strong></li>
<li><code>capitalize()</code>方法是返回一个字符串，该字符串首字母大写。所以获取属性名字后再使用该函数才可保证与子类名字相同。</li>
<li>在类<code>MainViewModel</code>中声明属性时，直接使用<code>ModelDelegate</code>代理属性赋值会报错：无法确定<code>ModelDelegate</code>类中<code>getValue()</code>方法中的泛型<code>T</code>。要解决这个问题只需要在定义属性时添加上<code>AbsModel</code>的子类型即可推导出泛型<code>T</code>类型。</li>
<li>因为<code>Models</code>的<code>register()</code>方法可以传入<code>String</code>类型的入参，则子类可以自己定义在<code>modelMap</code>中的<code>Key</code>值。</li>
<li>子类<code>PageModel</code>虽然在父类构造器中以<code>PageModel</code>为<code>Key</code>值添加进了一次<code>modelMap</code>中，但在自己的构造器中又以<code>PageModel2</code>为<code>Key</code>值再一次的添加入<code>modelMap</code>中。即在<code>modelMap</code>中<code>Key</code>值为<code>PageModel</code>和<code>PageModel2</code>对应的<code>Value</code>值都是同一个<code>PageModel</code>子类实例</li>
<li>如此可以定义属性<code>pageModel</code>和<code>pageModel2</code>通过代理获取同一个<code>PageModel</code>子类实例</li>
</ol>
<h1><a href="#九-参考文章" class="header-anchor">#</a><span id="九-参考文章">九、参考文章</span></h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26890263">Kotlin 中的 Nothing 和 Unit</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0c2948f7e656">Java和Kotlin中泛型的协变、逆变和不变</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1715f0483768">Kotlin知识归纳（十二） —— 泛型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/generics.html">https://www.kotlincn.net/docs/reference/generics.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/bluishglc/article/details/60739183">Scala之自身类型(Self Type)</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/49738603">教你如何攻克Kotlin中泛型型变的难点(下篇)</a></li>
</ol>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-03-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/泛型/" title="泛型">泛型 </a><span class="leancloud_visitors"></span><span>大约13177个字, 43分钟55秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2021/03/08/kotlin学习系列六/,Puppet,kotlin学习系列六：泛型,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>