<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列十：协程二 · Puppet</title><meta name="description" content="一、前言
二、 Job

1. Job 生命周期


三、 Deffered
四、Job 与结构化并发
五、CoroutineContext

1. Context 的应用

1. launch()
2. withContext()
3. runBlocking()
4. 内置Dispatcher
"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列十：协程二</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-job">二、 Job</a>
<ul>
<li><a href="#1-job-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">1. <code>Job</code> 生命周期</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-deffered">三、 Deffered</a></li>
<li><a href="#%E5%9B%9B-job-%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91">四、Job 与结构化并发</a></li>
<li><a href="#%E4%BA%94-coroutinecontext">五、CoroutineContext</a>
<ul>
<li><a href="#1-context-%E7%9A%84%E5%BA%94%E7%94%A8">1. Context 的应用</a>
<ul>
<li><a href="#1-launch">1. <code>launch()</code></a></li>
<li><a href="#2-withcontext">2. <code>withContext()</code></a></li>
<li><a href="#3-runblocking">3. <code>runBlocking()</code></a></li>
<li><a href="#4-%E5%86%85%E7%BD%AEdispatcher">4. 内置Dispatcher</a></li>
</ul>
</li>
<li><a href="#2-%E4%B8%87%E7%89%A9%E7%9A%86%E6%9C%89context">2. 万物皆有Context</a>
<ul>
<li><a href="#1-coroutinescope">1. CoroutineScope</a></li>
<li><a href="#2-job-%E5%92%8C-dispatcher">2. Job 和 Dispatcher</a></li>
<li><a href="#3-coroutinename">3. CoroutineName</a></li>
<li><a href="#4-coroutineexceptionhandler">4. CoroutineExceptionHandler</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%AE%9E%E6%88%98%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6-kthttp">六、实战：网络请求框架 KtHttp</a>
<ul>
<li><a href="#1-%E4%BB%A5java%E6%80%9D%E7%BB%B4%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6">1. 以<code>Java</code>思维简单实现网络请求框架</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%80%9D%E7%BB%B4%E9%87%8D%E6%9E%84kthttp">2. 函数式思维重构<code>KtHttp</code></a></li>
<li><a href="#3-%E6%94%AF%E6%8C%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82call%E7%9A%84-kthttp">3. 支持异步请求（Call）的 KtHttp</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA-callback">1. 创建 Callback</a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA-ktcall-%E7%B1%BB">2. 创建 KtCall 类</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA-apiservice-%E5%8F%8A%E4%BF%AE%E6%94%B9-invoke-%E6%96%B9%E6%B3%95">3. 创建 ApiService 及修改 invoke 方法</a></li>
<li><a href="#4-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">4. 测试代码</a></li>
<li><a href="#5-%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5">5. 同时支持同步和异步</a></li>
</ul>
</li>
<li><a href="#4-%E6%94%AF%E6%8C%81%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E7%9A%84-kthttp">4. 支持挂起函数的 KtHttp</a>
<ul>
<li><a href="#1-%E8%A7%A3%E6%B3%95%E4%B8%80%E6%89%A9%E5%B1%95-ktcall">1. 解法一：扩展 KtCall</a>
<ul>
<li><a href="#1-%E6%89%A9%E5%B1%95%E5%87%BA-await-%E5%87%BD%E6%95%B0">1. 扩展出 await 函数</a></li>
<li><a href="#2-%E5%AE%9E%E7%8E%B0-await-%E5%87%BD%E6%95%B0">2. 实现 await 函数</a></li>
<li><a href="#3-suspendcoroutine-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%96%E6%B6%88">3. suspendCoroutine{} 不支持取消</a></li>
<li><a href="#4-%E4%BD%BF%E7%94%A8-suspendcancellablecoroutine-%E5%AE%9E%E7%8E%B0-await-%E5%87%BD%E6%95%B0">4. 使用 suspendCancellableCoroutine{} 实现 await 函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">七、参考文章</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 协程中的 <code>Job</code>、<code>Deferred</code>、<code>CoroutineContext</code>以及实现一个简单网络框架 <code>KtHttp</code></strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">朱涛老师</a>讲解的<code>Kotlin</code>系列的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程一</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程三</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-job" class="header-anchor">#</a><span id="二-job">二、 Job</span></h1>
<p><strong><code>Job</code> 其实就是协程的句柄</strong>。从某种程度上讲，当我们用 <code>launch</code> 和 <code>async</code> 创建一个协程以后，同时也会创建一个对应的 <code>Job</code> 对象。另外，<code>Job</code> 也是我们理解协程生命周期、结构化并发的关键知识点。通过 <code>Job</code> 暴露的 API，我们还可以让不同的协程之间互相配合，从而实现更加复杂的功能。</p>
<h2><a href="#1-job-生命周期" class="header-anchor">#</a><span id="1-job-生命周期">1. <code>Job</code> 生命周期</span></h2>
<p>上一章中学习 <code>launch</code>、<code>async</code> 的时候，了解到它们两个返回值类型分别是 <code>Job</code> 和 <code>Deferred</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deferred</span>&lt;<span class="type">out T</span>&gt; : <span class="type">Job</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Deferred</code> 的源代码如上所示，它其实也是继承自 <code>Job</code> 的。对应的，它只是多了一个泛型参数 <code>T</code>，还多了一个返回类型为 <code>T</code> 的 <code>await()</code> 方法。所以，不管是 <code>launch</code> 还是 <code>async</code>，它们本质上都会返回一个 <code>Job</code> 对象。</p>
<p>通过 <code>Job</code> 对象，主要可以做两件事情：</p>
<ul>
<li>使用 <code>Job</code> 监测协程的生命周期状态。</li>
<li>使用 <code>Job</code> 操控协程。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.log()       <span class="comment">// ①</span></span><br><span class="line">    job.cancel()    <span class="comment">// ②</span></span><br><span class="line">    job.log()       <span class="comment">// ③</span></span><br><span class="line">    delay(<span class="number">1500L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印Job的状态信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">log</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logX(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        isActive = <span class="variable">$isActive</span></span></span><br><span class="line"><span class="string">        isCancelled = <span class="variable">$isCancelled</span></span></span><br><span class="line"><span class="string">        isCompleted = <span class="variable">$isCompleted</span></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台输出带协程信息的log</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">logX</span><span class="params">(any: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">================================</span></span><br><span class="line"><span class="string"><span class="variable">$any</span></span></span><br><span class="line"><span class="string">Thread:<span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">================================&quot;&quot;&quot;</span>.trimIndent())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = true</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>在上面这段代码当中，定义了一个 <code>Job.log()</code> 扩展函数，它的作用就是打印 <code>Job</code> 的生命周期状态。通过调用这个函数，就可以知道对应的协程处于什么状态。</p>
</li>
<li>
<p><em>注释①</em>, 的调用结果，<code>“isActive = true”</code>，这代表了当前的协程处于活跃状态。</p>
</li>
<li>
<p><em>注释②</em>，调用了 <code>job.cancel()</code> 以后，协程任务就会被取消。因此，<em>注释③</em> 处的调用结果就会变成<code>“isCancelled = true”</code>，这代表了协程任务处于取消状态。</p>
</li>
<li>
<p>由此可以知道：</p>
<ul>
<li><code>job.log()</code>，其实就是在<strong>监测协程</strong>；</li>
<li><code>job.cancel()</code>，其实就是在<strong>操控协程</strong></li>
</ul>
</li>
<li>
<p>而除了 <code>job.cancel()</code> 可以操控协程以外，还可以使用 <code>job.start()</code> 来启动协程任务，一般来说，它都是搭配<code>“CoroutineStart.LAZY”</code>来使用的</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">//                  变化在这里</span></span><br><span class="line">    <span class="comment">//                      ↓</span></span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)     </span><br><span class="line">    job.log()       </span><br><span class="line">    job.start()     <span class="comment">// 变化在这里</span></span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = true</span></span><br><span class="line"><span class="comment">isCompleted = true</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>根据以上代码的运行结果，可以发现，当使用 <code>CoroutineStart.LAZY</code> 作为启动模式的时候，协程任务被 <code>launch</code> 以后，并不会立即执行，即使我们在代码中 <code>delay</code> 了 <code>500</code> 毫秒，<code>launch</code> 内部的&quot;<code>Coroutine start!</code>&quot;也仍然没有输出。这是典型的懒加载行为模式。</li>
<li>当在外部调用了 <code>job.start()</code> 以后，<code>job</code> 的状态才变成了 <code>Active</code> 活跃。而当调用了 <code>cancel</code> 以后，<code>job</code> 的状态才变成 <code>isCancelled</code>、<code>isCompleted</code>。</li>
</ol>
<p>由此，整理出 <code>Job</code> 整个的生命周期如下图：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/job.png" alt></p>
<p>从图中，可以看到，对于协程的 <code>Job</code> 来说，它有两种初始状态，如果 <code>Job</code> 是以懒加载的方式创建的，那么它的初始状态将会是 <code>New</code>；而如果一个协程是以<strong>非懒加载</strong>的方式创建的，那么它的初始状态就会是 <code>Active</code>。</p>
<p>仔细看第四段输出结果，会发现，当调用 <code>cancel</code> 以后，会出现一个奇怪的现象：<code>isCancelled = true</code>、<code>isCompleted = true</code>。也就是说，当协程任务被取消以后，<code>isCancelled</code> 和 <code>isCompleted</code> 同时都是 <code>true</code>。但这跟上面的流程图并不一致！这是为什么呢？这是因为，<strong>协程认为由于某种原因取消的协程，也仍然是一种“结束状态”</strong>，这其实也就对应了流程图中的“最终状态”。</p>
<p>换句话说，流程图当中的 <code>New</code>、<code>Active</code>、<code>Completing</code>、<code>Cancelling</code>、<code>Completed</code>、<code>Cancelled</code> 这些状态，都是 <code>Job</code> 内部私有的状态。而 <code>Job</code> 对外暴露出的 <code>isCompleted</code> 并不是与其一一对应的。<code>Job</code> 内部私有的 <code>Completed</code>、<code>Cancelled</code> 状态，都会认为是外部的 <code>isCompleted</code> 状态。</p>
<p>测试了协程 <code>cancel()</code> 方法以后，再来看看协程正常执行完毕的情况：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    job.start()</span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">1100L</span>)    <span class="comment">// ①</span></span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">2000L</span>)    <span class="comment">// ②</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================================</span><br><span class="line">isActive = <span class="literal">false</span></span><br><span class="line">isCancelled = <span class="literal">false</span></span><br><span class="line">isCompleted = <span class="literal">false</span></span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">isActive = <span class="literal">true</span></span><br><span class="line">isCancelled = <span class="literal">false</span></span><br><span class="line">isCompleted = <span class="literal">false</span></span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">Coroutine start!</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">isActive = <span class="literal">false</span></span><br><span class="line">isCancelled = <span class="literal">false</span></span><br><span class="line">isCompleted = <span class="literal">true</span></span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">Process end!</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在这段代码中，可以清晰地看到，协程的状态从 <code>Start</code> 到 <code>Active</code>，最后到 <code>Completed</code></li>
<li><em>注释①</em> 处，为了等待 <code>job</code> 任务执行完毕，在外面等待了 <em>1100</em> 毫秒，这种方式其实并不好，因为大部分情况下，很难从外部判断协程需要多长的时间才能结束（比如网络请求任务、下载任务）。</li>
<li><em>注释②</em> 处，使用 <code>delay(2000L)</code> 的方式，希望在 <code>job</code> 执行完毕以后输出“<code>Process end!</code>”，这样的代码，也是建立在“知道 <code>Job</code> 只需要 <code>1000</code> 毫秒就能执行完毕”的前提。</li>
</ol>
<p>如果协程内部的 <code>delay</code> 远大于外部的 <code>delay</code>，以上的运行结果就会完全不一样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">4000L</span>) <span class="comment">// 变化在这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    job.start()</span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">1100L</span>)    </span><br><span class="line">    job.log()</span><br><span class="line">    delay(<span class="number">2000L</span>)    </span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">到这里，job仍然还在delay，整个程序并没有完全退出。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>当将 <code>job</code> 内部的 <code>delay</code> 改为 <code>4000</code> 毫秒以后，执行结果就完全不一样了，无法监测到 <code>isCompleted</code> 状态。</li>
<li>如果实际运行了上面的代码，会发现“<code>Process end!</code>”输出以后，程序并没有立即结束，而是等待了大约 <code>900</code> 毫秒才结束，这是因为 <code>runBlocking</code> 会一直阻塞，等到 <code>job</code> 任务执行完毕以后才真正退出。</li>
<li>为了更加灵活地<strong>等待和监听</strong>协程的结束事件，可以用 <code>job.join()</code> 以及 <code>invokeOnCompletion &#123;&#125;</code> 来优化上面的代码。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟下载任务</span></span><br><span class="line">        <span class="keyword">val</span> time = (Random.nextDouble() * <span class="number">1000</span>).toLong()</span><br><span class="line">        logX(<span class="string">&quot;Delay time: = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">        delay(time)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        download()</span><br><span class="line">        logX(<span class="string">&quot;Coroutine end!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    job.log()</span><br><span class="line">    job.start()</span><br><span class="line">    job.log()</span><br><span class="line">    job.invokeOnCompletion &#123;</span><br><span class="line">        job.log() <span class="comment">// 协程结束以后就会调用这里的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    job.join()      <span class="comment">// 等待协程执行完毕</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = true</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = false</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Delay time: = 252</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">isActive = false</span></span><br><span class="line"><span class="comment">isCancelled = false</span></span><br><span class="line"><span class="comment">isCompleted = true</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>invokeOnCompletion &#123;&#125;</code> 的作用，其实就是监听协程结束的事件。需要注意的是，它和前面的 <code>isCompleted</code> 类似，如果 <code>job</code> 被取消了，<code>invokeOnCompletion &#123;&#125;</code> 这个回调仍然会被调用。</li>
<li><code>job.join()</code> 其实是一个“挂起函数”，它的作用就是：<strong>挂起当前的程序执行流程，等待 job 当中的协程任务执行完毕，然后再恢复当前的程序执行流程</strong>。</li>
</ol>
<p>至此，就对 <code>Job</code> 的两种使用场景都已经有了充分认识了。大概看看 <code>Job</code> 的源代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 状态查询API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCompleted: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCancelled: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCancellationException</span><span class="params">()</span></span>: CancellationException</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 操控状态API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = cancel(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">Throwable</span>? = <span class="literal">null</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 等待状态API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onJoin: SelectClause0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ 完成状态回调API ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(handler: <span class="type">CompletionHandler</span>)</span></span>: DisposableHandle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        onCancelling: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        invokeImmediately: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        handler: <span class="type">CompletionHandler</span>)</span></span>: DisposableHandle</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>Kotlin</code> 官方对 <code>Job</code> 的 <code>API</code> 做了更加详细的划分，但实际上来说都属于“<strong>监测状态</strong>”“<strong>操控状态</strong>”这两个大的范畴。</li>
<li>如何理解 <code>Job</code> 是协程的句柄”这句话呢？可以从现实生活中找例子，来建立大致的思维模型。<code>Job</code> 和协程的关系，就有点像“遥控器和空调的关系”。
<ul>
<li>空调遥控器可以监测空调的运行状态；<code>Job</code> 也可以监测协程的运行状态；</li>
<li>空调遥控器可以操控空调的运行状态，<code>Job</code> 也可以简单操控协程的运行状态。</li>
</ul>
</li>
</ol>
<h1><a href="#三-deffered" class="header-anchor">#</a><span id="三-deffered">三、 Deffered</span></h1>
<p><code>Deferred</code> 其实就是继承自 <code>Job</code> 的一个接口，它并没有在 <code>Job</code> 的基础上扩展出很多其他功能，最重要的就是 <code>await()</code> 这个方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        logX(<span class="string">&quot;Coroutine start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Coroutine end!&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Coroutine result!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">    println(<span class="string">&quot;Result = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Coroutine end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Result = Coroutine result!</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从代码的执行结果中，可以发现，<code>deferred.await()</code> 这个方法，不仅可以获取协程的执行结果，它还会阻塞当前协程的执行流程，直到协程任务执行完毕。在这一点的行为上，<code>await()</code> 和 <code>join()</code> 是类似的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deferred</span>&lt;<span class="type">out T</span>&gt; : <span class="type">Job</span> &#123;</span><br><span class="line"><span class="comment">//          注意这里</span></span><br><span class="line"><span class="comment">//            ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>await()</code>的函数签名，可以看到，<code>await()</code> 这个方法其实是一个挂起函数，这也就意味着，这个方法拥有挂起和恢复的能力。如果当前的 <code>Deferred</code> 任务还没执行完毕，那么，<code>await()</code> 就会挂起当前的协程执行流程，等待 <code>Deferred</code> 任务执行完毕，再恢复执行后面剩下的代码。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/continuation_dispa.gif" alt></p>
<p><strong>说明：</strong></p>
<ol>
<li>由上图所得 <code>await()</code> 后面的代码，虽然看起来是阻塞了，但它只是执行流程被挂起和恢复的一种表现。</li>
<li>上图也描述了之前 <code>job.join()</code> 的行为模式，在协程执行完毕之前，后面的协程代码都被暂时挂起了，等到协程执行完毕，才有机会继续执行。</li>
<li>总的来说，<code>Deferred</code> 只是比 <code>Job</code> 多了一个 <code>await()</code> 挂起函数而已，通过这个挂起函数，可以等待协程执行完毕的同时，还可以直接拿到协程的执行结果。</li>
</ol>
<h1><a href="#四-job-与结构化并发" class="header-anchor">#</a><span id="四-job-与结构化并发">四、Job 与结构化并发</span></h1>
<p>协程的优势在于<strong>结构化并发</strong>。<code>Kotlin</code> 协程的结构化并发，它的重要性，是仅次于“挂起函数”的。也就是说，<strong>“结构化并发”是 <code>Kotlin</code> 协程的第二大优势</strong>。</p>
<p>简单来说，“结构化并发”就是：<strong>带有结构和层级的并发</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> parentJob: Job</span><br><span class="line">    <span class="keyword">var</span> job1: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job2: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job3: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    parentJob = launch &#123;</span><br><span class="line">        job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job2 = launch &#123;</span><br><span class="line">            delay(<span class="number">3000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job3 = launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.children.forEachIndexed &#123; index, job -&gt;</span><br><span class="line">        <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; println(<span class="string">&quot;job1 === job is <span class="subst">$&#123;job1 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">1</span> -&gt; println(<span class="string">&quot;job2 === job is <span class="subst">$&#123;job2 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">2</span> -&gt; println(<span class="string">&quot;job3 === job is <span class="subst">$&#123;job3 === job&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parentJob.join() <span class="comment">// 这里会挂起大约5秒钟</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">job1 === job is true</span></span><br><span class="line"><span class="comment">job2 === job is true</span></span><br><span class="line"><span class="comment">job3 === job is true</span></span><br><span class="line"><span class="comment">// 等待大约5秒钟</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在上面的代码中，一共定义了 <em>4</em> 个 <code>Job</code>，<code>parentJob</code> 是最外层的 <code>launch</code> 返回的对象，而在这个 <code>launch</code> 的内部，还额外嵌套了三个 <code>launch</code>，它们的 <code>Job</code> 对象分别赋值给了 <code>job1</code>、<code>job2</code>、<code>job3</code>。</li>
<li>对“<code>parentJob.children</code>”进行了遍历，然后逐一对比了它们与 <code>job1</code>、<code>job2</code>、<code>job3</code> 的引用是否相等 <em>（“===”代表了引用相等，即是否是同一个对象）</em>。</li>
<li>根据打印结果，可以确定，<code>job1</code>、<code>job2</code>、<code>job3</code> 其实就是 <code>parentJob</code> 的 <code>children</code>。也就是说，使用 <code>launch</code> 创建出来的协程，是存在父子关系的。</li>
</ol>
<p><code>Job</code> 的源代码中还有两个 <code>API</code> 是用来描述父子关系的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ parent-child ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> children: Sequence&lt;Job&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InternalCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(child: <span class="type">ChildJob</span>)</span></span>: ChildHandle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，每个 <code>Job</code> 对象，都会有一个 <code>children</code> 属性，它的类型是 <code>Sequence</code>，它是一个惰性的集合，可以对它进行遍历。而 <code>attachChild()</code> 则是一个协程内部的 <code>API</code>，用于绑定 <code>ChildJob</code> 。用一个简单的结构图来描述上面 <em>4</em> 个 <code>Job</code> 之间的关系：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/job_parent_1.webp" alt></p>
<p>那么，这样的父子关系到底意味着什么呢？“<code>parentJob.join()</code>”这行代码会被挂起大约 <em>5</em> 秒钟。注意调用的是 <code>parentJob</code> 的 <code>join()</code> 方法，但是，它会等待其内部的 <code>job1</code>、<code>job2</code>、<code>job3</code> 全部执行完毕，才会恢复执行。换句话说，只有当 <code>job1</code>、<code>job2</code>、<code>job3</code> 全部执行完毕，<code>parentJob</code> 才算是执行完毕了。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/job_parent_2.gif" alt></p>
<p>所以说：<strong>结构化并发就是带有结构和层级的并发</strong>。</p>
<p>实际上，协程不像之前学过的线程，线程之间是不存在父子关系的，但<strong>协程之间是会存在父子关系的</strong>。不过协程的这种父子关系并不明显，如果不深入 <code>Job</code> 的源码，就无法意识到这一点。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> parentJob: Job</span><br><span class="line">    <span class="keyword">var</span> job1: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job2: Job? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> job3: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    parentJob = launch &#123;</span><br><span class="line">        job1 = launch &#123;</span><br><span class="line">            logX(<span class="string">&quot;Job1 start!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Job1 done!&quot;</span>) <span class="comment">// ①，不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job2 = launch &#123;</span><br><span class="line">            logX(<span class="string">&quot;Job2 start!&quot;</span>)</span><br><span class="line">            delay(<span class="number">3000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Job2 done!&quot;</span>) <span class="comment">// ②，不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job3 = launch &#123;</span><br><span class="line">            logX(<span class="string">&quot;Job3 start!&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            logX(<span class="string">&quot;Job3 done!&quot;</span>)<span class="comment">// ③，不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line"></span><br><span class="line">    parentJob.children.forEachIndexed &#123; index, job -&gt;</span><br><span class="line">        <span class="keyword">when</span> (index) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; println(<span class="string">&quot;job1 === job is <span class="subst">$&#123;job1 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">1</span> -&gt; println(<span class="string">&quot;job2 === job is <span class="subst">$&#123;job2 === job&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="number">2</span> -&gt; println(<span class="string">&quot;job3 === job is <span class="subst">$&#123;job3 === job&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parentJob.cancel() <span class="comment">// 变化在这里</span></span><br><span class="line">    logX(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Job1 start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Job2 start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#4</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Job3 start!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#5</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">job1 === job is true</span></span><br><span class="line"><span class="comment">job2 === job is true</span></span><br><span class="line"><span class="comment">job3 === job is true</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">// 这里不会等待5秒钟</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>这段代码，最大的改变就在于将“<code>parentJob.join</code>”改为了“<code>parentJob.cancel()</code>”。从运行结果中可以看到，即使调用的只是 <code>parentJob</code> 的 <code>cancel()</code> 方法，并没有碰过 <code>job1</code>、<code>job2</code>、<code>job3</code>，但是它们内部的协程任务也全都被取消了。用一个简单的动图来描述它们之间的关系：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/job_parent_3.gif" alt></p>
<p>由此，当以结构化的方式构建协程以后， <code>join()</code>、<code>cancel()</code> 等操作，也会以结构化的模式来执行。</p>
<h1><a href="#五-coroutinecontext" class="header-anchor">#</a><span id="五-coroutinecontext">五、CoroutineContext</span></h1>
<p>协程的 <code>Context</code>，在 <code>Kotlin</code> 当中具体的名字，叫做 <code>CoroutineContext</code>。从概念上讲，<code>CoroutineContext</code> 它只是个上下文而已，实际开发中最常见的用处就是切换线程池。</p>
<h2><a href="#1-context-的应用" class="header-anchor">#</a><span id="1-context-的应用">1. Context 的应用</span></h2>
<h3><a href="#1-launch" class="header-anchor">#</a><span id="1-launch">1. <code>launch()</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//                这里</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//                 ↓</span></span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>由上面<code>launch</code> 的部分源码可知，<code>CoroutineContext</code> 其实就是函数的第一个参数，它有默认值 <code>EmptyCoroutineContext</code>，顾名思义，这就是一个空的上下文对象。而如果想要指定 <code>launch</code> 工作的线程池的话，就需要自己传 <code>context</code> 这个参数。</p>
<h3><a href="#2-withcontext" class="header-anchor">#</a><span id="2-withcontext">2. <code>withContext()</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    logX(<span class="string">&quot;Before IO Context.&quot;</span>)</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        logX(<span class="string">&quot;In IO Context.&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;After IO Context.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>“<code>Dispatchers.IO</code>”，就是 <code>Kotlin</code> 官方提供的一个 <code>CoroutineContext</code> 对象。从上面代码中看到，当在 <code>withContext()</code> 这里指定线程池以后，<code>Lambda</code> 当中的代码就会被分发到 <code>DefaultDispatcher</code> 线程池中去执行，而它外部的所有代码仍然还是运行在 <code>main</code> 之上。</p>
<p>其实，<code>Kotlin</code> 官方还提供了挂起函数版本的 <code>main()</code> 函数，所以代码也可以改成这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：挂起函数版本的 <code>main()</code> 的底层做了很多封装，虽然它可以省去写 <code>runBlocking</code> 的麻烦，但不利于学习阶段的探索和研究。等到深入理解协程以后，就可以直接用“<code>suspend main()</code>”写 <code>Demo</code> 了。</p>
<h3><a href="#3-runblocking" class="header-anchor">#</a><span id="3-runblocking">3. <code>runBlocking()</code></span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面<code>runBlocking()</code>源码可以看到，它的第一个参数也是 <code>CoroutineContext</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据打印结果发现，所有的代码都运行在 <code>DefaultDispatcher</code> 这个线程池当中了。</p>
<h3><a href="#4-内置dispatcher" class="header-anchor">#</a><span id="4-内置dispatcher">4. 内置Dispatcher</span></h3>
<p>而 <code>Kotlin</code> 官方除了提供了 <code>Dispatchers.IO </code>以外，还提供了 <code>Dispatchers.Main</code>、<code>Dispatchers.Unconfined</code>、<code>Dispatchers.Default</code> 这几种内置 <code>Dispatcher</code>。</p>
<ul>
<li><strong><code>Dispatchers.Main</code></strong>，它只在 <code>UI</code> 编程平台才有意义，在 <code>Android</code>、<code>Swing</code> 之类的平台上，一般只有 <code>Main</code> 线程才能用于 <code>UI</code> 绘制。这个 <code>Dispatcher</code> 在普通的 <code>JVM</code> 工程当中，是无法直接使用的。</li>
<li><strong><code>Dispatchers.Unconfined</code></strong>，代表无所谓，当前协程可能运行在任意线程之上。</li>
<li><strong><code>Dispatchers.Default</code></strong>，它是用于 <code>CPU</code> 密集型任务的线程池。一般来说，它内部的线程个数是与机器 <code>CPU</code> 核心数量保持一致的，不过它有一个最小限制 <strong>2</strong>。</li>
<li><strong><code>Dispatchers.IO</code></strong>，它是用于 <code>IO</code> 密集型任务的线程池。它内部的线程数量一般会更多一些 <em>（比如 64 个）</em>，具体线程的数量可以通过参数来配置：<code>kotlinx.coroutines.io.parallelism</code>。</li>
</ul>
<p>需要特别注意的是，<code>Dispatchers.IO</code> 底层是可能复用 <code>Dispatchers.Default</code> 当中的线程的。之前示例代码中使用的都是 <code>Dispatchers.IO</code>，但实际运行的线程却是 <code>DefaultDispatcher</code> 这个线程池。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当 <code>Dispatchers.Default</code> 线程池当中有富余线程的时候，它是可以被 <code>IO</code> 线程池复用的。可以看到，后面三个结果的输出都是在同一个线程之上的，这就是因为 <code>Dispatchers.Default</code> 被 <code>Dispatchers.IO</code> 复用线程导致的。如果换成自定义的 <code>Dispatcher</code>，结果就会不一样了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> mySingleDispatcher = Executors.newSingleThreadExecutor &#123;</span><br><span class="line">    Thread(it, <span class="string">&quot;MySingleThread&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">&#125;.asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line"><span class="comment">//                          变化在这里</span></span><br><span class="line"><span class="comment">//                             ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(mySingleDispatcher) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">    logX(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ExecutorService.<span class="title">asCoroutineDispatcher</span><span class="params">()</span></span>: ExecutorCoroutineDispatcher =</span><br><span class="line">    ExecutorCoroutineDispatcherImpl(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Before IO Context.</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">In IO Context.</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">After IO Context.</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">BoyCoder</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，通过 <code>asCoroutineDispatcher()</code> 这个扩展函数，创建了一个 <code>Dispatcher</code>。从这可以看到，<code>Dispatcher</code> 的本质仍然还是线程。这也再次验证了之前的说法：<strong>协程运行在线程之上</strong>。<br>
然后当给 <code>runBlocking</code> 传入自定义的 <code>mySingleDispatcher</code> 以后，程序运行的结果就不一样了，由于它底层并没有复用线程，因此只有“<code>In IO Context</code>”是运行在 <code>DefaultDispatcher</code> 这个线程池的，其他代码都运行在 <code>mySingleDispatcher</code> 之上。</p>
<p>另外，除了要注意<code>Dispatchers.IO</code>外，还要注意<code>Dispatchers.Unconfined</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    logX(<span class="string">&quot;Before launch.&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;In launch.&quot;</span>) <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;End launch.&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;After launch.&quot;</span>)   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们的执行顺序应该是：1、4、2、3。但要注意，同样的代码模式在特殊的环境下，结果可能会不一样。比如在 <code>Android</code> 平台，或者是如果指定了 <code>Dispatchers.Unconfined</code> 这个特殊的 <code>Dispatcher</code>，它的这种行为模式也会被打破。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    logX(<span class="string">&quot;Before launch.&quot;</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//               变化在这里</span></span><br><span class="line"><span class="comment">//                  ↓</span></span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        logX(<span class="string">&quot;In launch.&quot;</span>)  <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;End launch.&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    logX(<span class="string">&quot;After launch&quot;</span>)    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">================================</span><br><span class="line">Before launch.</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">In launch.</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">After launch</span><br><span class="line">Thread:main <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">================================</span><br><span class="line">================================</span><br><span class="line">End launch.</span><br><span class="line">Thread:kotlinx.coroutines.DefaultExecutor <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上代码的运行顺序就变成了：1、2、4、3。</p>
<p>注意“<code>End launch</code>”运行的线程“<code>DefaultExecutor</code>”，其实 <code>Unconfined</code> 代表的意思就是，<strong>当前协程可能运行在任何线程之上，不作强制要求</strong>。由此可见，<code>Dispatchers.Unconfined</code> 其实是很危险的。所以，<strong>不应该随意使用 <code>Dispatchers.Unconfined</code></strong>。</p>
<h2><a href="#2-万物皆有context" class="header-anchor">#</a><span id="2-万物皆有context">2. 万物皆有Context</span></h2>
<p>在 <code>Kotlin</code> 协程当中，但凡是重要的概念，都或多或少跟 <code>CoroutineContext</code> 有关系：<code>Job</code>、<code>Dispatcher</code>、<code>CoroutineExceptionHandler</code>、<code>CoroutineScope</code>，甚至挂起函数，它们都跟 <code>CoroutineContext</code> 有着密切的联系。甚至，它们之中的 <code>Job</code>、<code>Dispatcher``、CoroutineExceptionHandler</code> 本身，就是 <code>Context</code>。</p>
<h3><a href="#1-coroutinescope" class="header-anchor">#</a><span id="1-coroutinescope">1. CoroutineScope</span></h3>
<p>之前提到要调用 <code>launch</code>，就必须先有“协程作用域”，也就是 <code>CoroutineScope</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//            注意这里</span></span><br><span class="line"><span class="comment">//               ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CoroutineScope 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面<code>CoroutineScope</code> 的源码，可见它其实就是一个简单的接口，而这个接口只有唯一的成员，就是 <code>CoroutineContext</code>。所以，<strong><code>CoroutineScope</code> 只是对 <code>CoroutineContext</code> 做了一层封装而已，它的核心能力其实都来自于 <code>CoroutineContext</code></strong>。而 <code>CoroutineScope</code> 最大的作用，就是可以批量控制协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 仅用于测试，生成环境不要使用这么简易的CoroutineScope</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;First start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First end!&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;Second start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Second end!&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        logX(<span class="string">&quot;Third start!&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;Third end!&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line"></span><br><span class="line">    scope.cancel()</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">First start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Third start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-3 @coroutine#4</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Second start!</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-2 @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，创建了一个简单的 <code>CoroutineScope</code>，接着，使用这个 <code>scope</code> 连续创建了三个协程，在 <em>500</em> 毫秒以后，就调用了 <code>scope.cancel()</code>，这样一来，代码中每个协程的“<code>end</code>”日志就不会输出了。这同样体现了协程结构化并发的理念，相同的功能，借助 <code>Job</code> 也同样可以实现。</p>
<h3><a href="#2-job-和-dispatcher" class="header-anchor">#</a><span id="2-job-和-dispatcher">2. Job 和 Dispatcher</span></h3>
<p>如果说 <code>CoroutineScope</code> 是封装了 <code>CoroutineContext</code>，那么 <code>Job</code> 就是一个真正的 <code>CoroutineContext</code> 了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以看出：<code>Job</code> 继承自 <code>CoroutineContext.Element</code>，而 <code>CoroutineContext.Element</code> 仍然继承自 <code>CoroutineContext</code>，这就意味着 <code>Job</code> 是间接继承自 <code>CoroutineContext</code> 的。所以说，<code>Job</code> 确实是一个真正的 <code>CoroutineContext</code>，所以如下代码也是正确的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job: CoroutineContext = Job()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的<code>CoroutineContext</code>部分源码中的 <code>get()</code>、<code>plus()</code>、<code>minusKey()</code>、<code>fold()</code> 这几个方法，可以看到 <code>CoroutineContext</code> 的接口设计，就跟集合 <code>API</code> 一样。准确来说，它的 <code>API</code> 设计和 <code>Map</code> 十分类似。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/coroutine_map.webp" alt></p>
<p>所以，完全可以把 <code>CoroutineContext</code> 当作 <code>Map</code> 来用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First end!&quot;</span>)  <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    scope.cancel()</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用了“<code>Job() + mySingleDispatcher</code>”这样的方式创建 <code>CoroutineScope</code>，代码之所以这么写，是因为 <code>CoroutineContext</code> 的 <code>plus()</code> 进行了操作符重载。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//     操作符重载</span></span><br><span class="line"><span class="comment">//        ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">plus</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br></pre></td></tr></table></figure>
<p>另外，还使用了“<code>coroutineContext[CoroutineDispatcher]</code>”这样的方式，访问当前协程所对应的 <code>Dispatcher</code>。这也是因为 <code>CoroutineContext</code> 的 <code>get()</code>，支持了操作符重载。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//     操作符重载</span></span><br><span class="line"><span class="comment">//        ↓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br></pre></td></tr></table></figure>
<p>在 <code>Kotlin</code> 当中很多集合也是支持 <code>get()</code> 方法重载的，比如 <code>List</code>、<code>Map</code>，我们都可以使用这样的语法：<code>list[0]</code>、<code>map[key]</code>，以数组下标的方式来访问集合元素。<br>
<code>Kotlin</code> 官方的源代码当中大量使用了操作符重载来简化代码逻辑，而 <code>CoroutineContext</code> 就是一个最典型的例子。</p>
<p>从上面的代码中也可以看出：<code>Dispatcher</code> 本身也是 <code>CoroutineContext</code>，不然就无法实现“<code>Job() + mySingleDispatcher</code>”。最重要的是，当以这样的方式创建出 <code>scope</code> 以后，后续创建的协程就全部都运行在 <code>mySingleDispatcher</code> 这个线程之上了。</p>
<p>下面来探究一下 <code>Dispatcher</code> 到底是如何跟 <code>CoroutineContext</code> 建立关系。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由上面 <code>Dispatchers</code> 的源码可见，<code>Dispatchers</code> 其实是一个 <code>object</code> 单例，它的内部成员的类型是 <code>CoroutineDispatcher</code>，而它又是继承自 <code>ContinuationInterceptor</code>，这个类则是实现了 <code>CoroutineContext.Element</code> 接口。由此可见，<code>Dispatcher</code> 确实就是 <code>CoroutineContext</code>。</p>
<h3><a href="#3-coroutinename" class="header-anchor">#</a><span id="3-coroutinename">3. CoroutineName</span></h3>
<p>除了上面几个重要的 <code>CoroutineContext</code> 之外，协程其实还有一些上下文还没提到的。比如 <code>CoroutineName</code>，当创建协程的时候，可以传入指定的名称。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    scope.launch(CoroutineName(<span class="string">&quot;MyFirstCoroutine!&quot;</span>)) &#123;</span><br><span class="line">        logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        logX(<span class="string">&quot;First end!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">500L</span>)</span><br><span class="line">    scope.cancel()</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Thread:MySingleThread @MyFirstCoroutine!#2  // 注意这里</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，调用 <code>launch</code> 的时候，传入了“<code>CoroutineName(“MyFirstCoroutine!”)</code>”作为协程的名字。在后面输出的结果中，得到了“<em>@MyFirstCoroutine!#2</em>”这样的输出。由此可见，其中的数字“<em>2</em>”，其实是一个自增的唯一 <code>ID</code>。</p>
<h3><a href="#4-coroutineexceptionhandler" class="header-anchor">#</a><span id="4-coroutineexceptionhandler">4. CoroutineExceptionHandler</span></h3>
<p><code>CoroutineContext</code> 当中，还有一个重要成员是 <code>CoroutineExceptionHandler</code>，它主要负责处理协程当中的异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineExceptionHandler</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>CoroutineExceptionHandler</code> 的接口定义其实很简单，<code>CoroutineExceptionHandler</code> 真正重要的，其实只有 <code>handleException()</code> 这个方法，如果要自定义异常处理器，就只需要实现该方法即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  这里使用了挂起函数版本的main()</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myExceptionHandler = CoroutineExceptionHandler &#123; _, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Catch exception: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = scope.launch(myExceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">val</span> s: String? = <span class="literal">null</span></span><br><span class="line">        s!!.length <span class="comment">// 空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Catch exception: java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>不过，虽然 <code>CoroutineExceptionHandler</code> 的用法看起来很简单，但当它跟协程“结构化并发”理念相结合以后，内部的异常处理逻辑是会很复杂。</p>
<p>最后，为清晰描述 <code>CoroutineContext</code> 元素之间的关系，画了如下张结构图：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/coroutinescope.png" alt></p>
<h1><a href="#六-实战网络请求框架-kthttp" class="header-anchor">#</a><span id="六-实战网络请求框架-kthttp">六、实战：网络请求框架 KtHttp</span></h1>
<h2><a href="#1-以java思维简单实现网络请求框架" class="header-anchor">#</a><span id="1-以java思维简单实现网络请求框架">1. 以<code>Java</code>思维简单实现网络请求框架</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.VALUE_PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Field</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">GET</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任何支持Get API</span></span><br><span class="line"><span class="comment"> * 以 GitHub repositories API 为例：</span></span><br><span class="line"><span class="comment"> * https://api.github.com/search/repositories?q=stars:&gt;=10000 language:kotlin&amp;sort=stars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/search/repositories&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;q&quot;</span>)</span> q: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;sort&quot;</span>)</span> sort: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">RepoList</span>(</span><br><span class="line">    <span class="keyword">var</span> total_count: <span class="built_in">Int</span>?,</span><br><span class="line">    <span class="keyword">var</span> items: List&lt;Repo&gt;?,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Repo</span>(</span><br><span class="line">    <span class="keyword">var</span> full_name: String?,</span><br><span class="line">    <span class="keyword">var</span> homepage: String?,</span><br><span class="line">    <span class="keyword">var</span> html_url: String?,</span><br><span class="line">    <span class="keyword">var</span> language: String?,</span><br><span class="line">    <span class="keyword">var</span> forks_count: String?,</span><br><span class="line">    <span class="keyword">var</span> topics: List&lt;String&gt;?,</span><br><span class="line">    <span class="keyword">var</span> owner: Owner?,</span><br><span class="line">    <span class="keyword">var</span> watchers: <span class="built_in">Int</span>?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Owner</span>(</span><br><span class="line">    <span class="keyword">var</span> login: String?,</span><br><span class="line">    <span class="keyword">var</span> html_url: String?,</span><br><span class="line">    <span class="keyword">var</span> type: String?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> api: ApiService = KtHttpV1.create(ApiService::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = api.repos(<span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>, <span class="string">&quot;stars&quot;</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> okHttpClient: OkHttpClient = OkHttpClient()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gson: Gson = Gson()</span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://api.github.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            service.classLoader,</span><br><span class="line">            arrayOf&lt;Class&lt;*&gt;&gt;(service)</span><br><span class="line">        <span class="comment">//          反射①  反射②</span></span><br><span class="line">        <span class="comment">//            ↓      ↓</span></span><br><span class="line">        ) &#123; proxy, method, args -&gt;</span><br><span class="line">        <span class="comment">//  反射③</span></span><br><span class="line">            <span class="keyword">val</span> annotations = method.annotations</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> annotations) &#123;</span><br><span class="line">                <span class="comment">//  反射④</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">annotation</span> <span class="keyword">is</span> GET) &#123;</span><br><span class="line">                    <span class="comment">//  反射⑤</span></span><br><span class="line">                    <span class="keyword">val</span> url = baseUrl + <span class="keyword">annotation</span>.value</span><br><span class="line">                    <span class="comment">//  反射⑥</span></span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> invoke(url, method, args!!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">// ① 根据url拼接参数，也就是：url + ?q=stars:&gt;=10000 language:kotlin&amp;sort=stars</span></span><br><span class="line">        <span class="comment">// ② 使用okHttpClient进行网络请求 </span></span><br><span class="line">        <span class="comment">// ③ 使用gson进行JSON解析 </span></span><br><span class="line">        <span class="comment">// ④ 返回结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 解析完整的 url</span></span><br><span class="line">        <span class="keyword">var</span> url = path</span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">                <span class="comment">// ②</span></span><br><span class="line">                <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                    <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                    <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                    <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// ③</span></span><br><span class="line">                        url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// ④</span></span><br><span class="line">                        url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行网络请求</span></span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line">        <span class="comment">// ⑤</span></span><br><span class="line">        <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">        <span class="keyword">val</span> body = response.body</span><br><span class="line">        <span class="keyword">val</span> json = body?.string()</span><br><span class="line">        <span class="comment">// JSON 解析</span></span><br><span class="line">        <span class="keyword">val</span> result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只是为了模拟Java动态代理，实际更复杂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApiImpl</span>(<span class="keyword">val</span> h: InvocationHandler) : Proxy(h), ApiService &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(q: <span class="type">String</span>, sort: <span class="type">String</span>)</span></span>: RepoList &#123;</span><br><span class="line">        <span class="keyword">val</span> method: Method = ::repos.javaMethod!!</span><br><span class="line">        <span class="keyword">val</span> args = arrayOf(q, sort)</span><br><span class="line">        <span class="keyword">return</span> h.invoke(<span class="keyword">this</span>, method, args) <span class="keyword">as</span> RepoList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>以上代码实现的 <code>KtHttp</code>，它的灵感来自于 <code>Retrofit</code>。<code>Retrofit</code>的底层使用了大量的泛型、注解和反射的技术。<code>KtHttp</code> 主要功能是请求了一个服务器的 <code>API</code>，然后在控制台输出了结果。通过这个 <code>KtHttp</code>，可以在程序当中访问任何服务器的 <code>API</code>，当前例子请求的<code>github</code>的中<code>stars</code>数量大于一万且语言类型为<code>kotlin</code>的仓库数据，且以<code>stars</code>数据进行排序。</p>
</li>
<li>
<p>定义三个数据类<code>Owner</code>、<code>Repo</code>、<code>RepoList</code>，用于描述服务器返回的内容。</p>
</li>
<li>
<p>定义两个注解<code>GET</code>、<code>Field</code>，一个用于修饰函数，一个用于修饰参数。这两个注解的 <code>Retention</code> 都是 <code>AnnotationRetention.RUNTIME</code>，这意味着这两个注解都是运行时可访问的。而这，也正好是后面要使用的反射的前提。</p>
</li>
<li>
<p>定义一个用于网络请求的接口<code>ApiService</code>，在这个接口当中，有两个注解：</p>
<ul>
<li><code>GET</code> 注解，代表了这个网络请求应该是 <code>GET</code> 请求，这是HTTP请求的一种方式。<code>GET</code> 注解当中的“<code>/search/repositories</code>”，代表了 <code>API</code> 的 <code>path</code>，它是和 <code>baseURL</code> 拼接的；</li>
<li><code>Field</code> 注解，代表了 <code>GET</code> 请求的参数。<code>Field</code> 注解当中的值也会和 <code>URL</code> 拼接在一起。</li>
</ul>
</li>
<li>
<p>之后在<code>main()</code>方法里进行网络请求：</p>
<ol>
<li>调用 <code>KtHttpV1.create()</code> 方法，传入了 <code>ApiService::class.java</code>，参数的类型是<code>Class</code>，返回值类型是 <code>ApiService</code>。这就相当于创建了 <code>ApiService</code> 这个接口的实现类的对象。</li>
<li>调用 <code>api.repos()</code> 这个方法，传入了 <code>stars:&gt;=10000 language:kotlin</code>、<code>stars</code> 这两个参数，代表想查询<code>stars</code>数量大于一万且语言类型为<code>kotlin</code>的仓库数据，且以<code>stars</code>数据进行排序。</li>
</ol>
</li>
<li>
<p>最后看一下网络请求的具体实现<code>KtHttpV1</code>：</p>
<ol>
<li>在<code>KtHttpV1.create()</code> 方法当中，直接返回了 <code>Proxy.newProxyInstance()</code> 这个方法的返回值，最后再将其转换成了 <code>T</code> 类型，<code>Proxy.newProxyInstance()</code>方法可以动态创建传入参数的实例化对象。也就是传入的参数<code>ApiService</code>接口的实例化对象。
<ul>
<li>通过使用反射将注解当中的值 <code>/search/repositories</code>、<code>q</code>、<code>sort</code> 取出来，然后拼接到 URL 当中去。</li>
<li>在 <em>反射注释①</em> 处，<code>method</code> 的类型是反射后的 <code>Method</code>，在这个例子当中，它最终会代表被调用的方法，也就是 <code>ApiService</code> 接口里面的 <code>repos()</code> 这个方法。</li>
<li>在 <em>反射注释②</em> 处：<code>args</code> 的类型是对象的数组，在例子当中，它最终会代表方法的参数的值，也就是“<code>api.repos(&quot;stars:&gt;=10000 language:kotlin&quot;, &quot;stars&quot;)</code>”当中的<code>stars:&gt;=10000 language:kotlin</code>和<code>stars</code>。</li>
<li>在 <em>反射注释③</em> 处：<code>method.annotations</code>，代表会取出 <code>repos()</code> 这个方法上面的所有注解，由于 <code>repos()</code> 这个方法上面可能会有多个注解，因此它是数组类型。</li>
<li>在 <em>反射注释④</em> 处：使用 <code>for</code> 循环，遍历所有的注解，找到 <code>GET</code> 注解。</li>
<li>在 <em>反射注释⑤</em> 处：找到 <code>GET</code> 注解以后，要取出 <code>@GET(“/search/repositories”)</code> 当中的<code>/search/repositories</code>，也就是“<code>annotation.value</code>”。这时候只需要用它与 <code>baseURL</code> 进行拼接，就可以得到完整的 <code>URL</code>。</li>
<li>在 <em>反射注释⑥</em> 处：<code>return@newProxyInstance</code>，用的是 <code>Lambda</code> 表达式当中的返回语法，在得到完整的 <code>URL</code> 以后，将剩下的逻辑都交给了 <code>invoke()</code> 这个方法。</li>
</ul>
</li>
<li><code>invoke()</code>方法需要实现功能是 根据url拼接参数、使用<code>okHttpClient</code>进行网络请求、使用<code>gson</code>进行<code>JSON</code>解析、返回结果
<ul>
<li>在 <em>注释①</em> 处，<code>method.parameterAnnotations</code>，它的作用是取出方法参数当中的所有注解，在这个案例当中，<code>repos()</code> 这个方法当中涉及到两个注解，它们分别是@Field(“q”)、@Field(“sort”)。</li>
<li>在 <em>注释②</em> 处，由于方法当中可能存在其他注解，因此要筛选出想要的 <code>Field</code> 注解。</li>
<li>在 <em>注释③</em> 处，这里是取出注解当中的值<code>q</code>，以及参数当中对应的值<code>stars:&gt;=10000 language:kotlin</code>进行拼接，<code>URL</code> 第一次拼接参数的时候，要用“<strong>?</strong>”分隔。</li>
<li>在 <em>注释④</em> 处，这里是取出注解当中的值<code>sort</code>，以及参数当中对应的值<code>stars</code>进行拼接，后面的参数拼接格式，是用“<strong>&amp;</strong>”分隔。</li>
<li>在 <em>注释⑤</em> 处，<code>method.genericReturnType</code> 取出 <code>repos()</code> 的返回值类型，也就是 <code>RepoList</code>，最终，用它来解析 <code>JSON</code>。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><code>KtHttp</code>，就是将 <code>URL</code> 的信息存储在了注解当中 <em>（比如 <code>q</code> 和 <code>sort</code>）</em>，而实际的参数值，是在函数调用的时候传进来的 <em>（比如 <code>stars:&gt;=10000 language:kotlin</code>和<code>stars</code>）</em> 。通过泛型、注解、反射的结合，将这些信息集到一起，完成整个 <code>URL</code> 的拼接，最后才通过 <code>OkHttp</code> 完成的网络请求、<code>Gson</code> 完成的解析。可以看到使用 <strong>动态代理 + 注解 + 反射</strong> 实现的这个网络请求框架不必在代码当中去实现每一个接口，而是只要是符合这样的代码模式，任意的接口和方法，都可以直接传进去，灵活性非常的好。</p>
</li>
</ol>
<h2><a href="#2-函数式思维重构kthttp" class="header-anchor">#</a><span id="2-函数式思维重构kthttp">2. 函数式思维重构<code>KtHttp</code></span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService2</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/search/repositories&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;q&quot;</span>)</span> q: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;sort&quot;</span>)</span> sort: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> KtHttpV2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> okHttpClient <span class="keyword">by</span> lazy &#123; OkHttpClient() &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson <span class="keyword">by</span> lazy &#123; Gson() &#125;</span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;https://api.github.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            T::<span class="keyword">class</span>.java.classLoader, <span class="comment">// ①</span></span><br><span class="line">            arrayOf(T::<span class="keyword">class</span>.java)  <span class="comment">// ②</span></span><br><span class="line">        ) &#123; _, method, args -&gt;</span><br><span class="line">            <span class="comment">// ③</span></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@newProxyInstance</span> method.annotations</span><br><span class="line">                .filterIsInstance&lt;GET&gt;()</span><br><span class="line">                .takeIf &#123; it.size == <span class="number">1</span> &#125;</span><br><span class="line">                ?.let &#123; invoke(<span class="string">&quot;<span class="variable">$baseUrl</span><span class="subst">$&#123;it[<span class="number">0</span>].value&#125;</span>&quot;</span>, method, args) &#125;</span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(url: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? =</span><br><span class="line">        method.parameterAnnotations</span><br><span class="line">            .takeIf &#123; method.parameterAnnotations.size == args.size &#125;</span><br><span class="line">            ?.mapIndexed &#123; index, it -&gt; Pair(it, args[index]) &#125;</span><br><span class="line">            ?.fold(url, ::parseUrl)</span><br><span class="line">            ?.let &#123; Request.Builder().url(it).build() &#125;</span><br><span class="line">            ?.let &#123; okHttpClient.newCall(it).execute().body?.string() &#125;</span><br><span class="line">            ?.let &#123; gson.fromJson(it, method.genericReturnType) &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseUrl</span><span class="params">(acc: <span class="type">String</span>, pair: <span class="type">Pair</span>&lt;<span class="type">Array</span>&lt;<span class="type">Annotation</span>&gt;, Any&gt;)</span></span> =</span><br><span class="line">        pair.first.filterIsInstance&lt;Field&gt;()</span><br><span class="line">            .first()</span><br><span class="line">            .let &#123; field -&gt;</span><br><span class="line">                <span class="keyword">if</span> (acc.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                    <span class="string">&quot;<span class="variable">$acc</span>&amp;<span class="subst">$&#123;field.value&#125;</span>=<span class="subst">$&#123;pair.second&#125;</span>&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="string">&quot;<span class="variable">$acc</span>?<span class="subst">$&#123;field.value&#125;</span>=<span class="subst">$&#123;pair.second&#125;</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = KtHttpV2.create&lt;ApiServiceV2&gt;().repos(</span><br><span class="line">        q = <span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>, </span><br><span class="line">        sort = <span class="string">&quot;stars&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>KtHttpV2</code>是使用了函数式思维重构的<code>KtHttp</code>，功能一致，只是实现代码更多使用了<code>Kotlin</code>语言特性。</p>
</li>
<li>
<p><code>okHttpClient</code>、<code>gson</code> 这两个成员通过 <code>by lazy</code> 委托的方式实现懒加载。</p>
</li>
<li>
<p>再看<code>create()</code>方法:</p>
<ol>
<li>之前代码 <code>create()</code> 会接收一个<code>Class</code>类型的参数。其实，针对这样的情况，完全可以省略掉这个参数。正常情况下，泛型参数类型会被擦除，这就是 <code>Java</code> 的泛型被称为“<em>伪泛型</em>”的原因。而通过使用 <code>inline</code> 和 <code>reified</code> 这两个关键字，就能实现 <strong>类型实化</strong>，也就是“真泛型”，进一步，就可以在代码 <em>注释①</em> 、<em>注释②</em> 的地方，使用“<code>T::class.java</code>”来得到 <code>Class</code> 对象。</li>
<li>在看 <em>注释③</em> 处：
<ul>
<li>首先，通过 <code>method.annotations</code>，来获取 <code>method</code> 的所有注解；</li>
<li>接着，用 <code>filterIsInstance()</code>，来筛选出想要找的 <code>GET</code> 注解。这里的 <code>filterIsInstance</code> 其实是 <code>filter</code> 的升级版，也就是过滤的意思；</li>
<li>之后，判断 <code>GET</code> 注解的数量，它的数量必须是 <em>1</em>，其他的都不行，这里的 <code>takeIf</code> 其实相当于 <code>if</code>；</li>
<li>最后，通过拼接出 <code>URL</code>，然后将程序执行流程交给 <code>invoke()</code> 方法。这里的&quot;<code>?.let&#123;&#125;</code>&quot;相当于判空。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>再看<code>invoke()</code>方法：</p>
<ul>
<li>第一步，通过 <code>method.parameterAnnotations</code>，获取方法当中所有的参数注解，在这里也就是<code>@Field(&quot;q&quot;)</code>、<code>@Field(&quot;sort&quot;)</code>。</li>
<li>第二步，通过 <code>takeIf</code> 来判断，参数注解数组的数量与参数的数量相等，也就是说 <code>@Field(&quot;q&quot;)</code>、<code>@Field(&quot;sort&quot;)</code>的数量是 <em>2</em>，那么<code>[&quot;stars:&gt;=10000 language:kotlin&quot;, &quot;stars&quot;]</code>的 <code>size</code> 也应该是 <em>2</em>，它必须是一一对应的关系。</li>
<li>第三步，将<code>@Field(&quot;q&quot;)</code>与&quot;<code>stars:&gt;=10000 language:kotlin</code>&quot;进行配对，将 <code>@Field(&quot;sort&quot;)</code>与&quot;<code>stars</code>&quot;进行配对。这里的 <code>mapIndexed</code>，其实就是 <code>map</code> 的升级版，它本质还是一种映射的语法，“注解数组类型”映射成了“Pair 数组”，只是多了一个 <code>index</code> 而已。</li>
<li>第四步，使用 <code>fold</code> 与 <code>parseUrl()</code> 这个方法，拼接出完整的 <code>URL</code>，也就是：<code>https://api.github.com/search/repositories?q=stars:&gt;=10000 language:kotlin&amp;sort=stars</code>。 这里使用了函数引用的语法“<code>::parseUrl</code>”。而 <code>fold</code> 这个操作符，其实就是高阶函数版的 <code>for</code> 循环。</li>
<li>第五步，构建出 <code>OkHttp</code> 的 <code>Request</code> 对象，并且将 <code>URL</code> 传入了进去，准备做网络请求。</li>
<li>第六步，通过 <code>okHttpClient</code> 发起了网络请求，并且拿到了 <code>String</code> 类型的 <code>JSON</code> 数据。</li>
<li>最后，通过 <code>Gson</code> 解析出 <code>JSON</code> 的内容，并且返回 <code>RepoList</code> 对象。</li>
</ul>
</li>
<li>
<p>再看看用于实现 <code>URL</code> 拼接的 <code>parseUrl()</code> 是如何实现的:</p>
<ul>
<li>首先，从注解的数组里筛选出 <code>Field</code> 类型的注解；</li>
<li>接着，通过 <code>first()</code> 取出第一个 <code>Field</code> 注解，这里它也应该是唯一的；</li>
<li>最后，判断当前的 <code>acc</code> 是否已经拼接过参数，如果没有拼接过，就用“<em>?</em>”分隔，如果已经拼接过参数，就用“<em>&amp;</em>”分隔。</li>
</ul>
</li>
</ol>
<h2><a href="#3-支持异步请求call的-kthttp" class="header-anchor">#</a><span id="3-支持异步请求call的-kthttp">3. 支持异步请求（Call）的 KtHttp</span></h2>
<p>在之前 <em>1.0</em>、<em>2.0</em> 版本的代码中，<code>KtHttp</code> 是只支持同步请求的，所有代码都会在一个线程中执行，因此这样的代码如果运行在 <code>Android</code>、<code>Swing</code> 之类的 <code>UI</code> 编程平台上，会导致主线程卡死。<br>
而异步代码，它跟同步代码最大的差异就是，有了一个 <code>Callback</code>，而且代码不再是按照顺序执行的了。</p>
<h3><a href="#1-创建-callback" class="header-anchor">#</a><span id="1-创建-callback">1. 创建 Callback</span></h3>
<p>为了实现异步请求，首先需要创建一个 <code>Callback</code> 接口，在这个 <code>Callback</code> 当中，可以拿到 <code>API</code> 请求的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;<span class="type">T: Any</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在 <code>Callback</code> 这个接口里，有一个泛型参数 <code>T</code>，还有两个回调，分别是 <code>onSuccess</code> 代表接口请求成功，<code>onFail</code> 代表接口请求失败。</li>
<li>需要特别注意的是，这里运用了空安全思维当中的泛型边界“<code>T: Any</code>”，这样一来，就可以保证 <code>T</code> 类型一定是非空的。</li>
</ol>
<h3><a href="#2-创建-ktcall-类" class="header-anchor">#</a><span id="2-创建-ktcall-类">2. 创建 KtCall 类</span></h3>
<p>创建好 <code>Callback</code> 后，还创建需要一个 <code>KtCall</code> 类，它的作用是承载 <code>Callback</code>，或者说，它是用来调用 <code>Callback</code> 的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KtCall</span>&lt;<span class="type">T: Any</span>&gt;(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gson: Gson,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> type: Type</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">T</span>&gt;)</span></span>: Call &#123;</span><br><span class="line">        call.enqueue(<span class="keyword">object</span> : okhttp3.Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">                callback.onFail(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    <span class="keyword">val</span> t = gson.fromJson&lt;T&gt;(response.body?.string(), type)</span><br><span class="line">                    callback.onSuccess(t)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    callback.onFail(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> call</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>KtCall</code> 这个类仍然使用了泛型边界“<code>T: Any</code>”，另外，它还有几个关键的成员分别是：<code>OkHttp</code> 的 <code>Call</code> 对象、<code>JSON</code> 解析的 <code>Gson</code> 对象，以及反射类型 <code>Type</code>。</li>
<li>然后还有一个 <code>call()</code> 方法，它接收的是前面定义的 <code>Callback</code> 对象，返回的是 <code>OkHttp</code> 的 <code>Call</code> 对象。所以总的来说，<code>call()</code> 方法当中的逻辑会分为三个步骤：
<ol>
<li>使用 <code>OkHttp</code> 的 <code>call</code> 对象请求 <code>API</code>，这里需要注意的是，为了将请求任务派发到异步线程，需要使用 <code>OkHttp</code> 的异步请求方法 <code>enqueue()</code>。</li>
<li>根据请求结果，调用 <code>callback.onSuccess()</code> 或者是 c<code>allback.onFail()</code>。如果请求成功了，在调用 <code>onSuccess()</code> 之前，还需要用 <code>Gson</code> 将请求结果进行解析，然后才返回，而且由于 <code>API</code> 返回的结果并不可靠，即使请求成功了，其中的 <code>JSON</code> 数据也不一定合法，所以这里一般还需要进行额外的判断。</li>
<li>返回 <code>OkHttp</code> 的 <code>Call</code> 对象。</li>
</ol>
</li>
</ol>
<h3><a href="#3-创建-apiservice-及修改-invoke-方法" class="header-anchor">#</a><span id="3-创建-apiservice-及修改-invoke-方法">3. 创建 ApiService 及修改 invoke 方法</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV3</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;q&quot;</span>)</span> q: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;sort&quot;</span>)</span> sort: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt; <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注释①</em> 处是该版本和最初版本之间的最大区别，由于 <code>repo()</code> 方法的返回值类型是 <code>KtCall</code>，为了支持这种写法， <code>invoke</code> 方法就需要跟着做一些小的改动：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这里也同样使用了泛型边界</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.parameterAnnotations.size != args.size) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> url = path</span><br><span class="line">    <span class="keyword">val</span> parameterAnnotations = method.parameterAnnotations</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> parameterAnnotations.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (parameterAnnotation <span class="keyword">in</span> parameterAnnotations[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameterAnnotation <span class="keyword">is</span> Field) &#123;</span><br><span class="line">                <span class="keyword">val</span> key = parameterAnnotation.value</span><br><span class="line">                <span class="keyword">val</span> value = args[i].toString()</span><br><span class="line">                <span class="keyword">if</span> (!url.contains(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                    url += <span class="string">&quot;?<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    url += <span class="string">&quot;&amp;<span class="variable">$key</span>=<span class="variable">$value</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> call = okHttpClient.newCall(request)</span><br><span class="line">    <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">return</span> KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到 KtCall&lt;RepoList&gt; 当中的 RepoList类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTypeArgument</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">    (method.genericReturnType <span class="keyword">as</span> ParameterizedType).actualTypeArguments[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>上述代码中大部分代码和初始版本的一样的，只是在最后封装了一个 <code>KtCall</code> 对象，直接返回。</p>
<h3><a href="#4-测试代码" class="header-anchor">#</a><span id="4-测试代码">4. 测试代码</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAsync1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建api对象</span></span><br><span class="line">    <span class="keyword">val</span> api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ktCall</span></span><br><span class="line">    <span class="keyword">val</span> ktCall: KtCall&lt;RepoList&gt; = api.repos(</span><br><span class="line">        q = <span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>,</span><br><span class="line">        sort = <span class="string">&quot;stars&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起call异步请求</span></span><br><span class="line">    ktCall.call(<span class="keyword">object</span> : Callback&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">RepoList</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(throwable)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAsync2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">    .repos(</span><br><span class="line">        q = <span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>,</span><br><span class="line">        sort = <span class="string">&quot;stars&quot;</span></span><br><span class="line">    ).call(<span class="keyword">object</span> : Callback&lt;RepoList&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">RepoList</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(throwable)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在<code>testAsync1()</code> 中一步步创建 <code>API</code> 对象、<code>ktCall</code> 对象，最后发起请求，但是会创建创建很多一次性临时对象。</li>
<li>推荐使用<code>testAsync2()</code>，采用链式调用的方式，减少了临时对象，且不必为临时变量取名字伤脑筋。</li>
</ol>
<h3><a href="#5-同时支持同步和异步" class="header-anchor">#</a><span id="5-同时支持同步和异步">5. 同时支持同步和异步</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiServiceV3</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">repos</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;q&quot;</span>)</span> q: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;sort&quot;</span>)</span> sort: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: KtCall&lt;RepoList&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;/repo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reposSync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;q&quot;</span>)</span> q: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Field(<span class="string">&quot;sort&quot;</span>)</span> sort: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RepoList <span class="comment">// 注意这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: RepoList = api.reposSync(q = <span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>, sort = <span class="string">&quot;stars&quot;</span>)</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>repoSync()</code> 的返回值类型是 <code>RepoList</code>，而不是 <code>KtCall</code> 类型，这其实是初始版本的写法。写到这里，虽然 <code>KtHttp</code> 支持了异步请求，但原本的同步请求反而不支持了。所以，为了让 <code>KtHttp</code> 同时支持两种请求方式，只需要增加一个 <code>if</code> 判断即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">invoke</span><span class="params">(path: <span class="type">String</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (isKtCallReturn(method)) &#123;</span><br><span class="line">        <span class="keyword">val</span> genericReturnType = getTypeArgument(method)</span><br><span class="line">        KtCall&lt;T&gt;(call, gson, genericReturnType)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="keyword">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> genericReturnType = method.genericReturnType</span><br><span class="line">        <span class="keyword">val</span> json = response.body?.string()</span><br><span class="line">        gson.fromJson&lt;Any?&gt;(json, genericReturnType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前接口的返回值类型是不是KtCall</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isKtCallReturn</span><span class="params">(method: <span class="type">Method</span>)</span></span> =</span><br><span class="line">    getRawType(method.genericReturnType) == KtCall::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，定义了一个方法 <code>isKtCallReturn()</code>，它的作用是判断当前接口方法的返回值类型是不是 <code>KtCall</code>，如果是的话，就认为它是一个异步接口，这时候返回 <code>KtCall</code> 对象；如果不是，就认为它是同步接口。这样我们只需要将初始版本的逻辑挪到 <code>else</code> 分支，就可以实现兼容了。</p>
<h2><a href="#4-支持挂起函数的-kthttp" class="header-anchor">#</a><span id="4-支持挂起函数的-kthttp">4. 支持挂起函数的 KtHttp</span></h2>
<p>在日常的开发工作当中，也许经常会面临这样的一个问题：虽然很想用 <code>Kotlin</code> 的协程来简化异步开发，但公司的底层框架全部都是 <code>Callback</code> 写的，根本不支持挂起函数。<br>
其实，当前的 <code>KtHttp</code> 就面临着类似的问题：<em>3.0</em> 版本只支持 <code>Callback</code> 异步调用，现在想要扩展出挂起函数的功能。这其实就是大部分 <code>Kotlin</code> 开发者会遇到的场景。<br>
针对这个问题，主要有两种解法：</p>
<ul>
<li>
<p>第一种解法，不改动 <code>SDK</code> 内部的实现，直接在 <code>SDK</code> 的基础上扩展出协程的能力。</p>
</li>
<li>
<p>第二种解法，改动 <code>SDK</code> 内部，让 <code>SDK</code> 直接支持挂起函数。下面先来看看第一种解法。</p>
</li>
</ul>
<h3><a href="#1-解法一扩展-ktcall" class="header-anchor">#</a><span id="1-解法一扩展-ktcall">1. 解法一：扩展 KtCall</span></h3>
<p>这种方式有一个优势，那就是不需要改动 <em>3.0</em> 版本的任何代码。这种场景在工作中也是十分常见的，比如说，项目中用到的 <code>SDK</code> 是开源的，或者 <code>SDK</code> 是公司其他部门开发的，无法改动 <code>SDK</code>。</p>
<h4><a href="#1-扩展出-await-函数" class="header-anchor">#</a><span id="1-扩展出-await-函数">1. 扩展出 await 函数</span></h4>
<p>具体的做法，就是为 <code>KtCall</code> 这个类扩展出一个挂起函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意这里                   函数名称</span></span><br><span class="line"><span class="comment">   ↓                        ↓        */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T = TODO()</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，定义了一个扩展函数 <code>await()</code>。首先，它是一个挂起函数，其次，它的扩展接收者类型是 <code>KtCall</code>，其中带着一个泛型 <code>T</code>，挂起函数的返回值也是泛型 <code>T</code>。而由于它是一个挂起函数，所以，代码就可以换成这样的方式来写了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> ktCall = KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">        .repos(q = <span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>, sort = <span class="string">&quot;stars&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = ktCall.await() <span class="comment">// 调用挂起函数</span></span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><a href="#2-实现-await-函数" class="header-anchor">#</a><span id="2-实现-await-函数">2. 实现 await 函数</span></h4>
<p>那么，现在就只剩下一个问题了：<code>await()</code> 具体该如何实现？在这里，需要用到 <code>Kotlin</code> 官方提供的一个顶层函数：<code>suspendCoroutine&#123;&#125;</code>，它的函数签名是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutine</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="comment">// 省略细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的函数签名，可以发现，它是一个挂起函数，也是一个高阶函数，参数类型是“<code>(Continuation) -&gt; Unit</code>”，它其实就<strong>等价于挂起函数类型</strong>！</p>
<p>所以，可以使用 <code>suspendCoroutine&#123;&#125;</code> 来实现 <code>await()</code> 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意这里                   </span></span><br><span class="line"><span class="comment">   ↓                                */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T = suspendCoroutine&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    <span class="comment">//   ↑</span></span><br><span class="line">    <span class="comment">// 注意这里 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细分析这段代码的话，会发现 <code>suspendCoroutine&#123;&#125;</code> 的作用，其实就是<strong>将挂起函数当中的 <code>continuation</code> 暴露出来</strong>。<br>
再来回顾一下 <code>Continuation</code> 这个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="comment">// 关键在于这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过定义可以看到，整个 <code>Continuation</code> 只有一个方法，那就是 <code>resumeWith()</code>，根据它的名字就可以推测出，它是用于“恢复”的，参数类型是 <code>Result</code>。所以很明显，这就是一个带有泛型的“结果”，它的作用就是承载协程执行的结果。</p>
<p>所以，综合来看，就可以进一步写出这样的代码了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWith(Result.success(<span class="keyword">data</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWith(Result.failure(throwable))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码逻辑就是，当网络请求执行成功以后，就调用 <code>resumeWith()</code>，同时传入 <code>Result.success(data)</code>；如果请求失败，我们就传入 <code>Result.failure(throwable)</code>，将对应的异常信息传进去。不过，可以借助 <code>Kotlin</code> 官方提供的扩展函数提升代码可读性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4><a href="#3-suspendcoroutine-不支持取消" class="header-anchor">#</a><span id="3-suspendcoroutine-不支持取消">3. suspendCoroutine{} 不支持取消</span></h4>
<p>到目前为止，<code>await()</code> 这个扩展函数其实就已经实现了。这时候，如果在协程当中调用 <code>await()</code> 方法的话，代码是可以正常执行的。不过，这种做法其实还有一点瑕疵，那就是不支持取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> deferred = async &#123;</span><br><span class="line">        KtHttpV3.create(ApiServiceV3::<span class="keyword">class</span>.java)</span><br><span class="line">            .repos(q = <span class="string">&quot;stars:&gt;=10000 language:kotlin&quot;</span>, sort = <span class="string">&quot;stars&quot;</span>)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deferred.invokeOnCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;invokeOnCompletion!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">50L</span>)</span><br><span class="line"></span><br><span class="line">    deferred.cancel()</span><br><span class="line">    println(<span class="string">&quot;Time cancel: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        println(deferred.await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Time exception: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Catch exception:<span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Time total: <span class="subst">$&#123;System.currentTimeMillis() - start&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line">    suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>) <span class="comment">// ①</span></span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">Time cancel: <span class="number">536</span>   <span class="comment">// ②</span></span><br><span class="line">Request success!   <span class="comment">// ③</span></span><br><span class="line">invokeOnCompletion!</span><br><span class="line">Time exception: <span class="number">3612</span>  <span class="comment">// ④</span></span><br><span class="line">Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine&#123;Cancelled&#125;@6043cd28</span><br><span class="line">Time total: <span class="number">3612</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>在 <code>main</code> 函数当中，在 <code>async</code> 里调用了挂起函数，接着 <code>50ms</code> 过去后，就去尝试取消协程。</li>
<li>这段代码中一共有三处地方需要注意：
<ul>
<li>结合<em>注释①、③</em> 一起分析，即使调用了 <code>deferred.cancel()</code>，网络请求仍然会继续执行。根据“<code>Catch exception:</code>”输出的异常信息，发现当 <code>deferred</code> 被取消以后还去调用 <code>await()</code> 的时候，会抛出异常。</li>
<li>对比<em>注释②、④</em> ，<code>deferred.await()</code> 虽然会抛出异常，但是它却耗时 <em>3000ms</em>。虽然 <code>deferred</code> 被取消了，但是当调用 <code>await()</code> 的时候，它并不会马上就抛出异常，而是会等到内部的网络请求执行结束以后，才抛出异常，在此之前都会被挂起。</li>
<li>综上所述，当使用 <code>suspendCoroutine&#123;&#125;</code> 来实现挂起函数的时候，<strong>默认情况下是不支持取消的</strong>。那么，具体该怎么做呢？其实也很简单，就是使用 <code>Kotlin</code> 官方提供的另一个 <code>API：</code> <strong><code>suspendCancellableCoroutine&#123;&#125;</code></strong>。</li>
</ul>
</li>
</ol>
<h4><a href="#4-使用-suspendcancellablecoroutine-实现-await-函数" class="header-anchor">#</a><span id="4-使用-suspendcancellablecoroutine-实现-await-函数">4. 使用 suspendCancellableCoroutine{} 实现 await 函数</span></h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> KtCall<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T =</span><br><span class="line"><span class="comment">//            变化1</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">    suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> call = call(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request success!&quot;</span>)</span><br><span class="line">                continuation.resume(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Request fail!：<span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">                continuation.resumeWithException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//            变化2</span></span><br><span class="line"><span class="comment">//              ↓</span></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            println(<span class="string">&quot;Call cancelled!&quot;</span>)</span><br><span class="line">            call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当使用 <code>suspendCancellableCoroutine&#123;&#125;</code> 的时候，可以往 <code>continuation</code> 对象上面设置一个监听：<code>invokeOnCancellation&#123;&#125;</code>，它代表当前的协程被取消了，这时候，只需要将 <code>OkHttp</code> 的 <code>call</code> 取消即可。<br>
这样一来，<code>main()</code> 函数就能保持不变，得到的输出结果却大不相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//suspendCoroutine结果：</span></span><br><span class="line"></span><br><span class="line">Time cancel: <span class="number">536</span>   </span><br><span class="line">Request success!   </span><br><span class="line">invokeOnCompletion!</span><br><span class="line">Time exception: <span class="number">3612</span>  <span class="comment">// ①</span></span><br><span class="line">Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine&#123;Cancelled&#125;@6043cd28</span><br><span class="line">Time total: <span class="number">3612</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//suspendCancellableCoroutine结果：</span></span><br><span class="line"></span><br><span class="line">Call cancelled!</span><br><span class="line">Time cancel: <span class="number">464</span></span><br><span class="line">invokeOnCompletion!</span><br><span class="line">Time exception: <span class="number">466</span>  <span class="comment">// ②</span></span><br><span class="line">Catch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine&#123;Cancelled&#125;@6043cd28</span><br><span class="line">Time total: <span class="number">466</span></span><br><span class="line">Request fail!：java.io.IOException: Canceled  <span class="comment">// ③</span></span><br></pre></td></tr></table></figure>
<p>对比<em>注释①、②</em> ，可以发现，后者是会立即响应协程取消事件的，所以当代码执行到 <code>deferred.await()</code> 的时候，会立即抛出异常，而不会挂起很长时间。另外，通过<em>注释③</em> 这里的结果，也可以发现，<code>OkHttp</code> 的网络请求确实被取消了。<br>
所以，可以得出一个结论，使用 <code>suspendCancellableCoroutine&#123;&#125;</code>，可以避免不必要的挂起，比如例子中的 <code>deferred.await()</code>；另外也可以节省计算机资源，因为这样可以避免不必要的协程任务，比如这里被成功取消的网络请求。<br>
到这里，解法一就已经完成了。这种方式并没有改动 <code>KtHttp</code> 的源代码，而是以扩展函数来实现的。</p>
<h1><a href="#七-参考文章" class="header-anchor">#</a><span id="七-参考文章">七、参考文章</span></h1>
<ol>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.github.com/en/rest/search?apiVersion=2022-11-28#search-repositories">Github公共搜索API</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.github.com/en/search-github/searching-on-github/searching-topics">Github公共搜索关键字说明</a></p>
</li>
</ol>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-04-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Job/" title="Job">Job </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Deferred/" title="Deferred">Deferred </a><i class="fa fa-tag"></i><a class="tag" href="/tags/CoroutineContext/" title="CoroutineContext">CoroutineContext </a><span class="leancloud_visitors"></span><span>大约13743个字, 45分钟48秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2021/04/15/kotlin学习系列十/,Puppet,kotlin学习系列十：协程二,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>