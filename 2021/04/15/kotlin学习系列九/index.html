<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列九：协程一 · Puppet</title><meta name="description" content="一、前言
二、协程基本概念

1. 什么是协程Coroutine
2. 协程调试

1. 协程 VM 参数
2. 断点调试协程




三、launch 启动协程

1. luanch启动协程示例
2. 设置线程休眠原因
3. launch源码简单分析


四、 runBlocking 启动协程

"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列九：协程一</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-%E5%8D%8F%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">二、协程基本概念</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8Bcoroutine">1. 什么是协程<code>Coroutine</code></a></li>
<li><a href="#2-%E5%8D%8F%E7%A8%8B%E8%B0%83%E8%AF%95">2. 协程调试</a>
<ul>
<li><a href="#1-%E5%8D%8F%E7%A8%8B-vm-%E5%8F%82%E6%95%B0">1. 协程 <code>VM</code> 参数</a></li>
<li><a href="#2-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B">2. 断点调试协程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-launch-%E5%90%AF%E5%8A%A8%E5%8D%8F%E7%A8%8B">三、launch 启动协程</a>
<ul>
<li><a href="#1-luanch%E5%90%AF%E5%8A%A8%E5%8D%8F%E7%A8%8B%E7%A4%BA%E4%BE%8B">1. <code>luanch</code>启动协程示例</a></li>
<li><a href="#2-%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E5%8E%9F%E5%9B%A0">2. 设置线程休眠原因</a></li>
<li><a href="#3-launch%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90">3. <code>launch</code>源码简单分析</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-runblocking-%E5%90%AF%E5%8A%A8%E5%8D%8F%E7%A8%8B">四、 runBlocking 启动协程</a>
<ul>
<li><a href="#1-%E5%90%AF%E5%8A%A8%E7%A4%BA%E4%BE%8B">1. 启动示例</a></li>
<li><a href="#2-%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E5%8F%8A%E5%AF%B9%E6%AF%94">2. 源码简单分析及对比</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0-kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83">五、挂起函数–Kotlin协程的核心</a>
<ul>
<li><a href="#1-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E4%BC%98%E5%8A%BF">1. 挂起函数优势</a></li>
<li><a href="#2-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-suspend">2. 深入理解 suspend</a></li>
<li><a href="#3-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0">3. 协程与挂起函数</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">六、参考文章</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 协程基本概念、协程调试、launch、runBlocking、挂起函数</strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">朱涛老师</a>讲解的<code>Kotlin</code>系列的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程二</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/" title="kotlin学习系列十一：协程三">kotlin学习系列十一：协程三</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-协程基本概念" class="header-anchor">#</a><span id="二-协程基本概念">二、协程基本概念</span></h1>
<p>协程源码库：<a target="_blank" rel="noopener" href="https://github.com/hltj/kotlinx.coroutines-cn">https://github.com/hltj/kotlinx.coroutines-cn</a></p>
<h2><a href="#1-什么是协程coroutine" class="header-anchor">#</a><span id="1-什么是协程coroutine">1. 什么是协程<code>Coroutine</code></span></h2>
<p><strong>协程</strong> 通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程 <em>（甚至不同机器）</em> 上调度执行，而代码则保持如同顺序执行一样简单</p>
<p><strong>协程</strong> 就像 <strong>非常轻量级的线程</strong>。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，<strong>一个线程中可以创建任意个协程</strong></p>
<p><strong>协程</strong> 很重要的一点就是当它挂起的时候，<strong>不会阻塞其他线程</strong>。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，<strong>协程代码的程序流是顺序的</strong>，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束</p>
<ul>
<li>协程是可以由程序自行控制 <strong>挂起、恢复</strong> 的程序</li>
<li>协程可以用来实现多任务的协作执行</li>
<li>协程可以用来解决异步任务控制流的灵活转移</li>
<li>协程可以让异步代码同步化</li>
<li>协程可以降低异步程序的设计复杂度</li>
</ul>
<h2><a href="#2-协程调试" class="header-anchor">#</a><span id="2-协程调试">2. 协程调试</span></h2>
<p>想要学好 <code>Kotlin</code> 协程，掌握它的调试技巧很重要。一般来说，我们可以通过两种方法来进行调试：设置 <code>VM</code> 参数、断点调试。</p>
<h3><a href="#1-协程-vm-参数" class="header-anchor">#</a><span id="1-协程-vm-参数">1. 协程 <code>VM</code> 参数</span></h3>
<p>只需要将 <code>VM</code> 参数设置成 <strong><code>-Dkotlinx.coroutines.debug</code></strong>，当我们在 <code>log</code> 当中打印“<code>Thread.currentThread().name</code>”的时候，如果当前代码是运行在协程当中的，则打印信息就会携带协程的相关信息</p>
<p>设置方法如下图所示，先打开<code>Run/Debug Configuration</code>窗口</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_vm_params_set1.png" alt></p>
<p>然后在该窗口中的<code>VM</code>框中添加<code>-Dkotlinx.coroutines.debug</code>即可。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_vm_params_set2.png" alt></p>
<p>添加成功后，示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不必关心代码逻辑，关心输出结果即可</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine started:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After launch:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">After launch:main</span></span><br><span class="line"><span class="comment">Coroutine started:DefaultDispatcher-worker-1 @coroutine#1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当代码处于协程当中的时候，“<code>Thread.currentThread().name</code>”是会带上协程相关的信息的，这里的“<code>@coroutine#1</code>”就代表了 <code>launch</code> 创建的协程。</p>
<h3><a href="#2-断点调试协程" class="header-anchor">#</a><span id="2-断点调试协程">2. 断点调试协程</span></h3>
<p>除了设置 <code>VM</code> 参数之外，还可以直接使用 <code>IDE</code> 的调试功能，直接以打断点的形式来调试协程。具体来说，主要以下几个注意事项：<br>
第一步，将 <code>Android Studio</code> 升级到最新版本，目前我使用的版本是 <code>Android Studio Dolphin | 2021.3.1 Patch 1</code> 版本。<br>
第二步，确保 <code>IDE</code> 自带的 <code>Kotlin</code> 编译器插件版本号大于 <em>1.4</em> ，目前我使用的是 <em>1.7.20</em> 。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_debug_info_pre.png" alt></p>
<p>第三步，为协程代码打断点，并且右击断点处，勾选 <code>suspend</code>、<code>All</code>，这代表了断点将会对协程生效。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_debug_info_point.png" alt></p>
<p>第四步，直接进行调试，当程序停留到断点处以后，就需要确保协程调试窗口已经被开启了，如下图所示，选择对应选项打开协程调试窗口</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_debug_info_window.png" alt></p>
<p>最后是协程调试窗口：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_debug_info_final.png" alt></p>
<p>在这个专属的协程调试窗口当中，可以看到很多有用的协程信息，包括：</p>
<ul>
<li>当前协程的名字，这里是“<code>coroutine#1</code>”；</li>
<li>当前协程运行在哪个线程之上，这里是“<code>DefaultDispatcher-worker-1</code>”；</li>
<li>当前协程的运行状态，这里是“<code>RUNNING</code>”；</li>
<li>当前协程的“创建调用栈”。</li>
</ul>
<p>通过调试，我们可以真真切切地看到，我们用 <code>launch</code> 创建了一个协程，“<code>coroutine#1</code>”，这个协程是运行在“<code>DefaultDispatcher-worker-1</code>”这个线程之上的</p>
<h1><a href="#三-launch-启动协程" class="header-anchor">#</a><span id="三-launch-启动协程">三、launch 启动协程</span></h1>
<p>可以把协程想象成了更加轻量的线程。线程的启动方式我们都知道，也就是 <code>new Thread()</code>、或者是 <code>thread&#123;&#125;</code>。那么，如何才能启动一个真正的协程呢？</p>
<h2><a href="#1-luanch启动协程示例" class="header-anchor">#</a><span id="1-luanch启动协程示例">1. <code>luanch</code>启动协程示例</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* delay 函数的定义</span></span><br><span class="line"><span class="comment">     注意这个关键字</span></span><br><span class="line"><span class="comment">          ↓                                            */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅用于研究，生产环境不建议使用GlobalScope</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="comment">// ②</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><em>注释①</em> ，<code>GlobalScope.launch&#123;&#125;</code>，它是一个高阶函数，它的作用就是启动一个协程。<code>GlobalScope</code> 是 <code>Kotlin</code> 官方为我们提供的“协程作用域”，这涉及到协程的“结构化并发”理念。</li>
<li><em>注释②</em> ，<code>delay()</code>，它的作用就是字面上的意思，“延迟”。以上代码中，我们是延迟了 <em>1</em> 秒。从 <code>delay()</code> 的函数签名这里可以发现，它的定义跟普通的函数不太一样，它多了一个“<code>suspend</code>”关键字，这代表了它是一个挂起函数。而这也就意味着，<code>delay</code> 将会拥有“挂起和恢复”的能力。<code>delay()</code> 是非阻塞，既然它拥有“挂起和恢复”的能力，那么它肯定能实现非阻塞</li>
<li><em>注释③</em> ，它的作用是让当前线程休眠 <em>2</em> 秒钟。很多协程的初学者都会很好奇，为什么上面的代码当中需要一个 <code>Thread.sleep(2000L)</code> 呢？它的作用是什么？</li>
</ol>
<h2><a href="#2-设置线程休眠原因" class="header-anchor">#</a><span id="2-设置线程休眠原因">2. 设置线程休眠原因</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">无</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>如上代码所示，删掉线程休眠的代码以后，协程代码就无法正常工作了。为了弄清楚这个问题，可以做一个类比，暂时先将协程代码改成如下线程代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//              守护线程</span></span><br><span class="line">    <span class="comment">//                 ↓</span></span><br><span class="line">    thread(isDaemon = <span class="literal">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">无</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，将代码改为线程以后，程序仍然没有输出任何结果。而这里，创建的 <code>Thread</code> 其实是一个“守护线程”。<strong>守护线程，就意味着当主线程结束的时候，它也会跟着被销毁</strong>。所以前面用 <code>GlobalScope</code> 创建的协程之所以不会正常运行，也是因为类似的原因。为了让问题能够更明确地暴露出来，为之前的代码增加一些日志：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine started!&quot;</span>)</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Process end!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果；</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据输出结果，我们可以推测出：<strong>通过 <code>launch</code> 创建的协程还没来得及开始执行，整个程序就已经结束了</strong> 。相应的，也就能推测出，之前案例中 <strong><code>Thread.sleep(2000)</code> 的作用就是为了不让主线程退出</strong> 。</p>
<h2><a href="#3-launch源码简单分析" class="header-anchor">#</a><span id="3-launch源码简单分析">3. <code>launch</code>源码简单分析</span></h2>
<p>协程代码特殊的一个行为模式，那就是：<strong>它的代码不是按照顺序执行的</strong> 。为了让这一点更加明显，我们再增加一些日志：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;                <span class="comment">// 1</span></span><br><span class="line">        println(<span class="string">&quot;Coroutine started!&quot;</span>)   <span class="comment">// 2</span></span><br><span class="line">        delay(<span class="number">1000L</span>)                    <span class="comment">// 3</span></span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)         <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After launch!&quot;</span>)            <span class="comment">// 5</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>)                 <span class="comment">// 6</span></span><br><span class="line">    println(<span class="string">&quot;Process end!&quot;</span>)             <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">After launch!</span></span><br><span class="line"><span class="comment">Coroutine started!</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">Process end!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据这个程序运行结果，以上的协程代码运行顺序是 <em>1、5、6、2、3、4、7</em>。也就是说，<code>launch</code> 并不会阻塞线程的执行，甚至，我们可以认为 <code>launch()</code> 当中 <code>Lambda</code> 一定就是在函数调用之后才执行的。<br>
通过 <code>launch</code> 启动一个协程以后，并没有让协程为我们返回一个执行结果，这其实就是典型的 <code>Fire-and-forget</code><em>(即发即弃，只发送消息,不关心消息是否发送成功)</em> 的应用场景。打个比方，<code>launch</code> 一个协程任务，就像猎人射箭一样。</p>
<p><code>launch</code> 和射箭，有几个共同点：</p>
<ul>
<li>箭一旦射出去了，目标就无法再被改变；协程一旦被 <code>launch</code>，那么它当中执行的任务也不会被中途改变。</li>
<li>箭如果命中了猎物，猎物也不会自动送到我们手上来；<code>launch</code> 的协程任务一旦完成了，即使有了结果，也没办法直接返回给调用方。</li>
</ul>
<p>那么，<code>launch</code> 为什么无法将结果返回给调用方呢？ <code>launch</code> 函数的源代码给出了答案，这个函数的返回值是一个 <code>Job</code>，它其实代表的是协程的句柄 <em>(Handle，句柄是对资源的抽象引用）</em>，它并不能为返回协程的执行结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p><code>CoroutineScope.launch()</code>，代表了 <code>launch</code> 其实是一个扩展函数，而它的“扩展接收者类型”是 <code>CoroutineScope</code>。这就意味着，<code>launch()</code> 会等价于 <code>CoroutineScope</code> 的成员方法。而要调用 <code>launch()</code> 来启动协程，就必须要先拿到 <code>CoroutineScope</code> 的对象。前面的案例，使用的 <code>GlobalScope</code>，其实就是 <code>Kotlin</code> 官方提供的一个 <code>CoroutineScope</code> 对象，方便开发者直接启动协程。</p>
</li>
<li>
<p>是第一个参数：<code>CoroutineContext</code>，它代表了协程的上下文，它的默认值是 <code>EmptyCoroutineContext</code>，如果不传这个参数，默认就会使用 <code>EmptyCoroutineContext</code>。一般来说，也可以传入 <code>Kotlin</code> 官方提供的 <code>Dispatchers</code>，来指定协程运行的线程池。协程上下文，是协程当中非常关键的元素。</p>
</li>
<li>
<p>是第二个参数：<code>CoroutineStart</code>，它代表了协程的启动模式。如果不传这个参数，它会默认使用 <code>CoroutineStart.DEFAULT</code>。<code>CoroutineStart</code> 其实是一个枚举类，一共有：<code>DEFAULT、LAZY、ATOMIC、UNDISPATCHED</code>。最常使用的就是 <code>DEFAULT、LAZY</code>，它们分别代表：立即执行、懒加载执行。</p>
</li>
<li>
<p>最后一个参数，是一个函数类型的 <code>block</code>，它的类型是<code>“suspend CoroutineScope.() -&gt; Unit”</code>，这个类型看起来有点复杂，先以“<code>(Int) -&gt; Double</code>”这个函数类型开始：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func1</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func1</span><br></pre></td></tr></table></figure>
<p>上面的代码很好理解，“<code>(Int) -&gt; Double</code>”代表了参数类型是 <code>Int</code>，返回值类型是 <code>Double</code> 的函数，<code>::func1</code> 这里，使用了函数引用的语法。接下来，再来看看“<code>CoroutineScope.(Int) -&gt; Double</code>”意味着什么：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">func2</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f2: CoroutineScope.(<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = CoroutineScope::func2</span><br></pre></td></tr></table></figure>
<p>很明显，在函数类型前面增加了一个接收者类型后，它的含义就变成了：这个函数应该是 <code>CoroutineScope</code> 类的成员方法或是扩展方法，并且，它的参数类型必须是 <code>Int</code>，返回值类型必须是 <code>Double</code>。那么，“<code>suspend (Int) -&gt; Double</code>”这个类型代表了什么呢？来看个例子：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">func3</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f3: <span class="keyword">suspend</span> (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func3</span><br></pre></td></tr></table></figure>
<p>有了前面的基础，很容易就能理解，“<code>suspend (Int) -&gt; Double</code>”，其实就代表了一个“挂起函数”，同时它的参数类型是 <code>Int</code>，返回值类型是 <code>Double</code>。</p>
<p>到这里，还可以进一步推理，请看下面的代码：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">func4</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f4: <span class="keyword">suspend</span> CoroutineScope.(<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = CoroutineScope::func4</span><br></pre></td></tr></table></figure>
<p>这时候，对于“<code>suspend CoroutineScope.(Int) -&gt; Double</code>”这个函数类型，它首先应该是一个“挂起函数”，同时，它还应该是 <code>CoroutineScope</code> 类的成员方法或是扩展方法，并且，它的参数类型必须是 <code>Int</code>，返回值类型必须是 <code>Double</code>。</p>
<p>那么现在，回头再看 <code>launch()</code> 函数的第三个参数“<code>suspend CoroutineScope.() -&gt; Unit</code>”，其实就能轻松分析出它的类型。</p>
</li>
</ol>
<h1><a href="#四-runblocking-启动协程" class="header-anchor">#</a><span id="四-runblocking-启动协程">四、 runBlocking 启动协程</span></h1>
<h2><a href="#1-启动示例" class="header-anchor">#</a><span id="1-启动示例">1. 启动示例</span></h2>
<p><code>async</code>，是在很多其他编程语言都存在的一种协程模式，比如 <code>C#</code>。在 <code>Kotlin</code> 当中，可以使用 <code>async&#123;&#125;</code> 创建协程，并且还能通过它返回的句柄拿到协程的执行结果。看个简单的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;In runBlocking:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred: Deferred&lt;String&gt; = async &#123;</span><br><span class="line">        println(<span class="string">&quot;In async:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@async</span> <span class="string">&quot;Task completed!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;After async:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = deferred.await()</span><br><span class="line">    println(<span class="string">&quot;Result is: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">In runBlocking:main @coroutine#1</span></span><br><span class="line"><span class="comment">After async:main @coroutine#1 // 注意，它比“In async”先输出</span></span><br><span class="line"><span class="comment">In async:main @coroutine#2</span></span><br><span class="line"><span class="comment">Result is: Task completed!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>上面的代码中，我们直接使用 <code>runBlocking</code> 来实现了 <code>main</code> 函数。</li>
<li>由于 <code>runBlocking</code> 的最后一个参数的类型是“<code>suspend CoroutineScope.() -&gt; T</code>”，因此在 <code>Lambda</code> 当中已经有了 <code>CoroutineScope</code>，所以我们可以直接在 <code>runBlocking</code> 当中，用 <code>async</code> 启动一个协程。</li>
<li>从程序的输出结果可以看到：
<ul>
<li>存在两个协程，<code>runBlocking</code> 启动的叫做“<code>coroutine#1</code>”；<code>async</code> 启动的叫做“<code>coroutine#2</code>”。</li>
<li><code>async</code> 启动协程以后，它也不会阻塞当前程序的执行流程，因为：“<code>After async</code>”在“<code>In async</code>”的前面就已经输出了。</li>
</ul>
</li>
<li><code>async&#123;&#125;</code>的返回值是一个 <code>Deferred</code> 对象，通过调用它的 <code>await()</code> 方法，就可以拿到协程的执行结果。对比前面 <code>launch</code> 举的“射箭”的例子，这里的 <code>async</code>，就更加像是“钓鱼”： 在钓鱼的时候，我们手里的鱼竿，就有点像是 <code>async</code> 当中的 <code>Deferred</code> 对象。只要手里有这根鱼竿，一旦有鱼儿上钩了，我们就可以直接拿到结果。</li>
</ol>
<h2><a href="#2-源码简单分析及对比" class="header-anchor">#</a><span id="2-源码简单分析及对比">2. 源码简单分析及对比</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 不同点1</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;&#125; <span class="comment">// 不同点2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span> <span class="comment">// 不同点1</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Deferred&lt;T&gt; &#123;&#125; <span class="comment">// 不同点2</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>从上面的代码中，可以发现 <code>launch</code> 和 <code>async</code> 的两个不同点：</p>
<ol>
<li>一个是 <code>block</code> 的函数类型，前者的返回值类型是 <code>Unit</code>，后者则是泛型 <code>T</code>；</li>
<li>另外一个不同点在返回值上，前者返回值类型是 <code>Job</code>，后者返回值类型是 <code>Deferred</code>。而 <code>async</code> 可以返回协程执行结果的原因也在于此</li>
</ol>
<p>这里，借用朱涛老师的动图，来演示程序整体的执行流程：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_continuation_flow.gif" alt></p>
<h1><a href="#五-挂起函数kotlin协程的核心" class="header-anchor">#</a><span id="五-挂起函数kotlin协程的核心">五、挂起函数–Kotlin协程的核心</span></h1>
<p><code>Kotlin</code> 协程最大的优势，就在于它的<strong>挂起函数</strong>。虽然很多编程语言都有协程的特性，但目前为止，只有 <code>Kotlin</code> 独树一帜，引入了“挂起函数”的概念。另外尽管有些语言的协程底层，也存在“挂起恢复”的概念，但是将这一概念直接暴露给开发者，直接用于修饰一个函数的，<code>Kotlin</code> 算是做了一种创新。</p>
<h2><a href="#1-挂起函数优势" class="header-anchor">#</a><span id="1-挂起函数优势">1. 挂起函数优势</span></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line">getUserInfo(<span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如上是一段简单的<code>Java</code>代码，在这段代码中，发起了一个异步请求，从服务端查询用户的信息，通过 <code>CallBack</code> 返回 <code>response</code>。这样的代码看起来没什么问题，平时我们写代码的时候也经常写类似的代码。不过实际的商业项目不可能这么简单，有的时候，可能需要连续执行几个异步任务，比如说，查询用户信息 --&gt; 查找该用户的好友列表 --&gt; 拿到好友列表后，查找该好友的动态。这样一来，代码就难免会往下面这个方向发展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line">getUserInfo(<span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            getFriendList(user, <span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String friendList)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (friendList != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(friendList);</span><br><span class="line">                        getFeedList(friendList, <span class="keyword">new</span> <span class="title class_">CallBack</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String feed)</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (feed != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    System.out.println(feed);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如上的代码模式就是 <strong>回调地狱</strong>。给它取这个名字是有原因的，以上代码存在诸多缺陷：<strong>可读性差、扩展性差、维护性差，极易出错</strong>！想象一下，如果让你基于以上代码再扩展出“超时取消”“出错重试”“进度展示”等相关功能，你会不会觉得头疼？所以这时候，就该轮到 <code>Kotlin</code> 协程出场了。用协程的挂起函数，来重构上面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = getUserInfo()</span><br><span class="line"><span class="keyword">val</span> friendList = getFriendList(user)</span><br><span class="line"><span class="keyword">val</span> feedList = getFeedList(friendList)</span><br></pre></td></tr></table></figure>
<p>以极简代码实现上述回调地狱，这就是 Kotlin 协程的魅力：<strong>以同步的方式完成异步任务</strong>。注意，以上代码之所以能写成类似同步的方式，关键还是在于 <code>getUserInfo()</code>、<code>getFriendList()</code>、<code>getFeedList()</code> 这三个请求函数的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delay(1000L)用于模拟网络请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFriendList</span><span class="params">(user: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tom, Jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起函数</span></span><br><span class="line"><span class="comment">// ↓</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFeedList</span><span class="params">(list: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;FeedList..&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>从以上代码中，可以看到，所谓的挂起函数，其实就是比普通的函数多了一个 <code>suspend</code> 关键字。如果去掉这个 <code>suspend</code> 关键字，所有的函数都会变成普通函数。</li>
<li>代码中的 <code>withContext(Dispatchers.IO)</code>，作用是控制协程执行的线程池</li>
</ol>
<p>实际上，挂起函数最神奇的地方，就在于它的挂起和恢复功能。从字面上看，<code>suspend</code> 这个词就是“挂起”的意思，而它既然能被挂起，自然就还可以被恢复。它们两个一般是成对出现的。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_user_flow.png" alt></p>
<p>如上图所示，描述了挂起函数整体的执行流程。</p>
<p><strong>说明：</strong></p>
<ul>
<li>
<p>在 <code>IntelliJ</code> 当中，挂起函数会有一个特殊的箭头标记，这样就便于我们分辨出当前调用的函数是否是普通函数。调用挂起函数的位置，叫做是<strong>挂起点</strong></p>
</li>
<li>
<p>表面上看起来是同步的代码，实际上也涉及到了线程切换，一行代码，切换了两个线程。</p>
<ul>
<li>比如“<code>val user = getUserInfo(</code>)”，其中“=”左边的代码运行在主线程，而“=”右边的代码运行在 <code>IO</code> 线程。</li>
<li>每一次从主线程到 <code>IO</code> 线程，都是一次协程挂起。</li>
<li>每一次从 <code>IO</code> 线程到主线程，都是一次协程恢复。</li>
</ul>
</li>
<li>
<p>挂起和恢复，这是<strong>挂起函数特有的能力</strong>，普通函数是不具备的。</p>
</li>
<li>
<p>挂起，只是将程序执行流程转移到了其他线程，主线程不会被阻塞。以上代码运行在 <code>Android</code> 系统， <code>App</code> 仍然可以响应用户的操作，主线程并不繁忙。</p>
</li>
</ul>
<h2><a href="#2-深入理解-suspend" class="header-anchor">#</a><span id="2-深入理解-suspend">2. 深入理解 suspend</span></h2>
<p><strong><code>Kotlin</code> 协程做到一行代码切换两个线程</strong>，实现方式都藏在了挂起函数的 <code>suspend</code> 关键字里。</p>
<p><code>suspend</code>，是 <code>Kotlin</code> 当中的一个关键字，它主要的作用是用于定义“挂起函数”。同样的一个函数，加上 <code>suspend</code> 修饰以后，它的函数类型就会发生改变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func1</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func1与func3唯一的区别</span></span><br><span class="line"><span class="comment">   ↓                         */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">func3</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">    <span class="keyword">return</span> num.toDouble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func1</span><br><span class="line"><span class="keyword">val</span> f2: <span class="keyword">suspend</span> (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func3</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f3: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func3 <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">val</span> f4: <span class="keyword">suspend</span> (<span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> = ::func1 <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>由以上代码可知，同样是 <code>Int</code> 作为参数，<code>Double</code> 作为返回值，有没有 <code>suspend</code> 修饰，它们两者的函数类型是不一样的。“<code>suspend (Int) -&gt; Double</code>”与“<code>(Int) -&gt; Double</code>”并不能互相赋值。因此，<code>Kotlin</code> 的函数类型，除了跟参数、返回值、接收者相关，还跟 <code>suspend</code> 相关。</p>
<p><em>小<code>tips</code>： <code>Compose</code>中的 <code>@Composable</code> 跟 <code>suspend</code> 一样，也可以改变一个函数的类型</em></p>
<p>那么，<code>suspend</code> 修饰的函数，到底会变成什么类型？将挂起函数与前面“回调地狱的代码”放在一起对比<br>
<img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_flow_1.webp" alt></p>
<p>其实，<strong>挂起函数的本质，就是 <code>Callback</code></strong>。</p>
<p>虽然写出来的挂起函数并没有任何 <code>Callback</code> 的逻辑，但是，当 <code>Kotlin</code> 编译器检测到 <code>suspend</code> 关键字修饰的函数以后，就会自动将挂起函数转换成带有 <code>CallBack</code> 的函数。</p>
<p>将上面的挂起函数反编译成 <code>Java</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                              Continuation 等价于 CallBack</span></span><br><span class="line"><span class="comment">//                                         ↓         </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">getUserInfo</span><span class="params">(Continuation $completion)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从反编译的结果来看，挂起函数确实变成了一个带有 <code>CallBack</code> 的函数，只是这个 <code>CallBack</code> 换了个名字，叫做 <code>Continuation</code>。<code>Continuation</code> 在 <code>Kotlin</code> 中的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      相当于 CallBack的onSuccess   结果   </span></span><br><span class="line"><span class="comment">//                 ↓                 ↓</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CallBack</span> &#123;</span><br><span class="line">    void onSuccess(String response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上定义，<code>Continuation</code> 本质上也就是一个带有泛型参数的 <code>CallBack</code>。这个“从挂起函数转换成 <code>CallBack</code> 函数”的过程，被叫做是 <code>CPS</code> 转换*（Continuation-Passing-Style Transformation）*。<code>Kotlin</code> 官方要将 <code>CallBack</code> 命名为 <code>Continuation</code> 的原因：<code>Continuation</code> 道出了它的实现原理。<br>
以下动画用来演示一下挂起函数在 <code>CPS</code> 转换过程中，函数签名的变化：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_flow_2.gif" alt></p>
<p>在上面 <code>CPS</code> 转换的过程中，函数的类型发生了变化：“<code>suspend ()-&gt;String</code>” 变成了 “<code>(Continuation)-&gt; Any?</code>”。<br>
而这就意味着，如果在 <code>Java</code> 中访问一个 <code>Kotlin</code> 挂起函数 <code>getUserInfo()</code>，会看到 <code>Java</code> 里的 <code>getUserInfo()</code> 的类型是“<code>(Continuation)-&gt; Object</code>” <em>（即接收 <code>Continuation</code> 为参数，返回值是 <code>Object</code>）</em>。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_flow_5.png" alt></p>
<p><strong>那么 <code>Continuation</code> 到底是什么？</strong> 只需要把握住 <code>Continuation</code> 的词源 <code>Continue</code> 即可。<code>Continue</code> 是“继续”的意思，<code>Continuation</code> 则是“接下来要做的事情”。放到程序中，<code>Continuation</code> 就代表了，“程序继续运行下去需要执行的代码”，“接下来要执行的代码”，或者是“剩下的代码”。</p>
<p>就以上面的代码为例，当程序运行 <code>getUserInfo()</code> 这个挂起函数的时候，它的“<code>Continuation</code>”则是下图红框的代码：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_flow_6.webp" alt></p>
<p>这样理解了 <code>Continuation</code> 以后，<code>CPS</code> 也就容易理解了，它其实就是<strong>将程序接下来要执行的代码进行传递的一种模式</strong>。<br>
<strong>而 <code>CPS</code> 转换，就是将原本的同步挂起函数转换成 <code>CallBack</code> 异步代码的过程</strong>。这个转换是编译器在背后做的，程序员对此并无感知。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_flow_3.gif" alt></p>
<p>根据这个动图，可以看到当程序执行到 <code>getUserInfo() </code>的时候，剩下的未执行代码都被一起打包了起来，以 <code>Continuation</code> 的形式，传递给了 <code>getUserInfo()</code> 的 <code>Callback</code> 回调当中。当然，这种方式其实只是大致模拟了挂起函数的 <code>CPS</code> 转换过程，实际细节要远比这个复杂。</p>
<p>以上就是 <code>Kotlin</code> 挂起函数的核心原理，它的挂起和恢复，其实也是通过 <code>CPS</code> 转换来实现的。</p>
<p>再来看看之前的协程思维模型：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/kotlin_con_flow_4.gif" alt></p>
<p>所以，协程之所以是非阻塞，是因为它支持“挂起和恢复”；<br>
而挂起和恢复的能力，主要是源自于“挂起函数”；<br>
而挂起函数是由 <code>CPS</code> 实现的，其中的 <code>Continuation</code>，本质上就是 <code>Callback</code>。</p>
<h2><a href="#3-协程与挂起函数" class="header-anchor">#</a><span id="3-协程与挂起函数">3. 协程与挂起函数</span></h2>
<p>协程和挂起函数虽然都是支持挂起和恢复的，但它们不是一种东西。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getUserInfo() <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BoyCoder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，直接在 <code>main</code> 函数当中调用了 <code>getUserInfo()</code> 这个挂起函数，这时候， <code>IDE</code> 会报错：挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用。这个意思也很好理解，对于这样的要求，很容易就能写出下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在协程中调用getUserInfo()</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个挂起函数中调用getUserInfo()</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">anotherSuspendFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = getUserInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>runBlocking</code> 的函数签名：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的第二个参数 <code>block</code> 的类型“<code>suspend CoroutineScope.() -&gt; T</code>”，如此 <code>block</code> 也是一个挂起函数的类型！所以说，虽然“协程和挂起函数”都可以调用“挂起函数”，但是协程的 <code>Lambda</code>，也是挂起函数。所以，它们本质上都是因为“挂起函数可以调用挂起函数”。也就是说，站在目前的阶段来看，可以认为：<strong>挂起和恢复，是协程的一种底层能力；而挂起函数，是这种底层能力的一种表现形式，通过暴露出来的 <code>suspend</code> 关键字，开发者可以在上层，非常方便地使用这种底层能力。</strong></p>
<h1><a href="#六-参考文章" class="header-anchor">#</a><span id="六-参考文章">六、参考文章</span></h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">Kotlin 编程第一课</a></li>
</ol>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-04-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><span class="leancloud_visitors"></span><span>大约6957个字, 23分钟11秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2021/04/15/kotlin学习系列九/,Puppet,kotlin学习系列九：协程一,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>