<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ltt"><title>kotlin学习系列十一：协程三 · Puppet</title><meta name="description" content="一、前言
二、 Channel

1. Channel 是管道
2. Channel 参数解析

1. 案例 1：capacity = UNLIMITED
2. 案例2：capacity = CONFLATED
3. 案例3：onBufferOverflow 用法
4. 案例4：onBufferOv"><meta name="keywords" content="技术博客,Hexo,Android,Linux,HTML,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Puppet</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/puppet16"><i class="fa fa-github"></i></a></li><li><a href="mailto:mailto:2542469086@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Ltt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin学习系列十一：协程三</a></h3></div><div class="post-content"><p><div class="toc">
<!-- toc -->
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一、前言</a></li>
<li><a href="#%E4%BA%8C-channel">二、 Channel</a>
<ul>
<li><a href="#1-channel-%E6%98%AF%E7%AE%A1%E9%81%93">1. Channel 是管道</a></li>
<li><a href="#2-channel-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90">2. Channel 参数解析</a>
<ul>
<li><a href="#1-%E6%A1%88%E4%BE%8B-1capacity-unlimited">1. 案例 1：capacity = UNLIMITED</a></li>
<li><a href="#2-%E6%A1%88%E4%BE%8B2capacity-conflated">2. 案例2：capacity = CONFLATED</a></li>
<li><a href="#3-%E6%A1%88%E4%BE%8B3onbufferoverflow-%E7%94%A8%E6%B3%95">3. 案例3：onBufferOverflow 用法</a></li>
<li><a href="#4-%E6%A1%88%E4%BE%8B4onbufferoverflow-%E7%94%A8%E6%B3%952">4. 案例4：onBufferOverflow 用法2</a></li>
<li><a href="#5-%E6%A1%88%E4%BE%8B5onundeliveredelement-%E4%BD%9C%E7%94%A8">5. 案例5：onUndeliveredElement 作用</a></li>
</ul>
</li>
<li><a href="#3-channel-%E5%85%B3%E9%97%AD%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98">3. Channel 关闭引发的问题</a>
<ul>
<li><a href="#1-produce">1. produce{}</a></li>
<li><a href="#2-receive%E6%96%B9%E6%B3%95">2. receive()方法</a></li>
<li><a href="#3-channelconsumeeach">3. channel.consumeEach {}</a></li>
</ul>
</li>
<li><a href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-channel-%E6%98%AF%E7%83%AD%E7%9A%84">4. 为什么说 Channel 是“热”的？</a></li>
<li><a href="#5-channel-%E7%9A%84%E8%83%BD%E5%8A%9B%E9%83%BD%E6%98%AF%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E5%BE%97%E6%9D%A5%E7%9A%84">5. Channel 的能力都是通过“组合”得来的</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-flow">三、 Flow</a>
<ul>
<li><a href="#1-flow-%E5%B0%B1%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B5%81">1. Flow 就是“数据流”</a></li>
<li><a href="#2-flow-%E7%9A%84%E5%88%9B%E5%BB%BA">2. Flow 的创建</a></li>
<li><a href="#3-flow-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E7%AC%A6">3. Flow 中间操作符</a>
<ul>
<li><a href="#1-flow-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">1. Flow 生命周期</a>
<ul>
<li><a href="#1-onstart">1. onStart</a></li>
<li><a href="#2-oncompletion">2. onCompletion</a></li>
</ul>
</li>
<li><a href="#2-flow-catch-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">2. Flow catch 处理异常</a></li>
<li><a href="#3-%E5%88%87%E6%8D%A2-contextflowon-launchin">3. 切换 Context：flowOn、launchIn</a></li>
</ul>
</li>
<li><a href="#4-%E4%B8%8B%E6%B8%B8%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C%E7%AC%A6">4. 下游：终止操作符</a></li>
<li><a href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-flow-%E6%98%AF%E5%86%B7%E7%9A%84">5. 为什么说 Flow 是“冷”的？</a></li>
<li><a href="#6-flow-%E5%AE%9E%E8%B7%B5">6. Flow 实践</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-select">四、 select</a>
<ul>
<li><a href="#1-select-%E5%B0%B1%E6%98%AF%E9%80%89%E6%8B%A9%E6%9B%B4%E5%BF%AB%E7%9A%84%E7%BB%93%E6%9E%9C">1. select 就是选择“更快的结果”</a></li>
<li><a href="#2-select-%E5%92%8C-async">2. select 和 async</a></li>
<li><a href="#3-select-%E5%92%8C-channel">3. select 和 Channel</a></li>
<li><a href="#5-select-%E5%AE%9E%E6%88%98">5. select 实战</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><a href="#一-前言" class="header-anchor">#</a><span id="一-前言">一、前言</span></h1>
<ol>
<li>本文主要讲述<strong>Kotlin 协程中的 <code>Channel</code> 以及 <code>Flow</code></strong></li>
<li><em>本文是对<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100103401?tab=catalog">朱涛老师</a>讲解的<code>Kotlin</code>系列的总结笔记</em></li>
<li><strong>Kotlin官网：<a target="_blank" rel="noopener" href="https://kotlinlang.org/">https://kotlinlang.org/</a></strong></li>
<li><strong>Kotlin中文官网：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/">https://www.kotlincn.net/</a></strong></li>
<li><strong>Kotlin源码：<a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></strong></li>
<li>Kotlin 学习系列文章：
<ul>
<li>
<a href="/2020/12/07/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/" title="Kotlin学习系列一：内置类型">kotlin学习系列一：内置类型</a>
</li>
<li>
<a href="/2020/12/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/" title="Kotlin学习系列二：类与接口初解">kotlin学习系列二：类与接口初解</a>
</li>
<li>
<a href="/2021/01/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89/" title="Kotlin学习系列三：表达式">kotlin学习系列三：表达式</a>
</li>
<li>
<a href="/2021/01/22/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B/" title="Kotlin学习系列四：函数进阶">kotlin学习系列四：函数进阶</a>
</li>
<li>
<a href="/2021/02/02/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%94/" title="Kotlin学习系列五：类型进阶">kotlin学习系列五：类型进阶</a>
</li>
<li>
<a href="/2021/03/08/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AD/" title="kotlin学习系列六：泛型">kotlin学习系列六：泛型</a>
</li>
<li>
<a href="/2021/03/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%83/" title="kotlin学习系列七：反射">kotlin学习系列七：反射</a>
</li>
<li>
<a href="/2021/03/23/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%85%AB/" title="kotlin 学习系列八：注解">kotlin学习系列八：注解</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%9D/" title="kotlin学习系列九：协程一">kotlin学习系列九：协程一</a>
</li>
<li>
<a href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">kotlin学习系列十：协程二</a>
</li>
<li>
<a href="/2023/05/25/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/" title="kotlin学习系列十二：协程四">kotlin学习系列十二：协程四</a>
</li>
</ul>
</li>
</ol>
<h1><a href="#二-channel" class="header-anchor">#</a><span id="二-channel">二、 Channel</span></h1>
<p>前面学习的挂起函数、<code>async</code>，它们一次都只能返回一个结果。但在某些业务场景下，往往需要协程返回多个结果，比如微信等软件的 <code>IM</code> 通道接收的消息，或者是手机 <code>GPS</code> 定位返回的经纬度坐标需要实时更新。那么，在这些场景下，我们之前学习的协程知识就无法直接解决了。而 <code>Channel</code>，就是专门用来做这种事情的。</p>
<h2><a href="#1-channel-是管道" class="header-anchor">#</a><span id="1-channel-是管道">1. Channel 是管道</span></h2>
<p><code>Channel</code> 就是一个管道。<code>Channel</code> 这个管道的其中一端，是发送方；管道的另一端是接收方。而管道本身，则可以用来传输数据。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/channel.gif" alt></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 2，在一个单独的协程当中发送管道消息</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it) <span class="comment">// 挂起函数</span></span><br><span class="line">            logX(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 3，在一个单独的协程当中接收管道消息</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;  <span class="comment">// 挂起函数</span></span><br><span class="line">            logX(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#3</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">// 4，程序不会退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>通过运行的结果，首先可以看到的就是：<code>coroutine#2</code>、<code>coroutine#3</code>，这两个协程是交替执行的。这段代码，其实和我们第 13 讲当中提到的“互相协作”的模式是类似的，两个协程会轮流执行。</li>
<li>还可以看出来，<code>Channel</code> 可以跨越不同的协程进行通信。在“<code>coroutine#1</code>”当中创建的 <code>Channel</code>，然后分别在 <code>coroutine#2</code>、<code>coroutine#3</code> 当中使用 <code>Channel</code> 来传递数据。</li>
<li>另外在代码中，还有四个注释：
<ul>
<li><em>注释 1</em>，通过“<code>Channel()</code>”这样的方式，就可以创建一个管道。其中传入的泛型 <code>Int</code>，就代表了这个管道里面传递的数据类型。也就是说这里创建的 <code>Channel</code>，就是用于传递 <code>Int</code> 数据的。</li>
<li><em>注释 2</em>，创建了一个新的协程，然后在协程当中调用了 <code>send()</code> 方法，发送数据到管道里。其中的 <code>send()</code> 方法是一个挂起函数。</li>
<li><em>注释 3</em>，在另一个协程当中，通过遍历 <code>channel</code>，将管道当中的数据都取了出来。这里，使用的是 for 循环。</li>
<li><em>注释 4</em>，通过运行结果，还可以发现一个细节，那就是程序在输出完所有的结果以后，并不会退出。主线程不会结束，整个程序还会处于运行状态。</li>
</ul>
</li>
</ol>
<p>要解决主线程不能退出的问题，只需要加一行代码即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            logX(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close() <span class="comment">// 变化在这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            logX(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<code>channel</code> 其实也是一种协程资源，在用完 <code>channel</code> 以后，如果我们不去主动关闭它的话，是会造成不必要的资源浪费的。在上面的案例中，如果我们忘记调用“<code>channel.close()</code>”，程序将永远不会停下来。</p>
<h2><a href="#2-channel-参数解析" class="header-anchor">#</a><span id="2-channel-参数解析">2. Channel 参数解析</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    capacity: <span class="type">Int</span> = RENDEZVOUS,</span></span></span><br><span class="line"><span class="params"><span class="function">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND,</span></span></span><br><span class="line"><span class="params"><span class="function">    onUndeliveredElement: ((<span class="type">E</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Channel&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上为<code>Channel</code> 的部分源代码，可以看到，当调用“<code>Channel()</code>”的时候，感觉像是在调用一个构造函数，但实际上它却只是一个普通的顶层函数。这个函数带有一个泛型参数 <code>E</code>，另外还有三个参数。</p>
<p>第一个参数，<strong><code>capacity</code></strong>，代表了管道的容量。日常生活中的管道，自身也是有容量的，即使接收方不将数据取走，管道本身也可以存储一些数据。而 <code>Kotlin</code> 的 <code>Channel</code>，在默认情况下是“<code>RENDEZVOUS</code>”，也就代表了 <code>Channel</code> 的容量为 <em>0</em>。</p>
<blockquote>
<p>题外话：<code>RENDEZVOUS</code> 这个单词源自法语。它有约会、碰面的意思，可以理解为“发送方、接收方，不见不散”。</p>
</blockquote>
<p>除此之外，<code>capacity</code> 还有其他几种情况，比如说：</p>
<ul>
<li><code>UNLIMITED</code>，代表了无限容量；</li>
<li><code>CONFLATED</code>，代表了容量为 <em>1</em>，新的数据会替代旧的数据；</li>
<li><code>BUFFERED</code>，代表了具备一定的缓存容量，默认情况下是 <code>64</code>，具体容量由这个 <code>VM</code> 参数决定 “<code>kotlinx.coroutines.channels.defaultBuffer</code>”。</li>
</ul>
<p>第二个参数，<strong><code>onBufferOverflow</code></strong>，也就是指当指定了 <code>capacity</code> 的容量，等管道的容量满了时，<code>Channel</code> 的应对策略是怎么样的。这里，它主要有三种做法：</p>
<ul>
<li><code>SUSPEND</code>，当管道的容量满了以后，如果发送方还要继续发送，就会挂起当前的 <code>send()</code> 方法。由于它是一个挂起函数，所以可以以非阻塞的方式，将发送方的执行流程挂起，等管道中有了空闲位置以后再恢复。</li>
<li><code>DROP_OLDEST</code>，顾名思义，就是丢弃最旧的那条数据，然后发送新的数据；</li>
<li><code>DROP_LATEST</code>，丢弃最新的那条数据。这里要注意，这个动作的含义是丢弃当前正准备发送的那条数据，而管道中的内容将维持不变。</li>
</ul>
<p>下图可以清晰描述上面的几种模式：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/channel1.jpeg" alt></p>
<p>第三个参数，<strong><code>onUndeliveredElement</code></strong>，它其实相当于一个异常处理回调。当管道中的某些数据没有被成功接收的时候，这个回调就会被调用。</p>
<p>为了对这三个参数有个更具体的认识，来看几个代码的案例。</p>
<h3><a href="#1-案例-1capacity-unlimited" class="header-anchor">#</a><span id="1-案例-1capacity-unlimited">1. 案例 1：capacity = UNLIMITED</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(capacity = Channel.Factory.UNLIMITED)</span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close() <span class="comment">// 变化在这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码对比 <em>代码段 1</em>，其实只改动了一点点。在创建 <code>Channel</code> 的时候，设置了 <code>capacity = Channel.Factory.UNLIMITED</code>。不过，通过分析运行的结果，可以发现代码的运行顺序就跟之前完全不一样了。<br>
对于发送方来说，由于 <code>Channel</code> 的容量是无限大的，所以发送方可以一直往管道当中塞入数据，等数据都塞完以后，接收方才开始接收。这跟之前的交替执行是不一样的。</p>
<h3><a href="#2-案例2capacity-conflated" class="header-anchor">#</a><span id="2-案例2capacity-conflated">2. 案例2：capacity = CONFLATED</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(capacity = Channel.Factory.CONFLATED)</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当设置 <code>capacity = CONFLATED</code> 的时候，发送方也会一直发送数据，而且，对于接收方来说，它永远只能接收到最后一条数据。</p>
<h3><a href="#3-案例3onbufferoverflow-用法" class="header-anchor">#</a><span id="3-案例3onbufferoverflow-用法">3. 案例3：onBufferOverflow 用法</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        capacity = <span class="number">1</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如上代码可以运用 <code>onBufferOverflow</code> 与 <code>capacity</code>，来实现 <code>CONFLATED</code> 的效果。可以看出来，其实 <code>capacity = 1</code>, <code>onBufferOverflow = BufferOverflow.DROP_OLDEST</code>，就代表了 <code>capacity = CONFLATED</code>。</p>
<h3><a href="#4-案例4onbufferoverflow-用法2" class="header-anchor">#</a><span id="4-案例4onbufferoverflow-用法2">4. 案例4：onBufferOverflow 用法2</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        capacity = <span class="number">3</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_LATEST</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">            println(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.send(<span class="number">4</span>) <span class="comment">// 被丢弃</span></span><br><span class="line">        println(<span class="string">&quot;Send: 4&quot;</span>)</span><br><span class="line">        channel.send(<span class="number">5</span>) <span class="comment">// 被丢弃</span></span><br><span class="line">        println(<span class="string">&quot;Send: 5&quot;</span>) </span><br><span class="line"></span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send: 1</span></span><br><span class="line"><span class="comment">Send: 2</span></span><br><span class="line"><span class="comment">Send: 3</span></span><br><span class="line"><span class="comment">Send: 4</span></span><br><span class="line"><span class="comment">Send: 5</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可见，<code>onBufferOverflow = BufferOverflow.DROP_LATEST</code> 就意味着，当 <code>Channel</code> 容量满了以后，之后再继续发送的内容，就会直接被丢弃。</p>
<h3><a href="#5-案例5onundeliveredelement-作用" class="header-anchor">#</a><span id="5-案例5onundeliveredelement-作用">5. 案例5：onUndeliveredElement 作用</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 无限容量的管道</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(Channel.UNLIMITED) &#123;</span><br><span class="line">        println(<span class="string">&quot;onUndeliveredElement = <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价这种写法</span></span><br><span class="line"><span class="comment">//    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = &#123; println(&quot;onUndeliveredElement = $it&quot;) &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入三个数据</span></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">        channel.send(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出一个，剩下两个</span></span><br><span class="line">    channel.receive()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消当前channel</span></span><br><span class="line">    channel.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">onUndeliveredElement = 2</span></span><br><span class="line"><span class="comment">onUndeliveredElement = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>onUndeliveredElement</code> 的作用，就是一个回调，当发送出去的 <code>Channel</code> 数据无法被接收方处理的时候，就可以通过 <code>onUndeliveredElement</code> 这个回调，来进行监听。<br>
它的使用场景一般都是用于<strong>接收方对数据是否被消费特别关心</strong>的场景。比如说，发送出去的消息，接收方是不是真的收到了？对于接收方没收到的信息，发送方就可以灵活处理了，比如针对这些没收到的消息，发送方可以先记录下来，等下次重新发送。</p>
<h2><a href="#3-channel-关闭引发的问题" class="header-anchor">#</a><span id="3-channel-关闭引发的问题">3. Channel 关闭引发的问题</span></h2>
<h3><a href="#1-produce" class="header-anchor">#</a><span id="1-produce">1. produce{}</span></h3>
<p>在前面提到的<code>代码段 1</code> 里，由于忘记调用了 <code>close()</code>，所以会导致程序一直运行无法终止。这个问题其实是很严重的。为了解决这一问题，<code>Kotlin</code> 官方提供了另一种创建 <code>Channel</code> 的方式，也就是 <strong><code>produce&#123;&#125;</code> 高阶函数</strong> 。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            logX(<span class="string">&quot;Send: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 3，接收数据</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            logX(<span class="string">&quot;Receive: <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，使用 <code>produce&#123;&#125;</code> 以后，就不用再去调用 <code>close()</code> 方法了，因为 <code>produce&#123;&#125;</code> 会自动调用 <code>close()</code> 方法。</p>
<h3><a href="#2-receive方法" class="header-anchor">#</a><span id="2-receive方法">2. receive()方法</span></h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">        <span class="comment">// 发送3条数据</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用4次receive()</span></span><br><span class="line">    channel.receive() <span class="comment">// 1</span></span><br><span class="line">    channel.receive() <span class="comment">// 2</span></span><br><span class="line">    channel.receive() <span class="comment">// 3</span></span><br><span class="line">    channel.receive() <span class="comment">// 异常</span></span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">ClosedReceiveChannelException: Channel was closed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在前面所有的代码当中，都是以 <code>for</code> 循环来迭代 <code>channel</code> 当中的元素的，但实际上，<code>channel</code> 还有一个 <strong><code>receive()</code></strong> 方法，它是与 <code>send(it)</code> 对应的。在上面代码中，只调用了 <em>3</em> 次 <code>send()</code>，却调用 <em>4</em> 次 <code>receive()</code>。</p>
<p>当第 <em>4</em> 次调用 <code>receive()</code> 的时候，代码会抛出异常“<code>ClosedReceiveChannelException</code>”，这其实也代表： <code>Channel</code> 已经被关闭了。所以这也就说明了，<code>produce &#123;&#125;</code>确实会调用 <code>close()</code> 方法。不然的话，第 <code>4</code> 次 <code>receive()</code> 会被挂起，而不是抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel: Channel&lt;<span class="built_in">Int</span>&gt; = Channel()</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            channel.send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用4次receive()</span></span><br><span class="line">    channel.receive()       <span class="comment">// 1</span></span><br><span class="line">    println(<span class="string">&quot;Receive: 1&quot;</span>)</span><br><span class="line">    channel.receive()       <span class="comment">// 2</span></span><br><span class="line">    println(<span class="string">&quot;Receive: 2&quot;</span>)</span><br><span class="line">    channel.receive()       <span class="comment">// 3</span></span><br><span class="line">    println(<span class="string">&quot;Receive: 3&quot;</span>)</span><br><span class="line">    channel.receive()       <span class="comment">// 永远挂起</span></span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Receive: 1</span></span><br><span class="line"><span class="comment">Receive: 2</span></span><br><span class="line"><span class="comment">Receive: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码可见，第 <code>4</code> 次调用 <code>receive()</code>，就会导致程序被永久挂起，后面的 <code>logX(&quot;end&quot;)</code> 是没有机会继续执行的。也就是说，<strong>直接使用 <code>receive()</code> 是很容易出问题</strong>。</p>
<p><code>Channel</code> 其实还有两个属性：<code>isClosedForReceive</code>、<code>isClosedForSend</code>。这两个属性，就可以用来判断当前的 <code>Channel</code> 是否已经被关闭。由于 <code>Channel</code> 分为发送方和接收方，所以这两个参数也是针对这两者的。</p>
<ul>
<li>对于发送方来说，可以使用“<code>isClosedForSend</code>”来判断当前的 <code>Channel</code> 是否关闭；</li>
<li>对于接收方来说，可以使用“<code>isClosedForReceive</code>”来判断当前的 <code>Channel</code> 是否关闭。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 1，创建管道</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">        <span class="comment">// 发送3条数据</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用while循环判断isClosedForReceive</span></span><br><span class="line">    <span class="keyword">while</span> (!channel.isClosedForReceive) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = channel.receive()</span><br><span class="line">        println(<span class="string">&quot;Receive <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Send 1</span></span><br><span class="line"><span class="comment">Receive 1</span></span><br><span class="line"><span class="comment">Receive 2</span></span><br><span class="line"><span class="comment">Send 2</span></span><br><span class="line"><span class="comment">Send 3</span></span><br><span class="line"><span class="comment">Receive 3</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上代码看起来是可以正常工作了。但是，<strong>仍然不建议用这种方式</strong>。因为，当为管道指定了 <code>capacity</code> 以后，以上的判断方式将会变得不可靠！原因是 <em>1.6.0</em> 版本的协程库，运行这样的代码会崩溃，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce(capacity = <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        (<span class="number">1.</span><span class="number">.300</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!channel.isClosedForReceive) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = channel.receive()</span><br><span class="line">        println(<span class="string">&quot;Receive <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">// 省略部分</span></span><br><span class="line"><span class="comment">Receive 300</span></span><br><span class="line"><span class="comment">Send 300</span></span><br><span class="line"><span class="comment">ClosedReceiveChannelException: Channel was closed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>所以，最好不要用 <strong><code>channel.receive()</code></strong>。即使配合 <code>isClosedForReceive</code> 这个判断条件，直接调用 <code>channel.receive()</code> 仍然是一件非常危险的事情！</p>
<h3><a href="#3-channelconsumeeach" class="header-anchor">#</a><span id="3-channelconsumeeach">3. channel.consumeEach {}</span></h3>
<p>实际上，除了可以使用 <code>for</code> 循环以外，还可以使用 <code>Kotlin</code> 提供的另一个高阶函数：<code>channel.consumeEach &#123;&#125;</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce(capacity = <span class="number">3</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.300</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    channel.consumeEach &#123;</span><br><span class="line">        println(<span class="string">&quot;Receive <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logX(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">部分输出结果：</span></span><br><span class="line"><span class="comment">Send 1</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">Send 2</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">Send 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">Send 4</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">Receive 1</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">Receive 2</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">Receive 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">Receive 4</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">Receive 5</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">Send 5</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">Send 6</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">Send 7</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>所以，想要读取 <code>Channel</code> 当中的数据时，一定要使用 <code>for</code> 循环，或者是 <code>channel.consumeEach &#123;&#125;</code>，千万不要直接调用 <code>channel.receive()</code>。</p>
<blockquote>
<p>补充：在某些特殊场景下，如果必须要自己来调用 <code>channel.receive()</code>，那么可以考虑使用 <code>receiveCatching()</code>，它可以防止异常发生。</p>
</blockquote>
<h2><a href="#4-为什么说-channel-是热的" class="header-anchor">#</a><span id="4-为什么说-channel-是热的">4. 为什么说 Channel 是“热”的？</span></h2>
<p><code>Channel</code> 其实就是用来传递“数据流”的。注意，这里的数据流，指的是多个数据组合形成的流。前面挂起函数、<code>async</code> 返回的数据，就像是水滴一样，而 <code>Channel</code> 则像是自来水管当中的水流一样。</p>
<p><span id="jumpChannelCode">在业界一直有一种说法</span>：<code>Channel</code> 是“热”的。也是因为这句话，在 <code>Kotlin</code> 当中，也经常把 <code>Channel</code> 称为“热数据流”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 只发送不接受</span></span><br><span class="line">    <span class="keyword">val</span> channel = produce&lt;<span class="built_in">Int</span>&gt;(capacity = <span class="number">10</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Send 1</span></span><br><span class="line"><span class="comment">Send 2</span></span><br><span class="line"><span class="comment">Send 3</span></span><br><span class="line"><span class="comment">程序结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，定义了一个 <code>Channel</code>，管道的容量是 <em>10</em>，然后发送了 <em>3</em> 个数据。但在代码中并没有消费 Channel 当中的数据。所以，<strong>这种“不管有没有接收方，发送方都会工作”的模式，就是我们将其认定为“热”的原因</strong>。<br>
这就有点像是一个热心的饭店服务员，不管你有没有提要求，服务员都会给你端茶送水，把茶水摆在你的饭桌上。当你想要喝水的时候，就可以直接从饭桌上拿了 <em>（当你想要数据的时候，就可以直接从管道里取出来了）</em>。又或者，<code>Channel</code> 的发送方，其实就像是“自来水厂”，不管你是不是要用水，自来水厂都会把水送到你家门口的管道当中来。这样当你想要用水的时候，打开水龙头就会马上有水了。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/channel5.jpeg" alt></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = produce&lt;<span class="built_in">Int</span>&gt;(capacity = <span class="number">0</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;Before send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Before send 1</span></span><br><span class="line"><span class="comment">程序将无法退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当把 <code>capacity</code> 改成 <em>0</em> 以后，可以看到 <code>Channel</code> 的发送方仍然是会工作的，只是说，在它调用 <code>send()</code> 方法的时候，由于接收方还未就绪，且管道容量为 <em>0</em>，所以它会被挂起。所以，它仍然还是有在工作的。最直接的证据就是：<strong>这个程序将无法退出，一直运行下去</strong>。这个后果更加严重！<br>
但是，总的来说，不管接收方是否存在，<code>Channel</code> 的发送方一定会工作。对应的，你可以想象成：虽然你的饭桌已经没有空间了，但服务员还是端来了茶水站在了你旁边，只是没有把茶水放在你桌上，等饭桌有了空间，或者你想喝水了，你就能马上喝到。<br>
至于自来水的那个场景，可以想象成，你家就在自来水厂的门口，你们之间的管道容量为 <code>0</code>，但这并不意味着自来水厂没有工作。</p>
<h2><a href="#5-channel-的能力都是通过组合得来的" class="header-anchor">#</a><span id="5-channel-的能力都是通过组合得来的">5. Channel 的能力都是通过“组合”得来的</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt;, <span class="type">ReceiveChannel</span>&lt;<span class="type">E</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上 <code>Channel</code> 的源代码定义，<code>Channel</code> 本身只是一个接口。</p>
<p>而且，<code>Channel</code> 本身并没有什么方法和属性，它其实只是 <code>SendChannel</code>、<code>ReceiveChannel</code> 这两个接口的组合。也就是说，<code>Channel</code> 的所有能力，都是来自于 <code>SendChannel</code>、<code>ReceiveChannel</code> 这两个接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SendChannel</span>&lt;<span class="type">in E</span>&gt; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isClosedForSend: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(element: <span class="type">E</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1，select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2，非挂起函数的接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">trySend</span><span class="params">(element: <span class="type">E</span>)</span></span>: ChannelResult&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">(cause: <span class="type">Throwable</span>? = <span class="literal">null</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnClose</span><span class="params">(handler: (<span class="type">cause</span>: <span class="type">Throwable</span>?) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReceiveChannel</span>&lt;<span class="type">out E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isClosedForReceive: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: E</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receiveCatching</span><span class="params">()</span></span>: ChannelResult&lt;E&gt;</span><br><span class="line">    <span class="comment">// 3，select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceive: SelectClause1&lt;E&gt;</span><br><span class="line">    <span class="comment">// 4，select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5，非挂起函数的接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryReceive</span><span class="params">()</span></span>: ChannelResult&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: ChannelIterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的源码中，大部分的接口其实已经见过了。只有 <em>5</em> 个还没见过：</p>
<ul>
<li><em>注释 1、3、4</em>，它们是跟 <code>select</code> 相关的，后续会有介绍。</li>
<li><em>注释 2、5</em>，是专门为非协程环境提供的 <code>API</code>，也就是说，当不在协程作用域的时候，也可以调用这两个方法来操作 <code>Channel</code>。不过大部分情况下，我们都应该优先使用挂起函数版本的 API。<br>
所以，如果说 <code>Channel</code> 是一个管道，那么 <code>SendChannel</code>、<code>ReceiveChannel</code> 就是组成这个管道的两个零件。</li>
</ul>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/channel3.jpeg" alt></p>
<p>其实对于 <code>Channel</code> 来说，也可以实现对外暴露不变性集合的思路</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChannelModel</span> &#123;</span><br><span class="line">    <span class="comment">// 对外只提供读取功能</span></span><br><span class="line">    <span class="keyword">val</span> channel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; <span class="keyword">by</span> ::_channel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _channel: Channel&lt;<span class="built_in">Int</span>&gt; = Channel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            _channel.send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> model = ChannelModel()</span><br><span class="line">    launch &#123;</span><br><span class="line">        model.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.channel.consumeEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是对于 <code>Channel</code> 来说，它的 <code>send()</code> 就相当于集合的写入 <code>API</code>，当想要做到“对写入封闭，对读取开放”的时候，就可以用之前学过的知识轻松做到。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/channel2.png" alt></p>
<p>而这一切，都得益于 <code>Channel</code> 的能力都是通过“组合”得来的。</p>
<h1><a href="#三-flow" class="header-anchor">#</a><span id="三-flow">三、 Flow</span></h1>
<p><code>Flow</code>，可以说是在 <code>Kotlin</code> 协程当中自成体系的知识点。<strong><code>Flow</code> 极其强大、极其灵活</strong>。简单的异步场景，可以直接使用挂起函数、<code>launch</code>、<code>async</code>；至于复杂的异步场景，就可以使用 <code>Flow</code>。在很多技术领域，<code>Flow</code> 已经开始占领 <code>RxJava</code> 原本的领地，在 <code>Android</code> 领域，<code>Flow</code> 甚至还要取代原本 <code>LiveData</code> 的地位。</p>
<h2><a href="#1-flow-就是数据流" class="header-anchor">#</a><span id="1-flow-就是数据流">1. Flow 就是“数据流”</span></h2>
<p><code>Flow</code> 这个单词有“流”的意思，比如 <code>Cash Flow</code> 代表了“现金流”；<code>Traffic Flow</code> 代表了“车流”；<code>Flow</code> 在 <code>Kotlin</code> 协程当中，其实就是“数据流”的意思。因为 <code>Flow</code> 当中“流淌”的，都是数据。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/flow5.gif" alt></p>
<p>上面的动图，可以简单描述 <code>Flow</code> 的行为模式，可以看到，<code>Flow</code> 和 <code>Channel</code> 不一样，<code>Flow</code> 并不是只有“发送”“接收”两个行为，它当中流淌的数据是可以在中途改变的。</p>
<p><code>Flow</code> 的数据发送方，称之为“上游”；数据接收方称之为“下游”。跟现实生活中一样，上下游其实也是相对的概念。比如可以看到下面的图，对于<em>中转站 2</em> 来说，<em>中转站 1</em> 就相当于它的上游。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/flow4.jpeg" alt></p>
<p>另外，也可以看到，在发送方、接收方的中间，是可以有多个“中转站”的。在这些中转站里，就可以对数据进行一些处理了。其实，<code>Flow</code> 这样的数据模型，在现实生活中也存在，比如说长江，它有发源地和下游，中间还有很多大坝、水电站，甚至还有一些污水净化厂。</p>
<h2><a href="#2-flow-的创建" class="header-anchor">#</a><span id="2-flow-的创建">2. Flow 的创建</span></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;                  <span class="comment">// 上游，发源地</span></span><br><span class="line">        emit(<span class="number">1</span>)             <span class="comment">// 挂起函数</span></span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        emit(<span class="number">4</span>)</span><br><span class="line">        emit(<span class="number">5</span>)</span><br><span class="line">    &#125;.filter &#123; it &gt; <span class="number">2</span> &#125;     <span class="comment">// 中转站1</span></span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;     <span class="comment">// 中转站2</span></span><br><span class="line">        .take(<span class="number">2</span>)            <span class="comment">// 中转站3</span></span><br><span class="line">        .collect&#123;           <span class="comment">// 下游</span></span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：                       </span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>结合着之前的图片来分析这段代码，可以轻易的分析出它的执行结果。因为 <code>Flow</code> 的这种链式调用的 <code>API</code>，本身就非常符合人的阅读习惯。</p>
<p>而且，<code>Flow</code> 写出来的代码非常清晰易懂，可以对照前面的示意图来看一下上面代码的执行逻辑：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/flow3.jpeg" alt></p>
<p>简单分析一下上述代码：</p>
<ul>
<li><strong><code>flow&#123;&#125;</code></strong>，是一个高阶函数，它的作用就是创建一个新的 <code>Flow</code>。在它的 <code>Lambda</code> 当中，可以使用 <code>emit()</code> 这个挂起函数往下游发送数据，这里的 <code>emit</code> 其实就是“发射”“发送”的意思。上游创建了一个“数据流”，同时也要负责发送数据。这跟现实生活也是一样的：长江里的水从上游产生，这是天经地义的。所以，对于上游而言，只需要创建 <code>Flow</code>，然后发送数据即可，其他的都交给中转站和下游。</li>
<li><strong><code>filter&#123;&#125;</code>、<code>map&#123;&#125;</code>、<code>take(2)</code></strong>，它们是中间操作符，就像中转站一样，它们的作用就是对数据进行处理。<code>Flow</code> 最大的优势，就是它的操作符跟集合操作符高度一致。只要会用 <code>List</code>、<code>Sequence</code>，那就可以快速上手 <code>Flow</code> 的操作符，这中间几乎没有额外的学习成本。</li>
<li><strong><code>collect&#123;&#125;</code></strong>，也被称为终止操作符或者末端操作符，它的作用其实只有一个：终止 <code>Flow</code> 数据流，并且接收这些数据。</li>
</ul>
<p>除了使用 <code>flow&#123;&#125;</code> 创建 <code>Flow</code> 以外，还可以使用 <code>flowOf()</code> 这个函数。所以，从某种程度上讲，<code>Flow</code> 跟 <code>Kotlin</code> 的集合其实也是有一些相似之处的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中，可以看到 <code>Flow API</code> 与集合 <code>API</code> 之间的共性。<code>listOf</code> 创建 <code>List</code>，<code>flowOf</code> 创建 <code>Flow</code>。遍历 <code>List</code>，使用 <code>forEach&#123;&#125;</code>；遍历 <code>Flow</code>，使用 <code>collect&#123;&#125;</code>。</p>
<p>在某些场景下，甚至可以把 <code>Flow</code> 当做集合来使用，或者反过来，把集合当做 <code>Flow</code> 来用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// Flow转List</span></span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .toList()</span><br><span class="line">        .filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List转Flow</span></span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .asFlow()</span><br><span class="line">        .filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，使用了 <strong><code>Flow.toList()</code>、<code>List.asFlow()</code></strong> 这两个扩展函数，让数据在 <code>List</code>、<code>Flow</code> 之间来回转换，而其中的代码甚至不需要做多少改变。</p>
<p>到这里，展现三种创建 <code>Flow</code> 的方式，下面以表格的形式总结一下。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/flow2.jpeg" alt></p>
<p>现在知道 <code>Flow</code> 的 <code>API</code> 总体分为三个部分：上游、中间操作、下游。其中对于上游来说，一般有三种创建方式，这些也都需要好好掌握。那么接下来，重点看看中间操作符。</p>
<h2><a href="#3-flow-中间操作符" class="header-anchor">#</a><span id="3-flow-中间操作符">3. Flow 中间操作符</span></h2>
<p>中间操作符 <code>（Intermediate Operators）</code>，除了之前提到的 <code>map</code>、<code>filter</code>、<code>take</code> 这种从集合那边“抄”来的操作符之外，还有一些特殊的操作符需要特别注意。这些操作符跟 <code>Kotlin</code> 集合 <code>API</code> 是没关系的，它们是专门为 <code>Flow</code> 设计的。</p>
<h3><a href="#1-flow-生命周期" class="header-anchor">#</a><span id="1-flow-生命周期">1. Flow 生命周期</span></h3>
<p>在 <code>Flow</code> 的中间操作符当中，<strong><code>onStart</code>、<code>onCompletion</code></strong> 这两个是比较特殊的。它们是以操作符的形式存在，但实际上的作用，是监听生命周期回调。</p>
<h4><a href="#1-onstart" class="header-anchor">#</a><span id="1-onstart">1. onStart</span></h4>
<p><strong><code>onStart</code></strong>，它的作用是注册一个监听事件：当 <code>flow</code> 启动以后，它就会被回调。具体可以看下面这个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123;</span><br><span class="line">            println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .onStart &#123; println(<span class="string">&quot;onStart&quot;</span>) &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">onStart</span></span><br><span class="line"><span class="comment">filter: 1</span></span><br><span class="line"><span class="comment">filter: 2</span></span><br><span class="line"><span class="comment">filter: 3</span></span><br><span class="line"><span class="comment">map: 3</span></span><br><span class="line"><span class="comment">collect: 6</span></span><br><span class="line"><span class="comment">filter: 4</span></span><br><span class="line"><span class="comment">map: 4</span></span><br><span class="line"><span class="comment">collect: 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>onStart</code> 的执行顺序，并不是严格按照上下游来执行的。虽然 <code>onStart</code> 的位置是处于下游，而 <code>filter</code>、<code>map</code>、<code>take</code> 是上游，但 <code>onStart</code> 是最先执行的。因为它本质上是一个回调，不是一个数据处理的中间站。<br>
相应的，<code>filter</code>、<code>map</code>、<code>take</code> 这类操作符，它们的执行顺序是跟它们的位置相关的。最终的执行结果，也会受到位置变化的影响。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// 注意这里</span></span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123;</span><br><span class="line">            println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onStart &#123; println(<span class="string">&quot;onStart&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">onStart</span></span><br><span class="line"><span class="comment">filter: 1</span></span><br><span class="line"><span class="comment">filter: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可见，在以上代码中，将 <code>take(2)</code> 的位置挪到了上游的起始位置，这时候程序的执行结果就完全变了。</p>
<h4><a href="#2-oncompletion" class="header-anchor">#</a><span id="2-oncompletion">2. onCompletion</span></h4>
<p>理解了 <code>onStart</code> 以后，<code>onCompletion</code> 也就很好理解了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;onCompletion&quot;</span>) &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">filter: 1</span></span><br><span class="line"><span class="comment">filter: 2</span></span><br><span class="line"><span class="comment">filter: 3</span></span><br><span class="line"><span class="comment">collect: 3</span></span><br><span class="line"><span class="comment">filter: 4</span></span><br><span class="line"><span class="comment">collect: 4</span></span><br><span class="line"><span class="comment">onCompletion</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>和 <code>onStart</code> 类似，<code>onCompletion</code> 的执行顺序，跟它在 <code>Flow</code> 当中的位置无关。<code>onCompletion</code> 只会在 <code>Flow</code> 数据流执行完毕以后，才会回调。</p>
<p><code>Flow.onCompletion&#123;&#125;</code> 和 <code>Job.invokeOnCompletion&#123;&#125;</code> 这个生命周期回调类似，<code>onCompletion&#123;&#125;</code> 在面对以下三种情况时都会进行回调：</p>
<ul>
<li><em>情况 1</em>，<code>Flow</code> 正常执行完毕；</li>
<li><em>情况 2</em>，<code>Flow</code> 当中出现异常；</li>
<li><em>情况 3</em>，<code>Flow</code> 被取消。</li>
</ul>
<p>对于<code>情况 1</code>，已经在上面的代码中验证过了。接下来，我们看看后面两种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            emit(<span class="number">1</span>)</span><br><span class="line">            emit(<span class="number">2</span>)</span><br><span class="line">            emit(<span class="number">3</span>)</span><br><span class="line">        &#125;.onCompletion &#123; println(<span class="string">&quot;onCompletion first: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">            .collect &#123;</span><br><span class="line">                println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (it == <span class="number">2</span>) &#123;</span><br><span class="line">                    cancel()            <span class="comment">// 1</span></span><br><span class="line">                    println(<span class="string">&quot;cancel&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line"></span><br><span class="line">    flowOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;onCompletion second: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            <span class="comment">// 仅用于测试，生产环境不应该这么创建异常</span></span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException() <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">collect: 1</span></span><br><span class="line"><span class="comment">collect: 2</span></span><br><span class="line"><span class="comment">cancel</span></span><br><span class="line"><span class="comment">onCompletion first: JobCancellationException: // 3</span></span><br><span class="line"><span class="comment">collect: 4</span></span><br><span class="line"><span class="comment">onCompletion second: IllegalStateException    // 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的<code>注释 1</code> 当中，在 <code>collect&#123;&#125;</code> 里调用了 <code>cancel</code> 方法，这会取消掉整个 <code>Flow</code>，这时候，<code>flow&#123;&#125;</code> 当中剩下的代码将不会再被执行。最后，<code>onCompletion</code> 也会被调用，同时，注意 <em>注释 3</em>，这里还会带上对应的异常信息 <code>JobCancellationException</code>。<br>
同样的，根据<em>注释 2、4</em>，也能分析出一样的结果。<br>
而且从上面的代码里，也可以看到，当 <code>Flow</code> 当中发生异常以后，<code>Flow</code> 就会终止。</p>
<h3><a href="#2-flow-catch-处理异常" class="header-anchor">#</a><span id="2-flow-catch-处理异常">2. Flow catch 处理异常</span></h3>
<p>前面已经介绍过，<code>Flow</code> 主要有三个部分：上游、中间操作、下游。那么，<code>Flow</code> 当中的异常，也可以根据这个标准来进行分类，也就是异常发生的位置。对于发生在上游、中间操作这两个阶段的异常，可以直接使用 <code>catch</code> 这个操作符来进行捕获和进一步处理。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;catch: <span class="variable">$it</span>&quot;</span>) &#125; <span class="comment">// 注意这里</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">catch: java.lang.IllegalStateException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>catch</code> 这个操作符，其实就相当于平时使用的 <code>try-catch</code> 的意思。只是说，后者是用于普通的代码，而前者是用于 <code>Flow</code> 数据流的，两者的核心理念是一样的。不过，考虑到 <code>Flow</code> 具有上下游的特性，<strong><code>catch</code> 这个操作符的作用是和它的位置强相关的</strong>。</p>
<p><strong><code>catch</code> 的作用域，仅限于 <code>catch</code> 的上游</strong>。换句话说，发生在 <code>catch</code> 上游的异常，才会被捕获，发生在 <code>catch</code> 下游的异常，则不会被捕获。为此，可以换一个写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; println(<span class="string">&quot;catch: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .filter &#123; it / <span class="number">0</span> &gt; <span class="number">1</span>&#125;  <span class="comment">// 故意制造异常</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上面代码的执行结果里，可以看到，<code>catch</code> 对于发生在它下游的异常是无能为力的。打个比方说，长江上面的污水处理厂，当然只能处理它上游的水，而对于发生在下游的污染，是无能为力的。<br>
那么，发生在上游源头，还有发生在中间操作的异常，处理起来其实很容易，只需要留意 <code>catch</code> 的作用域即可。最后就是发生在下游末尾处的异常了。<br>
对于发生在下游的异常，就不能用 <code>catch</code> 操作符了。最简单的办法，其实是使用 <code>try-catch</code>，把 <code>collect&#123;&#125;</code> 当中可能出现问题的代码包裹起来。比如像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .onCompletion &#123; println(<span class="string">&quot;onCompletion second: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                println(<span class="string">&quot;Catch <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，针对 <code>Flow</code> 当中的异常处理，主要有两种手段：一个是 <code>catch</code> 操作符，它主要用于上游异常的捕获；而 <code>try-catch</code> 这种传统的方式，更多的是应用于下游异常的捕获。</p>
<h3><a href="#3-切换-contextflowon-launchin" class="header-anchor">#</a><span id="3-切换-contextflowon-launchin">3. 切换 Context：flowOn、launchIn</span></h3>
<p>前面介绍过，<code>Flow</code> 非常适合复杂的异步任务。在大部分的异步任务当中，都需要频繁切换工作的线程。对于耗时任务，需要线程池当中执行，对于 <code>UI</code> 任务，需要在主线程执行。而在 <code>Flow</code> 当中，借助 <code>flowOn</code> 这一个操作符，就可以灵活实现以上的需求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 1&quot;</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 2&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow.filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO)  <span class="comment">// 注意这里</span></span><br><span class="line">        .collect &#123;</span><br><span class="line">            logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Start</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Filter: 1</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Emit: 1</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Filter: 2</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Emit: 2</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Filter: 3</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Emit: 3</span></span><br><span class="line"><span class="comment">Thread:DefaultDispatcher-worker-1 @coroutine#2</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">Collect 3</span></span><br><span class="line"><span class="comment">Thread:main @coroutine#1</span></span><br><span class="line"><span class="comment">================================</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>flowOn</code> 操作符也是和它的位置强相关的。它的作用域跟前面的 <code>catch</code> 类似：<strong><code>flowOn</code> 仅限于它的上游</strong>。<br>
在上面的代码中，<code>flowOn</code> 的上游，就是 <code>flow&#123;&#125;</code>、<code>filter&#123;&#125;</code> 当中的代码，所以，它们的代码全都运行在 <code>DefaultDispatcher</code> 这个线程池当中。只有 <code>collect&#123;&#125;</code> 当中的代码是运行在 <code>main</code> 线程当中的。对应的，如果挪动一下上面代码中 <code>flowOn</code> 的位置，会发现执行结果就会不一样，比如这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line">flow.flowOn(Dispatchers.IO) <span class="comment">// 注意这里</span></span><br><span class="line">    .filter &#123;</span><br><span class="line">        logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123;</span><br><span class="line">        logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">filter当中的代码会执行在main线程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里的代码执行结果，很容易就能推测出来，因为 <code>flowOn</code> 的作用域仅限于上游，所以它只会让 <code>flow&#123;&#125;</code> 当中的代码运行在 <code>DefaultDispatcher</code> 当中，剩下的代码则执行在 <code>main</code> 线程。<br>
但是到这里，就会遇到一个类似 <code>catch</code> 的困境：如果想要指定 <code>collect</code> 当中的 <code>Context</code>，该怎么办呢？最简单的办法，就是用前面学过的：<strong><code>withContext&#123;&#125;</code></strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">flow.flowOn(Dispatchers.IO)</span><br><span class="line">    .filter &#123;</span><br><span class="line">        logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .collect &#123;</span><br><span class="line">        withContext(mySingleDispatcher) &#123;</span><br><span class="line">            logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">collect&#123;&#125;将运行在MySingleThread</span></span><br><span class="line"><span class="comment">filter&#123;&#125;运行在main</span></span><br><span class="line"><span class="comment">flow&#123;&#125;运行在DefaultDispatcher</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，直接在 <code>collect&#123;&#125;</code> 里使用了 <code>withContext&#123;&#125;</code>，所以它的执行就交给了 <code>MySingleThread</code>。不过，有的时候，想要改变除了 <code>flowOn</code> 以外所有代码的 <code>Context</code>。比如，希望 <code>collect&#123;&#125;</code>、<code>filter&#123;&#125;</code> 都运行在 <code>MySingleThread</code>。那么这时候，可以考虑使用 <code>withContext&#123;&#125;</code> 进一步扩大包裹的范围，就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">withContext(mySingleDispatcher) &#123;</span><br><span class="line">    flow.flowOn(Dispatchers.IO)</span><br><span class="line">        .filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .collect&#123;</span><br><span class="line">            logX(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">collect&#123;&#125;将运行在MySingleThread</span></span><br><span class="line"><span class="comment">filter&#123;&#125;运行在MySingleThread</span></span><br><span class="line"><span class="comment">flow&#123;&#125;运行在DefaultDispatcher</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>不过，这种写法终归是有些丑陋，因此，<code>Kotlin</code> 官方还提供了另一个操作符，<code>launchIn</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段15</span></span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(mySingleDispatcher)</span><br><span class="line">flow.flowOn(Dispatchers.IO)</span><br><span class="line">    .filter &#123;</span><br><span class="line">        logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .onEach &#123;</span><br><span class="line">        logX(<span class="string">&quot;onEach <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .launchIn(scope)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">onEach&#123;&#125;将运行在MySingleThread</span></span><br><span class="line"><span class="comment">filter&#123;&#125;运行在MySingleThread</span></span><br><span class="line"><span class="comment">flow&#123;&#125;运行在DefaultDispatcher</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在这段代码中，不再直接使用 <code>collect&#123;&#125;</code>，而是借助了 <code>onEach&#123;&#125;</code> 来实现类似 <code>collect&#123;&#125;</code> 的功能。同时在最后使用了 <code>launchIn(scope)</code>，把它上游的代码都分发到指定的线程当中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">launchIn</span><span class="params">(scope: <span class="type">CoroutineScope</span>)</span></span>: Job = scope.launch &#123;</span><br><span class="line">    collect() <span class="comment">// tail-call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是 <code>launchIn</code> 的源代码，它的定义极其简单：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段16</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">launchIn</span><span class="params">(scope: <span class="type">CoroutineScope</span>)</span></span>: Job = scope.launch &#123;</span><br><span class="line">    collect() <span class="comment">// tail-call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，<code>launchIn</code> 从严格意义来讲，应该算是一个下游的终止操作符，因为它本质上是调用了 <code>collect()</code>。</p>
<p>因此，上面的<em>代码段 16</em>，也会等价于下面的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段17</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(mySingleDispatcher)</span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        logX(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 1&quot;</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 2&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        logX(<span class="string">&quot;Emit: 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .filter &#123;</span><br><span class="line">            logX(<span class="string">&quot;Filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onEach &#123;</span><br><span class="line">            logX(<span class="string">&quot;onEach <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    scope.launch &#123; <span class="comment">// 注意这里</span></span><br><span class="line">        flow.collect()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    delay(<span class="number">100L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，总的来说，对于 <code>Flow</code> 当中的线程切换，可以使用 <code>flowOn</code>、<code>launchIn</code>、<code>withContext</code>，但其实，<code>flowOn</code>、<code>launchIn</code> 就已经可以满足需求了。另外，由于 <code>Flow</code> 当中直接使用 <code>withContext</code> 是很容易引发其他问题的，因此，<strong><code>withContext</code> 在 <code>Flow</code> 当中是不被推荐的，即使要用，也应该谨慎再谨慎。</strong>，因为 <code>Kotlin</code> 不允许在 <code>withContext</code> 里 调用 <code>emit()</code> 是因为 <code>emit()</code> 默认不是线程安全的</p>
<h2><a href="#4-下游终止操作符" class="header-anchor">#</a><span id="4-下游终止操作符">4. 下游：终止操作符</span></h2>
<p>最后，就到了下游阶段，来看看终止操作符 <em>（Terminal Operators）</em> 的含义和使用。</p>
<blockquote>
<p>这里的 <code>Terminal</code>，其实有终止、末尾、终点的意思。</p>
</blockquote>
<p>在 <code>Flow</code> 当中，终止操作符的意思就是终止整个 <code>Flow</code> 流程的操作符。这里的“终止”，其实是跟前面的“中间”操作符对应的。<br>
具体来说，就是在 <code>filter</code> 操作符的后面，还可以继续添加其他的操作符，比如说 <code>map</code>，因为 <code>filter</code> 本身就是一个“中间”操作符。但是，<code>collect</code> 操作符之后，无法继续使用 <code>map</code> 之类的操作，因为 <code>collect</code> 是一个“终止”操作符，代表 <code>Flow</code> 数据流的终止。<br>
<code>Flow</code> 里面，最常见的终止操作符就是 <code>collect</code>。除此之外，还有一些从集合当中“抄”过来的操作符，也是 <code>Flow</code> 的终止操作符。比如 <code>first()</code>、<code>single()</code>、<code>fold&#123;&#125;</code>、<code>reduce&#123;&#125;</code>。<br>
另外，将 <code>Flow</code> 转换成集合的时候，它本身也就意味着 <code>Flow</code> 数据流的终止。比如说，前面用过的 <code>toList</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段18</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// Flow转List</span></span><br><span class="line">    flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .toList()           <span class="comment">// 注意这里</span></span><br><span class="line">        .filter &#123; it &gt; <span class="number">2</span> &#125;</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当调用了 <code>toList()</code> 以后，往后所有的操作符，都不再是 <code>Flow</code> 的 <code>API</code> 调用了，虽然它们的名字没有变，<code>filter</code>、<code>map</code>，这些都只是集合的 <code>API</code>。所以，严格意义上讲，<code>toList</code> 也算是一个终止操作符。</p>
<h2><a href="#5-为什么说-flow-是冷的" class="header-anchor">#</a><span id="5-为什么说-flow-是冷的">5. 为什么说 Flow 是“冷”的？</span></h2>
<p>如果理解了之前所说的 <code>Channel</code> 为什么是“热”的，那么就一定可以理解 <code>Flow</code> 为什么是“冷”的。现在模仿<a href="#jumpChannelCode">前面的 Channel 代码</a>，写一段 <code>Flow</code> 的代码，两相对比之下其实马上就能发现它们之间的差异。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 冷数据流</span></span><br><span class="line">    <span class="keyword">val</span> flow = flow &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;Before send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            emit(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 热数据流</span></span><br><span class="line">    <span class="keyword">val</span> channel = produce&lt;<span class="built_in">Int</span>&gt;(capacity = <span class="number">0</span>) &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">            println(<span class="string">&quot;Before send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            send(it)</span><br><span class="line">            println(<span class="string">&quot;Send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">Before send 1</span></span><br><span class="line"><span class="comment">// Flow 当中的代码并未执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>Channel</code> 之所以被认为是“热”的原因，是因为不管有没有接收方，发送方都会工作。那么对应的，<code>Flow</code> 被认为是“冷”的原因，就是因为只有调用终止操作符之后，<code>Flow</code> 才会开始工作。</p>
<p><code>Flow</code> 不仅是“冷”的，它还是“懒”的。为了暴露出它的这个特点，稍微改造一下<code>代码段 1</code>，然后加一些日志：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        println(<span class="string">&quot;emit: 3&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">        println(<span class="string">&quot;emit: 4&quot;</span>)</span><br><span class="line">        emit(<span class="number">4</span>)</span><br><span class="line">        println(<span class="string">&quot;emit: 5&quot;</span>)</span><br><span class="line">        emit(<span class="number">5</span>)</span><br><span class="line">    &#125;.filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it * <span class="number">2</span></span><br><span class="line">    &#125;.collect &#123;</span><br><span class="line">        println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">emit: 3</span></span><br><span class="line"><span class="comment">filter: 3</span></span><br><span class="line"><span class="comment">map: 3</span></span><br><span class="line"><span class="comment">collect: 6</span></span><br><span class="line"><span class="comment">emit: 4</span></span><br><span class="line"><span class="comment">filter: 4</span></span><br><span class="line"><span class="comment">map: 4</span></span><br><span class="line"><span class="comment">collect: 8</span></span><br><span class="line"><span class="comment">emit: 5</span></span><br><span class="line"><span class="comment">filter: 5</span></span><br><span class="line"><span class="comment">map: 5</span></span><br><span class="line"><span class="comment">collect: 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过上面的运行结果，可以发现，<code>Flow</code>一次只会处理一条数据。虽然它也是 <code>Flow</code>“冷”的一种表现，但这个特性准确来说是“懒”。</p>
<p>结合“服务员端茶送水”的场景思考，<code>Flow</code> 不仅是一个“冷淡”的服务员，还是一个“懒惰”的服务员：明明饭桌上有 <em>3</em> 个人需要喝水，但服务员偏偏不一次性上 <em>3</em> 杯水，而是要这 <em>3</em> 个人，每个人都叫服务员一次，服务员才会一杯一杯地送 <em>3</em> 杯水过来。</p>
<p>对比 <code>Channel</code> 的思维模型来看的话：</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/flow1.jpeg" alt></p>
<blockquote>
<p>提示：<code>Flow</code> 默认情况下是“懒惰”的，但也可以通过配置让它“勤快”起来。</p>
</blockquote>
<h2><a href="#6-flow-实践" class="header-anchor">#</a><span id="6-flow-实践">6. Flow 实践</span></h2>
<p><code>Flow</code> 非常适合复杂的异步任务场景。借助它的 <code>flowOn</code>、<code>launchIn</code>，可以写出非常灵活的代码。比如说，在 <code>Android</code>、<code>Swing</code> 之类的 <code>UI</code> 平台之上，可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段21</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">        repeat(<span class="number">3</span>)&#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            emit(it)</span><br><span class="line">            logX(<span class="string">&quot;emit <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟Android、Swing的UI</span></span><br><span class="line">    <span class="keyword">val</span> uiScope = CoroutineScope(mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    loadData()</span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO) <span class="comment">// 1，耗时任务</span></span><br><span class="line">        .onEach &#123;</span><br><span class="line">            logX(<span class="string">&quot;onEach <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .launchIn(uiScope)      <span class="comment">// 2，UI任务</span></span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很容易理解，让耗时任务在 <code>IO</code> 线程池执行，更新 <code>UI</code> 则在 <code>UI</code> 线程。如果结合前面学过的 <code>Flow</code> 操作符，还可以设计出更加有意思的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段22</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100L</span>)</span><br><span class="line">            emit(it)</span><br><span class="line">            logX(<span class="string">&quot;emit <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(it: <span class="type">Int</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showLoading</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Show loading&quot;</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hideLoading</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Hide loading&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> uiScope = CoroutineScope(mySingleDispatcher)</span><br><span class="line"></span><br><span class="line">    loadData()</span><br><span class="line">        .onStart &#123; showLoading() &#125;          <span class="comment">// 显示加载弹窗</span></span><br><span class="line">        .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .<span class="keyword">catch</span> &#123; throwable -&gt;</span><br><span class="line">            println(throwable)</span><br><span class="line">            hideLoading()                   <span class="comment">// 隐藏加载弹窗</span></span><br><span class="line">            emit(-<span class="number">1</span>)                   <span class="comment">// 发生异常以后，指定默认值</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onEach &#123; updateUI(it) &#125;            <span class="comment">// 更新UI界面 </span></span><br><span class="line">        .onCompletion &#123; hideLoading() &#125;     <span class="comment">// 隐藏加载弹窗</span></span><br><span class="line">        .launchIn(uiScope)</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">10000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，通过监听 <code>onStart</code>、<code>onCompletion</code> 的回调事件，就可以实现 <code>Loading</code> 弹窗的显示和隐藏。而对于出现异常的情况，也可以在 <code>catch&#123;&#125;</code> 当中调用 <code>emit()</code>，给出一个默认值，这样就可以有效防止 <code>UI</code> 界面出现空白。不得不说，以上代码的可读性是非常好的。</p>
<h1><a href="#四-select" class="header-anchor">#</a><span id="四-select">四、 select</span></h1>
<p><code>select</code>，在 <em>Kotlin 1.6</em> 当中，仍然是一个<strong>实验性的特性（Experimental）</strong>。但是， <code>select</code> 具有较强的实用性。<code>select</code> 可以说是软件架构当中非常重要的一个组件，在很多业务场景下，<code>select</code> 与 <code>Deferred</code>、<code>Channel</code> 结合以后，在大大提升程序的响应速度的同时，还可以提高程序的灵活性、扩展性。</p>
<h2><a href="#1-select-就是选择更快的结果" class="header-anchor">#</a><span id="1-select-就是选择更快的结果">1. select 就是选择“更快的结果”</span></h2>
<p>由于 <code>select</code> 的工作机制比较抽象，先来假设一个场景，看看 <code>select</code> 适用于什么样的场景。</p>
<p>客户端，想要查询一个商品的详情。目前有两个服务：缓存服务，速度快但信息可能是旧的；网络服务，速度慢但信息一定是最新的。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/select1.jpeg" alt></p>
<p>对于这个场景，如果实现其中的逻辑的话，能够实现类似这样的代码逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNetworkInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.8</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(product: <span class="type">Product</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;product.productId&#125;</span>==<span class="subst">$&#123;product.price&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line">    <span class="comment">// 查询缓存</span></span><br><span class="line">    <span class="keyword">val</span> cacheInfo = getCacheInfo(productId)</span><br><span class="line">    <span class="keyword">if</span> (cacheInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(cacheInfo)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询网络</span></span><br><span class="line">    <span class="keyword">val</span> latestInfo = getNetworkInfo(productId)</span><br><span class="line">    <span class="keyword">if</span> (latestInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(latestInfo)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Product</span>(</span><br><span class="line">    <span class="keyword">val</span> productId: String,</span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 112</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 314</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>考虑到缓存服务速度更快，先去查询缓存服务，如果查询到了信息，就会去更新 <code>UI</code> 界面。之后去查询网络服务，拿到最新的信息之后，我们再来更新 <code>UI</code> 界面。也就是这样：</p>
<ul>
<li>第一步：查询缓存信息；</li>
<li>第二步：缓存服务返回信息，更新 <code>UI</code>；</li>
<li>第三步：查询网络服务；</li>
<li>第四步：网络服务返回信息，更新 <code>UI</code>。</li>
</ul>
<p>这种做法的好处在于，用户可以第一时间看到商品的信息，虽然它暂时会展示旧的信息，但由于同时查询了网络服务，旧缓存信息也马上会被替代成新的信息。这样的做法，可以最大程度保证用户体验。</p>
<p>不过，以上整个流程都是建立在“缓存服务一定更快”的前提下的，万一缓存服务出了问题，它的速度变慢了，甚至是超时、无响应呢？</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/select2.jpeg" alt></p>
<p>这时候，你回过头来分析 <em>代码段 1</em> 的话，你就会发现：程序执行流程会卡在第二步，迟迟无法进行第三步。具体来说，是因为 <code>getCacheInfo()</code> 它是一个挂起函数，只有这个程序执行成功以后，才可以继续执行后面的任务。可以把 <code>getCacheInfo()</code> 当中的 <code>delay</code> 时间修改成 <em>2000</em> 毫秒，去验证一下。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行结果：</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 2013</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 2214</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>面对这样的场景，其实需要一个可以灵活选择的语法：“两个挂起函数同时执行，谁返回的速度更快，就选择谁”。这其实就是 <code>select</code> 的典型使用场景。</p>
<h2><a href="#2-select-和-async" class="header-anchor">#</a><span id="2-select-和-async">2. select 和 async</span></h2>
<p>上面的这个场景，可以用 <code>async</code> 搭配 <code>select</code> 来使用。<code>async</code> 可以实现并发，<code>select</code> 则可以选择最快的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line">    <span class="comment">//          1，注意这里</span></span><br><span class="line">    <span class="comment">//               ↓</span></span><br><span class="line">    <span class="keyword">val</span> product = select&lt;Product?&gt; &#123;</span><br><span class="line">        <span class="comment">// 2，注意这里</span></span><br><span class="line">        async &#123; getCacheInfo(productId) &#125;</span><br><span class="line">            .onAwait &#123; <span class="comment">// 3，注意这里</span></span><br><span class="line">                it</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 4，注意这里</span></span><br><span class="line">        async &#123; getNetworkInfo(productId) &#125;</span><br><span class="line">            .onAwait &#123;  <span class="comment">// 5，注意这里</span></span><br><span class="line">                it</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(product)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 127</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上面的执行结果，可以看到，由于缓存的服务更快，所以，<code>select</code> 确实选择了更快的那个结果。代码中一共有四个注释：</p>
<ul>
<li><em>注释 1</em>，使用 <code>select</code> 这个高阶函数包裹了两次查询的服务，同时传入了泛型参数 <code>Product</code>，代表要选择的数据类型是 <code>Product</code>。</li>
<li><em>注释 2，4</em> 中，使用了 <code>async</code> 包裹了 <code>getCacheInfo()</code>、<code>getNetworkInfo()</code> 这两个挂起函数，这是为了让这两个查询实现并发执行。</li>
<li><em>注释 3，5</em> 中，使用 <code>onAwait&#123;&#125;</code> 将执行结果传给了 <code>select&#123;&#125;</code>，而 <code>select</code> 才能进一步将数据返回给 <code>product</code> 局部变量。<strong>注意，这里使用的 <code>onAwait&#123;&#125;</code>，而不是 <code>await()</code>。</strong></li>
</ul>
<p>现在，假设，缓存服务出现了问题，需要 <em>2000</em> 毫秒才能返回：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">    <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 226</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这时候，通过执行结果，可以发现，<code>select</code> 可以在缓存服务出现问题的时候，灵活选择网络服务的结果。从而避免用户等待太长的时间，得到糟糕的体验。<br>
不过，“<em>代码段 1</em>”和“<em>代码段 2</em>”其实并不是完全等价的。因为在<em>代码段 2</em> 当中，用户大概率是会展示旧的缓存信息。但实际场景下，是需要进一步更新最新信息的。其实，在<em>代码段 2</em> 的基础上，也可以轻松实现，只是说，需要为 <code>Product</code> 这个数据类增加一个标记。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段4</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Product</span>(</span><br><span class="line">    <span class="keyword">val</span> productId: String,</span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="comment">// 是不是缓存信息</span></span><br><span class="line">    <span class="keyword">val</span> isCache: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后对 <em>代码段 2</em> 进行一些改造：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段5</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNetworkInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        <span class="keyword">return</span> Product(productId, <span class="number">9.8</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(product: <span class="type">Product</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;product.productId&#125;</span>==<span class="subst">$&#123;product.price&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1，缓存和网络，并发执行</span></span><br><span class="line">    <span class="keyword">val</span> cacheDeferred = async &#123; getCacheInfo(productId) &#125;</span><br><span class="line">    <span class="keyword">val</span> latestDeferred = async &#123; getNetworkInfo(productId) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2，在缓存和网络中间，选择最快的结果</span></span><br><span class="line">    <span class="keyword">val</span> product = select&lt;Product?&gt; &#123;</span><br><span class="line">        cacheDeferred.onAwait &#123;</span><br><span class="line">                it?.copy(isCache = <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        latestDeferred.onAwait &#123;</span><br><span class="line">                it?.copy(isCache = <span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，更新UI</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(product)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4，如果当前结果是缓存，那么再取最新的网络服务结果</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span> &amp;&amp; product.isCache) &#123;</span><br><span class="line">        <span class="keyword">val</span> latest = latestDeferred.await()?: <span class="keyword">return</span><span class="symbol">@runBlocking</span></span><br><span class="line">        updateUI(latest)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 120</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 220</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>对比<em>代码段 1</em> 和<em>代码段 5</em> 的执行结果，会发现<em>代码段 5</em> 的总体耗时更短。</p>
</li>
<li>
<p>另外在上面的代码中，还有几个注释：</p>
<ul>
<li>首先看<em>注释 1</em>，将 <code>getCacheInfo()</code>、<code>getNetworkInfo()</code> 提取到了 <code>select</code> 的外部，让它们通过 <code>async</code> 并发执行。</li>
<li><em>注释 2</em>，仍然是通过 <code>select</code> 选择最快的那个结果，接着在<em>注释 3</em> 这里第一时间更新 <code>UI</code> 界面。</li>
<li>注释 4，判断当前的 <code>product</code> 是不是来自于缓存，如果是的话，还需要用最新的信息更新 <code>UI</code>。</li>
</ul>
</li>
</ol>
<p>然后在这里，假设缓存服务出现了问题，需要 <em>2000</em> 毫秒才能返回：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段6</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCacheInfo</span><span class="params">(productId: <span class="type">String</span>)</span></span>: Product? &#123;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    delay(<span class="number">2000L</span>)</span><br><span class="line">    <span class="keyword">return</span> Product(productId, <span class="number">9.9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 224</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，代码仍然可以正常执行。其实，当前的这个例子很简单，不使用 <code>select</code> 同样也可以实现。不过，<code>select</code> 这样的代码模式的优势在于，扩展性非常好。</p>
<p>下面，可以再来假设一下，现在有了多个缓存服务。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/select4.jpeg" alt></p>
<p>对于这个问题，其实只需要稍微改动一下<em>代码段 3</em> 就行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段7</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> productId = <span class="string">&quot;xxxId&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cacheDeferred = async &#123; getCacheInfo(productId) &#125;</span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    <span class="keyword">val</span> cacheDeferred2 = async &#123; getCacheInfo2(productId) &#125;</span><br><span class="line">    <span class="keyword">val</span> latestDeferred = async &#123; getNetworkInfo(productId) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> product = select&lt;Product?&gt; &#123;</span><br><span class="line">        cacheDeferred.onAwait &#123;</span><br><span class="line">            it?.copy(isCache = <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        cacheDeferred2.onAwait &#123;</span><br><span class="line">            it?.copy(isCache = <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latestDeferred.onAwait &#123;</span><br><span class="line">            it?.copy(isCache = <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateUI(product)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span> &amp;&amp; product.isCache) &#123;</span><br><span class="line">        <span class="keyword">val</span> latest = latestDeferred.await() ?: <span class="keyword">return</span><span class="symbol">@runBlocking</span></span><br><span class="line">        updateUI(latest)</span><br><span class="line">        println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">xxxId==9.9</span></span><br><span class="line"><span class="comment">Time cost: 125</span></span><br><span class="line"><span class="comment">xxxId==9.8</span></span><br><span class="line"><span class="comment">Time cost: 232</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当增加一个缓存服务进来的时候，代码只需要做很小的改动，就可以实现。所以，总的来说，对比传统的挂起函数串行的执行流程，<code>select</code> 这样的代码模式，不仅可以提升程序的<strong>整体响应速度</strong>，还可以大大提升程序的<strong>灵活性、扩展性</strong>。</p>
<h2><a href="#3-select-和-channel" class="header-anchor">#</a><span id="3-select-和-channel">3. select 和 Channel</span></h2>
<p>在前面的内容提到过，在协程中返回一个内容的时候，可以使用挂起函数、<code>async</code>，但如果要返回多个结果的话，就要用 <code>Channel</code> 和 <code>Flow</code>。那么，来看看 <code>select</code> 和 <code>Channel</code> 的搭配使用。<br>
这里，有两个管道，<code>channel1</code>、<code>channel2</code>，它们里面的内容分别是 <em>1、2、3；a、b、c</em>，通过 <code>select</code>，将它们当中的数据收集出来并打印。</p>
<p><img src="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/select3.gif" alt></p>
<p>对于这个问题，如果不借助 <code>select</code> 来实现的话，其实可以大致做到，但结果不会令人满意。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段8</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce &#123;</span><br><span class="line">        send(<span class="number">1</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="number">3</span>)</span><br><span class="line">        delay(<span class="number">150L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel1.consumeEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel2.consumeEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">Time cost: 989</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过普通的方式，代码是串行执行的，执行结果并不符合预期。<code>channel1</code> 执行完毕以后，才会执行 <code>channel2</code>，程序总体的执行时间，也是两者的总和。最关键的是，如果 <code>channel1</code> 当中如果迟迟没有数据的话，程序会一直卡着不执行。</p>
<p>当然，以上的问题，通过其他方式也可以解决，但最方便的解决方案，还是 <code>select</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段9</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce &#123;</span><br><span class="line">        send(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        delay(<span class="number">150L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String = select&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 1， 选择channel1</span></span><br><span class="line">        channel1.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2， 选择channel1</span></span><br><span class="line">        channel2.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">6</span>)&#123;<span class="comment">// 3， 选择6次结果</span></span><br><span class="line">        selectChannel(channel1, channel2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">Time cost: 540</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从程序的执行结果中，可以看到，程序的输出结果符合预期，同时它的执行耗时，也比<em>代码段 8</em> 要少很多。上面的代码中有几个注释：</p>
<ul>
<li><em>注释 1 和 2</em>，<code>onReceive&#123;&#125;</code> 是 <code>Channel</code> 在 <code>select</code> 当中的语法，当 <code>Channel</code> 当中有数据以后，它就会被回调，通过这个 <code>Lambda</code>，可以将结果传出去。</li>
<li><em>注释 3</em>，这里执行了 <em>6</em> 次 <code>select</code>，目的是要把两个管道中的所有数据都消耗掉。<em>管道 1</em> 有 <em>3</em> 个数据、<em>管道 2</em> 有 <em>3</em> 个数据，所以加起来，需要选择 <em>6</em> 次。这时候，假设 <code>channel1</code> 出了问题，它不再产生数据了，看看程序会怎么样执行。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段10</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 变化在这里</span></span><br><span class="line">        delay(<span class="number">15000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String = select&lt;String&gt; &#123;</span><br><span class="line">        channel1.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        channel2.onReceive&#123;</span><br><span class="line">            it.also &#123; println(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    repeat(<span class="number">3</span>)&#123;</span><br><span class="line">        selectChannel(channel1, channel2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">Time cost: 533</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，将 <code>channel1</code> 当中的 <code>send()</code> 都删除了，并且，<code>repeat()</code> 的次数变成了 <em>3</em> 次，因为管道里只有三个数据了。<br>
这时候，会发现，<code>select</code> 也是可以正常执行的。不过，有时候可能并不清楚每个 <code>Channel</code> 当中有多少个数据，比如说，这里如果还是写 <code>repeat(6)</code> 的话，程序就会出问题了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅改动这里</span></span><br><span class="line">repeat(<span class="number">6</span>)&#123;</span><br><span class="line">    selectChannel(channel1, channel2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">崩溃：</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; ClosedReceiveChannelException: Channel was closed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>channel2</code> 当中只有 <em>3</em> 个数据，它发送完数据以后就会被关闭，而 <code>select</code> 是会被调用 <em>6</em> 次的，所以就会触发上面的 <code>ClosedReceiveChannelException</code> 异常。</p>
<p>在前面，学过 <code>receiveCatching()</code> 这个方法，它可以封装 <code>Channel</code> 的结果，防止出现 <code>ClosedReceiveChannelException</code>。类似的，当 <code>Channel</code> 与 <code>select</code> 配合的时候，可以使用 <code>onReceiveCatching&#123;&#125;</code> 这个高阶函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce&lt;String&gt; &#123;</span><br><span class="line">        delay(<span class="number">15000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String =</span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            channel1.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel1 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            channel2.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel2 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = selectChannel(channel1, channel2)</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">channel2 is closed!</span></span><br><span class="line"><span class="comment">channel2 is closed!</span></span><br><span class="line"><span class="comment">channel2 is closed!</span></span><br><span class="line"><span class="comment">Time cost: 541</span></span><br><span class="line"><span class="comment">程序不会立即退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这时候，即使不知道管道里有多少个数据，也不用担心崩溃的问题。在 <code>onReceiveCatching&#123;&#125;</code> 这个高阶函数当中，可以使用 <code>it.getOrNull()</code> 来获取管道里的数据，如果获取的结果是 <code>null</code>，就代表管道已经被关闭了。<br>
不过，上面的代码仍然还有一个问题，那就是，当得到所有结果以后，程序不会立即退出，因为 <code>channel1</code> 一直在 <code>delay()</code>。这时候，当完成 <em>6</em> 次 <code>repeat()</code> 调用以后，将 <code>channel1</code>、<code>channel2</code> 取消即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码段13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> channel1 = produce&lt;String&gt; &#123;</span><br><span class="line">        delay(<span class="number">15000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> channel2 = produce &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        send(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        send(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectChannel</span><span class="params">(channel1: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, channel2: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String =</span><br><span class="line">        select&lt;String&gt; &#123;</span><br><span class="line">            channel1.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel1 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            channel2.onReceiveCatching &#123;</span><br><span class="line">                it.getOrNull() ?: <span class="string">&quot;channel2 is closed!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = selectChannel(channel1, channel2)</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变化在这里</span></span><br><span class="line">    channel1.cancel()</span><br><span class="line">    channel2.cancel()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Time cost: <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，对比一下<em>代码段 13</em> 和<em>代码段 10</em> 的话，就会发现程序的执行效率提升的同时，扩展性和灵活性也更好了。</p>
<blockquote>
<p>提示：这种将多路数据以非阻塞的方式合并成一路数据的模式，在其他领域也有广泛的应用，比如说操作系统、<code>Java NIO（Non-blocking I/O）</code>等等。</p>
</blockquote>
<h2><a href="#5-select-实战" class="header-anchor">#</a><span id="5-select-实战">5. select 实战</span></h2>
<p>当 <code>Deferred</code>、<code>Channel</code> 与 <code>select</code> 配合的时候，它们原本的 <code>API</code> 会多一个 <code>on</code> 前缀。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deferred</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select相关  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onJoin: SelectClause0</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onAwait: SelectClause1&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SendChannel</span>&lt;<span class="type">in E</span>&gt; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(element: <span class="type">E</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReceiveChannel</span>&lt;<span class="type">out E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">()</span></span>: E</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">receiveCatching</span><span class="params">()</span></span>: ChannelResult&lt;E&gt;</span><br><span class="line">    <span class="comment">// select相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceive: SelectClause1&lt;E&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，只要记住了 <code>Deferred</code>、<code>Channel</code> 的 <code>API</code>，是不需要额外记忆 <code>select</code> 的 <code>API</code> 的，只需要在原本的 <code>API</code> 的前面加上一个 <code>on</code> 就行了。<br>
另外要注意，当 <code>select</code> 与 <code>Deferred</code> 结合使用的时候，当并行的 <code>Deferred</code> 比较多的时候，往往需要在得到一个最快的结果以后，去取消其他的 <code>Deferred</code>。比如说，对于 <code>Deferred1</code>、<code>Deferred2</code>、<code>Deferred3</code>、<code>Deferred4</code>、<code>Deferred5</code>，其中 <code>Deferred2</code> 返回的结果最快，这时候，往往会希望取消其他的 <code>Deferred</code>，以节省资源。那么在这个时候，可以使用类似这样的方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">fastest</span><span class="params">(<span class="keyword">vararg</span> deferreds: <span class="type">Deferred</span>&lt;<span class="type">T</span>&gt;)</span></span>: T = select &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">cancelAll</span><span class="params">()</span></span> = deferreds.forEach &#123; it.cancel() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (deferred <span class="keyword">in</span> deferreds) &#123;</span><br><span class="line">            deferred.onAwait &#123;</span><br><span class="line">                cancelAll()</span><br><span class="line">                it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred1 = async &#123;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">&quot;done1&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred2 = async &#123;</span><br><span class="line">        delay(<span class="number">50L</span>)</span><br><span class="line">        println(<span class="string">&quot;done2&quot;</span>)</span><br><span class="line">        <span class="string">&quot;result2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred3 = async &#123;</span><br><span class="line">        delay(<span class="number">10000L</span>)</span><br><span class="line">        println(<span class="string">&quot;done3&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred4 = async &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;done4&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result4&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred5 = async &#123;</span><br><span class="line">        delay(<span class="number">14000L</span>)</span><br><span class="line">        println(<span class="string">&quot;done5&quot;</span>)    <span class="comment">// 没机会执行</span></span><br><span class="line">        <span class="string">&quot;result5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = fastest(deferred1, deferred2, deferred3, deferred4, deferred5)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">done2</span></span><br><span class="line"><span class="comment">result2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>所以，借助这样的方式，不仅可以通过 <code>async</code> 并发执行协程，也可以借助 <code>select</code> 得到最快的结果，而且，还可以避免不必要的资源浪费。</p>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-04-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><i class="fa fa-tag"></i><a class="tag" href="/tags/协程/" title="协程">协程 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Channel/" title="Channel">Channel </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Flow/" title="Flow">Flow </a><span class="leancloud_visitors"></span><span>大约14518个字, 48分钟23秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://puppet16.github.io/2021/04/15/kotlin学习系列十一/,Puppet,kotlin学习系列十一：协程三,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/04/06/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87/" title="kotlin学习系列番外篇">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/04/15/kotlin%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%81/" title="kotlin学习系列十：协程二">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'xpSQCFiXzEQnCBUKrP6EHIUF-gzGzoHsz',
  app_key:'Ev5N03MrqLzS683mu92hf4RO',
  placeholder:'行至水穷处，坐看云起时...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"dialog":{"enable":false,"hitokoto":true}});</script></body></html>